let fs = () => 'Only works on searver';
let shell = fs;

try {
  fs = require('fs');
  shell = require('shelljs');
} catch(e) {}



function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

class MapScript {
  constructor (absolutePath, script) {
    this.script = script;
    script = MapScript.removeReg(/\/\/.*?\n/g, '', script);
    script = MapScript.removeReg(/`.*?`/g, '', script);
    script = MapScript.removeReg(/([^\\])\/[^\n]{1,}?[^\\]\//g, '$1', script);
    script = MapScript.removeReg(MapScript.reg.block, '', script);
    script = MapScript.removeReg(/\s{2,}/g, ' ', script);

    this.absPath = () => absolutePath;
    this.dir = () => absolutePath.replace(/^(.*\/).*$/, '$1')
    this.existingExports = MapScript.regToNameArr(MapScript.reg.export, script);
    this.requires = MapScript.regToNameArr(MapScript.reg.require, script);
    this.classes = MapScript.regToNameArr(MapScript.reg.class, script);
    this.functions = MapScript.regToNameArr(MapScript.reg.function, script);
    this.consts = MapScript.regToNameArr(MapScript.reg.const, script);

    this.exports = this.existingExports.length > 0 ?
                    this.existingExports : (this.classes.length > 0 ?
                        this.classes : (this.functions.length > 0 ?
                          this.functions : this.consts));

    this.exportStr = () => {
      let exportStr = '';
      if (this.existingExports.length === 0) {
        if (this.exports.length === 1) return `module.exports = ${this.exports[0]}\n`;
        this.exports.forEach((exprt) => (exportStr += `exports.${exprt} = ${exprt}\n`));
      }
      return exportStr;
    }

    this.requireStr = async () => {
      return new Promise(async (resolve) => {
        let requireStr = '';
        if (this.requires.length === 0) {
          const reqReg = MapScript.findRequireReg();
          console.log(reqReg)
          if (reqReg) {
            const referenced = this.script.match(reqReg.all) || [];
            const filesRefd = {};
            filesRefd[this.absPath()] = true;
            for (let i = 0; i < referenced.length; i += 1) {
              const ref = referenced[i];
              const formattedRef = ref.match(reqReg.first)[1];
              const refMap = MapScript.list[formattedRef];
              if (!filesRefd[refMap.absPath()]) {
                filesRefd[refMap.absPath()] = true;
                const moduleExport = refMap.exports.length === 1;
                console.log(this.dir(), '->', refMap.absPath())
                const relitivePath = await MapScript.toRelitivePath(refMap.absPath(), this.dir());
                requireStr += `const ${formattedRef} = require('${relitivePath}')`;
                requireStr += moduleExport ? ';\n' : `.${formattedRef};\n`
              }
            }
          }
        }
        resolve(requireStr);
      });
      return requireStr;
    }

    this.toString = async () => {
      const arrToStr = (name, arr) => `(${arr.length}) ${name}: ${arr}\n`;
      console.log(`File: ${absolutePath}\n` +
             arrToStr('exports', this.exports) +
             arrToStr('requires', this.requires) +
             arrToStr('classes', this.classes) +
             arrToStr('functions', this.functions) +
             arrToStr('consts', this.consts) +
             `requireStr ${await this.requireStr()}\n` +
             `exportStr ${this.exportStr()}\n` +
             `script: \n${script}`);
    }
    this.exports.forEach((name) => MapScript.list[name] = this);
  }
}

MapScript.list = {};
MapScript.findRequireReg = () => {
  let reg = '';
  const names = Object.keys(MapScript.list);
  console.log('nameslen', names.length);
  if (names.length === 0) return null;
  names.forEach((name) => {
    reg += `${name}|`;
  });
  reg = reg.substr(0, reg.length - 1);
  reg = `[^a-z^A-Z^$^_](${reg})[^a-z^A-Z^0-9^$^_]`;
  return {all: new RegExp(reg, 'g'), first: new RegExp(reg)};
}
MapScript.regToNameArr = function (regObj, script) {
  const arr = [];
  const matches = script.match(regObj.all) || [];
  matches.forEach((match) =>
    arr.push(regObj.name.apply(null, match.match(regObj.first))))
  return arr;
}

MapScript.removeReg = function (reg, replace, script) {
  while(script.match(reg)) {
    script = script.replace(reg, replace);
  }
  return script;
}

MapScript.value = {one: (match, one) => one};
MapScript.value.exports = (match, one, two, exportName, realName) => {
  return exportName || realName;
}

MapScript.reg = {};
MapScript.reg.const = {
  all: /const\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)\s{1,}=/g,
  first: /const\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)\s{1,}=/,
  name: MapScript.value.one
}

MapScript.reg.function = {
  all: /function\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)/g,
  first: /function\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)/,
  name: MapScript.value.one
}

MapScript.reg.class = {
  all: /class\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)/g,
  first: /class\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)/,
  name: MapScript.value.one
}
MapScript.reg.export = {
  all: /(module.|)exports(.([a-zA-Z$_][a-zA-Z0-9$_]*)|)\s*=\s*([a-zA-Z$_][a-zA-Z0-9$_]*)/g,
  first: /(module.|)exports(.([a-zA-Z$_][a-zA-Z0-9$_]*)|)\s*=\s*([a-zA-Z$_][a-zA-Z0-9$_]*)/,
  name: MapScript.value.exports
}

MapScript.reg.require = {
  all: /require\((.*?)\)/g,
  first: /require\((.*?)\)/,
  name: MapScript.value.one
}

MapScript.reg.block = /\{[^{^}]*\}/g;
MapScript.upFolderRegex = /(\/|^)([^/]{3,}|[^.]|[^.].|.[^.])\/\.\.\//g;


MapScript.simplifyPath = function (path) {
  path = path.replace(/^\.\//, '');
  path = path.replace(/\/.\//, '/');
  path += path.match(/^.*\.(js|json)$/) ? '' : '.js';
  let simplified = path;
  let currSimplify = path;
  while(currSimplify.match(MapScript.upFolderRegex)) {
    currSimplify = currSimplify.replace(MapScript.upFolderRegex, '$1');
    simplified = currSimplify;
  }
  const fChar = simplified[0];
  if (fChar !== '.' && fChar !== '/') simplified = `./${simplified}`;
  return simplified;
}

MapScript.toRelitivePath = async function (path, dir) {
  const cmd = `realpath --relative-to='${dir}' '${path}'`;
  const promise = new Promise((resolve) => {
    function resolver(data) {
      const relPath = MapScript.simplifyPath(`${data.trim()}`);
      resolve(relPath);
    }
    const child = shell.exec(cmd, {async: true});
    child.stdout.on('data', resolver);
  });
  return promise;
}


class RequireJS {
  constructor(projectDir, main) {
    function guessProjectDir () {
      const stackTarget = new Error().stack.split('\n')[4];
      return stackTarget === undefined ? '' : stackTarget
          .replace(/^.*?\(([^(^:]*)\/[^/]{1,}?:.*$/, '$1');
    }

    projectDir = projectDir || guessProjectDir();
    const scripts = {};
    const prefixReg = /^\.\//;
    const trimPrefix = (path) => path.replace(prefixReg, '');

    const nameReg = /^(.*)\/(.*)$/;
    function guessFilePath (wrongPath, currFile) {
      const guesses = [];
      const fileName = wrongPath.replace(nameReg, '$2');
      Object.keys(scripts).forEach((path) => {
        const name = path.replace(nameReg, '$2');
        if (name === fileName) guesses.push(determinRelitivePath(currFile, path));
      });
      return guesses;
    }

    function determinRelitivePath(from, to) {
      from = trimPrefix(MapScript.simplifyPath(from))
      from = from.replace(nameReg, '$1');
      from = from.split('/');
      to = trimPrefix(MapScript.simplifyPath(to))
      to = to.split('/');
      let index = 0;
      while (from[index] && from[index] === to[index]) {
        index += 1;
      }
      const backPages = from.length - index;
      const relPathArr = backPages === 0  ? `./${to.slice(to.length - 1)}` :
                          new Array(backPages).fill('..').concat(to.slice(index)).join('/');
      return relPathArr;
    }

    function requireWrapper (absDir, relitivePath, filePath) {
      relitivePath = MapScript.simplifyPath(relitivePath);
      const path = MapScript.simplifyPath(`${absDir}${relitivePath}`);
      if (scripts[path] instanceof Unloaded) {
        scripts[path] = scripts[path].load();
      }
      if (scripts[path] === undefined) console.warn(`Trying to load a none exisant js file
\t'${relitivePath}' from file '${filePath}'
\t\tDid you mean:\n\t\t\t${guessFilePath(relitivePath, filePath).join('\n\t\t\t')}`);
      return scripts[path];
    }

    function requireFunc (absoluteDir, filePath) {
      return (relitivePath) => requireWrapper(absoluteDir, relitivePath, filePath);
    }

    const loadPath = [];
    class Unloaded {
      constructor(path, func) {
        const absoluteDir = MapScript.simplifyPath(path).replace(/(.*\/).*/, '$1');
        const modulee = {exports: {}};
        this.load = () => {
          if (loadPath.indexOf(path) !== -1) throw Error(`Circular Reference: \n\t\t${loadPath.join('\n\t\t')}`);
          loadPath.push(path);
          // console.log('loading: ', path);
          func(requireFunc(absoluteDir, path), modulee.exports, modulee);
          loadPath.splice(loadPath.indexOf(path), 1);
          return modulee.exports;
        };
      }
    }

    function addFunction (path, func) {
      scripts[path] = new Unloaded(path, func);
    }

    let header;
    this.header = () => {
      if (header === undefined) {
        header = fs.readFileSync(__filename, 'utf8');
      }
      return `${header}\n\n\n`;
    }

    this.footer = () => {
      return `window.onload = () => RequireJS.init('${main}')\n`;
    }

    let guess = false;
    this.guess = (g) => guess = (typeof g) === 'boolean' ? g : !guess;

    function resolveBody (script) {
      async function resolver(resolve) {
        try {
          JSON.parse(script);
          resolve(`module.exports = ${script.trim()};`);
        } catch (e) {
          if (guess) {
            const reqStr = await map.requireStr();
            const expStr = map.exportStr();
            resolve(`${reqStr}\n${script}${expStr}\n`);
          } else {
            resolve(script);
          }
        }
      }
      return new Promise(resolver);
    }


    const startTime = new Date().getTime();
    const pathCache = {};
    function encapsulate(absolutePath, script) {
      const map = new MapScript(absolutePath, script);
      async function resolver (resolve) {
        if (pathCache[absolutePath] === undefined) {
          pathCache[absolutePath] = await MapScript.toRelitivePath(absolutePath, projectDir);
        }
        const body = await resolveBody(script);
        const encaps = `RequireJS.addFunction('${pathCache[absolutePath]}',
function (require, exports, module) {
${body.replace(/(^|\n)/g, '\n\t').substr(1)}
});\n\n\n`;
        resolve(encaps);

        if (guess && startTime + 10000 < new Date().getTime()) {
          console.log('writinggggg...')
          fs.writeFile(map.absPath(), body, 'utf8');
        }

      }
      const promise = new Promise(resolver);
      return promise;
    }

    function init(main) {
      requireWrapper ('', main)
    }

    this.init = init;
    this.encapsulate = encapsulate;
    this.addFunction = addFunction;
  }
}


try {
  exports.RequireJS = RequireJS;
} catch (e) {}

RequireJS = new RequireJS();



RequireJS.addFunction('./globals/CONSTANTS.js',
function (require, exports, module) {
	

	
	const Door = require('../app-src/objects/assembly/assemblies/door/door.js');
	
	const APP_ID = 'cabinet-builder';
	
	
	const PULL_TYPE = {
	  DRAWER: 'Drawer',
	  DOOR: 'Door'
	};
	
	exports.VIEWER = {height: 600, width: 600}
	exports.APP_ID = APP_ID
	exports.PULL_TYPE = PULL_TYPE
	
});


RequireJS.addFunction('./public/json/endpoints.json',
function (require, exports, module) {
	module.exports = {
	  "_envs": {
	    "local": "http://localhost:3000/cabinet",
	    "dev": "https://dev.jozsefmorrissey.com/cabinet",
	    "prod": "https://node.jozsefmorrissey.com/cabinet"
	  },
	  "user": {
	    "register": "/register",
	    "resendActivation": "/resend/activation",
	    "activate": "/activate/:email/:secret",
	    "validate": "/validate",
	    "login": "/login",
	    "status": "/status",
	    "resetPasswordRequest": "/reset/password/request",
	    "resetPassword": "/reset/password/:email/:secret"
	  },
	  "cabinet": {
	    "add": "/:id",
	    "list": "/all"
	  },
	  "config": {
	    "get": "/config/get",
	    "save": "/config/save"
	  },
	  "costs": {
	    "save": "/costs/save",
	    "get": "/costs/get"
	  },
	  "configuration": {
	    "save": "/configuration/save",
	    "get": "/configuration/get"
	  },
	  "patterns": {
	    "save": "/patterns/save",
	    "get": "/patterns/get"
	  },
	  "properties": {
	    "save": "/properties/save",
	    "get": "/properties/get"
	  },
	  "templates": {
	    "save": "/templates/save",
	    "get": "/templates/get"
	  },
	  "order": {
	    "add": "/order/:id",
	    "get": "/order/:id",
	    "list": "/list/orders"
	  },
	  "export": {
	    "dxf": "/export/dxf"
	  }
	};
});


RequireJS.addFunction('./generated/EPNTS.js',
function (require, exports, module) {
	const Endpoints = require('../../../public/js/utils/endpoints.js');
	const json = require('../public/json/endpoints.json');
	module.exports = new Endpoints(json, 'local').getFuncObj();
});


RequireJS.addFunction('./public/js/3d-modeling/lightgl.js',
function (require, exports, module) {
	/*
	 * lightgl.js
	 * http://github.com/evanw/lightgl.js/
	 *
	 * Copyright 2011 Evan Wallace
	 * Released under the MIT license
	 */
	module.exports = (function() {
	
	// src/shader.js
	// Provides a convenient wrapper for WebGL shaders. A few uniforms and attributes,
	// prefixed with `gl_`, are automatically added to all shader sources to make
	// simple shaders easier to write.
	//
	// Example usage:
	//
	//     var shader = new GL.Shader('\
	//       void main() {\
	//         gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
	//       }\
	//     ', '\
	//       uniform vec4 color;\
	//       void main() {\
	//         gl_FragColor = color;\
	//       }\
	//     ');
	//
	//     shader.uniforms({
	//       color: [1, 0, 0, 1]
	//     }).draw(mesh);
	
	function regexMap(regex, text, callback) {
	  while ((result = regex.exec(text)) != null) {
	    callback(result);
	  }
	}
	
	// Non-standard names beginning with `gl_` must be mangled because they will
	// otherwise cause a compiler error.
	var LIGHTGL_PREFIX = 'LIGHTGL';
	
	// ### new GL.Shader(vertexSource, fragmentSource)
	//
	// Compiles a shader program using the provided vertex and fragment shaders.
	function Shader(vertexSource, fragmentSource) {
	  // Allow passing in the id of an HTML script tag with the source
	  function followScriptTagById(id) {
	    var element = document.getElementById(id);
	    return element ? element.text : id;
	  }
	  vertexSource = followScriptTagById(vertexSource);
	  fragmentSource = followScriptTagById(fragmentSource);
	
	  // Headers are prepended to the sources to provide some automatic functionality.
	  var header = '\
	    uniform mat3 gl_NormalMatrix;\
	    uniform mat4 gl_ModelViewMatrix;\
	    uniform mat4 gl_ProjectionMatrix;\
	    uniform mat4 gl_ModelViewProjectionMatrix;\
	    uniform mat4 gl_ModelViewMatrixInverse;\
	    uniform mat4 gl_ProjectionMatrixInverse;\
	    uniform mat4 gl_ModelViewProjectionMatrixInverse;\
	  ';
	  var vertexHeader = header + '\
	    attribute vec4 gl_Vertex;\
	    attribute vec4 gl_TexCoord;\
	    attribute vec3 gl_Normal;\
	    attribute vec4 gl_Color;\
	    vec4 ftransform() {\
	      return gl_ModelViewProjectionMatrix * gl_Vertex;\
	    }\
	  ';
	  var fragmentHeader = '\
	    precision highp float;\
	  ' + header;
	
	  // Check for the use of built-in matrices that require expensive matrix
	  // multiplications to compute, and record these in `usedMatrices`.
	  var source = vertexSource + fragmentSource;
	  var usedMatrices = {};
	  regexMap(/\b(gl_[^;]*)\b;/g, header, function(groups) {
	    var name = groups[1];
	    if (source.indexOf(name) != -1) {
	      var capitalLetters = name.replace(/[a-z_]/g, '');
	      usedMatrices[capitalLetters] = LIGHTGL_PREFIX + name;
	    }
	  });
	  if (source.indexOf('ftransform') != -1) usedMatrices.MVPM = LIGHTGL_PREFIX + 'gl_ModelViewProjectionMatrix';
	  this.usedMatrices = usedMatrices;
	
	  // The `gl_` prefix must be substituted for something else to avoid compile
	  // errors, since it's a reserved prefix. This prefixes all reserved names with
	  // `_`. The header is inserted after any extensions, since those must come
	  // first.
	  function fix(header, source) {
	    var replaced = {};
	    var match = /^((\s*\/\/.*\n|\s*#extension.*\n)+)[^]*$/.exec(source);
	    source = match ? match[1] + header + source.substr(match[1].length) : header + source;
	    regexMap(/\bgl_\w+\b/g, header, function(result) {
	      if (!(result in replaced)) {
	        source = source.replace(new RegExp('\\b' + result + '\\b', 'g'), LIGHTGL_PREFIX + result);
	        replaced[result] = true;
	      }
	    });
	    return source;
	  }
	  vertexSource = fix(vertexHeader, vertexSource);
	  fragmentSource = fix(fragmentHeader, fragmentSource);
	
	  // Compile and link errors are thrown as strings.
	  function compileSource(type, source) {
	    var shader = gl.createShader(type);
	    gl.shaderSource(shader, source);
	    gl.compileShader(shader);
	    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	      throw new Error('compile error: ' + gl.getShaderInfoLog(shader));
	    }
	    return shader;
	  }
	  this.program = gl.createProgram();
	  gl.attachShader(this.program, compileSource(gl.VERTEX_SHADER, vertexSource));
	  gl.attachShader(this.program, compileSource(gl.FRAGMENT_SHADER, fragmentSource));
	  gl.linkProgram(this.program);
	  if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
	    throw new Error('link error: ' + gl.getProgramInfoLog(this.program));
	  }
	  this.attributes = {};
	  this.uniformLocations = {};
	
	  // Sampler uniforms need to be uploaded using `gl.uniform1i()` instead of `gl.uniform1f()`.
	  // To do this automatically, we detect and remember all uniform samplers in the source code.
	  var isSampler = {};
	  regexMap(/uniform\s+sampler(1D|2D|3D|Cube)\s+(\w+)\s*;/g, vertexSource + fragmentSource, function(groups) {
	    isSampler[groups[2]] = 1;
	  });
	  this.isSampler = isSampler;
	}
	
	function isArray(obj) {
	  var str = Object.prototype.toString.call(obj);
	  return str == '[object Array]' || str == '[object Float32Array]';
	}
	
	function isNumber(obj) {
	  var str = Object.prototype.toString.call(obj);
	  return str == '[object Number]' || str == '[object Boolean]';
	}
	
	var tempMatrix = new Matrix();
	var resultMatrix = new Matrix();
	
	Shader.prototype = {
	  // ### .uniforms(uniforms)
	  //
	  // Set a uniform for each property of `uniforms`. The correct `gl.uniform*()` method is
	  // inferred from the value types and from the stored uniform sampler flags.
	  uniforms: function(uniforms) {
	    gl.useProgram(this.program);
	
	    for (var name in uniforms) {
	      var location = this.uniformLocations[name] || gl.getUniformLocation(this.program, name);
	      if (!location) continue;
	      this.uniformLocations[name] = location;
	      var value = uniforms[name];
	      if (value instanceof Vector) {
	        value = [value.x, value.y, value.z];
	      } else if (value instanceof Matrix) {
	        value = value.m;
	      }
	      if (isArray(value)) {
	        switch (value.length) {
	          case 1: gl.uniform1fv(location, new Float32Array(value)); break;
	          case 2: gl.uniform2fv(location, new Float32Array(value)); break;
	          case 3: gl.uniform3fv(location, new Float32Array(value)); break;
	          case 4: gl.uniform4fv(location, new Float32Array(value)); break;
	          // Matrices are automatically transposed, since WebGL uses column-major
	          // indices instead of row-major indices.
	          case 9: gl.uniformMatrix3fv(location, false, new Float32Array([
	            value[0], value[3], value[6],
	            value[1], value[4], value[7],
	            value[2], value[5], value[8]
	          ])); break;
	          case 16: gl.uniformMatrix4fv(location, false, new Float32Array([
	            value[0], value[4], value[8], value[12],
	            value[1], value[5], value[9], value[13],
	            value[2], value[6], value[10], value[14],
	            value[3], value[7], value[11], value[15]
	          ])); break;
	          default: throw new Error('don\'t know how to load uniform "' + name + '" of length ' + value.length);
	        }
	      } else if (isNumber(value)) {
	        (this.isSampler[name] ? gl.uniform1i : gl.uniform1f).call(gl, location, value);
	      } else {
	        throw new Error('attempted to set uniform "' + name + '" to invalid value ' + value);
	      }
	    }
	
	    return this;
	  },
	
	  // ### .draw(mesh[, mode])
	  //
	  // Sets all uniform matrix attributes, binds all relevant buffers, and draws the
	  // mesh geometry as indexed triangles or indexed lines. Set `mode` to `gl.LINES`
	  // (and either add indices to `lines` or call `computeWireframe()`) to draw the
	  // mesh in wireframe.
	  draw: function(mesh, mode) {
	    this.drawBuffers(mesh.vertexBuffers,
	      mesh.indexBuffers[mode == gl.LINES ? 'lines' : 'triangles'],
	      arguments.length < 2 ? gl.TRIANGLES : mode);
	  },
	
	  // ### .drawBuffers(vertexBuffers, indexBuffer, mode)
	  //
	  // Sets all uniform matrix attributes, binds all relevant buffers, and draws the
	  // indexed mesh geometry. The `vertexBuffers` argument is a map from attribute
	  // names to `Buffer` objects of type `gl.ARRAY_BUFFER`, `indexBuffer` is a `Buffer`
	  // object of type `gl.ELEMENT_ARRAY_BUFFER`, and `mode` is a WebGL primitive mode
	  // like `gl.TRIANGLES` or `gl.LINES`. This method automatically creates and caches
	  // vertex attribute pointers for attributes as needed.
	  drawBuffers: function(vertexBuffers, indexBuffer, mode) {
	    // Only construct up the built-in matrices we need for this shader.
	    var used = this.usedMatrices;
	    var MVM = gl.modelviewMatrix;
	    var PM = gl.projectionMatrix;
	    var MVMI = (used.MVMI || used.NM) ? MVM.inverse() : null;
	    var PMI = (used.PMI) ? PM.inverse() : null;
	    var MVPM = (used.MVPM || used.MVPMI) ? PM.multiply(MVM) : null;
	    var matrices = {};
	    if (used.MVM) matrices[used.MVM] = MVM;
	    if (used.MVMI) matrices[used.MVMI] = MVMI;
	    if (used.PM) matrices[used.PM] = PM;
	    if (used.PMI) matrices[used.PMI] = PMI;
	    if (used.MVPM) matrices[used.MVPM] = MVPM;
	    if (used.MVPMI) matrices[used.MVPMI] = MVPM.inverse();
	    if (used.NM) {
	      var m = MVMI.m;
	      matrices[used.NM] = [m[0], m[4], m[8], m[1], m[5], m[9], m[2], m[6], m[10]];
	    }
	    this.uniforms(matrices);
	
	    // Create and enable attribute pointers as necessary.
	    var length = 0;
	    for (var attribute in vertexBuffers) {
	      var buffer = vertexBuffers[attribute];
	      var location = this.attributes[attribute] ||
	        gl.getAttribLocation(this.program, attribute.replace(/^(gl_.*)$/, LIGHTGL_PREFIX + '$1'));
	      if (location == -1 || !buffer.buffer) continue;
	      this.attributes[attribute] = location;
	      gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
	      gl.enableVertexAttribArray(location);
	      gl.vertexAttribPointer(location, buffer.buffer.spacing, gl.FLOAT, false, 0, 0);
	      length = buffer.buffer.length / buffer.buffer.spacing;
	    }
	
	    // Disable unused attribute pointers.
	    for (var attribute in this.attributes) {
	      if (!(attribute in vertexBuffers)) {
	        gl.disableVertexAttribArray(this.attributes[attribute]);
	      }
	    }
	
	    // Draw the geometry.
	    if (length && (!indexBuffer || indexBuffer.buffer)) {
	      if (indexBuffer) {
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
	        gl.drawElements(mode, indexBuffer.buffer.length, gl.UNSIGNED_SHORT, 0);
	      } else {
	        gl.drawArrays(mode, 0, length);
	      }
	    }
	
	    return this;
	  }
	};
	
	// src/vector.js
	// Provides a simple 3D vector class. Vector operations can be done using member
	// functions, which return new vectors, or static functions, which reuse
	// existing vectors to avoid generating garbage.
	function Vector(x, y, z) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	}
	
	// ### Instance Methods
	// The methods `add()`, `subtract()`, `multiply()`, and `divide()` can all
	// take either a vector or a number as an argument.
	Vector.prototype = {
	  negative: function() {
	    return new Vector(-this.x, -this.y, -this.z);
	  },
	  add: function(v) {
	    if (v instanceof Vector) return new Vector(this.x + v.x, this.y + v.y, this.z + v.z);
	    else return new Vector(this.x + v, this.y + v, this.z + v);
	  },
	  subtract: function(v) {
	    if (v instanceof Vector) return new Vector(this.x - v.x, this.y - v.y, this.z - v.z);
	    else return new Vector(this.x - v, this.y - v, this.z - v);
	  },
	  multiply: function(v) {
	    if (v instanceof Vector) return new Vector(this.x * v.x, this.y * v.y, this.z * v.z);
	    else return new Vector(this.x * v, this.y * v, this.z * v);
	  },
	  divide: function(v) {
	    if (v instanceof Vector) return new Vector(this.x / v.x, this.y / v.y, this.z / v.z);
	    else return new Vector(this.x / v, this.y / v, this.z / v);
	  },
	  equals: function(v) {
	    return this.x == v.x && this.y == v.y && this.z == v.z;
	  },
	  dot: function(v) {
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	  },
	  cross: function(v) {
	    return new Vector(
	      this.y * v.z - this.z * v.y,
	      this.z * v.x - this.x * v.z,
	      this.x * v.y - this.y * v.x
	    );
	  },
	  length: function() {
	    return Math.sqrt(this.dot(this));
	  },
	  unit: function() {
	    return this.divide(this.length());
	  },
	  min: function() {
	    return Math.min(Math.min(this.x, this.y), this.z);
	  },
	  max: function() {
	    return Math.max(Math.max(this.x, this.y), this.z);
	  },
	  toAngles: function() {
	    return {
	      theta: Math.atan2(this.z, this.x),
	      phi: Math.asin(this.y / this.length())
	    };
	  },
	  angleTo: function(a) {
	    return Math.acos(this.dot(a) / (this.length() * a.length()));
	  },
	  toArray: function(n) {
	    return [this.x, this.y, this.z].slice(0, n || 3);
	  },
	  clone: function() {
	    return new Vector(this.x, this.y, this.z);
	  },
	  init: function(x, y, z) {
	    this.x = x; this.y = y; this.z = z;
	    return this;
	  }
	};
	
	// ### Static Methods
	// `Vector.randomDirection()` returns a vector with a length of 1 and a
	// statistically uniform direction. `Vector.lerp()` performs linear
	// interpolation between two vectors.
	Vector.negative = function(a, b) {
	  b.x = -a.x; b.y = -a.y; b.z = -a.z;
	  return b;
	};
	Vector.add = function(a, b, c) {
	  if (b instanceof Vector) { c.x = a.x + b.x; c.y = a.y + b.y; c.z = a.z + b.z; }
	  else { c.x = a.x + b; c.y = a.y + b; c.z = a.z + b; }
	  return c;
	};
	Vector.subtract = function(a, b, c) {
	  if (b instanceof Vector) { c.x = a.x - b.x; c.y = a.y - b.y; c.z = a.z - b.z; }
	  else { c.x = a.x - b; c.y = a.y - b; c.z = a.z - b; }
	  return c;
	};
	Vector.multiply = function(a, b, c) {
	  if (b instanceof Vector) { c.x = a.x * b.x; c.y = a.y * b.y; c.z = a.z * b.z; }
	  else { c.x = a.x * b; c.y = a.y * b; c.z = a.z * b; }
	  return c;
	};
	Vector.divide = function(a, b, c) {
	  if (b instanceof Vector) { c.x = a.x / b.x; c.y = a.y / b.y; c.z = a.z / b.z; }
	  else { c.x = a.x / b; c.y = a.y / b; c.z = a.z / b; }
	  return c;
	};
	Vector.cross = function(a, b, c) {
	  c.x = a.y * b.z - a.z * b.y;
	  c.y = a.z * b.x - a.x * b.z;
	  c.z = a.x * b.y - a.y * b.x;
	  return c;
	};
	Vector.unit = function(a, b) {
	  var length = a.length();
	  b.x = a.x / length;
	  b.y = a.y / length;
	  b.z = a.z / length;
	  return b;
	};
	Vector.fromAngles = function(theta, phi) {
	  return new Vector(Math.cos(theta) * Math.cos(phi), Math.sin(phi), Math.sin(theta) * Math.cos(phi));
	};
	Vector.randomDirection = function() {
	  return Vector.fromAngles(Math.random() * Math.PI * 2, Math.asin(Math.random() * 2 - 1));
	};
	Vector.min = function(a, b) {
	  return new Vector(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z));
	};
	Vector.max = function(a, b) {
	  return new Vector(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z));
	};
	Vector.lerp = function(a, b, fraction) {
	  return b.subtract(a).multiply(fraction).add(a);
	};
	Vector.fromArray = function(a) {
	  return new Vector(a[0], a[1], a[2]);
	};
	Vector.angleBetween = function(a, b) {
	  return a.angleTo(b);
	};
	
	// src/mesh.js
	// Represents indexed triangle geometry with arbitrary additional attributes.
	// You need a shader to draw a mesh; meshes can't draw themselves.
	//
	// A mesh is a collection of `GL.Buffer` objects which are either vertex buffers
	// (holding per-vertex attributes) or index buffers (holding the order in which
	// vertices are rendered). By default, a mesh has a position vertex buffer called
	// `vertices` and a triangle index buffer called `triangles`. New buffers can be
	// added using `addVertexBuffer()` and `addIndexBuffer()`. Two strings are
	// required when adding a new vertex buffer, the name of the data array on the
	// mesh instance and the name of the GLSL attribute in the vertex shader.
	//
	// Example usage:
	//
	//     var mesh = new GL.Mesh({ coords: true, lines: true });
	//
	//     // Default attribute "vertices", available as "gl_Vertex" in
	//     // the vertex shader
	//     mesh.vertices = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]];
	//
	//     // Optional attribute "coords" enabled in constructor,
	//     // available as "gl_TexCoord" in the vertex shader
	//     mesh.coords = [[0, 0], [1, 0], [0, 1], [1, 1]];
	//
	//     // Custom attribute "weights", available as "weight" in the
	//     // vertex shader
	//     mesh.addVertexBuffer('weights', 'weight');
	//     mesh.weights = [1, 0, 0, 1];
	//
	//     // Default index buffer "triangles"
	//     mesh.triangles = [[0, 1, 2], [2, 1, 3]];
	//
	//     // Optional index buffer "lines" enabled in constructor
	//     mesh.lines = [[0, 1], [0, 2], [1, 3], [2, 3]];
	//
	//     // Upload provided data to GPU memory
	//     mesh.compile();
	
	// ### new GL.Indexer()
	//
	// Generates indices into a list of unique objects from a stream of objects
	// that may contain duplicates. This is useful for generating compact indexed
	// meshes from unindexed data.
	function Indexer() {
	  this.unique = [];
	  this.indices = [];
	  this.map = {};
	}
	
	Indexer.prototype = {
	  // ### .add(v)
	  //
	  // Adds the object `obj` to `unique` if it hasn't already been added. Returns
	  // the index of `obj` in `unique`.
	  add: function(obj) {
	    var key = JSON.stringify(obj);
	    if (!(key in this.map)) {
	      this.map[key] = this.unique.length;
	      this.unique.push(obj);
	    }
	    return this.map[key];
	  }
	};
	
	// ### new GL.Buffer(target, type)
	//
	// Provides a simple method of uploading data to a GPU buffer. Example usage:
	//
	//     var vertices = new GL.Buffer(gl.ARRAY_BUFFER, Float32Array);
	//     var indices = new GL.Buffer(gl.ELEMENT_ARRAY_BUFFER, Uint16Array);
	//     vertices.data = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]];
	//     indices.data = [[0, 1, 2], [2, 1, 3]];
	//     vertices.compile();
	//     indices.compile();
	//
	function Buffer(target, type) {
	  this.buffer = null;
	  this.target = target;
	  this.type = type;
	  this.data = [];
	}
	
	Buffer.prototype = {
	  // ### .compile(type)
	  //
	  // Upload the contents of `data` to the GPU in preparation for rendering. The
	  // data must be a list of lists where each inner list has the same length. For
	  // example, each element of data for vertex normals would be a list of length three.
	  // This will remember the data length and element length for later use by shaders.
	  // The type can be either `gl.STATIC_DRAW` or `gl.DYNAMIC_DRAW`, and defaults to
	  // `gl.STATIC_DRAW`.
	  //
	  // This could have used `[].concat.apply([], this.data)` to flatten
	  // the array but Google Chrome has a maximum number of arguments so the
	  // concatenations are chunked to avoid that limit.
	  compile: function(type) {
	    var data = [];
	    for (var i = 0, chunk = 10000; i < this.data.length; i += chunk) {
	      data = Array.prototype.concat.apply(data, this.data.slice(i, i + chunk));
	    }
	    var spacing = this.data.length ? data.length / this.data.length : 0;
	    if (spacing != Math.round(spacing)) throw new Error('buffer elements not of consistent size, average size is ' + spacing);
	    this.buffer = this.buffer || gl.createBuffer();
	    this.buffer.length = data.length;
	    this.buffer.spacing = spacing;
	    gl.bindBuffer(this.target, this.buffer);
	    gl.bufferData(this.target, new this.type(data), type || gl.STATIC_DRAW);
	  }
	};
	
	// ### new GL.Mesh([options])
	//
	// Represents a collection of vertex buffers and index buffers. Each vertex
	// buffer maps to one attribute in GLSL and has a corresponding property set
	// on the Mesh instance. There is one vertex buffer by default: `vertices`,
	// which maps to `gl_Vertex`. The `coords`, `normals`, and `colors` vertex
	// buffers map to `gl_TexCoord`, `gl_Normal`, and `gl_Color` respectively,
	// and can be enabled by setting the corresponding options to true. There are
	// two index buffers, `triangles` and `lines`, which are used for rendering
	// `gl.TRIANGLES` and `gl.LINES`, respectively. Only `triangles` is enabled by
	// default, although `computeWireframe()` will add a normal buffer if it wasn't
	// initially enabled.
	function Mesh(options) {
	  options = options || {};
	  this.vertexBuffers = {};
	  this.indexBuffers = {};
	  this.addVertexBuffer('vertices', 'gl_Vertex');
	  if (options.coords) this.addVertexBuffer('coords', 'gl_TexCoord');
	  if (options.normals) this.addVertexBuffer('normals', 'gl_Normal');
	  if (options.colors) this.addVertexBuffer('colors', 'gl_Color');
	  if (!('triangles' in options) || options.triangles) this.addIndexBuffer('triangles');
	  if (options.lines) this.addIndexBuffer('lines');
	}
	
	Mesh.prototype = {
	  // ### .addVertexBuffer(name, attribute)
	  //
	  // Add a new vertex buffer with a list as a property called `name` on this object
	  // and map it to the attribute called `attribute` in all shaders that draw this mesh.
	  addVertexBuffer: function(name, attribute) {
	    var buffer = this.vertexBuffers[attribute] = new Buffer(gl.ARRAY_BUFFER, Float32Array);
	    buffer.name = name;
	    this[name] = [];
	  },
	
	  // ### .addIndexBuffer(name)
	  //
	  // Add a new index buffer with a list as a property called `name` on this object.
	  addIndexBuffer: function(name) {
	    var buffer = this.indexBuffers[name] = new Buffer(gl.ELEMENT_ARRAY_BUFFER, Uint16Array);
	    this[name] = [];
	  },
	
	  // ### .compile()
	  //
	  // Upload all attached buffers to the GPU in preparation for rendering. This
	  // doesn't need to be called every frame, only needs to be done when the data
	  // changes.
	  compile: function() {
	    for (var attribute in this.vertexBuffers) {
	      var buffer = this.vertexBuffers[attribute];
	      buffer.data = this[buffer.name];
	      buffer.compile();
	    }
	
	    for (var name in this.indexBuffers) {
	      var buffer = this.indexBuffers[name];
	      buffer.data = this[name];
	      buffer.compile();
	    }
	  },
	
	  // ### .transform(matrix)
	  //
	  // Transform all vertices by `matrix` and all normals by the inverse transpose
	  // of `matrix`.
	  transform: function(matrix) {
	    this.vertices = this.vertices.map(function(v) {
	      return matrix.transformPoint(Vector.fromArray(v)).toArray();
	    });
	    if (this.normals) {
	      var invTrans = matrix.inverse().transpose();
	      this.normals = this.normals.map(function(n) {
	        return invTrans.transformVector(Vector.fromArray(n)).unit().toArray();
	      });
	    }
	    this.compile();
	    return this;
	  },
	
	  // ### .computeNormals()
	  //
	  // Computes a new normal for each vertex from the average normal of the
	  // neighboring triangles. This means adjacent triangles must share vertices
	  // for the resulting normals to be smooth.
	  computeNormals: function() {
	    if (!this.normals) this.addVertexBuffer('normals', 'gl_Normal');
	    for (var i = 0; i < this.vertices.length; i++) {
	      this.normals[i] = new Vector();
	    }
	    for (var i = 0; i < this.triangles.length; i++) {
	      var t = this.triangles[i];
	      var a = Vector.fromArray(this.vertices[t[0]]);
	      var b = Vector.fromArray(this.vertices[t[1]]);
	      var c = Vector.fromArray(this.vertices[t[2]]);
	      var normal = b.subtract(a).cross(c.subtract(a)).unit();
	      this.normals[t[0]] = this.normals[t[0]].add(normal);
	      this.normals[t[1]] = this.normals[t[1]].add(normal);
	      this.normals[t[2]] = this.normals[t[2]].add(normal);
	    }
	    for (var i = 0; i < this.vertices.length; i++) {
	      this.normals[i] = this.normals[i].unit().toArray();
	    }
	    this.compile();
	    return this;
	  },
	
	  // ### .computeWireframe()
	  //
	  // Populate the `lines` index buffer from the `triangles` index buffer.
	  computeWireframe: function() {
	    var indexer = new Indexer();
	    for (var i = 0; i < this.triangles.length; i++) {
	      var t = this.triangles[i];
	      for (var j = 0; j < t.length; j++) {
	        var a = t[j], b = t[(j + 1) % t.length];
	        indexer.add([Math.min(a, b), Math.max(a, b)]);
	      }
	    }
	    if (!this.lines) this.addIndexBuffer('lines');
	    this.lines = indexer.unique;
	    this.compile();
	    return this;
	  },
	
	  // ### .getAABB()
	  //
	  // Computes the axis-aligned bounding box, which is an object whose `min` and
	  // `max` properties contain the minimum and maximum coordinates of all vertices.
	  getAABB: function() {
	    var aabb = { min: new Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE) };
	    aabb.max = aabb.min.negative();
	    for (var i = 0; i < this.vertices.length; i++) {
	      var v = Vector.fromArray(this.vertices[i]);
	      aabb.min = Vector.min(aabb.min, v);
	      aabb.max = Vector.max(aabb.max, v);
	    }
	    return aabb;
	  },
	
	  // ### .getBoundingSphere()
	  //
	  // Computes a sphere that contains all vertices (not necessarily the smallest
	  // sphere). The returned object has two properties, `center` and `radius`.
	  getBoundingSphere: function() {
	    var aabb = this.getAABB();
	    var sphere = { center: aabb.min.add(aabb.max).divide(2), radius: 0 };
	    for (var i = 0; i < this.vertices.length; i++) {
	      sphere.radius = Math.max(sphere.radius,
	        Vector.fromArray(this.vertices[i]).subtract(sphere.center).length());
	    }
	    return sphere;
	  }
	};
	
	// ### GL.Mesh.plane([options])
	//
	// Generates a square 2x2 mesh the xy plane centered at the origin. The
	// `options` argument specifies options to pass to the mesh constructor.
	// Additional options include `detailX` and `detailY`, which set the tesselation
	// in x and y, and `detail`, which sets both `detailX` and `detailY` at once.
	// Two triangles are generated by default.
	// Example usage:
	//
	//     var mesh1 = GL.Mesh.plane();
	//     var mesh2 = GL.Mesh.plane({ detail: 5 });
	//     var mesh3 = GL.Mesh.plane({ detailX: 20, detailY: 40 });
	//
	Mesh.plane = function(options) {
	  options = options || {};
	  var mesh = new Mesh(options);
	  detailX = options.detailX || options.detail || 1;
	  detailY = options.detailY || options.detail || 1;
	
	  for (var y = 0; y <= detailY; y++) {
	    var t = y / detailY;
	    for (var x = 0; x <= detailX; x++) {
	      var s = x / detailX;
	      mesh.vertices.push([2 * s - 1, 2 * t - 1, 0]);
	      if (mesh.coords) mesh.coords.push([s, t]);
	      if (mesh.normals) mesh.normals.push([0, 0, 1]);
	      if (x < detailX && y < detailY) {
	        var i = x + y * (detailX + 1);
	        mesh.triangles.push([i, i + 1, i + detailX + 1]);
	        mesh.triangles.push([i + detailX + 1, i + 1, i + detailX + 2]);
	      }
	    }
	  }
	
	  mesh.compile();
	  return mesh;
	};
	
	var cubeData = [
	  [0, 4, 2, 6, -1, 0, 0], // -x
	  [1, 3, 5, 7, +1, 0, 0], // +x
	  [0, 1, 4, 5, 0, -1, 0], // -y
	  [2, 6, 3, 7, 0, +1, 0], // +y
	  [0, 2, 1, 3, 0, 0, -1], // -z
	  [4, 5, 6, 7, 0, 0, +1]  // +z
	];
	
	function pickOctant(i) {
	  return new Vector((i & 1) * 2 - 1, (i & 2) - 1, (i & 4) / 2 - 1);
	}
	
	// ### GL.Mesh.cube([options])
	//
	// Generates a 2x2x2 box centered at the origin. The `options` argument
	// specifies options to pass to the mesh constructor.
	Mesh.cube = function(options) {
	  var mesh = new Mesh(options);
	
	  for (var i = 0; i < cubeData.length; i++) {
	    var data = cubeData[i], v = i * 4;
	    for (var j = 0; j < 4; j++) {
	      var d = data[j];
	      mesh.vertices.push(pickOctant(d).toArray());
	      if (mesh.coords) mesh.coords.push([j & 1, (j & 2) / 2]);
	      if (mesh.normals) mesh.normals.push(data.slice(4, 7));
	    }
	    mesh.triangles.push([v, v + 1, v + 2]);
	    mesh.triangles.push([v + 2, v + 1, v + 3]);
	  }
	
	  mesh.compile();
	  return mesh;
	};
	
	// ### GL.Mesh.sphere([options])
	//
	// Generates a geodesic sphere of radius 1. The `options` argument specifies
	// options to pass to the mesh constructor in addition to the `detail` option,
	// which controls the tesselation level. The detail is `6` by default.
	// Example usage:
	//
	//     var mesh1 = GL.Mesh.sphere();
	//     var mesh2 = GL.Mesh.sphere({ detail: 2 });
	//
	Mesh.sphere = function(options) {
	  function tri(a, b, c) { return flip ? [a, c, b] : [a, b, c]; }
	  function fix(x) { return x + (x - x * x) / 2; }
	  options = options || {};
	  var mesh = new Mesh(options);
	  var indexer = new Indexer();
	  detail = options.detail || 6;
	
	  for (var octant = 0; octant < 8; octant++) {
	    var scale = pickOctant(octant);
	    var flip = scale.x * scale.y * scale.z > 0;
	    var data = [];
	    for (var i = 0; i <= detail; i++) {
	      // Generate a row of vertices on the surface of the sphere
	      // using barycentric coordinates.
	      for (var j = 0; i + j <= detail; j++) {
	        var a = i / detail;
	        var b = j / detail;
	        var c = (detail - i - j) / detail;
	        var vertex = { vertex: new Vector(fix(a), fix(b), fix(c)).unit().multiply(scale).toArray() };
	        if (mesh.coords) vertex.coord = scale.y > 0 ? [1 - a, c] : [c, 1 - a];
	        data.push(indexer.add(vertex));
	      }
	
	      // Generate triangles from this row and the previous row.
	      if (i > 0) {
	        for (var j = 0; i + j <= detail; j++) {
	          var a = (i - 1) * (detail + 1) + ((i - 1) - (i - 1) * (i - 1)) / 2 + j;
	          var b = i * (detail + 1) + (i - i * i) / 2 + j;
	          mesh.triangles.push(tri(data[a], data[a + 1], data[b]));
	          if (i + j < detail) {
	            mesh.triangles.push(tri(data[b], data[a + 1], data[b + 1]));
	          }
	        }
	      }
	    }
	  }
	
	  // Reconstruct the geometry from the indexer.
	  mesh.vertices = indexer.unique.map(function(v) { return v.vertex; });
	  if (mesh.coords) mesh.coords = indexer.unique.map(function(v) { return v.coord; });
	  if (mesh.normals) mesh.normals = mesh.vertices;
	  mesh.compile();
	  return mesh;
	};
	
	// ### GL.Mesh.load(json[, options])
	//
	// Creates a mesh from the JSON generated by the `convert/convert.py` script.
	// Example usage:
	//
	//     var data = {
	//       vertices: [[0, 0, 0], [1, 0, 0], [0, 1, 0]],
	//       triangles: [[0, 1, 2]]
	//     };
	//     var mesh = GL.Mesh.load(data);
	//
	Mesh.load = function(json, options) {
	  options = options || {};
	  if (!('coords' in options)) options.coords = !!json.coords;
	  if (!('normals' in options)) options.normals = !!json.normals;
	  if (!('colors' in options)) options.colors = !!json.colors;
	  if (!('triangles' in options)) options.triangles = !!json.triangles;
	  if (!('lines' in options)) options.lines = !!json.lines;
	  var mesh = new Mesh(options);
	  mesh.vertices = json.vertices;
	  if (mesh.coords) mesh.coords = json.coords;
	  if (mesh.normals) mesh.normals = json.normals;
	  if (mesh.colors) mesh.colors = json.colors;
	  if (mesh.triangles) mesh.triangles = json.triangles;
	  if (mesh.lines) mesh.lines = json.lines;
	  mesh.compile();
	  return mesh;
	};
	
	// src/main.js
	// The internal `gl` variable holds the current WebGL context.
	var gl;
	
	var GL = {
	  // ### Initialization
	  //
	  // `GL.create()` creates a new WebGL context and augments it with more
	  // methods. The alpha channel is disabled by default because it usually causes
	  // unintended transparencies in the canvas.
	  create: function(options) {
	    options = options || {};
	    var canvas = document.createElement('canvas');
	    canvas.width = 800;
	    canvas.height = 600;
	    if (!('alpha' in options)) options.alpha = false;
	    try { gl = canvas.getContext('webgl', options); } catch (e) {}
	    try { gl = gl || canvas.getContext('experimental-webgl', options); } catch (e) {}
	    if (!gl) throw new Error('WebGL not supported');
	    gl.HALF_FLOAT_OES = 0x8D61;
	    addMatrixStack();
	    addImmediateMode();
	    addEventListeners();
	    addOtherMethods();
	    return gl;
	  },
	
	  // `GL.keys` contains a mapping of key codes to booleans indicating whether
	  // that key is currently pressed.
	  keys: {},
	
	  // Export all external classes.
	  Matrix: Matrix,
	  Indexer: Indexer,
	  Buffer: Buffer,
	  Mesh: Mesh,
	  HitTest: HitTest,
	  Raytracer: Raytracer,
	  Shader: Shader,
	  Texture: Texture,
	  Vector: Vector
	};
	
	// ### Matrix stack
	//
	// Implement the OpenGL modelview and projection matrix stacks, along with some
	// other useful GLU matrix functions.
	
	function addMatrixStack() {
	  gl.MODELVIEW = ENUM | 1;
	  gl.PROJECTION = ENUM | 2;
	  var tempMatrix = new Matrix();
	  var resultMatrix = new Matrix();
	  gl.modelviewMatrix = new Matrix();
	  gl.projectionMatrix = new Matrix();
	  var modelviewStack = [];
	  var projectionStack = [];
	  var matrix, stack;
	  gl.matrixMode = function(mode) {
	    switch (mode) {
	      case gl.MODELVIEW:
	        matrix = 'modelviewMatrix';
	        stack = modelviewStack;
	        break;
	      case gl.PROJECTION:
	        matrix = 'projectionMatrix';
	        stack = projectionStack;
	        break;
	      default:
	        throw new Error('invalid matrix mode ' + mode);
	    }
	  };
	  gl.loadIdentity = function() {
	    Matrix.identity(gl[matrix]);
	  };
	  gl.loadMatrix = function(m) {
	    var from = m.m, to = gl[matrix].m;
	    for (var i = 0; i < 16; i++) {
	      to[i] = from[i];
	    }
	  };
	  gl.multMatrix = function(m) {
	    gl.loadMatrix(Matrix.multiply(gl[matrix], m, resultMatrix));
	  };
	  gl.perspective = function(fov, aspect, near, far) {
	    gl.multMatrix(Matrix.perspective(fov, aspect, near, far, tempMatrix));
	  };
	  gl.frustum = function(l, r, b, t, n, f) {
	    gl.multMatrix(Matrix.frustum(l, r, b, t, n, f, tempMatrix));
	  };
	  gl.ortho = function(l, r, b, t, n, f) {
	    gl.multMatrix(Matrix.ortho(l, r, b, t, n, f, tempMatrix));
	  };
	  gl.scale = function(x, y, z) {
	    gl.multMatrix(Matrix.scale(x, y, z, tempMatrix));
	  };
	  gl.translate = function(x, y, z) {
	    gl.multMatrix(Matrix.translate(x, y, z, tempMatrix));
	  };
	  gl.rotate = function(a, x, y, z) {
	    gl.multMatrix(Matrix.rotate(a, x, y, z, tempMatrix));
	  };
	  gl.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz) {
	    gl.multMatrix(Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz, tempMatrix));
	  };
	  gl.pushMatrix = function() {
	    stack.push(Array.prototype.slice.call(gl[matrix].m));
	  };
	  gl.popMatrix = function() {
	    var m = stack.pop();
	    gl[matrix].m = hasFloat32Array ? new Float32Array(m) : m;
	  };
	  gl.project = function(objX, objY, objZ, modelview, projection, viewport) {
	    modelview = modelview || gl.modelviewMatrix;
	    projection = projection || gl.projectionMatrix;
	    viewport = viewport || gl.getParameter(gl.VIEWPORT);
	    var point = projection.transformPoint(modelview.transformPoint(new Vector(objX, objY, objZ)));
	    return new Vector(
	      viewport[0] + viewport[2] * (point.x * 0.5 + 0.5),
	      viewport[1] + viewport[3] * (point.y * 0.5 + 0.5),
	      point.z * 0.5 + 0.5
	    );
	  };
	  gl.unProject = function(winX, winY, winZ, modelview, projection, viewport) {
	    modelview = modelview || gl.modelviewMatrix;
	    projection = projection || gl.projectionMatrix;
	    viewport = viewport || gl.getParameter(gl.VIEWPORT);
	    var point = new Vector(
	      (winX - viewport[0]) / viewport[2] * 2 - 1,
	      (winY - viewport[1]) / viewport[3] * 2 - 1,
	      winZ * 2 - 1
	    );
	    return Matrix.inverse(Matrix.multiply(projection, modelview, tempMatrix), resultMatrix).transformPoint(point);
	  };
	  gl.matrixMode(gl.MODELVIEW);
	}
	
	// ### Immediate mode
	//
	// Provide an implementation of OpenGL's deprecated immediate mode. This is
	// depricated for a reason: constantly re-specifying the geometry is a bad
	// idea for performance. You should use a `GL.Mesh` instead, which specifies
	// the geometry once and caches it on the graphics card. Still, nothing
	// beats a quick `gl.begin(gl.POINTS); gl.vertex(1, 2, 3); gl.end();` for
	// debugging. This intentionally doesn't implement fixed-function lighting
	// because it's only meant for quick debugging tasks.
	
	function addImmediateMode() {
	  var immediateMode = {
	    mesh: new Mesh({ coords: true, colors: true, triangles: false }),
	    mode: -1,
	    coord: [0, 0, 0, 0],
	    color: [1, 1, 1, 1],
	    pointSize: 1,
	    shader: new Shader('\
	      uniform float pointSize;\
	      varying vec4 color;\
	      varying vec4 coord;\
	      void main() {\
	        color = gl_Color;\
	        coord = gl_TexCoord;\
	        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
	        gl_PointSize = pointSize;\
	      }\
	    ', '\
	      uniform sampler2D texture;\
	      uniform float pointSize;\
	      uniform bool useTexture;\
	      varying vec4 color;\
	      varying vec4 coord;\
	      void main() {\
	        gl_FragColor = color;\
	        if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\
	      }\
	    ')
	  };
	  gl.pointSize = function(pointSize) {
	    immediateMode.shader.uniforms({ pointSize: pointSize });
	  };
	  gl.begin = function(mode) {
	    if (immediateMode.mode != -1) throw new Error('mismatched gl.begin() and gl.end() calls');
	    immediateMode.mode = mode;
	    immediateMode.mesh.colors = [];
	    immediateMode.mesh.coords = [];
	    immediateMode.mesh.vertices = [];
	  };
	  gl.color = function(r, g, b, a) {
	    immediateMode.color = (arguments.length == 1) ? r.toArray().concat(1) : [r, g, b, a || 1];
	  };
	  gl.texCoord = function(s, t) {
	    immediateMode.coord = (arguments.length == 1) ? s.toArray(2) : [s, t];
	  };
	  gl.vertex = function(x, y, z) {
	    immediateMode.mesh.colors.push(immediateMode.color);
	    immediateMode.mesh.coords.push(immediateMode.coord);
	    immediateMode.mesh.vertices.push(arguments.length == 1 ? x.toArray() : [x, y, z]);
	  };
	  gl.end = function() {
	    if (immediateMode.mode == -1) throw new Error('mismatched gl.begin() and gl.end() calls');
	    immediateMode.mesh.compile();
	    immediateMode.shader.uniforms({
	      useTexture: !!gl.getParameter(gl.TEXTURE_BINDING_2D)
	    }).draw(immediateMode.mesh, immediateMode.mode);
	    immediateMode.mode = -1;
	  };
	}
	
	// ### Improved mouse events
	//
	// This adds event listeners on the `gl.canvas` element that call
	// `gl.onmousedown()`, `gl.onmousemove()`, and `gl.onmouseup()` with an
	// augmented event object. The event object also has the properties `x`, `y`,
	// `deltaX`, `deltaY`, and `dragging`.
	function addEventListeners() {
	  var context = gl, oldX = 0, oldY = 0, buttons = {}, hasOld = false;
	  var has = Object.prototype.hasOwnProperty;
	  function isDragging() {
	    for (var b in buttons) {
	      if (has.call(buttons, b) && buttons[b]) return true;
	    }
	    return false;
	  }
	  function augment(original) {
	    // Make a copy of original, a native `MouseEvent`, so we can overwrite
	    // WebKit's non-standard read-only `x` and `y` properties (which are just
	    // duplicates of `pageX` and `pageY`). We can't just use
	    // `Object.create(original)` because some `MouseEvent` functions must be
	    // called in the context of the original event object.
	    var e = {};
	    for (var name in original) {
	      if (typeof original[name] == 'function') {
	        e[name] = (function(callback) {
	          return function() {
	            callback.apply(original, arguments);
	          };
	        })(original[name]);
	      } else {
	        e[name] = original[name];
	      }
	    }
	    e.original = original;
	    e.x = e.pageX;
	    e.y = e.pageY;
	    for (var obj = gl.canvas; obj; obj = obj.offsetParent) {
	      e.x -= obj.offsetLeft;
	      e.y -= obj.offsetTop;
	    }
	    if (hasOld) {
	      e.deltaX = e.x - oldX;
	      e.deltaY = e.y - oldY;
	    } else {
	      e.deltaX = 0;
	      e.deltaY = 0;
	      hasOld = true;
	    }
	    oldX = e.x;
	    oldY = e.y;
	    e.dragging = isDragging();
	    e.preventDefault = function() {
	      e.original.preventDefault();
	    };
	    e.stopPropagation = function() {
	      e.original.stopPropagation();
	    };
	    return e;
	  }
	  function mousedown(e) {
	    gl = context;
	    if (!isDragging()) {
	      // Expand the event handlers to the document to handle dragging off canvas.
	      on(document, 'mousemove', mousemove);
	      on(document, 'mouseup', mouseup);
	      off(gl.canvas, 'mousemove', mousemove);
	      off(gl.canvas, 'mouseup', mouseup);
	    }
	    buttons[e.which] = true;
	    e = augment(e);
	    if (gl.onmousedown) gl.onmousedown(e);
	    e.preventDefault();
	  }
	  function mousemove(e) {
	    gl = context;
	    e = augment(e);
	    if (gl.onmousemove) gl.onmousemove(e);
	    e.preventDefault();
	  }
	  function mouseup(e) {
	    gl = context;
	    buttons[e.which] = false;
	    if (!isDragging()) {
	      // Shrink the event handlers back to the canvas when dragging ends.
	      off(document, 'mousemove', mousemove);
	      off(document, 'mouseup', mouseup);
	      on(gl.canvas, 'mousemove', mousemove);
	      on(gl.canvas, 'mouseup', mouseup);
	    }
	    e = augment(e);
	    if (gl.onmouseup) gl.onmouseup(e);
	    e.preventDefault();
	  }
	  function reset() {
	    hasOld = false;
	  }
	  function resetAll() {
	    buttons = {};
	    hasOld = false;
	  }
	  on(gl.canvas, 'mousedown', mousedown);
	  on(gl.canvas, 'mousemove', mousemove);
	  on(gl.canvas, 'mouseup', mouseup);
	  on(gl.canvas, 'mouseover', reset);
	  on(gl.canvas, 'mouseout', reset);
	  on(document, 'contextmenu', resetAll);
	}
	
	// ### Automatic keyboard state
	//
	// The current keyboard state is stored in `GL.keys`, a map of integer key
	// codes to booleans indicating whether that key is currently pressed. Certain
	// keys also have named identifiers that can be used directly, such as
	// `GL.keys.SPACE`. Values in `GL.keys` are initially undefined until that
	// key is pressed for the first time. If you need a boolean value, you can
	// cast the value to boolean by applying the not operator twice (as in
	// `!!GL.keys.SPACE`).
	
	function mapKeyCode(code) {
	  var named = {
	    8: 'BACKSPACE',
	    9: 'TAB',
	    13: 'ENTER',
	    16: 'SHIFT',
	    27: 'ESCAPE',
	    32: 'SPACE',
	    37: 'LEFT',
	    38: 'UP',
	    39: 'RIGHT',
	    40: 'DOWN'
	  };
	  return named[code] || (code >= 65 && code <= 90 ? String.fromCharCode(code) : null);
	}
	
	function on(element, name, callback) {
	  element.addEventListener(name, callback);
	}
	
	function off(element, name, callback) {
	  element.removeEventListener(name, callback);
	}
	
	on(document, 'keydown', function(e) {
	  if (!e.altKey && !e.ctrlKey && !e.metaKey) {
	    var key = mapKeyCode(e.keyCode);
	    if (key) GL.keys[key] = true;
	    GL.keys[e.keyCode] = true;
	  }
	});
	
	on(document, 'keyup', function(e) {
	  if (!e.altKey && !e.ctrlKey && !e.metaKey) {
	    var key = mapKeyCode(e.keyCode);
	    if (key) GL.keys[key] = false;
	    GL.keys[e.keyCode] = false;
	  }
	});
	
	function addOtherMethods() {
	  // ### Multiple contexts
	  //
	  // When using multiple contexts in one web page, `gl.makeCurrent()` must be
	  // called before issuing commands to a different context.
	  (function(context) {
	    gl.makeCurrent = function() {
	      gl = context;
	    };
	  })(gl);
	
	  // ### Animation
	  //
	  // Call `gl.animate()` to provide an animation loop that repeatedly calls
	  // `gl.onupdate()` and `gl.ondraw()`.
	  gl.animate = function() {
	    var post =
	      window.requestAnimationFrame ||
	      window.mozRequestAnimationFrame ||
	      window.webkitRequestAnimationFrame ||
	      function(callback) { setTimeout(callback, 1000 / 60); };
	    var time = new Date().getTime();
	    var context = gl;
	    function update() {
	      gl = context;
	      var now = new Date().getTime();
	      if (gl.onupdate) gl.onupdate((now - time) / 1000);
	      if (gl.ondraw) gl.ondraw();
	      post(update);
	      time = now;
	    }
	    update();
	  };
	
	  // ### Fullscreen
	  //
	  // Provide an easy way to get a fullscreen app running, including an
	  // automatic 3D perspective projection matrix by default. This should be
	  // called once.
	  //
	  // Just fullscreen, no automatic camera:
	  //
	  //     gl.fullscreen({ camera: false });
	  //
	  // Adjusting field of view, near plane distance, and far plane distance:
	  //
	  //     gl.fullscreen({ fov: 45, near: 0.1, far: 1000 });
	  //
	  // Adding padding from the edge of the window:
	  //
	  //     gl.fullscreen({ paddingLeft: 250, paddingBottom: 60 });
	  //
	  gl.fullscreen = function(options) {
	    options = options || {};
	    var top = options.paddingTop || 0;
	    var left = options.paddingLeft || 0;
	    var right = options.paddingRight || 0;
	    var bottom = options.paddingBottom || 0;
	    if (!document.body) {
	      throw new Error('document.body doesn\'t exist yet (call gl.fullscreen() from ' +
	        'window.onload() or from inside the <body> tag)');
	    }
	    document.body.appendChild(gl.canvas);
	    document.body.style.overflow = 'hidden';
	    gl.canvas.style.position = 'absolute';
	    gl.canvas.style.left = left + 'px';
	    gl.canvas.style.top = top + 'px';
	    function resize() {
	      gl.canvas.width = window.innerWidth - left - right;
	      gl.canvas.height = window.innerHeight - top - bottom;
	      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	      if (options.camera || !('camera' in options)) {
	        gl.matrixMode(gl.PROJECTION);
	        gl.loadIdentity();
	        gl.perspective(options.fov || 45, gl.canvas.width / gl.canvas.height,
	          options.near || 0.1, options.far || 1000);
	        gl.matrixMode(gl.MODELVIEW);
	      }
	      if (gl.ondraw) gl.ondraw();
	    }
	    on(window, 'resize', resize);
	    resize();
	  };
	}
	
	// A value to bitwise-or with new enums to make them distinguishable from the
	// standard WebGL enums.
	var ENUM = 0x12340000;
	
	// src/2d-projection.js
	
	// src/raytracer.js
	// Provides a convenient raytracing interface.
	
	// ### new GL.HitTest([t, hit, normal])
	//
	// This is the object used to return hit test results. If there are no
	// arguments, the constructed argument represents a hit infinitely far
	// away.
	function HitTest(t, hit, normal) {
	  this.t = arguments.length ? t : Number.MAX_VALUE;
	  this.hit = hit;
	  this.normal = normal;
	}
	
	// ### .mergeWith(other)
	//
	// Changes this object to be the closer of the two hit test results.
	HitTest.prototype = {
	  mergeWith: function(other) {
	    if (other.t > 0 && other.t < this.t) {
	      this.t = other.t;
	      this.hit = other.hit;
	      this.normal = other.normal;
	    }
	  }
	};
	
	// ### new GL.Raytracer()
	//
	// This will read the current modelview matrix, projection matrix, and viewport,
	// reconstruct the eye position, and store enough information to later generate
	// per-pixel rays using `getRayForPixel()`.
	//
	// Example usage:
	//
	//     var tracer = new GL.Raytracer();
	//     var ray = tracer.getRayForPixel(
	//       gl.canvas.width / 2,
	//       gl.canvas.height / 2);
	//     var result = GL.Raytracer.hitTestSphere(
	//       tracer.eye, ray, new GL.Vector(0, 0, 0), 1);
	function Raytracer() {
	  var v = gl.getParameter(gl.VIEWPORT);
	  var m = gl.modelviewMatrix.m;
	
	  var axisX = new Vector(m[0], m[4], m[8]);
	  var axisY = new Vector(m[1], m[5], m[9]);
	  var axisZ = new Vector(m[2], m[6], m[10]);
	  var offset = new Vector(m[3], m[7], m[11]);
	  this.eye = new Vector(-offset.dot(axisX), -offset.dot(axisY), -offset.dot(axisZ));
	
	  var minX = v[0], maxX = minX + v[2];
	  var minY = v[1], maxY = minY + v[3];
	  this.ray00 = gl.unProject(minX, minY, 1).subtract(this.eye);
	  this.ray10 = gl.unProject(maxX, minY, 1).subtract(this.eye);
	  this.ray01 = gl.unProject(minX, maxY, 1).subtract(this.eye);
	  this.ray11 = gl.unProject(maxX, maxY, 1).subtract(this.eye);
	  this.viewport = v;
	}
	
	Raytracer.prototype = {
	  // ### .getRayForPixel(x, y)
	  //
	  // Returns the ray originating from the camera and traveling through the pixel `x, y`.
	  getRayForPixel: function(x, y) {
	    x = (x - this.viewport[0]) / this.viewport[2];
	    y = 1 - (y - this.viewport[1]) / this.viewport[3];
	    var ray0 = Vector.lerp(this.ray00, this.ray10, x);
	    var ray1 = Vector.lerp(this.ray01, this.ray11, x);
	    return Vector.lerp(ray0, ray1, y).unit();
	  }
	};
	
	// ### GL.Raytracer.hitTestBox(origin, ray, min, max)
	//
	// Traces the ray starting from `origin` along `ray` against the axis-aligned box
	// whose coordinates extend from `min` to `max`. Returns a `HitTest` with the
	// information or `null` for no intersection.
	//
	// This implementation uses the [slab intersection method](http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm).
	Raytracer.hitTestBox = function(origin, ray, min, max) {
	  var tMin = min.subtract(origin).divide(ray);
	  var tMax = max.subtract(origin).divide(ray);
	  var t1 = Vector.min(tMin, tMax);
	  var t2 = Vector.max(tMin, tMax);
	  var tNear = t1.max();
	  var tFar = t2.min();
	
	  if (tNear > 0 && tNear < tFar) {
	    var epsilon = 1.0e-6, hit = origin.add(ray.multiply(tNear));
	    min = min.add(epsilon);
	    max = max.subtract(epsilon);
	    return new HitTest(tNear, hit, new Vector(
	      (hit.x > max.x) - (hit.x < min.x),
	      (hit.y > max.y) - (hit.y < min.y),
	      (hit.z > max.z) - (hit.z < min.z)
	    ));
	  }
	
	  return null;
	};
	
	// ### GL.Raytracer.hitTestSphere(origin, ray, center, radius)
	//
	// Traces the ray starting from `origin` along `ray` against the sphere defined
	// by `center` and `radius`. Returns a `HitTest` with the information or `null`
	// for no intersection.
	Raytracer.hitTestSphere = function(origin, ray, center, radius) {
	  var offset = origin.subtract(center);
	  var a = ray.dot(ray);
	  var b = 2 * ray.dot(offset);
	  var c = offset.dot(offset) - radius * radius;
	  var discriminant = b * b - 4 * a * c;
	
	  if (discriminant > 0) {
	    var t = (-b - Math.sqrt(discriminant)) / (2 * a), hit = origin.add(ray.multiply(t));
	    return new HitTest(t, hit, hit.subtract(center).divide(radius));
	  }
	
	  return null;
	};
	
	// ### GL.Raytracer.hitTestTriangle(origin, ray, a, b, c)
	//
	// Traces the ray starting from `origin` along `ray` against the triangle defined
	// by the points `a`, `b`, and `c`. Returns a `HitTest` with the information or
	// `null` for no intersection.
	Raytracer.hitTestTriangle = function(origin, ray, a, b, c) {
	  var ab = b.subtract(a);
	  var ac = c.subtract(a);
	  var normal = ab.cross(ac).unit();
	  var t = normal.dot(a.subtract(origin)) / normal.dot(ray);
	
	  if (t > 0) {
	    var hit = origin.add(ray.multiply(t));
	    var toHit = hit.subtract(a);
	    var dot00 = ac.dot(ac);
	    var dot01 = ac.dot(ab);
	    var dot02 = ac.dot(toHit);
	    var dot11 = ab.dot(ab);
	    var dot12 = ab.dot(toHit);
	    var divide = dot00 * dot11 - dot01 * dot01;
	    var u = (dot11 * dot02 - dot01 * dot12) / divide;
	    var v = (dot00 * dot12 - dot01 * dot02) / divide;
	    if (u >= 0 && v >= 0 && u + v <= 1) return new HitTest(t, hit, normal);
	  }
	
	  return null;
	};
	
	// src/texture.js
	// Provides a simple wrapper around WebGL textures that supports render-to-texture.
	
	// ### new GL.Texture(width, height[, options])
	//
	// The arguments `width` and `height` give the size of the texture in texels.
	// WebGL texture dimensions must be powers of two unless `filter` is set to
	// either `gl.NEAREST` or `gl.LINEAR` and `wrap` is set to `gl.CLAMP_TO_EDGE`
	// (which they are by default).
	//
	// Texture parameters can be passed in via the `options` argument.
	// Example usage:
	//
	//     var t = new GL.Texture(256, 256, {
	//       // Defaults to gl.LINEAR, set both at once with "filter"
	//       magFilter: gl.NEAREST,
	//       minFilter: gl.LINEAR,
	//
	//       // Defaults to gl.CLAMP_TO_EDGE, set both at once with "wrap"
	//       wrapS: gl.REPEAT,
	//       wrapT: gl.REPEAT,
	//
	//       format: gl.RGB, // Defaults to gl.RGBA
	//       type: gl.FLOAT // Defaults to gl.UNSIGNED_BYTE
	//     });
	function Texture(width, height, options) {
	  options = options || {};
	  this.id = gl.createTexture();
	  this.width = width;
	  this.height = height;
	  this.format = options.format || gl.RGBA;
	  this.type = options.type || gl.UNSIGNED_BYTE;
	  var magFilter = options.filter || options.magFilter || gl.LINEAR;
	  var minFilter = options.filter || options.minFilter || gl.LINEAR;
	  if (this.type === gl.FLOAT) {
	    if (!Texture.canUseFloatingPointTextures()) {
	      throw new Error('OES_texture_float is required but not supported');
	    }
	    if ((minFilter !== gl.NEAREST || magFilter !== gl.NEAREST) &&
	        !Texture.canUseFloatingPointLinearFiltering()) {
	      throw new Error('OES_texture_float_linear is required but not supported');
	    }
	  } else if (this.type === gl.HALF_FLOAT_OES) {
	    if (!Texture.canUseHalfFloatingPointTextures()) {
	      throw new Error('OES_texture_half_float is required but not supported');
	    }
	    if ((minFilter !== gl.NEAREST || magFilter !== gl.NEAREST) &&
	        !Texture.canUseHalfFloatingPointLinearFiltering()) {
	      throw new Error('OES_texture_half_float_linear is required but not supported');
	    }
	  }
	  gl.bindTexture(gl.TEXTURE_2D, this.id);
	  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.wrap || options.wrapS || gl.CLAMP_TO_EDGE);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.wrap || options.wrapT || gl.CLAMP_TO_EDGE);
	  gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, options.data || null);
	}
	
	var framebuffer;
	var renderbuffer;
	var checkerboardCanvas;
	
	Texture.prototype = {
	  // ### .bind([unit])
	  //
	  // Bind this texture to the given texture unit (0-7, defaults to 0).
	  bind: function(unit) {
	    gl.activeTexture(gl.TEXTURE0 + (unit || 0));
	    gl.bindTexture(gl.TEXTURE_2D, this.id);
	  },
	
	  // ### .unbind([unit])
	  //
	  // Clear the given texture unit (0-7, defaults to 0).
	  unbind: function(unit) {
	    gl.activeTexture(gl.TEXTURE0 + (unit || 0));
	    gl.bindTexture(gl.TEXTURE_2D, null);
	  },
	
	  // ### .canDrawTo()
	  //
	  // Check if rendering to this texture is supported. It may not be supported
	  // for floating-point textures on some configurations.
	  canDrawTo: function() {
	    framebuffer = framebuffer || gl.createFramebuffer();
	    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
	    var result = gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE;
	    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    return result;
	  },
	
	  // ### .drawTo(callback)
	  //
	  // Render all draw calls in `callback` to this texture. This method sets up
	  // a framebuffer with this texture as the color attachment and a renderbuffer
	  // as the depth attachment. It also temporarily changes the viewport to the
	  // size of the texture.
	  //
	  // Example usage:
	  //
	  //     texture.drawTo(function() {
	  //       gl.clearColor(1, 0, 0, 1);
	  //       gl.clear(gl.COLOR_BUFFER_BIT);
	  //     });
	  drawTo: function(callback) {
	    var v = gl.getParameter(gl.VIEWPORT);
	    framebuffer = framebuffer || gl.createFramebuffer();
	    renderbuffer = renderbuffer || gl.createRenderbuffer();
	    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
	    if (this.width != renderbuffer.width || this.height != renderbuffer.height) {
	      renderbuffer.width = this.width;
	      renderbuffer.height = this.height;
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
	    }
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
	    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
	    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
	      throw new Error('Rendering to this texture is not supported (incomplete framebuffer)');
	    }
	    gl.viewport(0, 0, this.width, this.height);
	
	    callback();
	
	    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	    gl.viewport(v[0], v[1], v[2], v[3]);
	  },
	
	  // ### .swapWith(other)
	  //
	  // Switch this texture with `other`, useful for the ping-pong rendering
	  // technique used in multi-stage rendering.
	  swapWith: function(other) {
	    var temp;
	    temp = other.id; other.id = this.id; this.id = temp;
	    temp = other.width; other.width = this.width; this.width = temp;
	    temp = other.height; other.height = this.height; this.height = temp;
	  }
	};
	
	// ### GL.Texture.fromImage(image[, options])
	//
	// Return a new image created from `image`, an `<img>` tag.
	Texture.fromImage = function(image, options) {
	  options = options || {};
	  var texture = new Texture(image.width, image.height, options);
	  try {
	    gl.texImage2D(gl.TEXTURE_2D, 0, texture.format, texture.format, texture.type, image);
	  } catch (e) {
	    if (location.protocol == 'file:') {
	      throw new Error('image not loaded for security reasons (serve this page over "http://" instead)');
	    } else {
	      throw new Error('image not loaded for security reasons (image must originate from the same ' +
	        'domain as this page or use Cross-Origin Resource Sharing)');
	    }
	  }
	  if (options.minFilter && options.minFilter != gl.NEAREST && options.minFilter != gl.LINEAR) {
	    gl.generateMipmap(gl.TEXTURE_2D);
	  }
	  return texture;
	};
	
	// ### GL.Texture.fromURL(url[, options])
	//
	// Returns a checkerboard texture that will switch to the correct texture when
	// it loads.
	Texture.fromURL = function(url, options) {
	  checkerboardCanvas = checkerboardCanvas || (function() {
	    var c = document.createElement('canvas').getContext('2d');
	    c.canvas.width = c.canvas.height = 128;
	    for (var y = 0; y < c.canvas.height; y += 16) {
	      for (var x = 0; x < c.canvas.width; x += 16) {
	        c.fillStyle = (x ^ y) & 16 ? '#FFF' : '#DDD';
	        c.fillRect(x, y, 16, 16);
	      }
	    }
	    return c.canvas;
	  })();
	  var texture = Texture.fromImage(checkerboardCanvas, options);
	  var image = new Image();
	  var context = gl;
	  image.onload = function() {
	    context.makeCurrent();
	    Texture.fromImage(image, options).swapWith(texture);
	  };
	  image.src = url;
	  return texture;
	};
	
	// ### GL.Texture.canUseFloatingPointTextures()
	//
	// Returns false if `gl.FLOAT` is not supported as a texture type. This is the
	// `OES_texture_float` extension.
	Texture.canUseFloatingPointTextures = function() {
	  return !!gl.getExtension('OES_texture_float');
	};
	
	// ### GL.Texture.canUseFloatingPointLinearFiltering()
	//
	// Returns false if `gl.LINEAR` is not supported as a texture filter mode for
	// textures of type `gl.FLOAT`. This is the `OES_texture_float_linear`
	// extension.
	Texture.canUseFloatingPointLinearFiltering = function() {
	  return !!gl.getExtension('OES_texture_float_linear');
	};
	
	// ### GL.Texture.canUseFloatingPointTextures()
	//
	// Returns false if `gl.HALF_FLOAT_OES` is not supported as a texture type.
	// This is the `OES_texture_half_float` extension.
	Texture.canUseHalfFloatingPointTextures = function() {
	  return !!gl.getExtension('OES_texture_half_float');
	};
	
	// ### GL.Texture.canUseFloatingPointLinearFiltering()
	//
	// Returns false if `gl.LINEAR` is not supported as a texture filter mode for
	// textures of type `gl.HALF_FLOAT_OES`. This is the
	// `OES_texture_half_float_linear` extension.
	Texture.canUseHalfFloatingPointLinearFiltering = function() {
	  return !!gl.getExtension('OES_texture_half_float_linear');
	};
	
	// src/matrix.js
	// Represents a 4x4 matrix stored in row-major order that uses Float32Arrays
	// when available. Matrix operations can either be done using convenient
	// methods that return a new matrix for the result or optimized methods
	// that store the result in an existing matrix to avoid generating garbage.
	
	var hasFloat32Array = (typeof Float32Array != 'undefined');
	
	// ### new GL.Matrix([elements])
	//
	// This constructor takes 16 arguments in row-major order, which can be passed
	// individually, as a list, or even as four lists, one for each row. If the
	// arguments are omitted then the identity matrix is constructed instead.
	function Matrix() {
	  var m = Array.prototype.concat.apply([], arguments);
	  if (!m.length) {
	    m = [
	      1, 0, 0, 0,
	      0, 1, 0, 0,
	      0, 0, 1, 0,
	      0, 0, 0, 1
	    ];
	  }
	  this.m = hasFloat32Array ? new Float32Array(m) : m;
	}
	
	Matrix.prototype = {
	  // ### .inverse()
	  //
	  // Returns the matrix that when multiplied with this matrix results in the
	  // identity matrix.
	  inverse: function() {
	    return Matrix.inverse(this, new Matrix());
	  },
	
	  // ### .transpose()
	  //
	  // Returns this matrix, exchanging columns for rows.
	  transpose: function() {
	    return Matrix.transpose(this, new Matrix());
	  },
	
	  // ### .multiply(matrix)
	  //
	  // Returns the concatenation of the transforms for this matrix and `matrix`.
	  // This emulates the OpenGL function `glMultMatrix()`.
	  multiply: function(matrix) {
	    return Matrix.multiply(this, matrix, new Matrix());
	  },
	
	  // ### .transformPoint(point)
	  //
	  // Transforms the vector as a point with a w coordinate of 1. This
	  // means translations will have an effect, for example.
	  transformPoint: function(v) {
	    var m = this.m;
	    return new Vector(
	      m[0] * v.x + m[1] * v.y + m[2] * v.z + m[3],
	      m[4] * v.x + m[5] * v.y + m[6] * v.z + m[7],
	      m[8] * v.x + m[9] * v.y + m[10] * v.z + m[11]
	    ).divide(m[12] * v.x + m[13] * v.y + m[14] * v.z + m[15]);
	  },
	
	  // ### .transformPoint(vector)
	  //
	  // Transforms the vector as a vector with a w coordinate of 0. This
	  // means translations will have no effect, for example.
	  transformVector: function(v) {
	    var m = this.m;
	    return new Vector(
	      m[0] * v.x + m[1] * v.y + m[2] * v.z,
	      m[4] * v.x + m[5] * v.y + m[6] * v.z,
	      m[8] * v.x + m[9] * v.y + m[10] * v.z
	    );
	  }
	};
	
	// ### GL.Matrix.inverse(matrix[, result])
	//
	// Returns the matrix that when multiplied with `matrix` results in the
	// identity matrix. You can optionally pass an existing matrix in `result`
	// to avoid allocating a new matrix. This implementation is from the Mesa
	// OpenGL function `__gluInvertMatrixd()` found in `project.c`.
	Matrix.inverse = function(matrix, result) {
	  result = result || new Matrix();
	  var m = matrix.m, r = result.m;
	
	  r[0] = m[5]*m[10]*m[15] - m[5]*m[14]*m[11] - m[6]*m[9]*m[15] + m[6]*m[13]*m[11] + m[7]*m[9]*m[14] - m[7]*m[13]*m[10];
	  r[1] = -m[1]*m[10]*m[15] + m[1]*m[14]*m[11] + m[2]*m[9]*m[15] - m[2]*m[13]*m[11] - m[3]*m[9]*m[14] + m[3]*m[13]*m[10];
	  r[2] = m[1]*m[6]*m[15] - m[1]*m[14]*m[7] - m[2]*m[5]*m[15] + m[2]*m[13]*m[7] + m[3]*m[5]*m[14] - m[3]*m[13]*m[6];
	  r[3] = -m[1]*m[6]*m[11] + m[1]*m[10]*m[7] + m[2]*m[5]*m[11] - m[2]*m[9]*m[7] - m[3]*m[5]*m[10] + m[3]*m[9]*m[6];
	
	  r[4] = -m[4]*m[10]*m[15] + m[4]*m[14]*m[11] + m[6]*m[8]*m[15] - m[6]*m[12]*m[11] - m[7]*m[8]*m[14] + m[7]*m[12]*m[10];
	  r[5] = m[0]*m[10]*m[15] - m[0]*m[14]*m[11] - m[2]*m[8]*m[15] + m[2]*m[12]*m[11] + m[3]*m[8]*m[14] - m[3]*m[12]*m[10];
	  r[6] = -m[0]*m[6]*m[15] + m[0]*m[14]*m[7] + m[2]*m[4]*m[15] - m[2]*m[12]*m[7] - m[3]*m[4]*m[14] + m[3]*m[12]*m[6];
	  r[7] = m[0]*m[6]*m[11] - m[0]*m[10]*m[7] - m[2]*m[4]*m[11] + m[2]*m[8]*m[7] + m[3]*m[4]*m[10] - m[3]*m[8]*m[6];
	
	  r[8] = m[4]*m[9]*m[15] - m[4]*m[13]*m[11] - m[5]*m[8]*m[15] + m[5]*m[12]*m[11] + m[7]*m[8]*m[13] - m[7]*m[12]*m[9];
	  r[9] = -m[0]*m[9]*m[15] + m[0]*m[13]*m[11] + m[1]*m[8]*m[15] - m[1]*m[12]*m[11] - m[3]*m[8]*m[13] + m[3]*m[12]*m[9];
	  r[10] = m[0]*m[5]*m[15] - m[0]*m[13]*m[7] - m[1]*m[4]*m[15] + m[1]*m[12]*m[7] + m[3]*m[4]*m[13] - m[3]*m[12]*m[5];
	  r[11] = -m[0]*m[5]*m[11] + m[0]*m[9]*m[7] + m[1]*m[4]*m[11] - m[1]*m[8]*m[7] - m[3]*m[4]*m[9] + m[3]*m[8]*m[5];
	
	  r[12] = -m[4]*m[9]*m[14] + m[4]*m[13]*m[10] + m[5]*m[8]*m[14] - m[5]*m[12]*m[10] - m[6]*m[8]*m[13] + m[6]*m[12]*m[9];
	  r[13] = m[0]*m[9]*m[14] - m[0]*m[13]*m[10] - m[1]*m[8]*m[14] + m[1]*m[12]*m[10] + m[2]*m[8]*m[13] - m[2]*m[12]*m[9];
	  r[14] = -m[0]*m[5]*m[14] + m[0]*m[13]*m[6] + m[1]*m[4]*m[14] - m[1]*m[12]*m[6] - m[2]*m[4]*m[13] + m[2]*m[12]*m[5];
	  r[15] = m[0]*m[5]*m[10] - m[0]*m[9]*m[6] - m[1]*m[4]*m[10] + m[1]*m[8]*m[6] + m[2]*m[4]*m[9] - m[2]*m[8]*m[5];
	
	  var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
	  for (var i = 0; i < 16; i++) r[i] /= det;
	  return result;
	};
	
	// ### GL.Matrix.transpose(matrix[, result])
	//
	// Returns `matrix`, exchanging columns for rows. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix.
	Matrix.transpose = function(matrix, result) {
	  result = result || new Matrix();
	  var m = matrix.m, r = result.m;
	  r[0] = m[0]; r[1] = m[4]; r[2] = m[8]; r[3] = m[12];
	  r[4] = m[1]; r[5] = m[5]; r[6] = m[9]; r[7] = m[13];
	  r[8] = m[2]; r[9] = m[6]; r[10] = m[10]; r[11] = m[14];
	  r[12] = m[3]; r[13] = m[7]; r[14] = m[11]; r[15] = m[15];
	  return result;
	};
	
	// ### GL.Matrix.multiply(left, right[, result])
	//
	// Returns the concatenation of the transforms for `left` and `right`. You can
	// optionally pass an existing matrix in `result` to avoid allocating a new
	// matrix. This emulates the OpenGL function `glMultMatrix()`.
	Matrix.multiply = function(left, right, result) {
	  result = result || new Matrix();
	  var a = left.m, b = right.m, r = result.m;
	
	  r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
	  r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
	  r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
	  r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];
	
	  r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
	  r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
	  r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
	  r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];
	
	  r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
	  r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
	  r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
	  r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];
	
	  r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
	  r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
	  r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
	  r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
	
	  return result;
	};
	
	// ### GL.Matrix.identity([result])
	//
	// Returns an identity matrix. You can optionally pass an existing matrix in
	// `result` to avoid allocating a new matrix. This emulates the OpenGL function
	// `glLoadIdentity()`.
	Matrix.identity = function(result) {
	  result = result || new Matrix();
	  var m = result.m;
	  m[0] = m[5] = m[10] = m[15] = 1;
	  m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
	  return result;
	};
	
	// ### GL.Matrix.perspective(fov, aspect, near, far[, result])
	//
	// Returns a perspective transform matrix, which makes far away objects appear
	// smaller than nearby objects. The `aspect` argument should be the width
	// divided by the height of your viewport and `fov` is the top-to-bottom angle
	// of the field of view in degrees. You can optionally pass an existing matrix
	// in `result` to avoid allocating a new matrix. This emulates the OpenGL
	// function `gluPerspective()`.
	Matrix.perspective = function(fov, aspect, near, far, result) {
	  var y = Math.tan(fov * Math.PI / 360) * near;
	  var x = y * aspect;
	  return Matrix.frustum(-x, x, -y, y, near, far, result);
	};
	
	// ### GL.Matrix.frustum(left, right, bottom, top, near, far[, result])
	//
	// Sets up a viewing frustum, which is shaped like a truncated pyramid with the
	// camera where the point of the pyramid would be. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix. This emulates
	// the OpenGL function `glFrustum()`.
	Matrix.frustum = function(l, r, b, t, n, f, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  m[0] = 2 * n / (r - l);
	  m[1] = 0;
	  m[2] = (r + l) / (r - l);
	  m[3] = 0;
	
	  m[4] = 0;
	  m[5] = 2 * n / (t - b);
	  m[6] = (t + b) / (t - b);
	  m[7] = 0;
	
	  m[8] = 0;
	  m[9] = 0;
	  m[10] = -(f + n) / (f - n);
	  m[11] = -2 * f * n / (f - n);
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = -1;
	  m[15] = 0;
	
	  return result;
	};
	
	// ### GL.Matrix.ortho(left, right, bottom, top, near, far[, result])
	//
	// Returns an orthographic projection, in which objects are the same size no
	// matter how far away or nearby they are. You can optionally pass an existing
	// matrix in `result` to avoid allocating a new matrix. This emulates the OpenGL
	// function `glOrtho()`.
	Matrix.ortho = function(l, r, b, t, n, f, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  m[0] = 2 / (r - l);
	  m[1] = 0;
	  m[2] = 0;
	  m[3] = -(r + l) / (r - l);
	
	  m[4] = 0;
	  m[5] = 2 / (t - b);
	  m[6] = 0;
	  m[7] = -(t + b) / (t - b);
	
	  m[8] = 0;
	  m[9] = 0;
	  m[10] = -2 / (f - n);
	  m[11] = -(f + n) / (f - n);
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	// ### GL.Matrix.scale(x, y, z[, result])
	//
	// This emulates the OpenGL function `glScale()`. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix.
	Matrix.scale = function(x, y, z, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  m[0] = x;
	  m[1] = 0;
	  m[2] = 0;
	  m[3] = 0;
	
	  m[4] = 0;
	  m[5] = y;
	  m[6] = 0;
	  m[7] = 0;
	
	  m[8] = 0;
	  m[9] = 0;
	  m[10] = z;
	  m[11] = 0;
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	// ### GL.Matrix.translate(x, y, z[, result])
	//
	// This emulates the OpenGL function `glTranslate()`. You can optionally pass
	// an existing matrix in `result` to avoid allocating a new matrix.
	Matrix.translate = function(x, y, z, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  m[0] = 1;
	  m[1] = 0;
	  m[2] = 0;
	  m[3] = x;
	
	  m[4] = 0;
	  m[5] = 1;
	  m[6] = 0;
	  m[7] = y;
	
	  m[8] = 0;
	  m[9] = 0;
	  m[10] = 1;
	  m[11] = z;
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	// ### GL.Matrix.rotate(a, x, y, z[, result])
	//
	// Returns a matrix that rotates by `a` degrees around the vector `x, y, z`.
	// You can optionally pass an existing matrix in `result` to avoid allocating
	// a new matrix. This emulates the OpenGL function `glRotate()`.
	Matrix.rotate = function(a, x, y, z, result) {
	  if (!a || (!x && !y && !z)) {
	    return Matrix.identity(result);
	  }
	
	  result = result || new Matrix();
	  var m = result.m;
	
	  var d = Math.sqrt(x*x + y*y + z*z);
	  a *= Math.PI / 180; x /= d; y /= d; z /= d;
	  var c = Math.cos(a), s = Math.sin(a), t = 1 - c;
	
	  m[0] = x * x * t + c;
	  m[1] = x * y * t - z * s;
	  m[2] = x * z * t + y * s;
	  m[3] = 0;
	
	  m[4] = y * x * t + z * s;
	  m[5] = y * y * t + c;
	  m[6] = y * z * t - x * s;
	  m[7] = 0;
	
	  m[8] = z * x * t - y * s;
	  m[9] = z * y * t + x * s;
	  m[10] = z * z * t + c;
	  m[11] = 0;
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	// ### GL.Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz[, result])
	//
	// Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking
	// toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.
	// You can optionally pass an existing matrix in `result` to avoid allocating
	// a new matrix. This emulates the OpenGL function `gluLookAt()`.
	Matrix.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  var e = new Vector(ex, ey, ez);
	  var c = new Vector(cx, cy, cz);
	  var u = new Vector(ux, uy, uz);
	  var f = e.subtract(c).unit();
	  var s = u.cross(f).unit();
	  var t = f.cross(s).unit();
	
	  m[0] = s.x;
	  m[1] = s.y;
	  m[2] = s.z;
	  m[3] = -s.dot(e);
	
	  m[4] = t.x;
	  m[5] = t.y;
	  m[6] = t.z;
	  m[7] = -t.dot(e);
	
	  m[8] = f.x;
	  m[9] = f.y;
	  m[10] = f.z;
	  m[11] = -f.dot(e);
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	return GL;
	})();
	
});


RequireJS.addFunction('./public/js/3d-modeling/csg.js',
function (require, exports, module) {
	

	const GL = require('./lightgl.js');
	
	// Constructive Solid Geometry (CSG) is a modeling technique that uses Boolean
	// operations like union and intersection to combine 3D solids. This library
	// implements CSG operations on meshes elegantly and concisely using BSP trees,
	// and is meant to serve as an easily understandable implementation of the
	// algorithm. All edge cases involving overlapping coplanar polygons in both
	// solids are correctly handled.
	//
	// Example usage:
	//
	//     var cube = CSG.cube();
	//     var sphere = CSG.sphere({ radius: 1.3 });
	//     var polygons = cube.subtract(sphere).toPolygons();
	//
	// ## Implementation Details
	//
	// All CSG operations are implemented in terms of two functions, `clipTo()` and
	// `invert()`, which remove parts of a BSP tree inside another BSP tree and swap
	// solid and empty space, respectively. To find the union of `a` and `b`, we
	// want to remove everything in `a` inside `b` and everything in `b` inside `a`,
	// then combine polygons from `a` and `b` into one solid:
	//
	//     a.clipTo(b);
	//     b.clipTo(a);
	//     a.build(b.allPolygons());
	//
	// The only tricky part is handling overlapping coplanar polygons in both trees.
	// The code above keeps both copies, but we need to keep them in one tree and
	// remove them in the other tree. To remove them from `b` we can clip the
	// inverse of `b` against `a`. The code for union now looks like this:
	//
	//     a.clipTo(b);
	//     b.clipTo(a);
	//     b.invert();
	//     b.clipTo(a);
	//     b.invert();
	//     a.build(b.allPolygons());
	//
	// Subtraction and intersection naturally follow from set operations. If
	// union is `A | B`, subtraction is `A - B = ~(~A | B)` and intersection is
	// `A & B = ~(~A | ~B)` where `~` is the complement operator.
	//
	// ## License
	//
	// Copyright (c) 2011 Evan Wallace (http://madebyevan.com/), under the MIT license.
	
	// # class CSG
	
	// Holds a binary space partition tree representing a 3D solid. Two solids can
	// be combined using the `union()`, `subtract()`, and `intersect()` methods.
	
	const CSG = function() {
	  this.polygons = [];
	};
	
	// Construct a CSG solid from a list of `CSG.Polygon` instances.
	CSG.fromPolygons = function(polygons) {
	  var csg = new CSG();
	  csg.polygons = polygons;
	  return csg;
	};
	
	CSG.toString = function () {
	  const list = [];
	  this.polygons.forEach((polygon) => {
	    const obj = {vertices: []};
	    polygon.vertices.forEach((vertex) =>
	        obj.vertices.push({x: vertex.pos.x, y: vertex.pos.y, z: vertex.pos.z}));
	    list.push(obj);
	  });
	  return JSON.stringify(list, null, 2);
	}
	
	CSG.prototype = {
	  clone: function() {
	    var csg = new CSG();
	    csg.polygons = this.polygons.map(function(p) { return p.clone(); });
	    return csg;
	  },
	
	  toPolygons: function() {
	    return this.polygons;
	  },
	
	  // Return a new CSG solid representing space in either this solid or in the
	  // solid `csg`. Neither this solid nor the solid `csg` are modified.
	  //
	  //     A.union(B)
	  //
	  //     +-------+            +-------+
	  //     |       |            |       |
	  //     |   A   |            |       |
	  //     |    +--+----+   =   |       +----+
	  //     +----+--+    |       +----+       |
	  //          |   B   |            |       |
	  //          |       |            |       |
	  //          +-------+            +-------+
	  //
	  union: function(csg) {
	    var a = new CSG.Node(this.clone().polygons);
	    var b = new CSG.Node(csg.clone().polygons);
	    a.clipTo(b);
	    b.clipTo(a);
	    b.invert();
	    b.clipTo(a);
	    b.invert();
	    a.build(b.allPolygons());
	    return CSG.fromPolygons(a.allPolygons());
	  },
	
	  // Return a new CSG solid representing space in this solid but not in the
	  // solid `csg`. Neither this solid nor the solid `csg` are modified.
	  //
	  //     A.subtract(B)
	  //
	  //     +-------+            +-------+
	  //     |       |            |       |
	  //     |   A   |            |       |
	  //     |    +--+----+   =   |    +--+
	  //     +----+--+    |       +----+
	  //          |   B   |
	  //          |       |
	  //          +-------+
	  //
	  subtract: function(csg) {
	    function cleanPolygons(polys) {
	      const vertexMap = {};
	      const polyMap = {};
	      for (let index = 0; index < polys.length; index += 1) {
	        const wrongList = [];
	        const poly = polys[index];
	        const connected = {};
	        let added = false;
	        for (let vIndex = 0; vIndex < poly.vertices.length; vIndex += 1) {
	          const vertex = poly.vertices[vIndex];
	          const vKey = vertex.toString();
	          if (vertexMap[vKey]) {
	            const key = vertexMap[vKey].key;
	            let obj = vertexMap[vKey];
	            if (vKey === '(50.8,0,0)') {
	              console.log('badKey')
	            }
	            if (!added) {
	              obj.list.push(poly);
	              added = key;
	            }
	            if (added !== vertexMap[vKey].key){
	              wrongList.push(obj);
	            }
	            connected[key] = obj;
	          } else {
	            let obj = {vertex};
	            vertexMap[vKey] = obj;
	            wrongList.push(obj);
	          }
	        }
	        let obj = {};
	        const connKeys = Object.keys(connected);
	        if (connKeys.length === 0) {
	          obj.list = [poly];
	          obj.key = String.random();
	          polyMap[obj.key] = obj;
	        } else {
	          obj = connected[connKeys[0]];
	          for (let index = 1; index < connKeys.length; index += 1) {
	            const connKey = connKeys[index];
	            const otherObj = connected[connKey];
	            if (connKey !== obj.key) delete polyMap[otherObj.key];
	            else
	              console.log('wtf');
	            otherObj.key = obj.key;
	            otherObj.connected = true;
	            obj.list.concatInPlace(otherObj.list);
	            polyMap[obj.key] = obj;
	            otherObj.list = obj.list;
	          }
	        }
	        for (let wIndex = 0; wIndex < wrongList.length; wIndex += 1) {
	          const wrongObj = wrongList[wIndex];
	          wrongObj.list = obj.list;
	          wrongObj.key = obj.key;
	        }
	      }
	      const polylists = Object.values(polyMap);
	      if (polylists.length === 0) return [];
	      let biggest = polylists[0].list;
	      for (let index = 1; index < polylists.length; index += 1)
	        if (biggest.length < polylists[index].list.length) biggest = polylists[index].list;
	      return biggest;
	    }
	    var a = new CSG.Node(this.clone().polygons);
	    var b = new CSG.Node(csg.clone().polygons);
	    a.invert();
	    a.clipTo(b);
	    b.clipTo(a);
	    b.invert();
	    b.clipTo(a);
	    b.invert();
	    a.build(b.allPolygons());
	    a.invert();
	    return CSG.fromPolygons(a.allPolygons());
	  },
	
	  // Return a new CSG solid representing space both this solid and in the
	  // solid `csg`. Neither this solid nor the solid `csg` are modified.
	  //
	  //     A.intersect(B)
	  //
	  //     +-------+
	  //     |       |
	  //     |   A   |
	  //     |    +--+----+   =   +--+
	  //     +----+--+    |       +--+
	  //          |   B   |
	  //          |       |
	  //          +-------+
	  //
	  intersect: function(csg) {
	    var a = new CSG.Node(this.clone().polygons);
	    var b = new CSG.Node(csg.clone().polygons);
	    a.invert();
	    b.clipTo(a);
	    b.invert();
	    a.clipTo(b);
	    b.clipTo(a);
	    a.build(b.allPolygons());
	    a.invert();
	    return CSG.fromPolygons(a.allPolygons());
	  },
	
	  // Return a new CSG solid with solid and empty space switched. This solid is
	  // not modified.
	  inverse: function() {
	    var csg = this.clone();
	    csg.polygons.map(function(p) { p.flip(); });
	    return csg;
	  },
	  endpoints: function () {
	    const endpoints = {};
	    const endpoint = (attr, value) => {
	      const max = endpoints[attr];
	      endpoints[attr] = max === undefined || max < value ? value : max;
	      const minAttr = `-${attr}`;
	      const min = endpoints[minAttr];
	      endpoints[minAttr] = min === undefined || min > value ? value : min;
	    }
	    this.polygons.forEach((poly) => poly.forEachVertex((vertex) => {
	      endpoint('x', vertex.pos.x);
	      endpoint('y', vertex.pos.y);
	      endpoint('z', vertex.pos.z);
	    }));
	    return endpoints;
	  },
	  distCenter: function () {
	    const endpoints = this.endpoints();
	    const x = ((endpoints.x + endpoints['-x']) / 2);
	    const y = ((endpoints.y + endpoints['-y']) / 2);
	    const z = ((endpoints.z + endpoints['-z']) / 2);
	    return {x,y,z};
	  },
	
	  rotate: function (rotations) {
	    if (Array.isArray(rotations)) {
	      for (let i = 0; i < rotations.length; i++) this.rotate(rotations[i])
	      return;
	    }
	    this.polygons.forEach((poly) => poly.forEachVertex((vertex) => {
	      let newPos = vertex.pos;
	      newPos = ArbitraryRotate(newPos, rotations.x, {x: 1, y:0, z:0});
	      newPos = ArbitraryRotate(newPos, rotations.y, {x: 0, y:1, z:0});
	      newPos = ArbitraryRotate(newPos, rotations.z, {x: 0, y:0, z:1});
	      return new CSG.Vertex(newPos, vertex.normal);
	    }));
	  },
	
	  translate: function (offset) {
	    this.polygons.forEach((poly) => poly.forEachVertex((vertex) => {
	      vertex.pos.x += offset.x;
	      vertex.pos.y += offset.y;
	      vertex.pos.z += offset.z;
	    }));
	  },
	
	  center: function (newCenter) {
	    const center = this.distCenter();
	    const offset = {
	      x: newCenter.x - center.x,
	      y: newCenter.y - center.y,
	      z: newCenter.z - center.z
	    }
	    this.translate(offset);
	  }
	};
	
	// Construct an axis-aligned solid cuboid. Optional parameters are `center` and
	// `radius`, which default to `[0, 0, 0]` and `[1, 1, 1]`. The radius can be
	// specified using a single number or a list of three numbers, one for each axis.
	//
	// Example code:
	//
	//     var cube = CSG.cube({
	//       center: [0, 0, 0],
	//       radius: 1
	//     });
	//
	// x1 = (x0  xc)cos()  (y0  yc)sin() + xc(Equation 3)
	// y1 = (x0  xc)sin() + (y0  yc)cos() + yc(Equation 4)
	CSG.cube = function(options) {
	  options = options || {};
	  var c = new CSG.Vector(options.center || [0, 0, 0]);
	  var r = !options.radius ? [1, 1, 1] : options.radius.length ?
	           options.radius : [options.radius, options.radius, options.radius];
	  if (options.demensions) {
	    r = [options.demensions[0]/2, options.demensions[1]/2, options.demensions[2]/2];
	  }
	  return CSG.fromPolygons([
	    [[0, 4, 6, 2], [-1, 0, 0]],
	    [[1, 3, 7, 5], [+1, 0, 0]],
	    [[0, 1, 5, 4], [0, -1, 0]],
	    [[2, 6, 7, 3], [0, +1, 0]],
	    [[0, 2, 3, 1], [0, 0, -1]],
	    [[4, 5, 7, 6], [0, 0, +1]]
	  ].map(function(info) {
	    return new CSG.Polygon(info[0].map(function(i) {
	      var pos = new CSG.Vector(
	        c.x + r[0] * (2 * !!(i & 1) - 1),
	        c.y + r[1] * (2 * !!(i & 2) - 1),
	        c.z + r[2] * (2 * !!(i & 4) - 1)
	      );
	      return new CSG.Vertex(pos, new CSG.Vector(info[1]));
	    }));
	  }));
	};
	
	// Construct a solid sphere. Optional parameters are `center`, `radius`,
	// `slices`, and `stacks`, which default to `[0, 0, 0]`, `1`, `16`, and `8`.
	// The `slices` and `stacks` parameters control the tessellation along the
	// longitude and latitude directions.
	//
	// Example usage:
	//
	//     var sphere = CSG.sphere({
	//       center: [0, 0, 0],
	//       radius: 1,
	//       slices: 16,
	//       stacks: 8
	//     });
	CSG.sphere = function(options) {
	  options = options || {};
	  var c = new CSG.Vector(options.center || [0, 0, 0]);
	  var r = options.radius || 1;
	  var slices = options.slices || 16;
	  var stacks = options.stacks || 8;
	  var polygons = [], vertices;
	  function vertex(theta, phi) {
	    theta *= Math.PI * 2;
	    phi *= Math.PI;
	    var dir = new CSG.Vector(
	      Math.cos(theta) * Math.sin(phi),
	      Math.cos(phi),
	      Math.sin(theta) * Math.sin(phi)
	    );
	    vertices.push(new CSG.Vertex(c.plus(dir.times(r)), dir));
	  }
	  for (var i = 0; i < slices; i++) {
	    for (var j = 0; j < stacks; j++) {
	      vertices = [];
	      vertex(i / slices, j / stacks);
	      if (j > 0) vertex((i + 1) / slices, j / stacks);
	      if (j < stacks - 1) vertex((i + 1) / slices, (j + 1) / stacks);
	      vertex(i / slices, (j + 1) / stacks);
	      polygons.push(new CSG.Polygon(vertices));
	    }
	  }
	  return CSG.fromPolygons(polygons);
	};
	
	// Construct a solid cylinder. Optional parameters are `start`, `end`,
	// `radius`, and `slices`, which default to `[0, -1, 0]`, `[0, 1, 0]`, `1`, and
	// `16`. The `slices` parameter controls the tessellation.
	//
	// Example usage:
	//
	//     var cylinder = CSG.cylinder({
	//       start: [0, -1, 0],
	//       end: [0, 1, 0],
	//       radius: 1,
	//       slices: 16
	//     });
	CSG.cylinder = function(options) {
	  options = options || {};
	  var s = new CSG.Vector(options.start || [0, -1, 0]);
	  var e = new CSG.Vector(options.end || [0, 1, 0]);
	  var ray = e.minus(s);
	  var r = options.radius || 1;
	  var slices = options.slices || 16;
	  var axisZ = ray.unit(), isY = (Math.abs(axisZ.y) > 0.5);
	  var axisX = new CSG.Vector(isY, !isY, 0).cross(axisZ).unit();
	  var axisY = axisX.cross(axisZ).unit();
	  var start = new CSG.Vertex(s, axisZ.negated());
	  var end = new CSG.Vertex(e, axisZ.unit());
	  var polygons = [];
	  function point(stack, slice, normalBlend) {
	    var angle = slice * Math.PI * 2;
	    var out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));
	    var pos = s.plus(ray.times(stack)).plus(out.times(r));
	    var normal = out.times(1 - Math.abs(normalBlend)).plus(axisZ.times(normalBlend));
	    return new CSG.Vertex(pos, normal);
	  }
	  for (var i = 0; i < slices; i++) {
	    var t0 = i / slices, t1 = (i + 1) / slices;
	    polygons.push(new CSG.Polygon([start, point(0, t0, -1), point(0, t1, -1)]));
	    polygons.push(new CSG.Polygon([point(0, t1, 0), point(0, t0, 0), point(1, t0, 0), point(1, t1, 0)]));
	    polygons.push(new CSG.Polygon([end, point(1, t1, 1), point(1, t0, 1)]));
	  }
	  return CSG.fromPolygons(polygons);
	};
	
	// # class Vector
	
	// Represents a 3D vector.
	//
	// Example usage:
	//
	//     new CSG.Vector(1, 2, 3);
	//     new CSG.Vector([1, 2, 3]);
	//     new CSG.Vector({ x: 1, y: 2, z: 3 });
	
	CSG.Vector = function(x, y, z) {
	  if (arguments.length == 3) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	  } else if ('x' in x) {
	    this.x = x.x;
	    this.y = x.y;
	    this.z = x.z;
	  } else {
	    this.x = x[0];
	    this.y = x[1];
	    this.z = x[2];
	  }
	};
	
	CSG.percision = 1000;
	
	CSG.Vector.prototype = {
	  clone: function() {
	    return new CSG.Vector(this.x, this.y, this.z);
	  },
	
	  negated: function() {
	    return new CSG.Vector(-this.x, -this.y, -this.z);
	  },
	
	  plus: function(a) {
	    return new CSG.Vector(this.x + a.x, this.y + a.y, this.z + a.z);
	  },
	
	  minus: function(a) {
	    return new CSG.Vector(this.x - a.x, this.y - a.y, this.z - a.z);
	  },
	
	  times: function(a) {
	    return new CSG.Vector(this.x * a, this.y * a, this.z * a);
	  },
	
	  dividedBy: function(a) {
	    return new CSG.Vector(this.x / a, this.y / a, this.z / a);
	  },
	
	  dot: function(a) {
	    return this.x * a.x + this.y * a.y + this.z * a.z;
	  },
	
	  lerp: function(a, t) {
	    return this.plus(a.minus(this).times(t));
	  },
	
	  length: function() {
	    return Math.sqrt(this.dot(this));
	  },
	
	  unit: function() {
	    return this.dividedBy(this.length());
	  },
	
	  cross: function(a) {
	    return new CSG.Vector(
	      this.y * a.z - this.z * a.y,
	      this.z * a.x - this.x * a.z,
	      this.x * a.y - this.y * a.x
	    );
	  }
	};
	
	// # class Vertex
	
	// Represents a vertex of a polygon. Use your own vertex class instead of this
	// one to provide additional features like texture coordinates and vertex
	// colors. Custom vertex classes need to provide a `pos` property and `clone()`,
	// `flip()`, and `interpolate()` methods that behave analogous to the ones
	// defined by `CSG.Vertex`. This class provides `normal` so convenience
	// functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`
	// is not used anywhere else.
	
	CSG.Vertex = function(pos, normal) {
	  this.pos = new CSG.Vector(pos);
	  this.normal = new CSG.Vector(normal);
	
	};
	
	CSG.Vertex.prototype = {
	  clone: function() {
	    return new CSG.Vertex(this.pos.clone(), this.normal.clone());
	  },
	  toString: function () {
	    return `(${this.pos.x},${this.pos.y},${this.pos.z})`
	  },
	
	  // Invert all orientation-specific data (e.g. vertex normal). Called when the
	  // orientation of a polygon is flipped.
	  flip: function() {
	    this.normal = this.normal.negated();
	  },
	
	  // Create a new vertex between this vertex and `other` by linearly
	  // interpolating all properties using a parameter of `t`. Subclasses should
	  // override this to interpolate additional properties.
	  interpolate: function(other, t) {
	    return new CSG.Vertex(
	      this.pos.lerp(other.pos, t),
	      this.normal.lerp(other.normal, t)
	    );
	  }
	};
	
	// # class Plane
	
	// Represents a plane in 3D space.
	
	CSG.Plane = function(normal, w) {
	  this.normal = normal;
	  this.w = w;
	};
	
	// `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a
	// point is on the plane.
	CSG.Plane.EPSILON = 1e-3;
	
	CSG.Plane.fromPoints = function(a, b, c) {
	  var n = b.minus(a).cross(c.minus(a)).unit();
	  return new CSG.Plane(n, n.dot(a));
	};
	
	CSG.Plane.prototype = {
	  clone: function() {
	    return new CSG.Plane(this.normal.clone(), this.w);
	  },
	
	  flip: function() {
	    this.normal = this.normal.negated();
	    this.w = -this.w;
	  },
	
	  // Split `polygon` by this plane if needed, then put the polygon or polygon
	  // fragments in the appropriate lists. Coplanar polygons go into either
	  // `coplanarFront` or `coplanarBack` depending on their orientation with
	  // respect to this plane. Polygons in front or in back of this plane go into
	  // either `front` or `back`.
	  splitPolygon: function(polygon, coplanarFront, coplanarBack, front, back) {
	    var COPLANAR = 0;
	    var FRONT = 1;
	    var BACK = 2;
	    var SPANNING = 3;
	
	    // Classify each point as well as the entire polygon into one of the above
	    // four classes.
	    var polygonType = 0;
	    var types = [];
	    for (var i = 0; i < polygon.vertices.length; i++) {
	      var t = this.normal.dot(polygon.vertices[i].pos) - this.w;
	      var type = (t < -CSG.Plane.EPSILON) ? BACK : (t > CSG.Plane.EPSILON) ? FRONT : COPLANAR;
	      polygonType |= type;
	      types.push(type);
	    }
	
	    // Put the polygon in the correct list, splitting it when necessary.
	    switch (polygonType) {
	      case COPLANAR:
	        (this.normal.dot(polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);
	        // console.log('COPLANAR');
	        break;
	      case FRONT:
	        front.push(polygon);
	        // console.log('FRONT');
	        break;
	      case BACK:
	        back.push(polygon);
	        // console.log('BACK');
	        break;
	      case SPANNING:
	        var f = [], b = [];
	        for (var i = 0; i < polygon.vertices.length; i++) {
	          var j = (i + 1) % polygon.vertices.length;
	          var ti = types[i], tj = types[j];
	          var vi = polygon.vertices[i], vj = polygon.vertices[j];
	          if (ti != BACK) f.push(vi);
	          if (ti != FRONT) b.push(ti != BACK ? vi.clone() : vi);
	          if ((ti | tj) == SPANNING) {
	            var t = (this.w - this.normal.dot(vi.pos)) / this.normal.dot(vj.pos.minus(vi.pos));
	            var v = vi.interpolate(vj, t);
	            f.push(v);
	            b.push(v.clone());
	          }
	        }
	        if (f.length >= 3) front.push(new CSG.Polygon(f, polygon.shared));
	        if (b.length >= 3) back.push(new CSG.Polygon(b, polygon.shared));
	        // console.log('SPANNING');
	        break;
	    }
	  }
	};
	
	// # class Polygon
	
	// Represents a convex polygon. The vertices used to initialize a polygon must
	// be coplanar and form a convex loop. They do not have to be `CSG.Vertex`
	// instances but they must behave similarly (duck typing can be used for
	// customization).
	//
	// Each convex polygon has a `shared` property, which is shared between all
	// polygons that are clones of each other or were split from the same polygon.
	// This can be used to define per-polygon properties (such as surface color).
	
	CSG.Polygon = function(vertices, shared) {
	  this.vertices = vertices;
	  this.shared = shared;
	  this.plane = CSG.Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
	};
	
	CSG.Polygon.prototype = {
	  clone: function() {
	    var vertices = this.vertices.map(function(v) { return v.clone(); });
	    return new CSG.Polygon(vertices, this.shared);
	  },
	
	  flip: function() {
	    this.vertices.reverse().map(function(v) { v.flip(); });
	    this.plane.flip();
	  },
	  forEachVertex: function (func) {
	    for (let vIndex = 0; vIndex < this.vertices.length; vIndex += 1) {
	      const vertex = this.vertices[vIndex];
	      const newVertex = func(vertex);
	      this.vertices[vIndex] = newVertex instanceof CSG.Vertex ? newVertex : vertex;
	    }
	  }
	};
	
	// # class Node
	
	// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons
	// by picking a polygon to split along. That polygon (and all other coplanar
	// polygons) are added directly to that node and the other polygons are added to
	// the front and/or back subtrees. This is not a leafy BSP tree since there is
	// no distinction between internal and leaf nodes.
	
	CSG.Node = function(polygons) {
	  this.plane = null;
	  this.front = null;
	  this.back = null;
	  this.polygons = [];
	  if (polygons) this.build(polygons);
	};
	
	CSG.Node.prototype = {
	  clone: function() {
	    var node = new CSG.Node();
	    node.plane = this.plane && this.plane.clone();
	    node.front = this.front && this.front.clone();
	    node.back = this.back && this.back.clone();
	    node.polygons = this.polygons.map(function(p) { return p.clone(); });
	    return node;
	  },
	
	  // Convert solid space to empty space and empty space to solid space.
	  invert: function() {
	    for (var i = 0; i < this.polygons.length; i++) {
	      this.polygons[i].flip();
	    }
	    if (this.plane === null) {
	      console.log(null);
	    }
	    this.plane.flip();
	    if (this.front) this.front.invert();
	    if (this.back) this.back.invert();
	    var temp = this.front;
	    this.front = this.back;
	    this.back = temp;
	  },
	
	  // Recursively remove all polygons in `polygons` that are inside this BSP
	  // tree.
	  clipPolygons: function(polygons) {
	    if (!this.plane) return polygons.slice();
	    var front = [], back = [];
	    for (var i = 0; i < polygons.length; i++) {
	      this.plane.splitPolygon(polygons[i], front, back, front, back);
	    }
	    if (this.front) front = this.front.clipPolygons(front);
	    if (this.back) back = this.back.clipPolygons(back);
	    else back = [];
	    return front.concat(back);
	  },
	
	  // Remove all polygons in this BSP tree that are inside the other BSP tree
	  // `bsp`.
	  clipTo: function(bsp) {
	    this.polygons = bsp.clipPolygons(this.polygons);
	    if (this.front) this.front.clipTo(bsp);
	    if (this.back) this.back.clipTo(bsp);
	  },
	
	  // Return a list of all polygons in this BSP tree.
	  allPolygons: function() {
	    var polygons = this.polygons.slice();
	    if (this.front) polygons = polygons.concat(this.front.allPolygons());
	    if (this.back) polygons = polygons.concat(this.back.allPolygons());
	    return polygons;
	  },
	
	  // Build a BSP tree out of `polygons`. When called on an existing tree, the
	  // new polygons are filtered down to the bottom of the tree and become new
	  // nodes there. Each set of polygons is partitioned using the first polygon
	  // (no heuristic is used to pick a good split).
	  build: function(polygons) {
	    // console.log('\n');
	    if (!polygons.length) return;
	    if (!this.plane) this.plane = polygons[0].plane.clone();
	    var front = [], back = [];
	    for (var i = 0; i < polygons.length; i++) {
	      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
	    }
	    if (front.length) {
	      if (!this.front) this.front = new CSG.Node();
	      this.front.build(front);
	    }
	    if (back.length) {
	      if (!this.back) this.back = new CSG.Node();
	      this.back.build(back);
	    }
	  }
	};
	
	/*
	   Rotate a point p by angle theta around an arbitrary axis r
	   Return the rotated point.
	   Positive angles are anticlockwise looking down the axis
	   towards the origin.
	   Assume right hand coordinate system.
	*/
	function ArbitraryRotate(point, degreestheta, radius)
	{
	  // theta = degreestheta * Math.PI/180;
	  theta = degreestheta * Math.PI/180;
	  // console.log('theta', theta);
	  let p = point;
	  let r = radius;
	   let q = {x: 0.0, y: 0.0, z: 0.0};
	   let costheta,sintheta;
	
	   const Normalise = (obj, attr) => obj[attr] *= obj[attr] > 0 ? 1 : -1;
	   Normalise(r, 'x',);
	   Normalise(r, 'y',);
	   Normalise(r, 'z',);
	
	   costheta = Math.cos(theta);
	   sintheta = Math.sin(theta);
	
	   q.x += (costheta + (1 - costheta) * r.x * r.x) * p.x;
	   q.x += ((1 - costheta) * r.x * r.y - r.z * sintheta) * p.y;
	   q.x += ((1 - costheta) * r.x * r.z + r.y * sintheta) * p.z;
	
	   q.y += ((1 - costheta) * r.x * r.y + r.z * sintheta) * p.x;
	   q.y += (costheta + (1 - costheta) * r.y * r.y) * p.y;
	   q.y += ((1 - costheta) * r.y * r.z - r.x * sintheta) * p.z;
	
	   q.z += ((1 - costheta) * r.x * r.z - r.y * sintheta) * p.x;
	   q.z += ((1 - costheta) * r.y * r.z + r.x * sintheta) * p.y;
	   q.z += (costheta + (1 - costheta) * r.z * r.z) * p.z;
	
	   return(q);
	}
	
	function rotate (point, rotation) {
	  let newPos = point;
	  newPos = ArbitraryRotate(newPos, rotation.x, {x: 1, y:0, z:0});
	  newPos = ArbitraryRotate(newPos, rotation.y, {x: 0, y:1, z:0});
	  newPos = ArbitraryRotate(newPos, rotation.z, {x: 0, y:0, z:1});
	  return newPos;
	}
	
	function reverseRotate (point, rotation) {
	  rotation = {x: rotation.x * -1, y: rotation.y * -1, z: rotation.z * -1};
	  let newPos = point;
	  newPos = ArbitraryRotate(newPos, rotation.z, {x: 0, y:0, z:1});
	  newPos = ArbitraryRotate(newPos, rotation.y, {x: 0, y:1, z:0});
	  newPos = ArbitraryRotate(newPos, rotation.x, {x: 1, y:0, z:0});
	  return newPos;
	}
	
	function transRotate (point, offset, rotation) {
	  let newPos = rotate (offset, rotation);
	  newPos.x += point.x;
	  newPos.y += point.y;
	  newPos.z += point.z;
	  return newPos;
	}
	
	function transRotateAll (points, offset, rotation) {
	  for (let index = 0; index < points.length; index++) {
	    points[index] = transRotate(points[index], offset, rotation);
	  }
	}
	
	function rotateAll (points, rotation) {
	  const ret = [];
	  for (let index = 0; index < points.length; index++) {
	    ret[index] = rotate(points[index], rotation);
	  }
	  return ret;
	}
	
	function reverseRotateAll (points, rotation) {
	  const ret = [];
	  for (let index = 0; index < points.length; index++) {
	    ret[index] = reverseRotate(points[index], rotation);
	  }
	  return ret;
	}
	
	function rotatePointAroundCenter(rotation, point, center, reverse) {
	  point.x -=  center.x;
	  point.y -= center.y;
	  point.z -= center.z;
	  const rotated = reverse ? reverseRotate(point, rotation) : rotate(point, rotation);
	  point.x =  center.x + rotated.x;
	  point.y = center.y + rotated.y;
	  point.z = center.z + rotated.z;
	  return point;
	}
	
	function rotatePointsAroundCenter(rotation, points, center, reverse) {
	  for (let index = 0; index < points.length; index++) {
	    rotatePointAroundCenter(rotation, points[index], center, reverse);
	  }
	  return points;
	}
	
	CSG.ArbitraryRotate = ArbitraryRotate;
	CSG.rotatePointsAroundCenter = rotatePointsAroundCenter;
	CSG.rotatePointAroundCenter = rotatePointAroundCenter;
	CSG.transRotate = transRotate;
	CSG.rotateAll = rotateAll;
	CSG.transRotateAll = transRotateAll;
	CSG.reverseRotateAll = reverseRotateAll;
	CSG.rotate = rotate;
	CSG.reverseRotate = reverseRotate;
	module.exports = CSG;
	
});


RequireJS.addFunction('./public/js/3d-modeling/export-dxf.js',
function (require, exports, module) {
	

	
	const Company = require('../../../app-src/objects/company.js');
	
	
	/*
	AutoCAD DXF Content
	
	These are the common headers, classes, tables, blocks, and objects required for AC2017 DXF files.
	
	## License
	
	Copyright (c) 2018 Z3 Development https://github.com/z3dev
	
	All code released under MIT license
	*/
	
	// Important Variables
	//   ANGDIR = 0 : counter clockwise angles
	//   INSUNITS = 4 : millimeters
	//
	const dxfHeaders = function () {
	  const content = `  0
	SECTION
	  2
	HEADER
	  9
	$ACADVER
	  1
	AC1027
	  9
	$ACADMAINTVER
	 70
	8
	  9
	$DWGCODEPAGE
	  3
	ANSI_1252
	  9
	$LASTSAVEDBY
	  1
	unknown
	  9
	$REQUIREDVERSIONS
	160
	0
	  9
	$INSBASE
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$EXTMIN
	 10
	1e+20
	 20
	1e+20
	 30
	1e+20
	  9
	$EXTMAX
	 10
	-1e+20
	 20
	-1e+20
	 30
	-1e+20
	  9
	$LIMMIN
	 10
	0.0
	 20
	0.0
	  9
	$LIMMAX
	 10
	12.0
	 20
	9.0
	  9
	$ORTHOMODE
	 70
	0
	  9
	$REGENMODE
	 70
	1
	  9
	$FILLMODE
	 70
	1
	  9
	$QTEXTMODE
	 70
	0
	  9
	$MIRRTEXT
	 70
	0
	  9
	$LTSCALE
	 40
	1.0
	  9
	$ATTMODE
	 70
	1
	  9
	$TEXTSIZE
	 40
	0.2
	  9
	$TRACEWID
	 40
	0.05
	  9
	$TEXTSTYLE
	  7
	Notes
	  9
	$CLAYER
	  8
	0
	  9
	$CELTYPE
	  6
	ByLayer
	  9
	$CECOLOR
	 62
	256
	  9
	$CELTSCALE
	 40
	1.0
	  9
	$DISPSILH
	 70
	0
	  9
	$DIMSCALE
	 40
	1.0
	  9
	$DIMASZ
	 40
	3.0
	  9
	$DIMEXO
	 40
	1.5
	  9
	$DIMDLI
	 40
	6.0
	  9
	$DIMRND
	 40
	0.0
	  9
	$DIMDLE
	 40
	0.0
	  9
	$DIMEXE
	 40
	3.0
	  9
	$DIMTP
	 40
	0.0
	  9
	$DIMTM
	 40
	0.0
	  9
	$DIMTXT
	 40
	3.0
	  9
	$DIMCEN
	 40
	3.0
	  9
	$DIMTSZ
	 40
	0.0
	  9
	$DIMTOL
	 70
	0
	  9
	$DIMLIM
	 70
	0
	  9
	$DIMTIH
	 70
	0
	  9
	$DIMTOH
	 70
	0
	  9
	$DIMSE1
	 70
	0
	  9
	$DIMSE2
	 70
	0
	  9
	$DIMTAD
	 70
	1
	  9
	$DIMZIN
	 70
	3
	  9
	$DIMBLK
	  1
	
	  9
	$DIMASO
	 70
	1
	  9
	$DIMSHO
	 70
	1
	  9
	$DIMPOST
	  1
	
	  9
	$DIMAPOST
	  1
	
	  9
	$DIMALT
	 70
	0
	  9
	$DIMALTD
	 70
	2
	  9
	$DIMALTF
	 40
	25.4
	  9
	$DIMLFAC
	 40
	1.0
	  9
	$DIMTOFL
	 70
	0
	  9
	$DIMTVP
	 40
	0.0
	  9
	$DIMTIX
	 70
	0
	  9
	$DIMSOXD
	 70
	0
	  9
	$DIMSAH
	 70
	0
	  9
	$DIMBLK1
	  1
	
	  9
	$DIMBLK2
	  1
	
	  9
	$DIMSTYLE
	  2
	Civil-Metric
	  9
	$DIMCLRD
	 70
	0
	  9
	$DIMCLRE
	 70
	0
	  9
	$DIMCLRT
	 70
	0
	  9
	$DIMTFAC
	 40
	1.0
	  9
	$DIMGAP
	 40
	2.0
	  9
	$DIMJUST
	 70
	0
	  9
	$DIMSD1
	 70
	0
	  9
	$DIMSD2
	 70
	0
	  9
	$DIMTOLJ
	 70
	1
	  9
	$DIMTZIN
	 70
	0
	  9
	$DIMALTZ
	 70
	0
	  9
	$DIMALTTZ
	 70
	0
	  9
	$DIMUPT
	 70
	0
	  9
	$DIMDEC
	 70
	2
	  9
	$DIMTDEC
	 70
	2
	  9
	$DIMALTU
	 70
	2
	  9
	$DIMALTTD
	 70
	2
	  9
	$DIMTXSTY
	  7
	Standard
	  9
	$DIMAUNIT
	 70
	0
	  9
	$DIMADEC
	 70
	2
	  9
	$DIMALTRND
	 40
	0.0
	  9
	$DIMAZIN
	 70
	2
	  9
	$DIMDSEP
	 70
	46
	  9
	$DIMATFIT
	 70
	3
	  9
	$DIMFRAC
	 70
	1
	  9
	$DIMLDRBLK
	  1
	
	  9
	$DIMLUNIT
	 70
	2
	  9
	$DIMLWD
	 70
	-2
	  9
	$DIMLWE
	 70
	-2
	  9
	$DIMTMOVE
	 70
	0
	  9
	$DIMFXL
	 40
	1.0
	  9
	$DIMFXLON
	 70
	0
	  9
	$DIMJOGANG
	 40
	0.785398163397
	  9
	$DIMTFILL
	 70
	0
	  9
	$DIMTFILLCLR
	 70
	0
	  9
	$DIMARCSYM
	 70
	0
	  9
	$DIMLTYPE
	  6
	
	  9
	$DIMLTEX1
	  6
	
	  9
	$DIMLTEX2
	  6
	
	  9
	$DIMTXTDIRECTION
	 70
	0
	  9
	$LUNITS
	 70
	2
	  9
	$LUPREC
	 70
	4
	  9
	$SKETCHINC
	 40
	0.1
	  9
	$FILLETRAD
	 40
	0.0
	  9
	$AUNITS
	 70
	4
	  9
	$AUPREC
	 70
	5
	  9
	$MENU
	  1
	.
	  9
	$ELEVATION
	 40
	0.0
	  9
	$PELEVATION
	 40
	0.0
	  9
	$THICKNESS
	 40
	0.0
	  9
	$LIMCHECK
	 70
	0
	  9
	$CHAMFERA
	 40
	0.0
	  9
	$CHAMFERB
	 40
	0.0
	  9
	$CHAMFERC
	 40
	0.0
	  9
	$CHAMFERD
	 40
	0.0
	  9
	$SKPOLY
	 70
	0
	  9
	$TDCREATE
	 40
	2457986.69756
	  9
	$TDUCREATE
	 40
	2455631.2632
	  9
	$TDUPDATE
	 40
	2457986.69756
	  9
	$TDUUPDATE
	 40
	2456436.43179
	  9
	$TDINDWG
	 40
	0.0003490741
	  9
	$TDUSRTIMER
	 40
	0.0003487153
	  9
	$USRTIMER
	 70
	1
	  9
	$ANGBASE
	 50
	0.0
	  9
	$ANGDIR
	 70
	0
	  9
	$PDMODE
	 70
	0
	  9
	$PDSIZE
	 40
	0.0
	  9
	$PLINEWID
	 40
	0.0
	  9
	$SPLFRAME
	 70
	0
	  9
	$SPLINETYPE
	 70
	6
	  9
	$SPLINESEGS
	 70
	8
	  9
	$HANDSEED
	  5
	5C7
	  9
	$SURFTAB1
	 70
	6
	  9
	$SURFTAB2
	 70
	6
	  9
	$SURFTYPE
	 70
	6
	  9
	$SURFU
	 70
	6
	  9
	$SURFV
	 70
	6
	  9
	$UCSBASE
	  2
	
	  9
	$UCSNAME
	  2
	
	  9
	$UCSORG
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSXDIR
	 10
	1.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSYDIR
	 10
	0.0
	 20
	1.0
	 30
	0.0
	  9
	$UCSORTHOREF
	  2
	
	  9
	$UCSORTHOVIEW
	 70
	0
	  9
	$UCSORGTOP
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGBOTTOM
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGLEFT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGRIGHT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGFRONT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGBACK
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSBASE
	  2
	
	  9
	$PUCSNAME
	  2
	
	  9
	$PUCSORG
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSXDIR
	 10
	1.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSYDIR
	 10
	0.0
	 20
	1.0
	 30
	0.0
	  9
	$PUCSORTHOREF
	  2
	
	  9
	$PUCSORTHOVIEW
	 70
	0
	  9
	$PUCSORGTOP
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGBOTTOM
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGLEFT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGRIGHT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGFRONT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGBACK
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$USERI1
	 70
	0
	  9
	$USERI2
	 70
	0
	  9
	$USERI3
	 70
	0
	  9
	$USERI4
	 70
	0
	  9
	$USERI5
	 70
	0
	  9
	$USERR1
	 40
	0.0
	  9
	$USERR2
	 40
	0.0
	  9
	$USERR3
	 40
	0.0
	  9
	$USERR4
	 40
	0.0
	  9
	$USERR5
	 40
	0.0
	  9
	$WORLDVIEW
	 70
	1
	  9
	$SHADEDGE
	 70
	3
	  9
	$SHADEDIF
	 70
	70
	  9
	$TILEMODE
	 70
	1
	  9
	$MAXACTVP
	 70
	64
	  9
	$PINSBASE
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PLIMCHECK
	 70
	0
	  9
	$PEXTMIN
	 10
	0.628866766397
	 20
	0.799999952316
	 30
	0.0
	  9
	$PEXTMAX
	 10
	9.02886638493
	 20
	7.19999957085
	 30
	0.0
	  9
	$PLIMMIN
	 10
	-0.700541819174
	 20
	-0.228100386192
	  9
	$PLIMMAX
	 10
	10.2994579405
	 20
	8.27189937351
	  9
	$UNITMODE
	 70
	0
	  9
	$VISRETAIN
	 70
	1
	  9
	$PLINEGEN
	 70
	0
	  9
	$PSLTSCALE
	 70
	1
	  9
	$TREEDEPTH
	 70
	3020
	  9
	$CMLSTYLE
	  2
	Standard
	  9
	$CMLJUST
	 70
	0
	  9
	$CMLSCALE
	 40
	1.0
	  9
	$PROXYGRAPHICS
	 70
	1
	  9
	$MEASUREMENT
	 70
	1
	  9
	$CELWEIGHT
	370
	-1
	  9
	$ENDCAPS
	280
	0
	  9
	$JOINSTYLE
	280
	0
	  9
	$LWDISPLAY
	290
	0
	  9
	$INSUNITS
	 70
	4
	  9
	$HYPERLINKBASE
	  1
	
	  9
	$STYLESHEET
	  1
	
	  9
	$XEDIT
	290
	1
	  9
	$CEPSNTYPE
	380
	0
	  9
	$PSTYLEMODE
	290
	1
	  9
	$FINGERPRINTGUID
	  2
	{39DB1BDD-BC6C-46D3-A333-DFCC0DC4782D}
	  9
	$VERSIONGUID
	  2
	{69EEBB2D-7039-498F-9366-3F994E4A07E7}
	  9
	$EXTNAMES
	290
	1
	  9
	$PSVPSCALE
	 40
	0.0
	  9
	$OLESTARTUP
	290
	0
	  9
	$SORTENTS
	280
	127
	  9
	$INDEXCTL
	280
	0
	  9
	$HIDETEXT
	280
	1
	  9
	$XCLIPFRAME
	280
	0
	  9
	$HALOGAP
	280
	0
	  9
	$OBSCOLOR
	 70
	257
	  9
	$OBSLTYPE
	280
	0
	  9
	$INTERSECTIONDISPLAY
	280
	0
	  9
	$INTERSECTIONCOLOR
	 70
	257
	  9
	$DIMASSOC
	280
	2
	  9
	$PROJECTNAME
	  1
	
	  9
	$CAMERADISPLAY
	290
	0
	  9
	$LENSLENGTH
	 40
	50.0
	  9
	$CAMERAHEIGHT
	 40
	0.0
	  9
	$STEPSPERSEC
	 40
	2.0
	  9
	$STEPSIZE
	 40
	6.0
	  9
	$3DDWFPREC
	 40
	2.0
	  9
	$PSOLWIDTH
	 40
	0.25
	  9
	$PSOLHEIGHT
	 40
	4.0
	  9
	$LOFTANG1
	 40
	1.57079632679
	  9
	$LOFTANG2
	 40
	1.57079632679
	  9
	$LOFTMAG1
	 40
	0.0
	  9
	$LOFTMAG2
	 40
	0.0
	  9
	$LOFTPARAM
	 70
	7
	  9
	$LOFTNORMALS
	280
	1
	  9
	$LATITUDE
	 40
	37.795
	  9
	$LONGITUDE
	 40
	-122.394
	  9
	$NORTHDIRECTION
	 40
	0.0
	  9
	$TIMEZONE
	 70
	-8000
	  9
	$LIGHTGLYPHDISPLAY
	280
	1
	  9
	$TILEMODELIGHTSYNCH
	280
	1
	  9
	$CMATERIAL
	347
	96
	  9
	$SOLIDHIST
	280
	1
	  9
	$SHOWHIST
	280
	1
	  9
	$DWFFRAME
	280
	2
	  9
	$DGNFRAME
	280
	0
	  9
	$REALWORLDSCALE
	290
	1
	  9
	$INTERFERECOLOR
	 62
	1
	  9
	$INTERFEREOBJVS
	345
	A3
	  9
	$INTERFEREVPVS
	346
	A0
	  9
	$CSHADOW
	280
	0
	  9
	$SHADOWPLANELOCATION
	 40
	0.0
	  0
	ENDSEC`
	  return content
	}
	
	const dxfClasses = function () {
	  const content = `  0
	SECTION
	  2
	CLASSES
	  0
	CLASS
	  1
	ACDBDICTIONARYWDFLT
	  2
	AcDbDictionaryWithDefault
	  3
	ObjectDBX Classes
	 90
	0
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	DICTIONARYVAR
	  2
	AcDbDictionaryVar
	  3
	ObjectDBX Classes
	 90
	0
	 91
	15
	280
	0
	281
	0
	  0
	CLASS
	  1
	TABLESTYLE
	  2
	AcDbTableStyle
	  3
	ObjectDBX Classes
	 90
	4095
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	MATERIAL
	  2
	AcDbMaterial
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	3
	280
	0
	281
	0
	  0
	CLASS
	  1
	VISUALSTYLE
	  2
	AcDbVisualStyle
	  3
	ObjectDBX Classes
	 90
	4095
	 91
	26
	280
	0
	281
	0
	  0
	CLASS
	  1
	SCALE
	  2
	AcDbScale
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	17
	280
	0
	281
	0
	  0
	CLASS
	  1
	MLEADERSTYLE
	  2
	AcDbMLeaderStyle
	  3
	ACDB_MLEADERSTYLE_CLASS
	 90
	4095
	 91
	3
	280
	0
	281
	0
	  0
	CLASS
	  1
	CELLSTYLEMAP
	  2
	AcDbCellStyleMap
	  3
	ObjectDBX Classes
	 90
	1152
	 91
	2
	280
	0
	281
	0
	  0
	CLASS
	  1
	EXACXREFPANELOBJECT
	  2
	ExAcXREFPanelObject
	  3
	EXAC_ESW
	 90
	1025
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	NPOCOLLECTION
	  2
	AcDbImpNonPersistentObjectsCollection
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	LAYER_INDEX
	  2
	AcDbLayerIndex
	  3
	ObjectDBX Classes
	 90
	0
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	SPATIAL_INDEX
	  2
	AcDbSpatialIndex
	  3
	ObjectDBX Classes
	 90
	0
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	IDBUFFER
	  2
	AcDbIdBuffer
	  3
	ObjectDBX Classes
	 90
	0
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	DIMASSOC
	  2
	AcDbDimAssoc
	  3
	"AcDbDimAssoc|Product Desc:     AcDim ARX App For Dimension|Company:          Autodesk, Inc.|WEB Address:      www.autodesk.com"
	 90
	0
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	ACDBSECTIONVIEWSTYLE
	  2
	AcDbSectionViewStyle
	  3
	ObjectDBX Classes
	 90
	1025
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	ACDBDETAILVIEWSTYLE
	  2
	AcDbDetailViewStyle
	  3
	ObjectDBX Classes
	 90
	1025
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	IMAGEDEF
	  2
	AcDbRasterImageDef
	  3
	ISM
	 90
	0
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	RASTERVARIABLES
	  2
	AcDbRasterVariables
	  3
	ISM
	 90
	0
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	IMAGEDEF_REACTOR
	  2
	AcDbRasterImageDefReactor
	  3
	ISM
	 90
	1
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	IMAGE
	  2
	AcDbRasterImage
	  3
	ISM
	 90
	2175
	 91
	1
	280
	0
	281
	1
	  0
	CLASS
	  1
	PDFDEFINITION
	  2
	AcDbPdfDefinition
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	PDFUNDERLAY
	  2
	AcDbPdfReference
	  3
	ObjectDBX Classes
	 90
	4095
	 91
	1
	280
	0
	281
	1
	  0
	CLASS
	  1
	DWFDEFINITION
	  2
	AcDbDwfDefinition
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	2
	280
	0
	281
	0
	  0
	CLASS
	  1
	DWFUNDERLAY
	  2
	AcDbDwfReference
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	1
	280
	0
	281
	1
	  0
	CLASS
	  1
	DGNDEFINITION
	  2
	AcDbDgnDefinition
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	2
	280
	0
	281
	0
	  0
	CLASS
	  1
	DGNUNDERLAY
	  2
	AcDbDgnReference
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	1
	280
	0
	281
	1
	  0
	ENDSEC`
	  return content
	}
	
	const dxfTables = function () {
	  const content = `  0
	SECTION
	  2
	TABLES
	  0
	TABLE
	  2
	VPORT
	  5
	8
	330
	0
	100
	AcDbSymbolTable
	 70
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	LTYPE
	  5
	5F
	330
	0
	100
	AcDbSymbolTable
	 70
	7
	  0
	LTYPE
	  5
	14
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	ByBlock
	 70
	0
	  3
	
	 72
	65
	 73
	0
	 40
	0.0
	  0
	LTYPE
	  5
	15
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	ByLayer
	 70
	0
	  3
	
	 72
	65
	 73
	0
	 40
	0.0
	  0
	LTYPE
	  5
	16
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	Continuous
	 70
	0
	  3
	Solid line
	 72
	65
	 73
	0
	 40
	0.0
	  0
	LTYPE
	  5
	1B1
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	CENTER
	 70
	0
	  3
	Center ____ _ ____ _ ____ _ ____ _ ____ _ ____
	 72
	65
	 73
	4
	 40
	2.0
	 49
	1.25
	 74
	0
	 49
	-0.25
	 74
	0
	 49
	0.25
	 74
	0
	 49
	-0.25
	 74
	0
	  0
	LTYPE
	  5
	1B2
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	DASHED
	 70
	0
	  3
	Dashed __ __ __ __ __ __ __ __ __ __ __ __ __ _
	 72
	65
	 73
	2
	 40
	0.75
	 49
	0.5
	 74
	0
	 49
	-0.25
	 74
	0
	  0
	LTYPE
	  5
	1B3
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	PHANTOM
	 70
	0
	  3
	Phantom ______  __  __  ______  __  __  ______
	 72
	65
	 73
	6
	 40
	2.5
	 49
	1.25
	 74
	0
	 49
	-0.25
	 74
	0
	 49
	0.25
	 74
	0
	 49
	-0.25
	 74
	0
	 49
	0.25
	 74
	0
	 49
	-0.25
	 74
	0
	  0
	LTYPE
	  5
	39E
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	HIDDEN
	 70
	0
	  3
	Hidden __ __ __ __ __ __ __ __ __ __ __ __ __ __
	 72
	65
	 73
	2
	 40
	9.525
	 49
	6.35
	 74
	0
	 49
	-3.175
	 74
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	LAYER
	  5
	2
	330
	0
	100
	AcDbSymbolTable
	 70
	3
	  0
	LAYER
	  5
	10
	330
	2
	100
	AcDbSymbolTableRecord
	100
	AcDbLayerTableRecord
	  2
	0
	 70
	0
	  6
	Continuous
	370
	-3
	390
	F
	347
	98
	348
	0
	  0
	LAYER
	  5
	1B4
	330
	2
	100
	AcDbSymbolTableRecord
	100
	AcDbLayerTableRecord
	  2
	View Port
	 70
	0
	  6
	Continuous
	290
	0
	370
	-3
	390
	F
	347
	98
	348
	0
	  0
	LAYER
	  5
	21D
	330
	2
	100
	AcDbSymbolTableRecord
	100
	AcDbLayerTableRecord
	  2
	Defpoints
	 70
	0
	  6
	Continuous
	290
	0
	370
	-3
	390
	F
	347
	98
	348
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	STYLE
	  5
	3
	330
	0
	100
	AcDbSymbolTable
	 70
	3
	  0
	STYLE
	  5
	11
	330
	3
	100
	AcDbSymbolTableRecord
	100
	AcDbTextStyleTableRecord
	  2
	Standard
	 70
	0
	 40
	0.0
	 41
	1.0
	 50
	0.0
	 71
	0
	 42
	0.2
	  3
	arial.ttf
	  4
	
	  0
	STYLE
	  5
	DC
	330
	3
	100
	AcDbSymbolTableRecord
	100
	AcDbTextStyleTableRecord
	  2
	Annotative
	 70
	0
	 40
	0.0
	 41
	1.0
	 50
	0.0
	 71
	0
	 42
	0.2
	  3
	arial.ttf
	  4
	
	  0
	STYLE
	  5
	178
	330
	3
	100
	AcDbSymbolTableRecord
	100
	AcDbTextStyleTableRecord
	  2
	Notes
	 70
	0
	 40
	3.0
	 41
	1.0
	 50
	0.0
	 71
	0
	 42
	0.2
	  3
	arial.ttf
	  4
	
	  0
	ENDTAB
	  0
	TABLE
	  2
	VIEW
	  5
	6
	330
	0
	100
	AcDbSymbolTable
	 70
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	UCS
	  5
	7
	330
	0
	100
	AcDbSymbolTable
	 70
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	APPID
	  5
	9
	330
	0
	100
	AcDbSymbolTable
	 70
	12
	  0
	APPID
	  5
	12
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD
	 70
	0
	  0
	APPID
	  5
	DD
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	AcadAnnoPO
	 70
	0
	  0
	APPID
	  5
	DE
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	AcadAnnotative
	 70
	0
	  0
	APPID
	  5
	DF
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_DSTYLE_DIMJAG
	 70
	0
	  0
	APPID
	  5
	E0
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_DSTYLE_DIMTALN
	 70
	0
	  0
	APPID
	  5
	107
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_MLEADERVER
	 70
	0
	  0
	APPID
	  5
	1B5
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	AcAecLayerStandard
	 70
	0
	  0
	APPID
	  5
	1BA
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_EXEMPT_FROM_CAD_STANDARDS
	 70
	0
	  0
	APPID
	  5
	237
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_DSTYLE_DIMBREAK
	 70
	0
	  0
	APPID
	  5
	28E
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_PSEXT
	 70
	0
	  0
	APPID
	  5
	4B0
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_NAV_VCDISPLAY
	 70
	0
	  0
	APPID
	  5
	4E3
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	HATCHBACKGROUNDCOLOR
	 70
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	DIMSTYLE
	  5
	A
	330
	0
	100
	AcDbSymbolTable
	 70
	3
	100
	AcDbDimStyleTable
	 71
	3
	340
	242
	340
	27
	340
	E1
	  0
	DIMSTYLE
	105
	27
	330
	A
	100
	AcDbSymbolTableRecord
	100
	AcDbDimStyleTableRecord
	  2
	Standard
	 70
	0
	 41
	3.0
	 42
	2.0
	 43
	9.0
	 44
	5.0
	140
	3.0
	141
	2.0
	147
	2.0
	340
	11
	1001
	ACAD_DSTYLE_DIMJAG
	1070
	388
	1040
	38.0
	1001
	ACAD_DSTYLE_DIMBREAK
	1070
	391
	1040
	90.0
	1001
	ACAD_DSTYLE_DIMTALN
	1070
	392
	1070
	0
	  0
	DIMSTYLE
	105
	E1
	330
	A
	100
	AcDbSymbolTableRecord
	100
	AcDbDimStyleTableRecord
	  2
	Annotative
	 70
	0
	 40
	0.0
	 41
	3.0
	 42
	2.5
	 43
	10.0
	 44
	5.0
	140
	3.0
	141
	2.0
	147
	2.0
	340
	11
	1001
	AcadAnnotative
	1000
	AnnotativeData
	1002
	{
	1070
	1
	1070
	1
	1002
	}
	1001
	ACAD_DSTYLE_DIMJAG
	1070
	388
	1040
	38.0
	1001
	ACAD_DSTYLE_DIMBREAK
	1070
	391
	1040
	90.0
	1001
	ACAD_DSTYLE_DIMTALN
	1070
	392
	1070
	0
	  0
	DIMSTYLE
	105
	242
	330
	A
	100
	AcDbSymbolTableRecord
	100
	AcDbDimStyleTableRecord
	  2
	Civil-Metric
	 70
	0
	 41
	3.0
	 42
	1.5
	 43
	6.0
	 44
	3.0
	 73
	0
	 74
	0
	 77
	1
	 78
	3
	 79
	2
	140
	3.0
	141
	3.0
	147
	2.0
	179
	2
	271
	2
	272
	2
	276
	1
	340
	11
	1001
	ACAD_DSTYLE_DIMBREAK
	1070
	391
	1040
	3.0
	1001
	ACAD_DSTYLE_DIMJAG
	1070
	388
	1040
	38.0
	1001
	ACAD_DSTYLE_DIMTALN
	1070
	392
	1070
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	BLOCK_RECORD
	  5
	1
	330
	0
	100
	AcDbSymbolTable
	 70
	4
	  0
	BLOCK_RECORD
	  5
	1F
	330
	1
	100
	AcDbSymbolTableRecord
	100
	AcDbBlockTableRecord
	  2
	*Model_Space
	340
	530
	 70
	0
	280
	1
	281
	0
	  0
	BLOCK_RECORD
	  5
	58
	330
	1
	100
	AcDbSymbolTableRecord
	100
	AcDbBlockTableRecord
	  2
	*Paper_Space
	340
	531
	 70
	0
	280
	1
	281
	0
	  0
	BLOCK_RECORD
	  5
	238
	330
	1
	100
	AcDbSymbolTableRecord
	100
	AcDbBlockTableRecord
	  2
	_ArchTick
	340
	0
	 70
	0
	280
	1
	281
	0
	  0
	BLOCK_RECORD
	  5
	23C
	330
	1
	100
	AcDbSymbolTableRecord
	100
	AcDbBlockTableRecord
	  2
	_Open30
	340
	0
	 70
	0
	280
	1
	281
	0
	  0
	ENDTAB
	  0
	ENDSEC`
	  return content
	}
	
	const dxfBlocks = function () {
	  const content = `  0
	SECTION
	  2
	BLOCKS
	  0
	BLOCK
	  5
	23A
	330
	238
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockBegin
	  2
	_ArchTick
	 70
	0
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  3
	_ArchTick
	  1
	
	  0
	ENDBLK
	  5
	23B
	330
	238
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockEnd
	  0
	BLOCK
	  5
	20
	330
	1F
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockBegin
	  2
	*Model_Space
	 70
	0
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  3
	*Model_Space
	  1
	
	  0
	ENDBLK
	  5
	21
	330
	1F
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockEnd
	  0
	BLOCK
	  5
	5A
	330
	58
	100
	AcDbEntity
	 67
	1
	  8
	0
	100
	AcDbBlockBegin
	  2
	*Paper_Space
	 70
	0
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  3
	*Paper_Space
	  1
	
	  0
	ENDBLK
	  5
	5B
	330
	58
	100
	AcDbEntity
	 67
	1
	  8
	0
	100
	AcDbBlockEnd
	  0
	BLOCK
	  5
	240
	330
	23C
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockBegin
	  2
	_Open30
	 70
	0
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  3
	_Open30
	  1
	
	  0
	ENDBLK
	  5
	241
	330
	23C
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockEnd
	  0
	ENDSEC`
	  return content
	}
	
	const dxfObjects = function () {
	  const content = `  0
	SECTION
	  2
	OBJECTS
	  0
	DICTIONARY
	  5
	C
	330
	0
	100
	AcDbDictionary
	281
	1
	  3
	ACAD_COLOR
	350
	524
	  3
	ACAD_GROUP
	350
	525
	  3
	ACAD_LAYOUT
	350
	526
	  3
	ACAD_MATERIAL
	350
	527
	  3
	ACAD_MLEADERSTYLE
	350
	528
	  3
	ACAD_MLINESTYLE
	350
	529
	  3
	ACAD_PLOTSETTINGS
	350
	52A
	  3
	ACAD_PLOTSTYLENAME
	350
	52C
	  3
	ACAD_SCALELIST
	350
	52D
	  3
	ACAD_TABLESTYLE
	350
	52E
	  3
	ACAD_VISUALSTYLE
	350
	52F
	  0
	DICTIONARY
	  5
	524
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	525
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	526
	330
	C
	100
	AcDbDictionary
	281
	1
	  3
	Model
	350
	530
	  3
	Layout1
	350
	531
	  0
	DICTIONARY
	  5
	527
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	528
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	529
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	52A
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	ACDBPLACEHOLDER
	  5
	52B
	330
	52C
	  0
	ACDBDICTIONARYWDFLT
	  5
	52C
	330
	C
	100
	AcDbDictionary
	281
	1
	  3
	Normal
	350
	52B
	100
	AcDbDictionaryWithDefault
	340
	52B
	  0
	DICTIONARY
	  5
	52D
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	52E
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	52F
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	LAYOUT
	  5
	530
	330
	526
	100
	AcDbPlotSettings
	  1
	
	  2
	DWFx ePlot (XPS Compatible).pc3
	  4
	ANSI_A_(8.50_x_11.00_Inches)
	  6
	
	 40
	5.8
	 41
	17.8
	 42
	5.8
	 43
	17.8
	 44
	215.9
	 45
	279.4
	 46
	0.0
	 47
	0.0
	 48
	0.0
	 49
	0.0
	140
	0.0
	141
	0.0
	142
	1.0
	143
	14.53
	 70
	11952
	 72
	0
	 73
	1
	 74
	0
	  7
	
	 75
	0
	147
	0.069
	148
	114.98
	149
	300.29
	100
	AcDbLayout
	  1
	Model
	 70
	1
	 71
	0
	 10
	0.0
	 20
	0.0
	 11
	12.0
	 21
	9.0
	 12
	0.0
	 22
	0.0
	 32
	0.0
	 14
	0.0
	 24
	0.0
	 34
	0.0
	 15
	0.0
	 25
	0.0
	 35
	0.0
	146
	0.0
	 13
	0.0
	 23
	0.0
	 33
	0.0
	 16
	1.0
	 26
	0.0
	 36
	0.0
	 17
	0.0
	 27
	1.0
	 37
	0.0
	 76
	0
	330
	1F
	  0
	LAYOUT
	  5
	531
	330
	526
	100
	AcDbPlotSettings
	  1
	
	  2
	DWFx ePlot (XPS Compatible).pc3
	  4
	ANSI_A_(8.50_x_11.00_Inches)
	  6
	
	 40
	5.8
	 41
	17.8
	 42
	5.8
	 43
	17.8
	 44
	215.9
	 45
	279.4
	 46
	0.0
	 47
	0.0
	 48
	0.0
	 49
	0.0
	140
	0.0
	141
	0.0
	142
	1.0
	143
	1.0
	 70
	688
	 72
	0
	 73
	1
	 74
	5
	  7
	acad.ctb
	 75
	16
	147
	1.0
	148
	0.0
	149
	0.0
	100
	AcDbLayout
	  1
	Layout1
	 70
	1
	 71
	1
	 10
	-0.7
	 20
	-0.23
	 11
	10.3
	 21
	8.27
	 12
	0.0
	 22
	0.0
	 32
	0.0
	 14
	0.63
	 24
	0.8
	 34
	0.0
	 15
	9.0
	 25
	7.2
	 35
	0.0
	146
	0.0
	 13
	0.0
	 23
	0.0
	 33
	0.0
	 16
	1.0
	 26
	0.0
	 36
	0.0
	 17
	0.0
	 27
	1.0
	 37
	0.0
	 76
	0
	330
	58
	  0
	ENDSEC`
	  return content
	}
	
	const dxfEntities = (objects, options) => {
	  const entityContents = objects.map((object, i) => {
	    return PolygonsTo3DFaces(object, options)
	  });
	
	  let section = `  0
	SECTION
	  2
	ENTITIES
	`
	  entityContents.forEach((content) => {
	    if (content) {
	      section += content
	    }
	  })
	  section += `  0
	ENDSEC`
	  return section
	}
	
	
	const serialize = (options, ...objects) => {
	  const defaults = {
	    geom3To: '3dface', // or polyline
	    pathTo: 'lwpolyline',
	    statusCallback: null,
	    colorIndex: 0
	  }
	  options = Object.assign({}, defaults, options)
	
	  options.entityId = 0 // sequence id for entities created
	
	  if (objects.length === 0) throw new Error('only JSCAD geometries can be serialized to DXF')
	
	  const dxfContent = `999
	Created by JSCAD
	${dxfHeaders(options)}
	${dxfClasses(options)}
	${dxfTables(options)}
	${dxfBlocks(options)}
	${dxfEntities(objects, options)}
	${dxfObjects(options)}
	  0
	EOF
	`
	  return [dxfContent]
	}
	
	let polygonToTriangles = (polygon) => {
	  const length = polygon.vertices.length - 2
	  if (length < 1) return []
	
	  const pivot = polygon.vertices[0]
	  const triangles = []
	  for (let i = 0; i < length; i++) {
	    triangles.push([pivot, polygon.vertices[i + 1], polygon.vertices[i + 2]])
	  }
	  return triangles
	}
	
	let triangleTo3DFaces = (triangle, options, color) => {
	  const corner10 = triangle[0].pos;
	  const corner11 = triangle[1].pos;
	  const corner12 = triangle[2].pos;
	  const corner13 = triangle[2].pos;
	  const str = `  0
	3DFACE
	  5
	MyPart
	  100
	AcDbEntity
	  8
	0
	  62
	${color}
	  100
	AcDbFace
	  70
	0
	  10
	${corner10.x}
	  20
	${corner10.y}
	  30
	${corner10.z}
	  11
	${corner11.x}
	  21
	${corner11.y}
	  31
	${corner11.z}
	  12
	${corner12.x}
	  22
	${corner12.y}
	  32
	${corner12.z}
	  13
	${corner13.x}
	  23
	${corner13.y}
	  33
	${corner13.z}
	`
	  return str
	}
	
	let PolygonsTo3DFaces = (csg, options) => {
	  let str = ''
	  const polygons = csg.polygons
	  // const objectColor = getColorNumber(object, options)
	  polygons.forEach((polygon, i) => {
	    const polyColor = 0;//polygon.color ? getColorNumber(polygon, options) : objectColor
	    const triangles = polygonToTriangles(polygon)
	    triangles.forEach((triangle, i) => {
	      str += triangleTo3DFaces(triangle, options, polyColor)
	    })
	  })
	  return [str]
	}
	exports.dxfHeaders = dxfHeaders
	exports.dxfClasses = dxfClasses
	exports.dxfTables = dxfTables
	exports.dxfBlocks = dxfBlocks
	exports.dxfObjects = dxfObjects
	exports.dxfEntities = dxfEntities
	exports.serialize = serialize
	
	
	
	
	
});


RequireJS.addFunction('./public/js/3d-modeling/viewer.js',
function (require, exports, module) {
	

	
	const du = require('../../../../../public/js/utils/dom-utils.js');
	const CSG = require('./csg.js');
	const GL = require('./lightgl.js');
	
	// Set the color of all polygons in this solid
	CSG.prototype.setColor = function(r, g, b) {
	  this.toPolygons().map(function(polygon) {
	    if (Array.isArray(r)) {
	      g = r[1];
	      b = r[2];
	      r = r[0];
	    }
	    polygon.shared = [r/255, g/255, b/255];
	  });
	};
	
	// Convert from CSG solid to GL.Mesh object
	CSG.prototype.toMesh = function() {
	  var mesh = new GL.Mesh({ normals: true, colors: true });
	  var indexer = new GL.Indexer();
	  this.toPolygons().map(function(polygon) {
	    var indices = polygon.vertices.map(function(vertex) {
	      vertex.color = polygon.shared || [1, 1, 1];
	      return indexer.add(vertex);
	    });
	    for (var i = 2; i < indices.length; i++) {
	      mesh.triangles.push([indices[0], indices[i - 1], indices[i]]);
	    }
	  });
	  mesh.vertices = indexer.unique.map(function(v) { return [v.pos.x, v.pos.y, v.pos.z]; });
	  mesh.normals = indexer.unique.map(function(v) { return [v.normal.x, v.normal.y, v.normal.z]; });
	  mesh.colors = indexer.unique.map(function(v) { return v.color; });
	  mesh.computeWireframe();
	  return mesh;
	};
	
	var angleX = 0;
	var angleY = 0;
	var viewers = [];
	
	// Set to true so lines don't use the depth buffer
	Viewer.lineOverlay = false;
	
	// A viewer is a WebGL canvas that lets the user view a mesh. The user can
	// tumble it around by dragging the mouse.
	function Viewer(csg, width, height, depth) {
	  viewers.push(this);
	  this.setDepth = (d) => depth = d;
	  let x = 0;
	  let y = 0;
	
	  let lastZoom;
	  let zoomCount = 0;
	  const zoom = (out) => {
	    let direction = (out === true ? 1 : -1);
	    let zoomOffset = 2;
	    let newTime = new Date().getTime();
	    if (lastZoom > newTime - 50) {
	      zoomCount++;
	      zoomOffset *= zoomCount;
	      zoomOffset = zoomOffset > 20 ? 20 : zoomOffset;
	    }
	    lastZoom = newTime;
	    depth += zoomOffset * direction;
	  };
	  this.zoom = zoom;
	  const pan = (leftRight, upDown) => {
	    x += leftRight;
	    y += upDown * -1;
	  }
	
	  // Get a new WebGL canvas
	  var gl = GL.create();
	  this.gl = gl;
	  this.mesh = csg.toMesh();
	  this.canvas = () => gl.canvas;
	
	  // Set up the viewport
	  gl.canvas.width = width;
	  gl.canvas.height = height;
	  gl.viewport(0, 0, width, height);
	  gl.matrixMode(gl.PROJECTION);
	  gl.loadIdentity();
	  gl.perspective(100, width / height, 0.1, 1000);
	  gl.rotate(180, 0, 1, 0);
	  gl.matrixMode(gl.MODELVIEW);
	
	  // Set up WebGL state
	  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	  gl.clearColor(0.93, 0.93, 0.93, 1);
	  gl.enable(gl.DEPTH_TEST);
	  gl.enable(gl.CULL_FACE);
	  gl.polygonOffset(1, 1);
	
	  // Black shader for wireframe
	  this.blackShader = new GL.Shader('\
	    void main() {\
	      gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
	    }\
	  ', '\
	    void main() {\
	      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);\
	    }\
	  ');
	
	  // Shader with diffuse and specular lighting
	  this.lightingShader = new GL.Shader('\
	    varying vec3 color;\
	    varying vec3 normal;\
	    varying vec3 light;\
	    void main() {\
	      const vec3 lightDir = vec3(3.0, 2.0, 3.0) / 3.741657386773941;\
	      light = (gl_ModelViewMatrix * vec4(lightDir, 0.005)).xyz;\
	      color = gl_Color.rgb;\
	      normal = gl_NormalMatrix * gl_Normal;\
	      gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
	    }\
	  ', '\
	    varying vec3 color;\
	    varying vec3 normal;\
	    varying vec3 light;\
	    void main() {\
	      vec3 n = normalize(normal);\
	      float diffuse = max(0.0, dot(light, n));\
	      float specular = pow(max(0.0, -reflect(light, n).z), 32.0) * sqrt(diffuse);\
	      gl_FragColor = vec4(mix(color * (0.3 + 0.7 * diffuse), vec3(1.0), specular), 1.0);\
	    }\
	  ');
	
	  function rotateEvent(e) {
	    angleY += e.deltaX * 2;
	    angleX += e.deltaY * 2;
	    // angleX = Math.max(-90, Math.min(90, angleX));
	  }
	
	  gl.onmousemove = function(e) {
	    if (e.dragging) {
	      if (shiftHeld) panEvent(e);
	      else rotateEvent(e);
	      gl.ondraw();
	    }
	  };
	
	  function zoomEvent(e) {
	    const st = document.documentElement.scrollTop;
	    if (e.deltaY < 0) {
	      zoom(true);
	    } else {
	      zoom();
	    }
	  }
	
	  function panEvent(e) {
	    const st = document.documentElement.scrollTop;
	    pan(e.deltaX, e.deltaY)
	  }
	
	  let lastScrollTop = 0;
	  gl.canvas.onwheel = function (e) {
	    zoomEvent(e);
	    gl.ondraw();
	  }
	  disableScroll(gl.canvas);
	
	  let shiftHeld = false;
	  window.onkeydown = (e) => {
	    shiftHeld = e.key === "Shift" ? true : false;
	  }
	  window.onkeyup = (e) => {
	    shiftHeld = !shiftHeld || e.key === "Shift" ? false : true;
	  }
	
	  var that = this;
	  gl.ondraw = function() {
	    gl.makeCurrent();
	
	    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	    gl.loadIdentity();
	    gl.translate(-x, y, -depth);
	    gl.rotate(angleX, -1, 0, 0);
	    gl.rotate(angleY, 0, -1, 0);
	
	    if (!Viewer.lineOverlay) gl.enable(gl.POLYGON_OFFSET_FILL);
	    that.lightingShader.draw(that.mesh, gl.TRIANGLES);
	    if (!Viewer.lineOverlay) gl.disable(gl.POLYGON_OFFSET_FILL);
	
	    if (Viewer.lineOverlay) gl.disable(gl.DEPTH_TEST);
	    gl.enable(gl.BLEND);
	    // that.blackShader.draw(that.mesh, gl.LINES);
	    gl.disable(gl.BLEND);
	    if (Viewer.lineOverlay) gl.enable(gl.DEPTH_TEST);
	  };
	
	  gl.ondraw();
	
	  // gl.canvas.width = '100vw';
	  // gl.canvas.height = '100vh';
	}
	
	var nextID = 0;
	function addViewer(viewer, id) {
	  du.find(id).appendChild(viewer.gl.canvas);
	}
	
	
	
	
	// left: 37, up: 38, right: 39, down: 40,
	// spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36
	var keys = {37: 1, 38: 1, 39: 1, 40: 1};
	
	function preventDefault(e) {
	  e.preventDefault();
	}
	
	function preventDefaultForScrollKeys(e) {
	  if (keys[e.keyCode]) {
	    preventDefault(e);
	    return false;
	  }
	}
	
	// modern Chrome requires { passive: false } when adding event
	var supportsPassive = false;
	try {
	  window.addEventListener("test", null, Object.defineProperty({}, 'passive', {
	    get: function () { supportsPassive = true; }
	  }));
	} catch(e) {}
	
	var wheelOpt = supportsPassive ? { passive: false } : false;
	var wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel';
	
	// call this to Disable
	function disableScroll(element) {
	  element.addEventListener('DOMMouseScroll', preventDefault, false); // older FF
	  element.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop
	  element.addEventListener('touchmove', preventDefault, wheelOpt); // mobile
	  element.addEventListener('keydown', preventDefaultForScrollKeys, false);
	}
	
	// call this to Enable
	function enableScroll(element) {
	  element.removeEventListener('DOMMouseScroll', preventDefault, false);
	  element.removeEventListener(wheelEvent, preventDefault, wheelOpt);
	  element.removeEventListener('touchmove', preventDefault, wheelOpt);
	  element.removeEventListener('keydown', preventDefaultForScrollKeys, false);
	}
	exports.Viewer = Viewer
	exports.addViewer = addViewer
	exports.preventDefault = preventDefault
	exports.preventDefaultForScrollKeys = preventDefaultForScrollKeys
	exports.disableScroll = disableScroll
	exports.enableScroll = enableScroll
	
});


RequireJS.addFunction('../../public/js/utils/custom-event.js',
function (require, exports, module) {
	

	
	
	class CustomEvent {
	  constructor(name) {
	    const watchers = [];
	    this.name = name;
	
	    const runFuncs = (e, detail) => watchers.forEach((func) => func(e, detail));
	
	    this.on = function (func) {
	      if ((typeof func) === 'function') {
	        watchers.push(func);
	      } else {
	        return 'on' + name;
	      }
	    }
	
	    this.trigger = function (element, detail) {
	      element = element ? element : window;
	      runFuncs(element, detail);
	      this.event.detail = detail;
	      if(document.createEvent){
	          element.dispatchEvent(this.event);
	      } else {
	          element.fireEvent("on" + this.event.eventType, this.event);
	      }
	    }
	//https://stackoverflow.com/questions/2490825/how-to-trigger-event-in-javascript
	    this.event;
	    if(document.createEvent){
	        this.event = document.createEvent("HTMLEvents");
	        this.event.initEvent(name, true, true);
	        this.event.eventName = name;
	    } else {
	        this.event = document.createEventObject();
	        this.event.eventName = name;
	        this.event.eventType = name;
	    }
	  }
	}
	
	module.exports = CustomEvent;
	
});


RequireJS.addFunction('../../public/js/utils/string-math-evaluator.js',
function (require, exports, module) {
	
const FunctionCache = require('./services/function-cache.js');
	
	function regexToObject (str, reg) {
	  const match = str.match(reg);
	  if (match === null) return null;
	  const returnVal = {};
	  for (let index = 2; index < arguments.length; index += 1) {
	    const attr = arguments[index];
	    if (attr) returnVal[attr] = match[index - 1];
	  }
	  return returnVal;
	}
	
	class StringMathEvaluator {
	  constructor(globalScope, resolver) {
	    globalScope = globalScope || {};
	    const instance = this;
	    let splitter = '.';
	
	    function resolve (path, currObj, globalCheck) {
	      if (path === '') return currObj;
	      const resolved = !globalCheck && resolver && resolver(path, currObj);
	      if (Number.isFinite(resolved)) return resolved;
	      try {
	        if ((typeof path) === 'string') path = path.split(splitter);
	        for (let index = 0; index < path.length; index += 1) {
	          currObj = currObj[path[index]];
	        }
	        if (currObj === undefined && !globalCheck) throw Error('try global');
	        return currObj;
	      }  catch (e) {
	        if (!globalCheck) return resolve(path, globalScope, true);
	      }
	    }
	
	    function multiplyOrDivide (values, operands) {
	      const op = operands[operands.length - 1];
	      if (op === StringMathEvaluator.multi || op === StringMathEvaluator.div) {
	        const len = values.length;
	        values[len - 2] = op(values[len - 2], values[len - 1])
	        values.pop();
	        operands.pop();
	      }
	    }
	
	    const resolveArguments = (initialChar, func) => {
	      return function (expr, index, values, operands, scope, path) {
	        if (expr[index] === initialChar) {
	          const args = [];
	          let endIndex = index += 1;
	          const terminationChar = expr[index - 1] === '(' ? ')' : ']';
	          let terminate = false;
	          let openParenCount = 0;
	          while(!terminate && endIndex < expr.length) {
	            const currChar = expr[endIndex++];
	            if (currChar === '(') openParenCount++;
	            else if (openParenCount > 0 && currChar === ')') openParenCount--;
	            else if (openParenCount === 0) {
	              if (currChar === ',') {
	                args.push(expr.substr(index, endIndex - index - 1));
	                index = endIndex;
	              } else if (openParenCount === 0 && currChar === terminationChar) {
	                args.push(expr.substr(index, endIndex++ - index - 1));
	                terminate = true;
	              }
	            }
	          }
	
	          for (let index = 0; index < args.length; index += 1) {
	            const stringMatch = args[index].match(StringMathEvaluator.stringReg);
	            if (stringMatch) {
	              args[index] = stringMatch[1];
	            } else {
	              args[index] =  instance.eval(args[index], scope);
	            }
	          }
	          const state = func(expr, path, scope, args, endIndex);
	          if (state) {
	            values.push(state.value);
	            return state.endIndex;
	          }
	        }
	      }
	    };
	
	    function chainedExpressions(expr, value, endIndex, path) {
	      if (expr.length === endIndex) return {value, endIndex};
	      let values = [];
	      let offsetIndex;
	      let valueIndex = 0;
	      let chained = false;
	      do {
	        const subStr = expr.substr(endIndex);
	        const offsetIndex = isolateArray(subStr, 0, values, [], value, path) ||
	                            isolateFunction(subStr, 0, values, [], value, path) ||
	                            (subStr[0] === '.' &&
	                              isolateVar(subStr, 1, values, [], value));
	        if (Number.isInteger(offsetIndex)) {
	          value = values[valueIndex];
	          endIndex += offsetIndex - 1;
	          chained = true;
	        }
	      } while (offsetIndex !== undefined);
	      return {value, endIndex};
	    }
	
	    const isolateArray = resolveArguments('[',
	      (expr, path, scope, args, endIndex) => {
	        endIndex = endIndex - 1;
	        let value = resolve(path, scope)[args[args.length - 1]];
	        return chainedExpressions(expr, value, endIndex, '');
	      });
	
	    const isolateFunction = resolveArguments('(',
	      (expr, path, scope, args, endIndex) =>
	          chainedExpressions(expr, resolve(path, scope).apply(null, args), endIndex, ''));
	
	    function isolateParenthesis(expr, index, values, operands, scope) {
	      const char = expr[index];
	      if (char === ')') throw new Error('UnExpected closing parenthesis');
	      if (char === '(') {
	        let openParenCount = 1;
	        let endIndex = index + 1;
	        while(openParenCount > 0 && endIndex < expr.length) {
	          const currChar = expr[endIndex++];
	          if (currChar === '(') openParenCount++;
	          if (currChar === ')') openParenCount--;
	        }
	        if (openParenCount > 0) throw new Error('UnClosed parenthesis');
	        const len = endIndex - index - 2;
	        values.push(instance.eval(expr.substr(index + 1, len), scope));
	        multiplyOrDivide(values, operands);
	        return endIndex;
	      }
	    };
	
	    function isolateOperand (char, operands) {
	      if (char === ')') throw new Error('UnExpected closing parenthesis');
	      switch (char) {
	        case '*':
	        operands.push(StringMathEvaluator.multi);
	        return true;
	        break;
	        case '/':
	        operands.push(StringMathEvaluator.div);
	        return true;
	        break;
	        case '+':
	        operands.push(StringMathEvaluator.add);
	        return true;
	        break;
	        case '-':
	        operands.push(StringMathEvaluator.sub);
	        return true;
	        break;
	      }
	      return false;
	    }
	
	    function isolateValueReg(reg, resolver) {
	      return function (expr, index, values, operands, scope) {
	        const match = expr.substr(index).match(reg);
	        let args;
	        if (match) {
	          let endIndex = index + match[0].length;
	          let value = resolver(match[0], scope);
	          if (!Number.isFinite(value)) {
	            const state = chainedExpressions(expr, scope, endIndex, match[0]);
	            if (state !== undefined) {
	              value = state.value;
	              endIndex = state.endIndex;
	            }
	          }
	          values.push(value);
	          multiplyOrDivide(values, operands);
	          return endIndex;
	        }
	      }
	    }
	
	    function convertFeetInchNotation(expr) {
	      expr = expr.replace(StringMathEvaluator.footInchReg, '($1*12+$2)') || expr;
	      expr = expr.replace(StringMathEvaluator.inchReg, '$1') || expr;
	      expr = expr.replace(StringMathEvaluator.footReg, '($1*12)') || expr;
	      return expr = expr.replace(StringMathEvaluator.multiMixedNumberReg, '($1+$2)') || expr;
	    }
	    function addUnexpressedMultiplicationSigns(expr) {
	      expr = expr.replace(/([0-9]{1,})(\s*)([a-zA-Z]{1,})/g, '$1*$3');
	      expr = expr.replace(/([a-zA-Z]{1,})\s{1,}([0-9]{1,})/g, '$1*$2');
	      expr = expr.replace(/\)([^a-z^A-Z^$^\s^)^+^\-^*^\/])/g, ')*$1');
	      return expr.replace(/([^a-z^A-Z^\s^$^(^+^\-^*^\/])\(/g, '$1*(');
	    }
	
	    const isolateNumber = isolateValueReg(StringMathEvaluator.decimalReg, Number.parseFloat);
	    const isolateVar = isolateValueReg(StringMathEvaluator.varReg, resolve);
	
	    function evaluate(expr, scope, percision) {
	      if (Number.isFinite(expr))
	        return expr;
	      expr = new String(expr);
	      expr = addUnexpressedMultiplicationSigns(expr);
	      expr = convertFeetInchNotation(expr);
	      scope = scope || globalScope;
	      const allowVars = (typeof scope) === 'object';
	      let operands = [];
	      let values = [];
	      let prevWasOpperand = true;
	      for (let index = 0; index < expr.length; index += 1) {
	        const char = expr[index];
	        if (prevWasOpperand) {
	          try {
	            let newIndex = isolateNumber(expr, index, values, operands, scope);
	            if (!newIndex && isolateOperand(char, operands))
	                throw new Error(`Invalid operand location ${expr.substr(0,index)}'${expr[index]}'${expr.substr(index + 1)}`);
	            newIndex ||= isolateParenthesis(expr, index, values, operands, scope) ||
	                (allowVars && isolateVar(expr, index, values, operands, scope));
	            if (Number.isInteger(newIndex)) {
	              index = newIndex - 1;
	              prevWasOpperand = false;
	            }
	          } catch (e) {
	            console.error(e);
	            return NaN;
	          }
	        } else {
	          prevWasOpperand = isolateOperand(char, operands);
	        }
	      }
	      if (prevWasOpperand) return NaN;
	
	      let value = values[0];
	      for (let index = 0; index < values.length - 1; index += 1) {
	        value = operands[index](values[index], values[index + 1]);
	        values[index + 1] = value;
	      }
	
	      if (Number.isFinite(value)) {
	        value = value;
	        return value;
	      }
	      return NaN;
	    }
	
	    this.eval = new FunctionCache(evaluate, this, 'sme');
	
	    this.evalObject = new FunctionCache((obj, scope) => {
	      const returnObj = Object.forEachConditional(obj, (value, key, object) => {
	        value = evaluate(value, scope);
	        if (!Number.isNaN(value)) object[key] = value;
	      }, (value) => (typeof value) === 'string');
	      return returnObj;
	    }, this, 'sme');
	  }
	}
	
	StringMathEvaluator.regex = /^\s*(([0-9]*)\s{1,}|)(([0-9]{1,})\s*\/([0-9]{1,})\s*|)$/;
	
	const mixNumberRegStr = "([0-9]{1,})\\s{1,}(([0-9]{1,})\\/([0-9]{1,}))";
	StringMathEvaluator.mixedNumberReg = new RegExp(`^${mixNumberRegStr}$`);
	StringMathEvaluator.multiMixedNumberReg = new RegExp(mixNumberRegStr, 'g');///([0-9]{1,})\s{1,}([0-9]{1,}\/[0-9]{1,})/g;
	StringMathEvaluator.fractionOrMixedNumberReg = /(^([0-9]{1,})\s|^){1,}([0-9]{1,}\/[0-9]{1,})$/;
	StringMathEvaluator.footInchReg = /\s*([0-9]{1,})\s*'\s*([0-9\/ ]{1,})\s*"\s*/g;
	StringMathEvaluator.footReg = /\s*([0-9]{1,})\s*'\s*/g;
	StringMathEvaluator.inchReg = /\s*([0-9]{1,})\s*"\s*/g;
	StringMathEvaluator.evaluateReg = /[-\+*/]|^\s*[0-9]{1,}\s*$/;
	const decimalRegStr = "((-|)(([0-9]{1,}\\.[0-9]{1,})|[0-9]{1,}(\\.|)|(\\.)[0-9]{1,}))";
	StringMathEvaluator.decimalReg = new RegExp(`^${decimalRegStr}`);///^(-|)(([0-9]{1,}\.[0-9]{1,})|[0-9]{1,}(\.|)|(\.)[0-9]{1,})/;
	StringMathEvaluator.multiDecimalReg = new RegExp(decimalRegStr, 'g');
	StringMathEvaluator.varReg = /^((\.|)([$_a-zA-Z][$_a-zA-Z0-9\.]*))/;
	StringMathEvaluator.stringReg = /\s*['"](.*)['"]\s*/;
	StringMathEvaluator.multi = (n1, n2) => n1 * n2;
	StringMathEvaluator.div = (n1, n2) => n1 / n2;
	StringMathEvaluator.add = (n1, n2) => n1 + n2;
	StringMathEvaluator.sub = (n1, n2) => n1 - n2;
	
	const npf = Number.parseFloat;
	StringMathEvaluator.convert = {eqn: {}};
	StringMathEvaluator.convert.metricToImperial = (value) => {
	  value = npf(value);
	  return value / 2.54;
	}
	
	StringMathEvaluator.resolveMixedNumber = (value) => {
	  const match = value.match(StringMathEvaluator.mixedNumberReg);
	  if (match) {
	    value = npf(match[1]) + (npf(match[3]) / npf(match[4]));
	  }
	  value = npf(value);
	  return value;
	}
	
	StringMathEvaluator.convert.imperialToMetric = (value) => {
	  value = npf(value);
	  return value * 2.54;
	}
	
	StringMathEvaluator.convert.eqn.metricToImperial = (str) =>
	  str.replace(StringMathEvaluator.multiDecimalReg, StringMathEvaluator.convert.metricToImperial);
	
	StringMathEvaluator.convert.eqn.imperialToMetric = (str) =>
	  str.replace(StringMathEvaluator.multiMixedNumberReg, StringMathEvaluator.resolveMixedNumber)
	  .replace(StringMathEvaluator.multiDecimalReg, StringMathEvaluator.convert.imperialToMetric);
	
	StringMathEvaluator.primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
	
	
	StringMathEvaluator.reduce = function(numerator, denominator) {
	  let reduced = true;
	  while (reduced) {
	    reduced = false;
	    for (let index = 0; index < StringMathEvaluator.primes.length; index += 1) {
	      const prime = StringMathEvaluator.primes[index];
	      if (prime >= denominator) break;
	      if (numerator % prime === 0 && denominator % prime === 0) {
	        numerator = numerator / prime;
	        denominator = denominator / prime;
	        reduced = true;
	        break;
	      }
	    }
	  }
	  if (numerator === 0) {
	    return '';
	  }
	  return `${numerator}/${denominator}`;
	}
	
	StringMathEvaluator.parseFraction = function (str) {
	  const regObj = regexToObject(str, StringMathEvaluator.regex, null, 'integer', null, 'numerator', 'denominator');
	  regObj.integer = Number.parseInt(regObj.integer) || 0;
	  regObj.numerator = Number.parseInt(regObj.numerator) || 0;
	  regObj.denominator = Number.parseInt(regObj.denominator) || 0;
	  if(regObj.denominator === 0) {
	    regObj.numerator = 0;
	    regObj.denominator = 1;
	  }
	  regObj.decimal = regObj.integer + (regObj.numerator / regObj.denominator);
	  return regObj;
	}
	
	StringMathEvaluator.toFraction = function (decimal, accuracy) {
	  if (decimal === NaN) return NaN;
	  accuracy = accuracy || '1/1000'
	  const fracObj = StringMathEvaluator.parseFraction(accuracy);
	  const denominator = fracObj.denominator;
	  if (fracObj.decimal === 0 || fracObj.integer > 0 || denominator > 1000) {
	    throw new Error('Please enter a fraction with a denominator between (0, 1000]')
	  }
	  let remainder = decimal;
	  let currRemainder = remainder;
	  let value = 0;
	  let numerator = 0;
	  while (currRemainder > 0) {
	    numerator += fracObj.numerator;
	    currRemainder -= fracObj.decimal;
	  }
	  const diff1 = decimal - ((numerator - fracObj.numerator) / denominator);
	  const diff2 = (numerator / denominator) - decimal;
	  numerator -= diff1 < diff2 ? fracObj.numerator : 0;
	  const integer = Math.floor(numerator / denominator);
	  numerator = numerator % denominator;
	  const fraction = StringMathEvaluator.reduce(numerator, denominator);
	  return (integer && fraction ? `${integer} ${fraction}` :
	            (integer ? `${integer}` : (fraction ? `${fraction}` : '0')));
	}
	
	try {
	  module.exports = StringMathEvaluator;
	} catch (e) {/* TODO: Consider Removing */}
	
});


RequireJS.addFunction('../../public/js/utils/$t.js',
function (require, exports, module) {
	

	
	
	
	const CustomEvent = require('./custom-event');
	const ExprDef = require('./expression-definition');
	
	class $t {
		constructor(template, id, selector) {
			if (selector) {
				const afterRenderEvent = new CustomEvent('afterRender');
				const beforeRenderEvent = new CustomEvent('beforeRender');
			}
	
			function varReg(prefix, suffix) {
			  const vReg = '([a-zA-Z_\\$][a-zA-Z0-9_\\$]*)';
			  prefix = prefix ? prefix : '';
			  suffix = suffix ? suffix : '';
			  return new RegExp(`${prefix}${vReg}${suffix}`)
			};
	
			function replace(needleRegEx, replaceStr, exceptions) {
			  return function (sub) {
			    if (!exceptions || exceptions.indexOf(sub) === -1) {
			      return sub.replace(needleRegEx, replaceStr)
			    } else {
			      return sub;
			    }
			  }
			}
	
			const signProps = {opening: /([-+\!])/};
			const relationalProps = {opening: /((\<|\>|\<\=|\>\=|\|\||\||&&|&))/};
			const ternaryProps = {opening: /\?/};
			const keyWordProps = {opening: /(new|null|undefined|typeof|NaN|true|false)[^a-z^A-Z]/, tailOffset: -1};
			const ignoreProps = {opening: /new \$t\('.*?'\).render\(.*?, '(.*?)', get\)/};
			const commaProps = {opening: /,/};
			const colonProps = {opening: /:/};
			const multiplierProps = {opening: /(===|[-+=*\/](=|))/};
			const stringProps = {opening: /('|"|`)(\1|.*?([^\\]((\\\\)*?|[^\\])(\1)))/};
			const spaceProps = {opening: /\s{1}/};
			const numberProps = {opening: /([0-9]*((\.)[0-9]{1,})|[0-9]{1,})/};
			const objectProps = {opening: '{', closing: '}'};
			const objectLabelProps = {opening: varReg(null, '\\:')};
			const groupProps = {opening: /\(/, closing: /\)/};
			const expressionProps = {opening: null, closing: null};
			const attrProps = {opening: varReg('(\\.', '){1,}')};
	
			// const funcProps = {
			//   opening: varReg(null, '\\('),
			//   onOpen: replace(varReg(null, '\\('), 'get("$1")('),
			//   closing: /\)/
			// };
			const arrayProps = {
			  opening: varReg(null, '\\['),
			  onOpen: replace(varReg(null, '\\['), 'get("$1")['),
			  closing: /\]/
			};
			const funcRefProps = {
				opening: /\[|\(/,
				closing: /\]|\)/
			};
			const memberRefProps = {
				opening: varReg('\\.', ''),
			};
			const variableProps = {
			  opening: varReg(),
			  onOpen: replace(varReg(), 'get("$1")'),
			};
			const objectShorthandProps = {
			  opening: varReg(),
			  onOpen: replace(varReg(), '$1: get("$1")'),
			};
	
	
			const expression = new ExprDef('expression', expressionProps);
			const ternary = new ExprDef('ternary', ternaryProps);
			const relational = new ExprDef('relational', relationalProps);
			const comma = new ExprDef('comma', commaProps);
			const colon = new ExprDef('colon', colonProps);
			const attr = new ExprDef('attr', attrProps);
			// const func = new ExprDef('func', funcProps);
			const funcRef = new ExprDef('funcRef', funcRefProps);
			const memberRef = new ExprDef('memberRef', memberRefProps);
			const string = new ExprDef('string', stringProps);
			const space = new ExprDef('space', spaceProps);
			const keyWord = new ExprDef('keyWord', keyWordProps);
			const group = new ExprDef('group', groupProps);
			const object = new ExprDef('object', objectProps);
			const array = new ExprDef('array', arrayProps);
			const number = new ExprDef('number', numberProps);
			const multiplier = new ExprDef('multiplier', multiplierProps);
			const sign = new ExprDef('sign', signProps);
			const ignore = new ExprDef('ignore', ignoreProps);
			const variable = new ExprDef('variable', variableProps);
			const objectLabel = new ExprDef('objectLabel', objectLabelProps);
			const objectShorthand = new ExprDef('objectShorthand', objectShorthandProps);
	
			expression.always(space, ignore, keyWord);
			expression.if(string, number, group, array, variable, funcRef, memberRef)
			      .then(multiplier, sign, relational, group)
			      .repeat();
			expression.if(string, group, array, variable, funcRef, memberRef)
						.then(attr)
			      .then(multiplier, sign, relational, expression, funcRef, memberRef)
						.repeat();
			expression.if(string, group, array, variable, funcRef, memberRef)
						.then(attr)
						.end();
	
			funcRef.if(expression).then(comma).repeat();
			funcRef.if(expression).end();
			memberRef.if(expression).then(comma).repeat();
			memberRef.if(expression).end();
	
			expression.if(sign)
			      .then(expression)
			      .then(multiplier, sign, relational, group)
			      .repeat();
			expression.if(string, number, group, array, variable)
			      .then(ternary)
			      .then(expression)
			      .then(colon)
			      .then(expression)
			      .end();
			expression.if(ternary)
			      .then(expression)
			      .then(colon)
			      .then(expression)
			      .end();
			expression.if(object, string, number, group, array, variable)
			      .end();
			expression.if(sign)
			      .then(number)
			      .end();
	
			object.always(space, ignore, keyWord);
			object.if(objectLabel).then(expression).then(comma).repeat();
			object.if(objectShorthand).then(comma).repeat();
			object.if(objectLabel).then(expression).end();
			object.if(objectShorthand).end();
	
			group.always(space, ignore, keyWord);
			group.if(expression).then(comma).repeat();
			group.if(expression).end();
	
			array.always(space, ignore, keyWord);
			array.if(expression).then(comma).repeat();
			array.if(expression).end();
	
			function getter(scope, parentScope) {
				parentScope = parentScope || function () {return undefined};
				function get(name) {
					if (name === 'scope') return scope;
					const split = new String(name).split('.');
					let currObj = scope;
					for (let index = 0; currObj != undefined && index < split.length; index += 1) {
						currObj = currObj[split[index]];
					}
					if (currObj !== undefined) return currObj;
					const parentScopeVal = parentScope(name);
					if (parentScopeVal !== undefined) return parentScopeVal;
	        else {
	          const globalVal = $t.global(name);
	          return globalVal === undefined ? '' : globalVal;
	        }
				}
				return get;
			}
	
			function defaultArray(elemName, get) {
				let resp = '';
				for (let index = 0; index < get('scope').length; index += 1) {
					if (elemName) {
						const obj = {};
	          obj.$index = index;
						obj[elemName] = get(index);
						resp += new $t(template).render(obj, undefined, get);
					} else {
						resp += new $t(template).render(get(index), undefined, get);
					}
				}
				return `${resp}`;
			}
	
			function arrayExp(varName, get) {
				varName = varName.trim();
				const array = get('scope');
				let built = '';
				for (let index = 0; index < array.length; index += 1) {
					const obj = {};
					obj[varName] = array[index];
					obj.$index = index;
					built += new $t(template).render(obj, undefined, get);
				}
				return built;
			}
	
			function itOverObject(varNames, get) {
				const match = varNames.match($t.objectNameReg);
				const keyName = match[1];
				const valueName = match[2];
				const obj = get('scope');
				const keys = Object.keys(obj);
				const isArray = Array.isArray(obj);
				let built = '';
				for (let index = 0; index < keys.length; index += 1) {
					const key = keys[index];
					if (!isArray || key.match(/^[0-9]{1,}$/)) {
						const childScope = {};
						childScope[keyName] = key;
						childScope[valueName] = obj[key];
						childScope.$index = index;
						built += new $t(template).render(childScope, undefined, get);
					}
				}
	      return built;
			}
	
			function rangeExp(elemName, rangeItExpr, get) {
				const match = rangeItExpr.match($t.rangeItExpReg);
				let startIndex = match[1].match(/^[0-9]{1,}$/) ?
							match[1] : get(match[1]);
				let endIndex = match[2].match(/^[0-9]*$/) ?
							match[2] : get(match[2]);
				if (((typeof startIndex) !== 'string' &&
								(typeof	startIndex) !== 'number') ||
									(typeof endIndex) !== 'string' &&
									(typeof endIndex) !== 'number') {
										throw Error(`Invalid range '${itExp}' evaluates to '${startIndex}..${endIndex}'`);
				}
	
				try {
					startIndex = Number.parseInt(startIndex);
				} catch (e) {
					throw Error(`Invalid range '${itExp}' evaluates to '${startIndex}..${endIndex}'`);
				}
				try {
					endIndex = Number.parseInt(endIndex);
				} catch (e) {
					throw Error(`Invalid range '${itExp}' evaluates to '${startIndex}..${endIndex}'`);
				}
	
				let index = startIndex;
				let built = '';
				while (true) {
					let increment = 1;
					if (startIndex > endIndex) {
						if (index <= endIndex) {
							break;
						}
						increment = -1;
					} else if (index >= endIndex) {
						break;
					}
					const obj = {$index: index};
					obj[elemName] = index;
					built += new $t(template).render(obj, undefined, get);
					index += increment;
				}
				return built;
			}
	
			function evaluate(get) {
				if ($t.functions[id]) {
					try {
						return $t.functions[id](get, $t);
					} catch (e) {
					  console.error(e);
					}
				} else {
					return eval($t.templates[id])
				}
			}
	
			function type(scope, expression) {
				if ((typeof scope) === 'string' && scope.match($t.rangeAttemptExpReg)) {
					if (scope.match($t.rangeItExpReg)) {
						return 'rangeExp'
					}
					return 'rangeExpFormatError';
				} else if (Array.isArray(scope)) {
					if (expression === undefined) {
						return 'defaultArray';
					} else if (expression.match($t.nameScopeExpReg)) {
						return 'nameArrayExp';
					}
				}
	
				if ((typeof scope) === 'object') {
					if (expression === undefined) {
						return 'defaultObject';
					} else if (expression.match($t.objectNameReg)){
						return 'itOverObject';
					} else if (expression.match($t.arrayNameReg)){
						return 'arrayExp';
					} else {
						return 'invalidObject';
					}
				} else {
					return 'defaultObject';
				}
			}
	
			// TODO: itExp is not longer an iteration expression. fix!!!!
			function render(scope, itExp, parentScope) {
	      if (scope === undefined) return '';
				let rendered = '';
				const get = getter(scope, parentScope);
				switch (type(scope, itExp)) {
					case 'rangeExp':
						rendered = rangeExp(itExp, scope, get);
						break;
					case 'rangeExpFormatError':
						throw new Error(`Invalid range itteration expression "${scope}"`);
					case 'defaultArray':
						rendered = defaultArray(itExp, get);
						break;
					case 'nameArrayExp':
						rendered = defaultArray(itExp, get);
						break;
					case 'arrayExp':
						rendered = arrayExp(itExp, get);
						break;
					case 'invalidArray':
						throw new Error(`Invalid iterative expression for an array "${itExp}"`);
					case 'defaultObject':
						rendered = evaluate(get);
						break;
					case 'itOverObject':
						rendered = itOverObject(itExp, get);
						break;
					case 'invalidObject':
						throw new Error(`Invalid iterative expression for an object "${itExp}"`);
					default:
						throw new Error(`Programming error defined type '${type()}' not implmented in switch`);
				}
	
	      if (selector) {
	        const elem = document.querySelector(selector);
	        if (elem !== null) {
	          beforeRenderEvent.trigger();
	          elem.innerHTML = rendered;
	          afterRenderEvent.trigger();
	        }
	      }
				return rendered;
			}
	
	
	//---------------------  Compile Functions ---------------//
	
			function stringHash(string) {
				let hashString = string;
				let hash = 0;
				for (let i = 0; i < hashString.length; i += 1) {
					const character = hashString.charCodeAt(i);
					hash = ((hash << 5) - hash) + character;
					hash &= hash; // Convert to 32bit integer
				}
				return hash;
			}
	
			function isolateBlocks(template) {
				let inBlock = false;
				let openBracketCount = 0;
				let block = '';
				let blocks = [];
				let str = template;
				for (let index = 0; index < str.length; index += 1) {
					if (inBlock) {
						block += str[index];
					}
					if (!inBlock && index > 0 &&
						str[index] == '{' && str[index - 1] == '{') {
						inBlock = true;
					} else if (inBlock && str[index] == '{') {
						openBracketCount++;
					} else if (openBracketCount > 0 && str[index] == '}') {
						openBracketCount--;
					} else if (str[index + 1] == '}' && str[index] == '}' ) {
						inBlock = false;
						blocks.push(`${block.substr(0, block.length - 1)}`);
						block = '';
					}
				}
				return blocks;
			}
	
			function compile() {
				const blocks = isolateBlocks(template);
				let str = template;
				for (let index = 0; index < blocks.length; index += 1) {
					const block = blocks[index];
					const parced = ExprDef.parse(expression, block);
					str = str.replace(`{{${block}}}`, `\` + $t.clean(${parced}) + \``);
				}
				return `\`${str}\``;
			}
	
	
					const repeatReg = /<([a-zA-Z-]*):t( ([^>]* |))repeat=("|')(([^>^\4]*?)\s{1,}in\s{1,}([^>^\4]*?))\4([^>]*>((?!(<\1:t[^>]*>|<\/\1:t>)).)*<\/)\1:t>/;
					function formatRepeat(string) {
						// tagname:1 prefix:2 quote:4 exlpression:5 suffix:6
						// string = string.replace(/<([^\s^:^-^>]*)/g, '<$1-ce');
						let match;
						while (match = string.match(repeatReg)) {
							let tagContents = match[2] + match[8];
	            let tagName = match[1];
	            let varNames = match[6];
	            let realScope = match[7];
							let template = `<${tagName}${tagContents}${tagName}>`.replace(/\\'/g, '\\\\\\\'').replace(/([^\\])'/g, '$1\\\'').replace(/''/g, '\'\\\'');
							let templateName = tagContents.replace(/.*\$t-id=('|")([\.a-zA-Z-_\/]*?)(\1).*/, '$2');
							let scope = 'scope';
							template = templateName !== tagContents ? templateName : template;
							const t = eval(`new $t(\`${template}\`)`);
	            let resolvedScope = "get('scope')";;
	            try {
	              // console.log('tagName', tagName);
	              // console.log('varNames', varNames);
	              // console.log('realScope', realScope);
	              // console.log('tagContents', tagContents);
								if (realScope.match(/[0-9]{1,}\.\.[0-9]{1,}/)){
	                resolvedScope = `'${realScope}'`;
	              } else {
	                resolvedScope = ExprDef.parse(expression, realScope);
	              }
	            } catch (e) {}
	            string = string.replace(match[0], `{{ new $t('${t.id()}').render(${resolvedScope}, '${varNames}', get)}}`);
						}
						return string;
					}
	
			if (id) {
				$t.templates[id] = undefined;
				$t.functions[id] = undefined;
			}
	
			template = template.replace(/\s{1,}/g, ' ');
			id = $t.functions[template] ? template : id || stringHash(template);
			if (!$t.functions[id]) {
				if (!$t.templates[id]) {
					template = template.replace(/\s{2,}|\n/g, ' ');
					template = formatRepeat(template);
					$t.templates[id] = compile();
				}
			}
			this.compiled = function () { return $t.templates[id];}
			this.render = render;
	    this.afterRender = (func) => afterRenderEvent.on(func);
	    this.beforeRender = (func) => beforeRenderEvent.on(func);
			this.type = type;
			this.isolateBlocks = isolateBlocks;
	    this.id = () => id;
		}
	}
	
	$t.templates = {};//{"-1554135584": '<h1>{{greeting}}</h1>'};
	$t.functions = {};
	$t.loadFunctions = (functions) => {
		Object.keys(functions).forEach((name) => {
			$t.functions[name] = functions[name];
		});
	
	}
	$t.isTemplate = (id) => $t.functions[id] !== undefined;
	$t.arrayNameReg = /^\s*([a-zA-Z][a-z0-9A-Z]*)\s*$/;
	$t.objectNameReg = /^\s*([a-zA-Z][a-z0-9A-Z]*)\s*,\s*([a-zA-Z][a-z0-9A-Z]*)\s*$/;
	$t.rangeAttemptExpReg = /^\s*(.*\.\..*)\s*$/;
	$t.rangeItExpReg = /^\s*([a-z0-9A-Z]*)\s*\.\.\s*([a-z0-9A-Z]*)\s*$/;
	$t.nameScopeExpReg = /^\s*([a-zA-Z][a-z0-9A-Z]*)\s*$/;
	$t.quoteStr = function (str) {
			str = str.replace(/\\`/g, '\\\\\\`')
			str = str.replace(/([^\\])`/g, '$1\\\`')
			return `\`${str.replace(/``/g, '`\\`')}\``;
		}
	$t.formatName = function (string) {
	    function toCamel(whoCares, one, two) {return `${one}${two.toUpperCase()}`;}
	    return string.replace(/([a-z])[^a-z^A-Z]{1,}([a-zA-Z])/g, toCamel);
	}
	$t.dumpTemplates = function (debug) {
		let templateFunctions = '';
		let tempNames = Object.keys($t.templates);
		for (let index = 0; index < tempNames.length; index += 1) {
			const tempName = tempNames[index];
			if (tempName) {
				let template = $t.templates[tempName];
	      if (debug === true) {
	        const endTagReg = /( \+) /g;
	        template = template.replace(endTagReg, '$1\n\t\t');
	      }
				templateFunctions += `\nexports['${tempName}'] = (get, $t) => \n\t\t${template}\n`;
			}
		}
		return templateFunctions;
	}
	
	$t.clean = (val) => val === undefined ? '' : val;
	
	function createGlobalsInterface() {
	  const GLOBALS = {};
	  const isMotifiable = (name) => GLOBALS[name] === undefined ||
	        GLOBALS[name].imutable !== 'true';
	  $t.global = function (name, value, imutable) {
	    if (value === undefined) return GLOBALS[name] ? GLOBALS[name].value : undefined;
	    if (isMotifiable(name)) GLOBALS[name] = {value, imutable};
	  }
	  $t.rmGlobal = function(name) {
	    if (isMotifiable(name)) delete GLOBALS[name];
	  }
	}
	createGlobalsInterface();
	
	module.exports = $t;
	
});


RequireJS.addFunction('../../public/js/utils/endpoints.js',
function (require, exports, module) {
	
class Endpoints {
	  constructor(config, host) {
	    const instance = this;
	    let environment;
	
	    if ((typeof config) !== 'object') {
	      host = config;
	      config = Endpoints.defaultConfig;
	    }
	
	    host = host || '';
	    this.setHost = (newHost) => {
	      if ((typeof newHost) === 'string') {
	        if (config._envs[newHost]) environment = newHost;
	        host = config._envs[newHost] || newHost;
	      }
	    };
	    this.setHost(host);
	    this.getHost = (env) => env === undefined ? host : config._envs[env];
	    this.getEnv = () => environment;
	
	    const endPointFuncs = {setHost: this.setHost, getHost: this.getHost, getEnv: this.getEnv};
	    this.getFuncObj = function () {return endPointFuncs;};
	
	
	    function build(str) {
	      const pieces = str.split(/:[a-zA-Z0-9]*/g);
	      const labels = str.match(/:[a-zA-Z0-9]*/g) || [];
	      return function () {
	        let values = [];
	        if (arguments[0] === null || (typeof arguments[0]) !== 'object') {
	          values = arguments;
	        } else {
	          const obj = arguments[0];
	          labels.map((value) => values.push(obj[value.substr(1)] !== undefined ? obj[value.substr(1)] : value))
	        }
	        let endpoint = '';
	        for (let index = 0; index < pieces.length; index += 1) {
	          const arg = values[index];
	          let value = '';
	          if (index < pieces.length - 1) {
	            value = arg !== undefined ? encodeURIComponent(arg) : labels[index];
	          }
	          endpoint += pieces[index] + value;
	        }
	        return `${host}${endpoint}`;
	      }
	    }
	
	    function configRecurse(currConfig, currFunc) {
	      const keys = Object.keys(currConfig);
	      for (let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        const value = currConfig[key];
	        if (key.indexOf('_') !== 0) {
	          if (value instanceof Object) {
	            currFunc[key] = {};
	            configRecurse(value, currFunc[key]);
	          } else {
	            currFunc[key] = build(value);
	          }
	        } else {
	          currFunc[key] = value;
	        }
	      }
	    }
	
	    configRecurse(config, endPointFuncs);
	  }
	}
	
	module.exports = Endpoints;
	
});


RequireJS.addFunction('../../public/js/utils/utils.js',
function (require, exports, module) {
	Math.PI12 = Math.PI/2;
	Math.PI32 = 3*Math.PI/2;
	Math.PI2 = 2*Math.PI;
	
	Math.PI14 = Math.PI/4;
	Math.PI34 = 3*Math.PI/4;
	Math.PI54 = 5*Math.PI/4;
	Math.PI74 = 7*Math.PI/4;
	
	
	
	function safeStdLibAddition() {
	  const addition = [];
	  function verify() {
	    additions.forEach((a) => {
	      if ((a.static && a.lib[a.field] !== a.func) ||
	      (!a.static && a.lib.prototype[a.field] !== a.func))
	        throw new Error(`Functionality was overwritten -` +
	                          `\n\tLibrary: ${a.lib}` +
	                          `\n\tStatic: ${a.static}` +
	                          `\n\tField: ${a.field}`)
	    });
	    delete additions;
	  }
	  function safeAdd (lib, field, func, static) {
	    if (!static && lib.prototype[field] === undefined)
	      lib.prototype[field] = func;
	    else if (lib[field] === undefined)
	      lib[field] = func;
	    else
	      console.error(`Attempting to overwrite functionality -` +
	                        `\n\tLibrary: ${lib}` +
	                        `\n\tStatic: ${static}` +
	                        `\n\tField: ${field}`);
	    addition.push({lib, field, func, static})
	  }
	  safeAdd(Function, 'safeStdLibAddition', safeAdd);
	}
	safeStdLibAddition();
	
	function processValue(value) {
	  let retVal;
	  if ((typeof value) === 'object' && value !== null) {
	    if ((typeof value.toJson) === 'function') {
	      retVal = value.toJson();
	    } else if ((typeof value.toJSON) === 'function') {
	      retVal = value.toJSON();
	    } else if (Array.isArray(value)){
	      const arr = [];
	      value.forEach((val) => {
	        if ((typeof val.toJson) === 'function') {
	          arr.push(val.toJson());
	        } else if ((typeof val.toJSON) === 'function') {
	          arr.push(val.toJSON());
	        } else {
	          arr.push(val);
	        }
	      });
	      retVal = arr;
	    } else {
	      const keys = Object.keys(value);
	      const obj = {};
	      for (let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        obj[key] = processValue(value[key]);
	      }
	      retVal = obj;
	    }
	  } else {
	    retVal = value;
	  }
	  return retVal;
	}
	
	Function.safeStdLibAddition(String, 'random',  function (len) {
	    len = len || 7;
	    let str = '';
	    while (str.length < len) str += Math.random().toString(36).substr(2);
	    return str.substr(0, len);
	}, true);
	
	Function.safeStdLibAddition(Math, 'mod',  function (val, mod) {
	  while (val < 0) val += mod;
	  return val % mod;
	}, true);
	
	Function.safeStdLibAddition(Number, 'NaNfinity',  function (...vals) {
	  for (let index = 0; index < vals.length; index++) {
	    let val = vals[index];
	    if(Number.isNaN(val) || !Number.isFinite(val)) return true;
	  }
	  return false;
	}, true);
	
	function stringHash() {
	  let hashString = this;
	  let hash = 0;
	  for (let i = 0; i < hashString.length; i += 1) {
	    const character = hashString.charCodeAt(i);
	    hash = ((hash << 5) - hash) + character;
	    hash &= hash; // Convert to 32bit integer
	  }
	  return hash;
	}
	
	Function.safeStdLibAddition(String, 'hash',  stringHash, false);
	
	const LEFT = 1;
	const RIGHT = 0;
	Function.safeStdLibAddition(String, 'obscure',  function (count) {
	    const direction = count < 0 ? LEFT : RIGHT;
	    const test = (index) => direction === LEFT ? index > this.length + count - 1 : index < count;
	    let str = '';
	    for (let index = 0; index < this.length; index += 1) {
	      if (test(index)) {
	        str += '*';
	      } else {
	        str += this[index];
	      }
	    }
	    return str;
	});
	
	const singleCharReg = /([a-zA-Z]{1,})[^a-z^A-Z]{1,}([a-zA-Z])[^a-z^A-Z]{1,}([a-zA-Z]{1,})/;
	const specialCharReg = /([a-zA-Z])[^a-z^A-Z^0-9]{1,}([a-zA-Z])/g;
	const charNumberReg = /([a-zA-Z])([0-9])/
	function singleCharReplace(whoCares, one, two, three) {
	  const oneLastChar = one[one.length - 1];
	  const twoLower = oneLastChar !== oneLastChar.toLowerCase();
	  const twoStr = twoLower ? two.toLowerCase() : two.toUpperCase();
	  const threeStr = twoLower ? `${three[0].toUpperCase()}${three.substr(1)}` :
	                                `${three[0].toLowerCase()}${three.substr(1)}`;
	  return `${one}${twoStr}${threeStr}`;
	}
	function camelReplace(whoCares, one, two) {return `${one}${two.toUpperCase ? two.toUpperCase() : two}`;}
	function toCamel() {
	  let string = `${this.substr(0,1).toLowerCase()}${this.substr(1)}`.replace(charNumberReg, camelReplace);
	  while (string.match(singleCharReg)) string = string.replace(singleCharReg, singleCharReplace);
	  return string.replace(specialCharReg, camelReplace);
	}
	Function.safeStdLibAddition(String, 'toCamel',  toCamel);
	
	const multipleUpperReg = /([A-Z]{2,})([a-z])/g;
	const caseChangeReg = /([a-z])([A-Z])/g;
	function pascalReplace(whoCares, one, two) {return `${one.toLowerCase()}_${two.toUpperCase ? two.toUpperCase() : two}`;}
	function toPascal() {
	  let string = this;
	  return string.replace(multipleUpperReg, pascalReplace)
	                .replace(caseChangeReg, pascalReplace)
	                .replace(charNumberReg, pascalReplace)
	                .replace(specialCharReg, pascalReplace);
	}
	Function.safeStdLibAddition(String, 'toPascal',  toPascal);
	
	function toKebab() {
	  return this.toPascal().toLowerCase().replace(/_/g, '-');
	}
	Function.safeStdLibAddition(String, 'toKebab',  toKebab);
	
	Function.safeStdLibAddition(String, 'toSnake',  function () {return this.toKebab().replace(/-/g, '_')});
	Function.safeStdLibAddition(String, 'toDot',  function () {return this.toKebab().replace(/-/g, '.')});
	Function.safeStdLibAddition(String, 'toScreamingDot',  function () {return this.toKebab().replace(/-/g, '.')});
	Function.safeStdLibAddition(String, 'toScreamingSnake',  function () {return this.toSnakeCase().toUpperCase()});
	Function.safeStdLibAddition(String, 'toScreamingKebab',  function () {return this.toKebab().toUpperCase()});
	Function.safeStdLibAddition(String, 'toSentance',  function () {return this.toPascal().replace(/_/g, ' ')});
	
	Function.safeStdLibAddition(Function, 'orVal',  function (funcOrVal, ...args) {
	  return (typeof funcOrVal) === 'function' ? funcOrVal(...args) : funcOrVal;
	}, true);
	
	const classLookup = {};
	const attrMap = {};
	const identifierAttr = '_TYPE';
	const immutableAttr = '_IMMUTABLE';
	const temporaryAttr = '_TEMPORARY';
	const doNotOverwriteAttr = '_DO_NOT_OVERWRITE';
	
	const clazz = {};
	clazz.object = () => JSON.clone(classLookup);
	clazz.get = (name) => classLookup[name];
	clazz.filter = (filterFunc) => {
	  const classes = clazz.object();
	  if ((typeof filterFunc) !== 'function') return classes;
	  const classIds = Object.keys(classes);
	  const obj = {};
	  for (let index = 0; index < classIds.length; index += 1) {
	    const id = classIds[index];
	    if (filterFunc(classes[id])) obj[id] = classes[id];
	  }
	  return obj;
	}
	
	function objEq(obj1, obj2) {
	  if (!(obj1 instanceof Object)) return false;
	  if (!(obj2 instanceof Object)) return false;
	  const obj1Keys = Object.keys(obj1);
	  const obj2Keys = Object.keys(obj2);
	  if (obj1Keys.length !== obj2Keys.length) return false;
	  obj1Keys.sort();
	  obj2Keys.sort();
	  for (let index = 0; index < obj1Keys.length; index += 1) {
	    const obj1Key = obj1Keys[index];
	    const obj2Key = obj2Keys[index];
	    if (obj1Key !== obj2Key) return false;
	    const obj1Val = obj1[obj1Key];
	    const obj2Val = obj2[obj2Key];
	    if (obj1Val instanceof Object) {
	      if (!obj1Val.equals(obj2)) return false;
	    } else if (obj1[obj1Key] !== obj2[obj2Key]) return false;
	  }
	  return true;
	}
	
	Function.safeStdLibAddition(Object, 'merge', (target, object, soft) => {
	  if (!(target instanceof Object)) return;
	  if (!(object instanceof Object)) return;
	  const objKeys = Object.keys(object);
	  for (let index = 0; index < objKeys.length; index++) {
	    const key = objKeys[index];
	    if (!soft || target[key] === undefined) {
	      target[key] = object[key];
	    }
	  }
	}, true);
	
	Function.safeStdLibAddition(Object, 'forAllRecursive', (object, func) => {
	  if (!(object instanceof Object)) return;
	  if ((typeof func) !== 'function') return;
	  const target = Array.isArray(object) ? [] :{};
	  const objKeys = Object.keys(object);
	  for (let index = 0; index < objKeys.length; index++) {
	    const key = objKeys[index];
	    if (object[key] instanceof Object) {
	      target[key] = Object.forAllRecursive(object[key], func);
	    } else target[key] = func(object[key], key, object);
	  }
	  return target;
	}, true);
	
	Function.safeStdLibAddition(Object, 'class', clazz, true);
	Function.safeStdLibAddition(Object, 'equals', objEq, true);
	
	
	Function.safeStdLibAddition(Math, 'toDegrees', function (rads) {
	  return rads * 180/Math.PI % 360;
	}, true);
	
	Function.safeStdLibAddition(Object, 'forEachConditional', function (obj, func, conditionFunc, modifyObject) {
	  if (!modifyObject) obj = JSON.clone(obj);
	  conditionFunc = (typeof conditionFunc) === 'function' ? conditionFunc : () => true;
	  const keys = Object.keys(obj);
	  for (let index = 0; index < keys.length; index++) {
	    const key = keys[index];
	    const value = obj[key];
	    if (conditionFunc(value)) func(value, key, obj);
	    if (value instanceof Object) Object.forEachConditional(value, func, conditionFunc, true);
	  }
	  return obj;
	}, true);
	
	Function.safeStdLibAddition(Math, 'toRadians', function (angle, accuracy) {
	  return (angle*Math.PI/180)%(2*Math.PI);
	}, true);
	
	Function.safeStdLibAddition(Math, 'midpoint', function (s, e) {
	  if (e < s) {
	    let t = s;
	    s = e;
	    e = t;
	  }
	  return s + (e - s)/2;
	}, true);
	
	// Ripped off of: https://stackoverflow.com/a/2450976
	Function.safeStdLibAddition(Array, 'shuffle', function () {
	  let currentIndex = this.length,  randomIndex;
	  while (currentIndex != 0) {
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex--;
	    [this[currentIndex], this[randomIndex]] = [
	      this[randomIndex], this[currentIndex]];
	  }
	});
	
	Function.safeStdLibAddition(Array, 'reorder', function () {
	  let count = 2;
	  let currentIndex = this.length,  randomIndex;
	  while (currentIndex != 0) {
	    randomIndex = (currentIndex * count++) % currentIndex;
	    currentIndex--;
	    [this[currentIndex], this[randomIndex]] = [
	      this[randomIndex], this[currentIndex]];
	  }
	});
	
	Function.safeStdLibAddition(Array, 'toJson', function (arr) {
	    const json = [];
	    arr.forEach((elem) => json.push(processValue(elem)));
	    return json;
	}, true);
	
	Function.safeStdLibAddition(Array, 'equalIndexOf', function (elem, startIndex, endIndex) {
	    startIndex =  startIndex > -1 ? startIndex : 0;
	    endIndex = endIndex < this.length ? endIndex : this.length;
	    for (let index = startIndex; index < endIndex; index += 1) {
	      if (elem && (typeof elem.equals) === 'function' && elem.equals(this[index])) {
	        return index;
	      } else if (elem === this[index]) {
	        return index;
	      }
	    }
	    return -1;
	});
	
	Function.safeStdLibAddition(Array, 'equals', function (other, startIndex, endIndex) {
	    startIndex =  startIndex > -1 ? startIndex : 0;
	    endIndex = endIndex < this.length ? endIndex : this.length;
	    if (endIndex < other.length) return false;
	    let equal = true;
	    for (let index = startIndex; equal && index < endIndex; index += 1) {
	      const elem = this[index];
	      if (elem && (typeof elem.equals) === 'function') {
	        if (!elem.equals(this[index])) {
	          return index;
	        }
	      } else if (elem !== other[index]) {
	        equal = false;
	      }
	    }
	    return equal;
	});
	
	Function.safeStdLibAddition(Array, 'removeAll', function (arr) {
	    for (let index = 0; index < arr.length; index += 1) {
	      this.remove(arr[index]);
	    }
	});
	
	Function.safeStdLibAddition(Array, 'remove', function (elem) {
	    for (let index = 0; index < this.length; index += 1) {
	      if (elem && (typeof elem.equals) === 'function' && elem.equals(this[index])) {
	        this.splice(index--, 1);
	      } else if (elem === this[index]) {
	        this.splice(index--, 1);
	      }
	    }
	});
	
	Function.safeStdLibAddition(Array, 'compare', function (original, neww, modify) {
	    const comparison = {both: [], removed: [], added: []};
	    const arr = original.concat(neww);
	    const visited = {new: {}, original: {}};
	    arr.forEach((elem) => {
	      const origIndex = original.equalIndexOf(elem);
	      const newIndex = neww.equalIndexOf(elem);
	      if (!visited.new[newIndex] && !visited.original[origIndex]) {
	        if (newIndex !== -1) visited.new[newIndex] = true;
	        if (origIndex !== -1) visited.original[origIndex] = true;
	        if (origIndex !== -1 && newIndex !== -1) comparison.both.push(elem);
	        else if (newIndex !== -1) comparison.added.push(elem);
	        else comparison.removed.push({elem, index: origIndex});
	      }
	    });
	
	    if (modify) {
	      if (comparison.removed.length > 0) {
	        let removed = 0;
	        comparison.removed.forEach((info) => original.splice(info.index - removed++, 1));
	        comparison.removed = comparison.removed.map((info) => info.elem);
	      }
	      if (comparison.added.length > 0) {
	        original.concatInPlace(neww);
	      }
	    }
	    return comparison.removed.length > 0 || comparison.added.length > 0 ? comparison : false;
	}, true);
	
	Function.safeStdLibAddition(Array, 'shuffle', function() {
	  let currentIndex = this.length,  randomIndex;
	  while (currentIndex != 0) {
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex--;
	    [this[currentIndex], this[randomIndex]] = [
	      this[randomIndex], this[currentIndex]];
	  }
	
	  return this;
	});
	
	Function.safeStdLibAddition(Array, 'concatInPlace', function (arr) {
	  if (arr === this) return;
	  for (let index = 0; index < arr.length; index += 1) {
	    if (this.indexOf(arr[index]) !== -1) {
	      console.error('duplicate');
	    } else {
	      this[this.length] = arr[index];
	    }
	  }
	});
	
	Function.safeStdLibAddition(Array, 'copy', function (arr) {
	  this.length = 0;
	  // const keys = Object.keys(this);
	  // for (let index = 0; index < keys.length; index += 1) delete this[keys[index]];
	  const newKeys = Object.keys(arr);
	  for (let index = 0; index < newKeys.length; index += 1) {
	    const key = newKeys[index];
	    this[key] = arr[key];
	  }
	});
	
	Function.safeStdLibAddition(Object, 'fromJson', function (rootJson) {
	  function interpretValue(value) {
	    if (value instanceof Object) {
	      const classname = value[identifierAttr];
	      const attrs = attrMap[classname] ? Object.keys(attrMap[classname]) :
	                    Object.keys(value).filter((attr) => !attr.match(/^_[A-Z]*[A-Z_]*$/));
	      if (Array.isArray(value)) {
	        const realArray = [];
	        for (let index = 0; index < value.length; index += 1) {
	          realArray[index] = Object.fromJson(value[index]);
	        }
	        return realArray;
	      } else if (classname && classLookup[classname]) {
	        if (classLookup[classname].fromJson) {
	          return classLookup[classname].fromJson(value);
	        } else {
	          const classObj = new (classLookup[classname])(value);
	          for (let index = 0; index < attrs.length; index += 1) {
	            const attr = attrs[index];
	            if ((typeof classObj[attr]) === 'function')
	            classObj[attr](interpretValue(value[attr]));
	            else
	            classObj[attr] = interpretValue(value[attr]);
	          };
	          return classObj;
	        }
	      } else {
	        if (classname) {
	          console.warn(`fromJson for class ${classname} not registered`)
	        }
	        const realObj = {}
	        for (let index = 0; index < attrs.length; index += 1) {
	          const attr = attrs[index];
	          realObj[attr] = interpretValue(value[attr]);
	        };
	        return realObj
	      }
	    }
	    return value;
	  }
	
	  if (!(rootJson instanceof Object)) return rootJson;
	  return interpretValue(rootJson);
	}, true);
	
	Function.safeStdLibAddition(Object, 'getSet',   function (obj, initialVals, ...attrs) {
	  const cxtrName = obj.constructor.name;
	  if (classLookup[cxtrName] === undefined) {
	    classLookup[cxtrName] = obj.constructor;
	  } else if (classLookup[cxtrName] !== obj.constructor) {
	    console.warn(`Object.fromJson will not work for the following class due to name conflict\n\taffected class: ${obj.constructor}\n\taready registered: ${classLookup[cxtrName]}`);
	  }
	  if (initialVals === undefined) return;
	  if (!(obj instanceof Object)) throw new Error('arg0 must be an instace of an Object');
	  let values = {};
	  let temporary = false;
	  let immutable = false;
	  let doNotOverwrite = false;
	  if ((typeof initialVals) === 'object') {
	    values = initialVals;
	    immutable = values[immutableAttr] === true;
	    temporary = values[temporaryAttr] === true;
	    doNotOverwrite = values[doNotOverwriteAttr] === true;
	    if (immutable) {
	      attrs = Object.keys(values);
	    } else {
	      attrs = Object.keys(values).concat(attrs);
	    }
	  } else {
	    attrs = [initialVals].concat(attrs);
	  }
	  if (attrMap[cxtrName] === undefined) attrMap[cxtrName] = [];
	  attrs.forEach((attr) => {
	    if (!attr.match(/^_[A-Z]*[A-Z_]*$/))
	      attrMap[cxtrName][attr] = true;
	  });
	
	  for (let index = 0; !doNotOverwrite && index < attrs.length; index += 1) {
	    const attr = attrs[index];
	    if (attr !== immutableAttr) {
	      if (immutable) obj[attr] = () => values[attr];
	      else {
	        obj[attr] = (value) => {
	          if (value === undefined) {
	            const noDefaults = (typeof obj.defaultGetterValue) !== 'function';
	            if (values[attr] !== undefined || noDefaults)
	            return values[attr];
	            return obj.defaultGetterValue(attr);
	          }
	          values[attr] = value;
	        }
	      }
	    }
	  }
	  if (!temporary) {
	    const origToJson = obj.toJson;
	    obj.toJson = (members, exclusive) => {
	      const restrictions = Array.isArray(members) && members.length;
	      const json = (typeof origToJson === 'function') ? origToJson() : {};
	      json[identifierAttr] = obj.constructor.name;
	      for (let index = 0; index < attrs.length; index += 1) {
	        const attr = attrs[index];
	        const inclusiveAndValid = restrictions && !exclusive && members.indexOf(attr) !== -1;
	        const exclusiveAndValid = restrictions && exclusive && members.indexOf(attr) === -1;
	        if (attr !== immutableAttr && (!restrictions || inclusiveAndValid || exclusiveAndValid)) {
	          // if (obj.constructor.name === 'SnapLocation2D')
	          //   console.log('foundit!');
	          const value = (typeof obj[attr]) === 'function' ? obj[attr]() : obj[attr];
	          json[attr] = processValue(value);
	        }
	      }
	      return json;
	    }
	  }
	  obj.fromJson = (json) => {
	    for (let index = 0; index < attrs.length; index += 1) {
	      const attr = attrs[index];
	      if (attr !== immutableAttr) {
	        if ((typeof obj[attr]) === 'function') {
	          if(Array.isArray(obj[attr]())){
	            obj[attr]().copy(Object.fromJson(json[attr]));
	          } else {
	            obj[attr](Object.fromJson(json[attr]));
	          }
	        }
	        else
	          obj[attr] = Object.fromJson(json[attr]);
	      }
	    };
	    return obj;
	  }
	  if (obj.constructor.DO_NOT_CLONE) {
	    obj.clone = () => obj;
	  } else {
	    obj.clone = () => {
	      const clone = new obj.constructor(obj.toJson());
	      clone.fromJson(obj.toJson());
	      return clone;
	    }
	  }
	  return attrs;
	}, true);
	Object.getSet.format = 'Object.getSet(obj, {initialValues:optional}, attributes...)'
	
	Function.safeStdLibAddition(Object, 'set',   function (obj, otherObj) {
	  if (otherObj === undefined) return;
	  if ((typeof otherObj) !== 'object') {
	    throw new Error('Requires one argument of type object or undefined for meaningless call');
	  }
	  const keys = Object.keys(otherObj);
	  keys.forEach((key) => obj[key] = otherObj[key]);
	}, true);
	
	Function.safeStdLibAddition(Array, 'set',   function (array, values, start, end) {
	  if (start!== undefined && end !== undefined && start > end) {
	    const temp = start;
	    start = end;
	    end = temp;
	  }
	  start = start || 0;
	  end = end || values.length;
	  for (let index = start; index < end; index += 1)
	    array[index] = values[index];
	  return array;
	}, true);
	
	const checked = {};
	
	// Swiped from https://stackoverflow.com/a/43197340
	function isClass(obj) {
	  const isCtorClass = obj.constructor
	      && obj.constructor.toString().substring(0, 5) === 'class'
	  if(obj.prototype === undefined) {
	    return isCtorClass
	  }
	  const isPrototypeCtorClass = obj.prototype.constructor
	    && obj.prototype.constructor.toString
	    && obj.prototype.constructor.toString().substring(0, 5) === 'class'
	  return isCtorClass || isPrototypeCtorClass
	}
	
	Function.safeStdLibAddition(JSON, 'clone',   function  (obj) {
	  if ((typeof obj) != 'object') return obj;
	  const keys = Object.keys(obj);
	  if (!checked[obj.constructor.name]) {
	    // console.log('constructor: ' + obj.constructor.name);
	    checked[obj.constructor.name] = true;
	  }
	
	  const clone = ((typeof obj.clone) === 'function') ? obj.clone() :
	                  Array.isArray(obj) ? [] : {};
	  for(let index = 0; index < keys.length; index += 1) {
	    const key = keys[index];
	    const member = obj[key];
	    if (member && (member.DO_NOT_CLONE || member.constructor.DO_NOT_CLONE)) {
	      clone[key] = member;
	    } else if ((typeof member) !== 'function') {
	      if ((typeof member) === 'object') {
	        if ((typeof member.clone) === 'function') {
	          clone[key] = member.clone();
	        } else {
	          clone[key] = JSON.clone(member);
	        }
	      } else {
	        clone[key] = member;
	      }
	    }
	    else if (isClass(member)) {
	      clone[key] = member;
	    }
	  }
	  return clone;
	}, true);
	
	Function.safeStdLibAddition(JSON, 'copy',   function  (obj) {
	  if (!(obj instanceof Object)) return obj;
	  return JSON.parse(JSON.stringify(obj));
	}, true);
	
	Function.safeStdLibAddition(String, 'parseSeperator',   function (seperator, isRegex) {
	  if (isRegex !== true) {
	    seperator = seperator.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&');
	  }
	  var keyValues = this.match(new RegExp('.*?=.*?(' + seperator + '|$)', 'g'));
	  var json = {};
	  for (let index = 0; keyValues && index < keyValues.length; index += 1) {
	    var split = keyValues[index].match(new RegExp('\\s*(.*?)\\s*=\\s*(.*?)\\s*(' + seperator + '|$)'));
	    if (split) {
	      json[split[1]] = split[2];
	    }
	  }
	  return json;
	});
	
	Function.safeStdLibAddition(Object, 'pathValue', function (obj, path, value) {
	  const attrs = path.split('.');
	  const lastIndex = attrs.length - 1;
	  let currObj = obj;
	  for (let index = 0; index < lastIndex; index += 1) {
	    let attr = attrs[index];
	    if (currObj[attr] === undefined) currObj[attr] = {};
	    currObj = currObj[attr];
	  }
	
	  const lastAttr = attrs[lastIndex];
	  if ((typeof currObj[lastAttr]) === 'function') {
	    return currObj[lastAttr](value);
	  } else if (value !== undefined) {
	    currObj[lastAttr] = value;
	  }
	  return currObj[lastAttr];
	}, true);
	
	
	/////////////////////////////////// Matrix Equations //////////////////////////
	
	Function.safeStdLibAddition(Array, 'translate', function (vector, doNotModify, quiet) {
	  let point = this;
	  let single = false;
	  if (doNotModify === true) point = Array.from(point);
	  const vecLen = vector.length;
	  if (point.length !== vecLen && !quiet) console.warn('vector.length !== point.length but we\' do it anyway (arg3(quiet) = true to silence)');
	  for (let i = 0; i < vecLen; i += 1) {
	    if (point[i] === undefined) point[i] = 0;
	    point[i] += vector[i];
	  }
	  return point;
	});
	
	Function.safeStdLibAddition(Array, 'inverse', function (doNotModify) {
	  const arr = doNotModify === true ? Array.from(this) : this;
	  for (let index = 0; index < arr.length; index += 1) {
	    arr[index] *= -1;
	  }
	  return arr;
	});
	
});


RequireJS.addFunction('../../public/js/utils/parse-arguments.js',
function (require, exports, module) {
	const trueReg = /^true$/;
	const falseReg = /^false$/;
	const numberReg = /^[0-9]{1,}$/;
	const arrayReg = /^(.*[,].*(,|)){1,}$/;
	
	function getValue(str) {
	  if (str === '') return undefined;
	  if (str.match(trueReg)) return true;
	  if (str.match(falseReg)) return false;
	  if (str.match(numberReg)) return Number.parseInt(str);
	  if (str.match(arrayReg)) {
	    const arr = [];
	    const elems = str.split(',');
	    for (let index = 0; index < elems.length; index += 1) {
	      arr.push(getValue(elems[index]));
	    }
	    return arr;
	  }
	  return str;
	}
	
	const valueRegex = /[A-Z.a-z]{1,}=.*$/;
	function argParser() {
	  for (let index = 2; index < process.argv.length; index += 1) {
	    const arg = process.argv[index];
	    if (arg.match(valueRegex)) {
	      const varName = arg.split('=', 1)[0];
	      const valueStr = arg.substr(varName.length + 1);
	      global[varName] = getValue(valueStr.trim());
	    }
	  }
	}
	
	global.__basedir = __dirname;
	argParser();
	
});


RequireJS.addFunction('../../public/js/utils/logic-tree.js',
function (require, exports, module) {
	

	const DecisionTree = require('./decision-tree');
	const DataSync = require('./data-sync');
	const Lookup = require('./object/lookup');
	
	const INTERNAL_FUNCTION_PASSWORD = String.random();
	const DEFAULT_GROUP = 'LogicTree';
	
	function getNode(nodeOwrapper) {
	  if (nodeOwrapper.constructor.name === 'DecisionNode') return nodeOwrapper;
	  return nodeOwrapper.node;
	}
	
	class LogicWrapper extends Lookup {
	  constructor(node) {
	    super(node ? node.nodeId() : undefined);
	    this.node = node;
	    this.nodeId = () => LogicWrapper.decode(this.id()).id;
	  }
	}
	
	class LogicType {
	  constructor(wrapperOrJson) {
	    Object.getSet(this, 'nodeId', 'optional', 'value', 'default');
	    this.wrapper = wrapperOrJson instanceof LogicWrapper ?
	                      wrapperOrJson :
	                      LogicWrapper.get(wrapperOrJson.nodeId);
	    this.nodeId(this.wrapper.node.nodeId());
	    let optional = false;
	    this.optional = (val) => {
	      if (val === true || val === false) {
	        optional = val;
	      }
	      return optional;
	    }
	    this.selectionMade = () => true;
	  }
	}
	
	class SelectLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    const json = wrapper;
	    wrapper = this.wrapper;
	    let value, def;
	    const instance = this;
	    this.madeSelection = () => validate(value, true) || validate(def, true);
	    function validate(val, silent) {
	      if (instance.optional() && val === null) return true;
	      const valid = (instance.optional() && val === null) ||
	                    (val !== null && wrapper.node.validState(val));
	      if (!silent && !valid)
	        throw SelectLogic.error;
	      return valid;
	    }
	    this.value = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        value = val;
	        wrapper.valueUpdate(value, wrapper);
	      }
	      return value === undefined ? (def === undefined ? null : def) : value;
	    }
	    this.selectionMade = () => value !== undefined;
	    this.options = () => {
	      return wrapper.node.stateNames();
	    }
	    this.default = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        def = val;
	        wrapper.defaultUpdate(value, wrapper);
	      }
	      return def;
	    }
	    this.selector = () => this.value();
	   }
	}
	
	SelectLogic.error = new Error('Invalid selection: use wrapper.options() to get valid list.')
	
	class MultiselectLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    wrapper = this.wrapper;
	    let value, def;
	    const instance = this;
	    this.madeSelection = () => validate(value, true) || validate(def, true);
	    function validate(val, silent) {
	      if (val === null) return instance.optional();
	      if (val === undefined) return false;
	      const stateNames = Object.keys(val);
	      if (instance.optional() && stateNames.length === 0) return true;
	      let valid = stateNames.length > 0;
	      stateNames.forEach((name) => valid = valid && wrapper.node.validState(name));
	      if (!silent && !valid) throw MultiselectLogic.error;
	      return valid;
	    }
	    this.value = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        value = val;
	        wrapper.valueUpdate(value);
	      }
	      let retVal = value === undefined ? def : value;
	      return retVal === null ? null : JSON.clone(retVal);
	    }
	    this.selectionMade = () => value !== undefined;
	    this.options = () => {
	      const options = {};
	      const stateNames = wrapper.node.stateNames();
	      stateNames.forEach((name) => options[name] = def[name] === undefined ? false : def[name]);
	      return options;
	    }
	    this.default = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        def = val;
	        wrapper.defaultUpdate(value);
	      }
	      return def;
	    }
	    this.selector = () => {
	      const obj = this.value();
	      if (obj === null || obj === undefined) return null;
	      const keys = Object.keys(obj);
	      let selector = '';
	      keys.forEach((key) => selector += obj[key] ? `|${key}` : '');
	      selector = selector.length === 0 ? null : new RegExp(`^${selector.substring(1)}$`);
	      return selector;
	    }
	  }
	}
	MultiselectLogic.error = new Error('Invalid multiselection: use wrapper.options() to get valid list.')
	
	
	class ConditionalLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    wrapper = this.wrapper;
	    let value, def;
	    validate(wrapper.node.payload());
	    def = wrapper.node.payload();
	    function validate(val, password) {
	      if ((typeof val.condition) !== 'function')
	        throw ConditionalLogic.error;
	    }
	    this.value = (val) => {
	      if (val !== undefined) {
	        validate(val);
	        value = val;
	        wrapper.valueUpdate(value);
	      }
	      return value || def;
	    }
	    this.options = () => undefined;
	    this.default = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        def = val;
	        wrapper.defaultUpdate(value);
	      }
	      return def;
	    }
	    this.selector = () => () =>
	      this.value().condition(wrapper.root());
	  }
	}
	ConditionalLogic.error = new Error('Invalid condition: must be a function that returns true or false based off of node input');
	
	class BranchLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    this.value = () => undefined;
	    this.options = () => undefined;
	    this.default = () => undefined;
	    this.selector = () => /.*/;
	  }
	}
	
	class LeafLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    this.value = () =>undefined;
	    this.options = () => undefined;
	    this.default = () => undefined;
	    this.selector = () => undefined;
	  }
	}
	
	LogicType.types = {SelectLogic, MultiselectLogic, ConditionalLogic, BranchLogic, LeafLogic};
	class LogicTree {
	  constructor(formatPayload) {
	    Object.getSet(this);
	    const tree = this;
	    let root;
	    let choices = {};
	    const wrapperMap = {};
	
	    function getTypeObjByNodeId(nodeId) {
	      return choices[get(nodeId).name];
	    }
	    let dataSync = new DataSync('nodeId', getTypeObjByNodeId);
	    dataSync.addConnection('value');
	    dataSync.addConnection('default');
	
	    function isOptional(node) {
	      return !(choices[node.name] === undefined || !choices[node.name].optional());
	    }
	
	    function isSelector(node) {
	      return node.payload().LOGIC_TYPE.match(/Select|Multiselect/);
	    }
	
	    function mustSelect(node) {
	      return !isOptional(node)  && node.payload().LOGIC_TYPE.match(/Select|Multiselect/);
	    }
	
	    function structure() { return root.node.toString(null, 'LOGIC_TYPE') }
	
	    function setChoice(name, val) {
	      choices[name].value(val);
	    }
	
	    function setDefault(name, val) {
	      choices[name].default(val);
	    }
	
	    function getByName(name) {
	      if (root.node === undefined) return undefined;
	      const node = root.node.getByName(name);
	      return node === undefined ? undefined : wrapNode(node);
	    }
	
	    function addChildrenFunc(wrapper, options) {
	      return (name) => {
	        const targetWrapper = getByName(name);
	        if (targetWrapper === undefined) throw new Error(`Invalid name: ${name}`);
	        const states = targetWrapper.node.states();
	        states.forEach((state) => wrapNode(wrapper.node.then(state)));
	        return wrapper;
	      }
	    }
	
	    function choicesToSelectors() {
	      const keys = Object.keys(choices);
	      const selectors = {};
	      keys.forEach((key) => selectors[key] = choices[key].selector());
	      return selectors;
	    }
	
	    function reachableTree(node) {
	      return (node || root.node).subtree(choicesToSelectors());
	    }
	
	    function leaves() {
	      const wrappers = [];
	      reachableTree().leaves().forEach((node) => wrappers.push(wrapNode(node)));
	      return wrappers;
	    }
	
	    function pathsToString() {
	      let paths = '=>';
	      forPath((wrapper, data) => {
	        if (data === undefined) paths = paths.substring(0, paths.length - 2) + "\n";
	        paths += `${wrapper.name}=>`;
	        return true;
	      });
	      paths = paths.substring(0, paths.length - 2)
	      return paths;
	    }
	
	    function forPath(func, reverse) {
	      const lvs = reachableTree().leaves();
	      let data = [];
	      let dIndex = 0;
	      lvs.forEach((leave) => {
	        const path = [];
	        let curr = leave;
	        while (curr !== undefined) {
	          path.push(curr);
	          curr = curr.back()
	        }
	        if (reverse === true) {
	          for (let index = 0; index < path.length; index += 1) {
	            data[dIndex] = func(wrapNode(path[index]), data[dIndex]);
	          }
	        } else {
	          for (let index = path.length - 1; index >= 0; index -= 1) {
	            data[dIndex] = func(wrapNode(path[index]), data[dIndex]);
	          }
	        }
	        dIndex++;
	      });
	      return data;
	    }
	
	    function forAll(func, node) {
	      (node || root.node).forEach((n) => {
	        func(wrapNode(n));
	      });
	    }
	
	    function forEach(func, node) {
	      reachableTree(node).forEach((n) => {
	        func(wrapNode(n));
	      });
	    }
	
	    function reachable(nameOwrapper) {
	      const wrapper = nameOwrapper instanceof LogicWrapper ?
	                        nameOwrapper : getByName(nameOwrapper);
	      return wrapper.node.conditionsSatisfied(choicesToSelectors(), wrapper.node);
	    }
	
	    function isComplete() {
	      const subtree = reachableTree();
	      let complete = true;
	      subtree.forEach((node) => {
	        if (node.states().length === 0 && node.payload().LOGIC_TYPE !== 'Leaf' &&
	              !selectionMade(node)) {
	          complete = false;
	        }
	      });
	      return complete;
	    }
	
	    function selectionMade(node, selectors) {
	      selectors = selectors || choicesToSelectors();
	      if (mustSelect(node)) {
	        const wrapper = wrapNode(node);
	        if (getTypeObj(wrapper) === undefined) {
	          throw new Error ('This should not happen. node wrapper was not made correctly.');
	        }
	        return getTypeObj(wrapper).madeSelection();
	      }
	      return true;
	    }
	
	    function getByPath(...args) {
	      return wrapNode(root.node.getNodeByPath(...args))
	    }
	    this.getByPath = getByPath;
	
	    function decisions(wrapper) {
	      return () =>{
	        const decisions = [];
	        const addedNodeIds = [];
	        const selectors = choicesToSelectors();
	        wrapper.node.forEach((node) => {
	          if (isSelector(node)) {
	            let terminatedPath = false;
	            let current = node;
	            while (current = current.back()){
	              if (addedNodeIds.indexOf(current.nodeId()) !== -1)
	                terminatedPath = true;
	            }
	            if (!terminatedPath) {
	              if (node.conditionsSatisfied(selectors, node)) {
	                if (selectionMade(node, selectors)) {
	                  decisions.push(wrapNode(node));
	                } else {
	                  decisions.push(wrapNode(node));
	                  addedNodeIds.push(node.nodeId());
	                }
	              }
	            }
	          }
	        });
	        return decisions;
	      }
	    }
	
	    function toJson(wrapper) {
	      return function () {
	        wrapper = wrapper || root;
	        const json = {_choices: {}, _TYPE: tree.constructor.name};
	        const keys = Object.keys(choices);
	        const ids = wrapper.node.map((node) => node.nodeId());
	        keys.forEach((key) => {
	          if (ids.indexOf(choices[key].nodeId()) !== -1) {
	            json._choices[key] = choices[key].toJson();
	            const valEqDefault = choices[key].default() === choices[key].value();
	            const selectionNotMade = !choices[key].selectionMade();
	            if(selectionNotMade || valEqDefault) json._choices[key].value = undefined;
	          }
	        });
	        json._tree = wrapper.node.toJson();
	        json._connectionList = dataSync.toJson(wrapper.node.nodes());
	        return json;
	      }
	    }
	
	    function children(wrapper) {
	      return () => {
	        const children = [];
	        wrapper.node.forEachChild((child) => children.push(wrapNode(child)));
	        return children;
	      }
	    }
	
	    function addStaticMethods(wrapper) {
	      wrapper.structure = structure;
	      wrapper.choicesToSelectors = choicesToSelectors;
	      wrapper.setChoice = setChoice;
	      wrapper.children = children(wrapper);
	      wrapper.getByPath = getByPath;
	      wrapper.setDefault = setDefault;
	      wrapper.attachTree = attachTree(wrapper);
	      wrapper.toJson = toJson(wrapper);
	      wrapper.root = () => root;
	      wrapper.isComplete = isComplete;
	      wrapper.reachable = (wrap) => reachable(wrap || wrapper);
	      wrapper.decisions = decisions(wrapper);
	      wrapper.forPath = forPath;
	      wrapper.forEach = forEach;
	      wrapper.forAll = forAll;
	      wrapper.pathsToString = pathsToString;
	      wrapper.leaves = leaves;
	      wrapper.toString = () =>
	          wrapper.node.subtree(choicesToSelectors()).toString(null, 'LOGIC_TYPE');
	    }
	
	    function getTypeObj(wrapper) {
	      return choices[wrapper.name];
	    }
	
	    function addHelperMetrhods (wrapper) {
	      const node = wrapper.node;
	      const type = node.payload().LOGIC_TYPE;
	      const name = node.name;
	      if (choices[name] === undefined) {
	        choices[name] = new (LogicType.types[`${type}Logic`])(wrapper);
	      }
	      const typeObj = choices[name];
	      wrapper.name = name;
	      wrapper.getTypeObj = () => getTypeObj(wrapper);
	      wrapper.value = typeObj.value;
	      wrapper.payload = () => node.payload();
	      wrapper.options = typeObj.options;
	      wrapper.optional = typeObj.optional;
	      wrapper.default = typeObj.default;
	      wrapper.selector = typeObj.selector;
	      wrapper.addChildren = addChildrenFunc(wrapper);
	      wrapper.valueSync = (w) => dataSync.valueSync(typeObj, w.getTypeObj());
	      wrapper.defaultSync = (w) => dataSync.defaultSync(typeObj, w.getTypeObj());
	      wrapper.valueUpdate = (value) => dataSync.valueUpdate(value, typeObj);
	      wrapper.defaultUpdate = (value) => dataSync.defaultUpdate(value, typeObj);
	    }
	
	    function attachTree(wrapper) {
	      return (tree) => {
	        const json = tree.toJson();
	        return incorrperateJsonNodes(json, wrapper.node);
	      }
	    }
	
	    function addTypeFunction(type, wrapper) {
	      wrapper[type.toLowerCase()] = (name, payload) => {
	        payload = typeof formatPayload === 'function' ?
	                          formatPayload(name, payload || {}, wrapper) : payload || {};
	        payload.LOGIC_TYPE = type;
	        let newWrapper;
	        if (root === undefined) {
	          root = wrapper;
	          root.node = new DecisionTree(name, payload);
	          root.payload = root.node.payload;
	          newWrapper = root;
	        } else if (getByName(name)) {
	          newWrapper = wrapNode(wrapper.node.then(name));
	        } else {
	          wrapper.node.addState(name, payload);
	          newWrapper = wrapNode(wrapper.node.then(name));
	        }
	        return newWrapper;
	      }
	    }
	
	    function getNode(nodeOrwrapperOrId) {
	      switch (nodeOrwrapperOrId.constructor.name) {
	        case 'DecisionNode':
	          return nodeOrwrapperOrId;
	        case 'LogicWrapper':
	          return nodeOrwrapperOrId.node;
	        default:
	          const node = DecisionTree.DecisionNode.get(nodeOrwrapperOrId);
	          if (node) return node;
	          return nodeOrwrapperOrId;
	      }
	    }
	
	    function get(nodeOidOwrapper) {
	      if (nodeOidOwrapper === undefined) return undefined;
	      const node = getNode(nodeOidOwrapper);
	      if (node instanceof DecisionTree.DecisionNode) {
	        return wrapperMap[node.nodeId()];
	      } else {
	        return wrapperMap[node];
	      }
	    }
	
	    const set = (wrapper) =>
	        wrapperMap[wrapper.node.nodeId()] = wrapper;
	    this.get = get;
	
	    function wrapNode(node) {
	      let wrapper = get(node);
	      if (wrapper) return wrapper;
	      wrapper = new LogicWrapper(node);
	      if (node === undefined) {
	        wrapper.toString = () =>
	          root !== undefined ? root.toString() : 'Empty Tree';
	      }
	      if (node === undefined || node.payload().LOGIC_TYPE !== 'Leaf') {
	        addTypeFunction('Select', wrapper);
	        addTypeFunction('Multiselect', wrapper);
	        addTypeFunction('Conditional', wrapper);
	        addTypeFunction('Leaf', wrapper);
	        addTypeFunction('Branch', wrapper);
	      }
	      addStaticMethods(wrapper);
	      if (node && node.payload().LOGIC_TYPE !== undefined) {
	        addHelperMetrhods(wrapper);
	        set(wrapper);
	      }
	      return wrapper;
	    }
	
	    function updateChoices(jsonChoices) {
	      const keys = Object.keys(jsonChoices);
	      keys.forEach((key) =>
	          choices[key].fromJson(jsonChoices[key]));
	    }
	
	    function incorrperateJsonNodes(json, node) {
	      const decisionTree = new DecisionTree(json._tree);
	
	      let newNode;
	      if (node !== undefined) {
	        newNode = node.attachTree(decisionTree);
	      } else {
	        root = wrapNode(decisionTree);
	        rootWrapper.node = root.node;
	        newNode = root.node;
	      }
	      newNode.forEach((n) =>
	          wrapNode(n));
	      dataSync.fromJson(json._connectionList);
	      updateChoices(json._choices);
	      return node;
	    }
	
	    let rootWrapper = wrapNode();
	    if (formatPayload && formatPayload._TYPE === this.constructor.name) incorrperateJsonNodes(formatPayload);
	    return rootWrapper;
	  }
	}
	
	LogicTree.LogicWrapper = LogicWrapper;
	
	module.exports = LogicTree;
	
});


RequireJS.addFunction('../../public/js/utils/custom-event-delay.js',
function (require, exports, module) {
	

	
	
	class CustomEvent {
	  constructor(name, delay) {
	    if (delay === undefined) delay = 0;
	    let triggerId = 0;
	    const watchers = [];
	    this.name = name;
	
	    let lastTriggerTime;
	    let lastTriggerId;
	    const runFuncs = (e, detail, tId) => {
	      const time = new Date().getTime();
	      if (lastTriggerId === tId ) {
	        if (lastTriggerTime + delay < time) {
	          watchers.forEach((func) => func(e, detail));
	        } else {
	          setTimeout(() => {
	            runFuncs(e, detail, tId);
	          }, delay);
	        }
	      }
	    }
	
	    this.on = function (func) {
	      if ((typeof func) === 'function') {
	        watchers.push(func);
	      } else {
	        return 'on' + name;
	      }
	    }
	
	    this.trigger = function (element, detail) {
	      element = element ? element : window;
	      lastTriggerTime = new Date().getTime();
	      const tId = triggerId + 1;
	      triggerId += 1;
	      lastTriggerId = tId;
	      runFuncs(element, detail, tId);
	      this.event.detail = detail;
	      if(document.createEvent){
	          element.dispatchEvent(this.event);
	      } else {
	          element.fireEvent("on" + this.event.eventType, this.event);
	      }
	    }
	//https://stackoverflow.com/questions/2490825/how-to-trigger-event-in-javascript
	    this.event;
	    if(document.createEvent){
	        this.event = document.createEvent("HTMLEvents");
	        this.event.initEvent(name, true, true);
	        this.event.eventName = name;
	    } else {
	        this.event = document.createEventObject();
	        this.event.eventName = name;
	        this.event.eventType = name;
	    }
	  }
	}
	
	module.exports = CustomEvent;
	
});


RequireJS.addFunction('../../public/js/utils/measurement.js',
function (require, exports, module) {
	
  try {
	    Lookup = require('./object/lookup');
	    StringMathEvaluator = require('./string-math-evaluator');
	  } catch(e) {}
	
	
	function regexToObject (str, reg) {
	  const match = str.match(reg);
	  if (match === null) return null;
	  const returnVal = {};
	  for (let index = 2; index < arguments.length; index += 1) {
	    const attr = arguments[index];
	    if (attr) returnVal[attr] = match[index - 1];
	  }
	  return returnVal;
	}
	
	let units = [
	  'Metric',
	  'Imperial (US)'
	]
	let unit = units[1];
	
	
	class Measurement extends Lookup {
	  constructor(value, notMetric) {
	    super();
	    if ((typeof value) === 'string') {
	      value += ' '; // Hacky fix for regularExpression
	    }
	
	    const determineUnit = () => {
	      if ((typeof notMetric === 'string')) {
	        const index = units.indexOf(notMetric);
	        if (index !== -1) return units[index];
	      } else if ((typeof notMetric) === 'boolean') {
	        if (notMetric === true) return unit;
	      }
	      return units[0];
	    }
	
	    let decimal = 0;
	    let nan = value === null || value === undefined;
	    this.isNaN = () => nan;
	
	    const parseFraction = (str) => {
	      const regObj = regexToObject(str, Measurement.regex, null, 'integer', null, 'numerator', 'denominator');
	      regObj.integer = Number.parseInt(regObj.integer) || 0;
	      regObj.numerator = Number.parseInt(regObj.numerator) || 0;
	      regObj.denominator = Number.parseInt(regObj.denominator) || 0;
	      if(regObj.denominator === 0) {
	        regObj.numerator = 0;
	        regObj.denominator = 1;
	      }
	      regObj.decimal = regObj.integer + (regObj.numerator / regObj.denominator);
	      return regObj;
	    };
	
	    function reduce(numerator, denominator) {
	      let reduced = true;
	      while (reduced) {
	        reduced = false;
	        for (let index = 0; index < Measurement.primes.length; index += 1) {
	          const prime = Measurement.primes[index];
	          if (prime >= denominator) break;
	          if (numerator % prime === 0 && denominator % prime === 0) {
	            numerator = numerator / prime;
	            denominator = denominator / prime;
	            reduced = true;
	            break;
	          }
	        }
	      }
	      if (numerator === 0) {
	        return '';
	      }
	      return ` ${numerator}/${denominator}`;
	    }
	
	    function fractionEquivalent(decimalValue, accuracy) {
	      accuracy = accuracy || '1/32'
	      const fracObj = parseFraction(accuracy);
	      const denominator = fracObj.denominator;
	      if (fracObj.decimal === 0 || fracObj.integer > 0 || denominator > 1000) {
	        throw new Error('Please enter a fraction with a denominator between (0, 1000]')
	      }
	      let sign = decimalValue > 0 ? 1 : -1;
	      let remainder = Math.abs(decimalValue);
	      let currRemainder = remainder;
	      let value = 0;
	      let numerator = 0;
	      while (currRemainder > 0) {
	        numerator += fracObj.numerator;
	        currRemainder -= fracObj.decimal;
	      }
	      const diff1 = decimalValue - ((numerator - fracObj.numerator) / denominator);
	      const diff2 = (numerator / denominator) - decimalValue;
	      numerator -= diff1 < diff2 ? fracObj.numerator : 0;
	      const integer = sign * Math.floor(numerator / denominator);
	      numerator = numerator % denominator;
	      return {integer, numerator, denominator};
	    }
	
	    this.fraction = (accuracy, standardDecimal) => {
	      standardDecimal = standardDecimal || decimal;
	      if (nan) return NaN;
	      const obj = fractionEquivalent(standardDecimal, accuracy);
	      if (obj.integer === 0 && obj.numerator === 0) return '0';
	      const integer = obj.integer !== 0 ? obj.integer : '';
	      return `${integer}${reduce(obj.numerator, obj.denominator)}`;
	    }
	    this.standardUS = (accuracy) => this.fraction(accuracy, convertMetricToUs(decimal));
	
	    this.display = (accuracy) => {
	      switch (unit) {
	        case units[0]: return new String(this.decimal(10));
	        case units[1]: return this.standardUS(accuracy);
	        default:
	            return this.standardUS(accuracy);
	      }
	    }
	
	    this.value = (accuracy) => this.decimal(accuracy);
	
	    this.decimal = (accuracy) => {
	      if (nan) return NaN;
	      accuracy = accuracy % 10 ? accuracy : 10000;
	      return Math.round(decimal * accuracy) / accuracy;
	    }
	
	    function getDecimalEquivalant(string) {
	      string = string.trim();
	      if (string.match(Measurement.decimalReg)) {
	        return Number.parseFloat(string);
	      } else if (string.match(StringMathEvaluator.fractionOrMixedNumberReg)) {
	        return parseFraction(string).decimal
	      }
	      nan = true;
	      return NaN;
	    }
	
	    const convertMetricToUs = (standardDecimal) =>  standardDecimal / 2.54;
	    const convertUsToMetric = (standardDecimal) => value = standardDecimal * 2.54;
	
	    function standardize(ambiguousDecimal) {
	      switch (determineUnit()) {
	        case units[0]:
	          return ambiguousDecimal;
	        case units[1]:
	          return convertUsToMetric(ambiguousDecimal);
	        default:
	          throw new Error('This should not happen, Measurement.unit should be the gate keeper that prevents invalid units from being set');
	      }
	    }
	
	    if ((typeof value) === 'number') {
	      decimal = standardize(value);
	    } else if ((typeof value) === 'string') {
	      try {
	        const ambiguousDecimal = getDecimalEquivalant(value);
	        decimal = standardize(ambiguousDecimal);
	      } catch (e) {
	        nan = true;
	      }
	    } else {
	      nan = true;
	    }
	  }
	}
	
	Measurement.unit = (newUnit) => {
	  for (index = 0; index < units.length; index += 1) {
	    if (newUnit === units[index]) unit = newUnit;
	  }
	  return unit
	};
	Measurement.units = () => JSON.parse(JSON.stringify(units));
	Measurement.regex = /^\s*(([0-9]*)\s{1,}|)(([0-9]{1,})\s*\/([0-9]{1,})\s*|)$/;
	Measurement.primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
	Measurement.rangeRegex = /^\s*(\(|\[)(.*),(.*)(\)|\])\s*/;
	Measurement.decimalReg = /(^(-|)[0-9]*(\.|$|^)[0-9]*)$/;
	
	
	Measurement.validation = function (range) {
	  const obj = regexToObject(range, Measurement.rangeRegex, 'minBound', 'min', 'max', 'maxBound');
	  let min = obj.min.trim() !== '' ?
	        new Measurement(obj.min).decimal() : Number.MIN_SAFE_INTEGER;
	  let max = obj.max.trim() !== '' ?
	        new Measurement(obj.max).decimal() : Number.MAX_SAFE_INTEGER;
	  const minCheck = obj.minBound === '(' ? ((val) => val > min) : ((val) => val >= min);
	  const maxCheck = obj.maxBound === ')' ? ((val) => val < max) : ((val) => val <= max);
	  return function (value) {
	    const decimal = new Measurement(value).decimal();
	    if (decimal === NaN) return false;
	    return minCheck(decimal) && maxCheck(decimal);
	  }
	}
	
	Measurement.decimal = (value) => {
	  return new Measurement(value, true).decimal();
	}
	
	Measurement.round = (value, percision) => {
	  if (percision)
	  return new Measurement(value).decimal(percision);
	  return Math.round(value * 10000000) / 10000000;
	}
	
	try {
	  module.exports = Measurement;
	} catch (e) {/* TODO: Consider Removing */}
	
});


RequireJS.addFunction('../../public/js/utils/data-sync.js',
function (require, exports, module) {
	

	class DataSync {
	  constructor(idAttr, getById) {
	    let connections = {};
	    let lastValue = {};
	    let idMap = {};
	
	    const getId = (objOid) => !(objOid instanceof Object) ? objOid :
	      ((typeof objOid[idAttr] === 'function' ? objOid[idAttr]() : objOid[idAttr]));
	
	    const getArray = (elems) => !elems ? [] : (elems.length === 1 ? elems[0] : elems);
	
	
	    function makeSyncronous(key,...objOids) {
	      objOids = getArray(objOids);
	      for (let index = 1; index < objOids.length; index += 1) {
	        let id;
	        const obj1Id = getId(objOids[index - 1]);
	        const obj2Id = getId(objOids[index]);
	        idMap[obj1Id] = idMap[obj1Id] || {};
	        idMap[obj2Id] = idMap[obj2Id] || {};
	        if (idMap[obj1Id][key] === undefined) {
	          if (idMap[obj2Id][key] === undefined) {
	            id = String.random();
	          } else {
	            id = idMap[obj2Id][key];
	          }
	        } else { id = idMap[obj1Id][key]; }
	        idMap[obj1Id][key] = id;
	        idMap[obj2Id][key] = id;
	        connections[id] = connections[id] || [];
	        if (connections[id].indexOf(obj1Id) === -1) {
	          connections[id].push(obj1Id)
	        }
	        if (connections[id].indexOf(obj2Id) === -1) {
	          connections[id].push(obj2Id)
	        }
	      }
	    }
	
	    function unSync(key,...objOids) {
	      objOids = getArray(objOids);
	      for (let index = 1; index < objOids.length; index += 1) {
	        const id = getId(objOids[index]);
	        const connId = idMap[id][key];
	        const conns = connections[connId];
	        let tIndex;
	        while ((tIndex = conns.indexOf(id)) !== -1) conns.split(tIndex, 1);
	        delete idMap[id][key];
	      }
	    }
	
	    function update(key, value, objOid) {
	      const id = getId(objOid);
	      if (!idMap[id] || !idMap[id][key]) return;
	      const connId = idMap[id] && idMap[id][key];
	      if (connId === undefined) return;
	      if (lastValue[connId] !== value) {
	        lastValue[connId] = value;
	        const objIds = connections[connId];
	        for (let index = 0; objIds && index < objIds.length; index ++) {
	          const obj = getById(objIds[index]);
	          if (obj !== undefined) obj[key](value);
	        }
	      }
	    }
	
	    function shouldRun(hasRan, validIds, id) {
	      return !hasRan && (validIds === null || validIds.indexOf(id) !== -1);
	    }
	
	    function forEach(func, ...objOids) {
	      objOids = getArray(objOids);
	      let alreadyRan = {};
	      let validIds = objOids === undefined ? null :
	                      objOids.map((objOid) => getId(objOid));
	      let ids = Object.keys(idMap);
	      for (let index = 0; index < ids.length; index += 1) {
	        const id = ids[index];
	        const idKeys = Object.keys(idMap[id]);
	        for (let iIndex = 0; iIndex < idKeys.length; iIndex += 1) {
	          const idKey = idKeys[iIndex];
	          const connectionId = idMap[id][idKey];
	          if (shouldRun(alreadyRan[connectionId], validIds, id)) {
	            const connIds = connections[connectionId];
	            const applicableConnections = [];
	            for (let cIndex = 0; cIndex < connIds.length; cIndex += 1) {
	              if (shouldRun(alreadyRan[connectionId], validIds, id)) {
	                applicableConnections.push(connIds[cIndex]);
	              }
	            }
	            if (applicableConnections.length === 0) throw new Error('This should never happen');
	            func(idKey, applicableConnections);
	            alreadyRan[connectionId] = true;
	          }
	        }
	      }
	    }
	
	    function fromJson(connections) {
	      const keys = Object.keys(connections);
	      keys.forEach((key) => {
	        this.addConnection(key);
	        const groups = connections[key];
	        groups.forEach((group) => {
	          this[`${key}Sync`](group);
	        });
	      });
	    }
	
	
	    function toJson(...objOids) {
	      objOids = getArray(objOids);
	      const connects = {};
	      forEach((key, connections) => {
	        if (connects[key] === undefined) connects[key] = [];
	        connects[key].push(connections);
	      }, ...objOids);
	      return connects;
	    }
	
	    this.addConnection = (key) => {
	      this[`${key}Sync`] = (...objOids) => makeSyncronous(key, ...objOids);
	      this[`${key}UnSync`] = (...objOids) => makeSyncronous(key, ...objOids);
	      this[`${key}Update`] = (value, objOid) => update(key,value, objOid);
	    }
	    this.toJson = toJson;
	    this.fromJson = fromJson;
	  }
	}
	
	module.exports = DataSync;
	
});


RequireJS.addFunction('../../public/js/utils/approximate.js',
function (require, exports, module) {
	

	
	let defaultAccuracy;
	
	class Approximate {
	  constructor(accuracy) {
	    if ((typeof accuracy) !== 'number' || accuracy === defaultAccuracy) return Approximate.default;
	
	    function approximate(value) {
	      return Math.round(value * accuracy) / accuracy;
	    }
	
	    function approximateFunc(test) {
	      return function () {
	        if (arguments.length === 2) return test(approximate(arguments[0]), approximate(arguments[1]));
	        for (let index = 1; index < arguments.length; index++) {
	          if (!test(approximate(arguments[index - 1]), approximate(arguments[index]))) return false;
	        }
	        return true;
	      }
	    }
	    const af = approximateFunc;
	    approximate.eq = af((one, two) => one === two);
	    approximate.neq = af((one, two) => one !== two);
	    approximate.gt = af((one, two) => one > two);
	    approximate.lt = af((one, two) => one < two);
	    approximate.gteq = af((one, two) => one >= two);
	    approximate.lteq = af((one, two) => one <= two);
	    approximate.eqAbs = af((one, two) => Math.abs(one) === Math.abs(two));
	    approximate.neqAbs = af((one, two) => Math.abs(one) !== Math.abs(two));
	    approximate.abs = (value) => Math.abs(approximate(value));
	    approximate.object = (obj) => {
	      const approx = {};
	      return Object.forAllRecursive(obj,
	            (value) => (typeof value) === 'number' ? approximate(value) : value);
	    }
	    approximate.sameSign = af((value1, value2) => (value1 === 0 && value2 === 0) || 
	                                                      (value2 > 0 && value1 > 0) ||
	                                                      (value2 < 0 && value1 < 0));
	    return approximate;
	  }
	}
	
	
	Approximate.setDefault = (accuracy) => {
	  if ((typeof accuracy) !== 'number') throw new Error('Must enter a number for accuracy: hint must be a power of 10');
	  Approximate.default = new Approximate(accuracy);
	  defaultAccuracy = accuracy;
	  Approximate.default.new = (acc) => new Approximate(acc);
	  Approximate.default.setDefault = Approximate.default;
	}
	
	Approximate.setDefault(1000);
	
	module.exports  = Approximate.default;
	
});


RequireJS.addFunction('../../public/js/utils/decision-tree.js',
function (require, exports, module) {
	

	const Lookup = require('./object/lookup')
	const REMOVAL_PASSWORD = String.random();
	
	// terminology
	// name - String to define state;
	// payload - data returned for a given state
	//             - @_UNIQUE_NAME_GROUP - An Identifier used to insure all nodes of multople trees have a unique name.
	//                          note: only applicable on root node. governs entire tree
	// stateObject - object defining states {name: [payload]...}
	// states - array of availible state names.
	// node - {name, states, payload, then, addState, addStates};
	// then(name) - a function to set a following state.
	// next(name) - a function to get the next state.
	// back() - a function to move back up the tree.
	// top() - a function to get root;
	// subtree(conditions, parent) - returns a subtree.
	//    @conditions - object identifying conditions for each name or _DEFAULT for undefined
	//    @parent - can be used to atach a copy to another branch or tree
	// returns all functions return current node;
	class DecisionNode extends Lookup{
	  constructor(tree, name, instancePayload, parent) {
	    super(instancePayload && instancePayload._nodeId ?
	              instancePayload._nodeId : String.random(7));
	    Object.getSet(this, 'name');
	    const stateMap = {};
	    let jump;
	    let isComplete = false; // null : requires evaluation
	    instancePayload = instancePayload || {};
	    const formatId = (nodeId) =>
	      nodeId.replace(/^decision-node-(.*)$/, '$1') || nodeId;
	    const instance = this;
	    this.nodeId = () => DecisionNode.decode(this.id()).id;
	    instancePayload._nodeId = this.nodeId();
	    tree.nodeMap[this.nodeId()];
	    // tree.nodeMap[instancePayload._nodeId] = this;
	    this.isTree = (t) => t === tree;
	    this.setValue = (key, value) => instancePayload[key] = value;
	    this.getByName = (n) => tree.stateTemplates[n];
	    this.tree = () => tree;
	    this.getNode = (nodeOid) => nodeOid instanceof DecisionNode ? nodeOid : tree.idMap[formatId(nodeOid)];
	    this.name = name.toString();
	    this.states = () => Object.values(stateMap);
	    this.instancePayload = () => instancePayload;
	    this.set = (key, value) => instancePayload[key] = value;
	    this.fromJson = undefined;
	    this.instanceCount = (n) => tree.instanceCount(n || this.name);
	    this.lastInstance = () => tree.instanceCount(this.name) === 1;
	    this.stateDefined = tree.stateDefined;
	    this.payload = () => {
	      const copy = JSON.clone(tree.stateConfigs[name]) || {};
	      Object.keys(instancePayload).forEach((key) => {
	        copy[key] = instancePayload[key];
	      });
	      return copy;
	    };
	    this.jump = (name) => {
	      if (name) jump = tree.getState(name, parent);
	      return jump;
	    };
	    this.getNodeByPath = tree.getNodeByPath;
	    this.isLeaf = () => Object.keys(stateMap).length === 0;
	    this.stateNames = () => Object.keys(stateMap);
	    this.structureChanged = () => {
	      isComplete = null;
	      if (parent) parent.structureChanged();
	    }
	    this.remove = (node, password) => {
	      if (node === undefined) {
	        tree.remove(this, REMOVAL_PASSWORD);
	        tree = undefined;
	      } else if (REMOVAL_PASSWORD !== password) {
	        throw new Error('Attempting to remove node without going through the proper process find the node object you want to remove and call node.remove()');
	      } else {
	        let removed = false;
	        Object.keys(stateMap).forEach((name) => {
	          const realNode = stateMap[name];
	          if (realNode === node) {
	            delete stateMap[name];
	            removed = true;
	          }
	        });
	      }
	    }
	
	    this.validState = (name) => name !== undefined && instance.stateNames().indexOf(name.toString()) !== -1;
	
	    function attachTree(t) {
	      return t.subtree(null, instance, tree);
	    }
	
	    this.then = (name, instancePayload, conditional) => {
	      if (name instanceof DecisionNode) return attachTree(name);
	      if (Array.isArray(name)) {
	        const returnNodes = [];
	        for (let index = 0; index < name.length; index += 1) {
	          returnNodes.push(this.then(name[index]));
	        }
	        return returnNodes;
	      }
	      this.structureChanged();
	      const newState = tree.getState(name, this, instancePayload);
	      if ((typeof conditional) === 'string') {
	        const stateId = `${this.name}:${conditional}`;
	        stateMap[stateId] = tree.getState(stateId, this, instancePayload);
	        stateMap[stateId].jump(newState);
	      } else {
	        stateMap[name] = newState;
	      }
	      if (tree.stateTemplates[name] === undefined)
	        tree.stateTemplates[name] = newState;
	      return newState === undefined ? undefined : newState.jump() || newState;
	    }
	    this.addState = (name, payload) => tree.addState(name, payload) && this;
	    this.addStates = (sts) => tree.addStates(sts) && this;
	    this.next = (name) => {
	      const state = stateMap[name];
	      return state === undefined ? undefined : state.jump() || state;
	    }
	
	    this.nameTaken = tree.nameTaken;
	
	    this.back = () => parent;
	    this.top = () => tree.rootNode;
	    this.isRoot = () => !(parent instanceof DecisionNode)
	
	    this.getRoot = () => {
	      const root = this;
	      while (!root.isRoot()) root = root.back();
	      return root;
	    }
	
	    this.copy = (t) => new DecisionNode(t || tree, this.name, instancePayload);
	
	    // Breath First Search
	    this.forEach = (func) => {
	      const stateKeys = Object.keys(stateMap);
	      func(this);
	      for(let index = 0; index < stateKeys.length; index += 1) {
	        const state = stateMap[stateKeys[index]];
	        state.forEach(func);
	      }
	    }
	
	    this.forEachChild = (func) => {
	      const stateKeys = Object.keys(stateMap);
	      for(let index = 0; index < stateKeys.length; index += 1) {
	        const state = stateMap[stateKeys[index]];
	        func(state);
	      }
	    }
	    this.children = () => {
	      const children = [];
	      this.forEachChild((child) => children.push(child));
	      return children;
	    }
	
	    this.map = (func) => {
	      const ids = [];
	      this.forEach((node) => ids.push(func(node)));
	      return ids;
	    }
	
	    this.nodes = () => {
	      return this.map((node) => node);
	    }
	
	    this.leaves = () => {
	      const leaves = [];
	      this.forEach((node) => {
	        if (node.isLeaf()) leaves.push(node);
	      });
	      return leaves;
	    }
	
	    this.addChildren = (nodeId) => {
	      const orig = this.getNode(nodeId);
	      const states = orig.states();
	      states.forEach((state) => this.then(state));
	      return this;
	    }
	
	    this.stealChildren = (nodeOid) => {
	      return this.getNode(nodeOid).addChildren(this);
	    }
	
	    this.conditionsSatisfied = tree.conditionsSatisfied;
	
	    this.change = (name) => {
	      const newNode = this.back().then(name);
	      const root = this.top();
	      newNode.stealChildren(this);
	      this.remove();
	    }
	
	    this.subtree = (conditions, parent, t) => {
	      if (parent && !parent.conditionsSatisfied(conditions, this)) return undefined
	      conditions = conditions instanceof Object ? conditions : {};
	      const stateKeys = Object.keys(stateMap);
	      let copy;
	      if (parent === undefined) copy = this.copy(t);
	      else {
	        const target = t === undefined ? parent : t;
	        const nameTaken = target.nameTaken(this.name);
	        try {
	          if (!nameTaken) target.addState(this.name, tree.stateConfigs[this.name] || {});
	        } catch (e) {
	          target.nameTaken(this.name);
	          throw e;
	        }
	        copy = parent.then(this.name, instancePayload);
	      }
	
	      for(let index = 0; index < stateKeys.length; index += 1) {
	        const state = stateMap[stateKeys[index]];
	        state.subtree(conditions, copy, t);
	      }
	      return copy;
	    }
	
	    this.nodeOnlyToJson = (noStates) => {
	      const json = {nodeId: this.nodeId(), name, states: [],
	                    payload: Object.fromJson(instancePayload)};
	      if (noStates !== true) {
	        this.states().forEach((state) =>
	          json.states.push(state.nodeOnlyToJson()));
	      }
	      return json;
	    }
	    this.toJson = (noStates) => {
	      const json = tree.toJson(this, noStates);
	      json.name = this.name;
	      json.payload = Object.fromJson(instancePayload);
	      json.nodes = this.nodeOnlyToJson(noStates);
	      return json;
	    }
	
	    this.declairedName = tree.declairedName;
	    this.toString = (tabs, attr) => {
	      tabs = tabs || 0;
	      const tab = new Array(tabs).fill('  ').join('');
	      let str = `${tab}${this.name}`;
	      str += attr ? `) ${this.payload()[attr]}\n` : '\n';
	      const stateKeys = Object.keys(stateMap);
	      for(let index = 0; index < stateKeys.length; index += 1) {
	        str += stateMap[stateKeys[index]].toString(tabs + 1, attr);
	      }
	      return str;
	    }
	    this.attachTree = attachTree;
	    this.treeToJson = tree.toJson;
	    this.conditionsSatisfied = tree.conditionsSatisfied;
	  }
	}
	DecisionNode.DO_NOT_CLONE = true;
	DecisionNode.stateMap = {};
	
	
	class DecisionTree {
	  constructor(name, payload) {
	    let json;
	    if (name._TYPE === 'DecisionTree') {
	      json = name;
	      payload = json.payload;
	      name = json.name;
	    }
	    const names = {};
	    name = name || String.random();
	    payload = payload || {};
	    const stateConfigs = {};
	    const idMap = {};
	    this.idMap = idMap;
	    const nodeMap = {};
	    Object.getSet(this, {name, stateConfigs, payload});
	    const tree = this;
	    tree.stateTemplates = {};
	
	    this.nameTaken = (n) => Object.keys(tree.stateConfigs).indexOf(n) !== -1;
	
	    function addState(name, payload) {
	      if (tree.declairedName(name)) {
	        throw new Error('Name already declared: This requires unique naming possibly relitive to other trees use DecisionTree.undeclairedName(name) to validate names')
	      }
	      tree.declareName(name);
	      return stateConfigs[name] = payload;
	    }
	
	    function stateDefined(name) {
	      const exists = false;
	      tree.rootNode.forEach((node) =>
	        exists = exists || node.name === name);
	      return exists;
	    }
	
	    function instanceCount(name) {
	      let count = 0;
	      tree.rootNode.forEach((node) =>
	        count += node.name === name ? 1 : 0);
	      return count;
	    }
	
	    function remove(node, password) {
	      if (!node.isTree(tree)) throw new Error('Node has already been removed');
	      let removeList = [node];
	      let index = 0;
	      let currNode;
	      while (currNode = removeList[index]) {
	          currNode.back().remove(currNode, password);
	          removeList = removeList.concat(currNode.states());
	          index += 1;
	      }
	      names[node.name] = undefined;
	    }
	
	    function addStates(sts) {
	      if ((typeof sts) !== 'object') throw new Error('Argument must be an object\nFormat: {[name]: payload...}');
	      const keys = Object.keys(sts);
	      keys.forEach((key) => addState(key, sts[key]));
	    }
	
	    function getState(name, parent, instancePayload) {
	      const node = new DecisionNode(tree, name, instancePayload, parent);
	      idMap[node.nodeId()] = node;
	      return node;
	    }
	
	    const toJson = this.toJson;
	    this.toJson = (node, noStates) => {
	      node = node || this.rootNode;
	      const json = {stateConfigs: {}, _TYPE: this.constructor.name};
	      if (noStates) {
	        json.stateConfigs[name] = stateConfigs[node.name];
	      } else {
	        const names = Array.isArray(node) ? node : node.map((n) => n.name);
	        names.forEach((name) => {
	          const s = stateConfigs[name];
	          json.stateConfigs[name] = s && s.toJson ? s.toJson() : s;
	        });
	      }
	
	      return json;
	    }
	
	    function conditionsSatisfied(conditions, state) {
	      const parent = state.back()
	      if (parent === null) return true;
	      conditions = conditions || {};
	      const cond = conditions[state.name] === undefined ?
	                    conditions._DEFAULT : conditions[state.name];
	      const func = (typeof cond) === 'function' ? cond : null;
	      if (func && !func(state)) {
	        return false;
	      }
	      return parentConditionsSatisfied(conditions, state);
	    }
	
	    function parentConditionsSatisfied(conditions, state) {
	      if ((typeof state.back) !== 'function') {
	        console.log('here')
	      }
	      const parent = state.back();
	      if (parent === null) return true;
	      conditions = conditions || {};
	      const cond = conditions[parent.name] === undefined ?
	                    conditions._DEFAULT : conditions[parent.name];
	      const noRestrictions = cond === undefined;
	      const regex = cond instanceof RegExp ? cond : null;
	      const target = (typeof cond) === 'string' ? cond : null;
	      const func = (typeof cond) === 'function' ? cond : null;
	      if (noRestrictions || (regex && state.name.match(regex)) ||
	              (target !== null && state.name === target) ||
	              (func && func(state))) {
	        return parentConditionsSatisfied(conditions, parent);
	      }
	      return false;
	    }
	
	    function getNodeByPath(...path) {
	      let currNode = tree.rootNode;
	      path.forEach((name) => currNode = currNode.next(name));
	      return currNode;
	    }
	
	    this.remove = remove;
	    this.getNodeByPath = getNodeByPath;
	    this.conditionsSatisfied = conditionsSatisfied;
	    this.getState = getState;
	    this.addState = addState;
	    this.addStates = addStates;
	    this.nodeMap = nodeMap;
	    this.instanceCount = instanceCount;
	    this.stateConfigs = stateConfigs;
	
	    this.rootNode = new DecisionNode(tree, name, payload, null);
	    idMap[this.rootNode.nodeId()] = this.rootNode;
	    payload._nodeId = this.rootNode.nodeId();
	    tree.declareName = (name) => names[name] = true;
	    tree.declairedName = (name) => !!names[name];
	
	    if (json !== undefined) {
	      addStates(Object.fromJson(json.stateConfigs));
	      let index = 0;
	      let jsons = [json.nodes];
	      let currJson;
	      nodeMap[jsons[index].name] = this.rootNode;
	      while (currJson = jsons[index]) {
	        currJson.states.forEach((state) => {
	          jsons.push(state);
	          state.instancePayload = state.instancePayload || {};
	          state.instancePayload._nodeId = state.nodeId;
	          nodeMap[state.name] = nodeMap[currJson.name].then(state.name, state.instancePayload);
	        });
	        index++;
	      }
	    }
	
	    return this.rootNode;
	  }
	}
	
	DecisionTree.DecisionNode = DecisionNode;
	module.exports = DecisionTree;
	
});


RequireJS.addFunction('../../public/js/utils/dom-utils.js',
function (require, exports, module) {
	
const frag = document.createDocumentFragment();
	function validSelector (selector) {
	  try {
	    frag.querySelector(selector)
	    return selector;
	  } catch (e) {
	    const errMsg = `Invalid Selector: '${selector}'` ;
	    console.error(errMsg);
	    return null;
	  }
	};
	const VS = validSelector;
	
	function parseSeperator(string, seperator, isRegex) {
	  if (isRegex !== true) {
	    seperator = seperator.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&');
	  }
	  var keyValues = string.match(new RegExp('.*?=.*?(' + seperator + '|$)', 'g'));
	  var json = {};
	  for (let index = 0; keyValues && index < keyValues.length; index += 1) {
	    var split = keyValues[index].match(new RegExp('\\s*(.*?)\\s*=\\s*(.*?)\\s*(' + seperator + '|$)'));
	    if (split) {
	      json[split[1]] = split[2];
	    }
	  }
	  return json;
	}
	
	
	const du = {create: {}, class: {}, cookie: {}, param: {}, style: {}, is: {},
	      scroll: {}, input: {}, on: {}, move: {}, url: {}, fade: {}, position: {}};
	du.find = (selector) => document.querySelector(selector);
	du.find.all = (selector) => document.querySelectorAll(selector);
	
	du.create.element = function (tagname, attributes) {
	  const elem = document.createElement(tagname);
	  const keys = Object.keys(attributes || {});
	  keys.forEach((key) => elem.setAttribute(key, attributes[key]));
	  return elem;
	}
	
	function keepInBounds (elem, minimum) {
	  function checkDir(dir) {
	    const rect = elem.getBoundingClientRect();
	    if (rect[dir] < minimum) {
	      elem.style[dir] = minimum + 'px';
	    }
	  }
	  checkDir('left');
	  checkDir('right');
	  checkDir('top');
	  checkDir('bottom');
	}
	
	du.zIndex = function (elem) {
	  return Number.parseInt(document.defaultView.getComputedStyle(elem, null)
	    .getPropertyValue("z-index"), 10);
	}
	du.move.inFront = function (elem, timeout) {
	  setTimeout(function () {
	    var exclude = du.find.downAll('*', elem);
	    exclude.push(elem);
	    var elems = document.querySelectorAll('*');
	    var highest = Number.MIN_SAFE_INTEGER;
	    for (var i = 0; i < elems.length; i++) {
	      const e = elems[i];
	      if (exclude.indexOf(e) === -1) {
	        var zindex = du.zIndex(e);
	      }
	      if (zindex > highest) highest = zindex;
	    }
	    if (highest < Number.MAX_SAFE_INTEGER) elem.style.zIndex = highest + 1;
	  },  timeout || 0);
	}
	
	du.move.relitive = function (elem, target, direction, props) {
	  props = props || {};
	  const clientHeight = document.documentElement.clientHeight;
	  const clientWidth = document.documentElement.clientWidth;
	  const rect = target.getBoundingClientRect();
	
	  const style = {};
	  const padding = props.padding || 5;
	  style.cursor = props.cursor || 'unset';
	  style.padding = `${padding}px`;
	  style.position = props.position || 'absolute';
	  style.backgroundColor = props.backgroundColor || 'transparent';
	
	  const scrollY =  props.isFixed ? 0 : window.scrollY;
	  const scrollX =  props.isFixed ? 0 : window.scrollX;
	  const isTop = direction.indexOf('top') !== -1;
	  const isBottom = direction.indexOf('bottom') !== -1;
	  const isRight = direction.indexOf('right') !== -1;
	  const isLeft = direction.indexOf('left') !== -1;
	  if (isTop) {
	    style.top = rect.top - elem.clientWidth - padding + scrollY;
	  } else { style.top = 'unset'; }
	
	  if (isBottom) {
	    style.bottom = (clientHeight - rect.bottom - elem.clientHeight) - padding - scrollY + 'px';
	  } else { style.bottom = 'unset'; }
	
	  if (!isTop && !isBottom) {
	    style.bottom = (clientHeight - rect.bottom + rect.height/2 - elem.clientHeight / 2) - padding - scrollY + 'px';
	  }
	
	  if (isRight) {
	    style.right = clientWidth - rect.right - elem.clientWidth - padding - scrollX + 'px';
	  } else { style.right = 'unset'; }
	
	  if (isLeft) {
	    style.left = rect.left - padding - elem.clientWidth + scrollX;
	  } else { style.left = 'unset'; }
	
	  if (!isLeft && ! isRight) {
	    style.right = clientWidth - rect.right + rect.width/2 - elem.clientWidth/2 - padding - scrollX + 'px';
	  }
	
	  du.style(elem, style);
	  keepInBounds(elem, padding);
	}
	
	du.move.below = function (elem, target) {
	  du.move.relitive(elem, target, 'bottom');
	}
	
	du.move.above = function (elem, target) {
	  du.move.relitive(elem, target, 'bottom');
	}
	
	du.find.up = function (selector, node) {
	  selector = VS(selector);
	  if (node instanceof HTMLElement) {
	    if (node.matches(selector)) {
	      return node;
	    } else {
	      return du.find.up(selector, node.parentNode);
	    }
	  }
	}
	
	function visibility(hide, targets) {
	  targets = Array.isArray(targets) ? targets : [targets];
	  for (let index = 0; index < targets.length; index += 1) {
	    const target = targets[index];
	    if ((typeof target) === 'string') {
	      targets = targets.concat(Array.from(document.querySelectorAll(target)));
	    } else if (target instanceof HTMLElement) {
	      target.hidden = hide;
	    } else if (Array.isArray(target) || target instanceof NodeList || target instanceof HTMLCollection) {
	      targets = targets.concat(Array.from(target));
	    }
	  }
	}
	
	du.hide = (...targets) => visibility(true, targets);
	du.show = (...targets) => visibility(false, targets);
	
	du.id = function (id) {return document.getElementById(id);}
	
	du.appendError = (target, message) => {
	  return function (e) {
	    const parent = target.parentNode;
	    const error = document.createElement('div');
	    error.className = 'error';
	    error.innerHTML = message;
	    parent.insertBefore(error, target.nextElementSibling)
	  }
	}
	
	const jsAttrReg = /<([a-zA-Z]{1,}[^>]{1,})(\s|'|")on[a-z]{1,}=/;
	du.innerHTML = (text, elem) => {
	  if (text === undefined) return undefined;
	  const clean = text.replace(/<script(| [^<]*?)>/, '').replace(jsAttrReg, '<$1');
	  if (clean !== text) {
	    throw new JsDetected(text, clean);
	  }
	  if (elem !== undefined) elem.innerHTML = clean;
	  return clean;
	}
	
	du.find.upAll = function(selector, node) {
	  const elems = [];
	  let elem = node;
	  selector = VS(selector);
	  while(elem = du.find.up(selector, elem)) {
	    elems.push(elem);
	    elem = elem.parentElement;
	  }
	  return elems;
	}
	
	du.depth = function(node) {return upAll('*', node).length};
	
	du.find.downInfo = function (selector, node, distance, leafSelector) {
	  const nodes = node instanceof HTMLCollection ? node : [node];
	  distance = distance || 0;
	  selector = VS(selector);
	
	  function recurse (node, distance) {
	    if (node instanceof HTMLElement) {
	      if (node.matches(selector)) {
	        return { node, distance, matches: [{node, distance}]};
	      }
	    }
	    return { distance: Number.MAX_SAFE_INTEGER, matches: [] };
	  }
	
	  let matches = [];
	  let found = { distance: Number.MAX_SAFE_INTEGER };
	  for (let index = 0; index < nodes.length; index += 1) {
	    const currNode = nodes[index];
	    const maybe = recurse(currNode, ++distance);
	    if (maybe.node) {
	      matches = matches.concat(maybe.matches);
	      found = maybe.distance < found.distance ? maybe : found;
	
	    }
	    if (!leafSelector || !currNode.matches(leafSelector)) {
	      const childRes = du.find.downInfo(selector, currNode.children, distance + 1, leafSelector);
	      matches = matches.concat(childRes.matches);
	      found = childRes.distance < found.distance ? childRes : found;
	    }
	  }
	  found.matches = matches
	  found.list = matches.map((match) => match.node);
	  return found;
	}
	
	du.find.down = function(selector, node) {return du.find.downInfo(selector, node).node};
	du.find.downAll = function(selector, node) {return du.find.downInfo(selector, node).list};
	
	du.find.closest = function(selector, node) {
	  const visited = [];
	  selector = VS(selector);
	  function recurse (currNode, distance) {
	    let found = { distance: Number.MAX_SAFE_INTEGER };
	    if (!currNode || (typeof currNode.matches) !== 'function') {
	      return found;
	    }
	    visited.push(currNode);
	    if (currNode.matches(selector)) {
	      return { node: currNode, distance };
	    } else {
	      for (let index = 0; index < currNode.children.length; index += 1) {
	        const child = currNode.children[index];
	        if (visited.indexOf(child) === -1) {
	          const maybe = recurse(child, distance + index + 1);
	          found = maybe && maybe.distance < found.distance ? maybe : found;
	        }
	      }
	      if (visited.indexOf(currNode.parentNode) === -1) {
	        const maybe = recurse(currNode.parentNode, distance + 1);
	        found = maybe && maybe.distance < found.distance ? maybe : found;
	      }
	      return found;
	    }
	  }
	
	  return recurse(node, 0).node;
	}
	
	
	const selectors = {};
	let matchRunIdCount = 0;
	function getTargetId(target) {
	  if((typeof target.getAttribute) === 'function') {
	    let targetId = target.getAttribute('du-match-run-id');
	    if (targetId === null || targetId === undefined) {
	      targetId = matchRunIdCount + '';
	      target.setAttribute('du-match-run-id', matchRunIdCount++)
	    }
	    return targetId;
	  }
	  return target === document ?
	        '#document' : target === window ? '#window' : undefined;
	}
	
	
	
	function runMatch(event) {
	  const  matchRunTargetId = getTargetId(event.currentTarget);
	  const selectStrs = Object.keys(selectors[matchRunTargetId][event.type]);
	  selectStrs.forEach((selectStr) => {
	    const target = du.find.up(selectStr, event.target);
	    const everything = selectStr === '*';
	    if (everything || target) {
	      selectors[matchRunTargetId][event.type][selectStr].forEach((func) => func(target, event));
	    }
	  })
	}
	
	du.is.hidden = function (target) {
	  const elem = du.find.up('[hidden]', target);
	  return elem !== undefined;
	}
	
	du.class.add = function(target, clazz) {
	  du.class.remove(target, clazz);
	  target.className += ` ${clazz}`;
	}
	
	du.class.swap = function(target, newClass, oldClass) {
	  du.class.remove(target, oldClass);
	  du.class.add(target, newClass)
	}
	
	function classReg(clazz) {
	  return new RegExp(`(^| )(${clazz}( |$)){1,}`, 'g');
	}
	
	du.class.remove = function(target, clazz) {
	  if (!(target instanceof HTMLElement)) return;
	  target.className = target.className.replace(classReg(clazz), ' ').trim();
	}
	
	du.class.has = function(target, clazz) {
	  return target.className.match(classReg(clazz));
	}
	
	du.class.toggle = function(target, clazz) {
	  if (du.class.has(target, clazz)) du.class.remove(target, clazz);
	  else du.class.add(target, clazz);
	}
	
	function onKeycombo(event, func, args) {
	  const keysDown = {};
	  const keyup = (target, event) => {
	    keysDown[event.key] = false;
	  }
	  const keydown = (target, event) => {
	    let allPressed = true;
	    keysDown[event.key] = true;
	    for (let index = 0; allPressed && index < args.length; index += 1) {
	      allPressed = allPressed && keysDown[args[index]];
	    }
	    if (allPressed) {
	      console.log('All Pressed!!!');
	      func(target, event);
	    }
	  }
	  du.on.match('keyup', '*', keyup);
	  return {event: 'keydown', func: keydown};
	}
	
	const argEventReg = /^(.*?)(|:(.*))$/;
	function filterCustomEvent(event, func) {
	  const split = event.split(':');
	  event = split[0];
	  const args = split[1] ? split[1].split(',') : [];
	  let customEvent = {func, event};
	  switch (event) {
	    case 'enter':
	      customEvent.func = (target, event) => event.key === 'Enter' && func(target, event);
	      customEvent.event = 'keydown';
	      break;
	    case 'keycombo':
	      customEvent = onKeycombo(event, func, args);
	    break;
	  }
	  return customEvent;
	}
	
	du.on.match = function(event, selector, func, target) {
	  const filter = filterCustomEvent(event, func);
	  target = target || document;
	  selector = VS(selector);
	  if (selector === null) return;
	  if ((typeof func) !== 'function') console.warn(`Attempting to create an event without calling function.\nevent: "${event}"\nselector: ${selector}`)
	  const  matchRunTargetId = getTargetId(target);
	  if (selectors[matchRunTargetId] === undefined) {
	    selectors[matchRunTargetId] = {};
	  }
	  if (selectors[matchRunTargetId][filter.event] === undefined) {
	    selectors[matchRunTargetId][filter.event] = {};
	    target.addEventListener(filter.event, runMatch);
	  }
	  if ( selectors[matchRunTargetId][filter.event][selector] === undefined) {
	    selectors[matchRunTargetId][filter.event][selector] = [];
	  }
	
	  const selectorArray = selectors[matchRunTargetId][filter.event][selector];
	  // if (selectorArray.indexOf(func) !== -1) {
	    selectorArray.push(filter.func);
	  // }
	}
	
	du.cookie.set = function(name, value, lifeMilliSecs) {
	  if (value instanceof Object) {
	    value = JSON.stringify(value);
	  }
	  const expireDate = new Date();
	  expireDate.setTime(expireDate.getTime() + (lifeMilliSecs || (8035200000))); //93 days by default
	  document.cookie = `${name}=${value}; expires=${expireDate.toUTCString()}`;
	}
	
	du.cookie.get = function(name, seperator) {
	  const cookie = parseSeperator(document.cookie, ';')[name];
	  if (seperator === undefined) return cookie;
	  const values = cookie === undefined ? [] : cookie.split(seperator);
	  if (arguments.length < 3) return values;
	  let obj = {};
	  for (let index = 2; index < arguments.length; index += 1) {
	    const key = arguments[index];
	    const value = values[index - 2];
	    obj[key] = value;
	  }
	  return obj;
	}
	
	du.url.breakdown = function () {
	  const breakdown = {};
	  const hashMatch = window.location.href.match(/(.*?)#(.*)/, '$1');
	  let noHash;
	  if (hashMatch) {
	    noHash = hashMatch[1];
	    breakdown.hashtag = hashMatch[2]
	  } else {
	    noHash = window.location.href;
	  }
	  const domainMatch = noHash.match(/(.*?):\/\/([^\/]*?)(:([0-9]{1,5})|)(\/[^?^#]*)/)
	  breakdown.protocol = domainMatch[1];
	  breakdown.domain = domainMatch[2];
	  breakdown.port = domainMatch[4] || undefined;
	  breakdown.path = domainMatch[5];
	
	  const urlMatch = noHash.match(/.*?:\/\/([^.]{1,})\.([^\/]*?)\.([^.^\/]{1,})(\/.*)/);
	  if (urlMatch) {
	    breakdown.subdomain = urlMatch[1];
	    breakdown.secondLevelDomain = urlMatch[2];
	    breakdown.topLevelDomaian = urlMatch[3]
	  }
	  breakdown.paramStr = noHash.substr(noHash.indexOf('?') + 1);
	
	  breakdown.params = parseSeperator(breakdown.paramStr, '&');
	  return breakdown;
	}
	
	du.url.build = function (b) {
	  const paramArray = [];
	  Object.keys(b.params).forEach((key) => paramArray.push(`${key}=${b.params[key]}`));
	  const paramStr = paramArray.length > 0 ? `?${paramArray.join('&')}` : '';
	  const portStr = b.port ? `:${b.port}` : '';
	  const hashStr = b.hashtag ? `#${b.hashtag}` : '';
	  return `${b.protocol}://${b.domain}${portStr}${b.path}${paramStr}${hashStr}`;
	}
	
	du.url.change = function (url) {
	  window.history.pushState(null,"", url);
	}
	
	du.param.get = function(name) {
	  let params = du.url.breakdown().params;
	  const value = params[name];
	  if (value === undefined) return undefined;
	  return decodeURI(value);
	}
	
	du.param.remove = function (name) {
	  const breakdown = du.url.breakdown();
	  delete breakdown.params[name];
	  du.url.change(du.url.build(breakdown));
	}
	
	du.style = function(elem, style, time) {
	  const save = {};
	  const keys = Object.keys(style);
	  keys.forEach((key) => {
	    save[key] = elem.style[key];
	    elem.style[key] = style[key];
	  });
	
	  if (time) {
	    setTimeout(() => {
	      keys.forEach((key) => {
	        elem.style[key] = save[key];
	      });
	    }, time);
	  }
	}
	
	function center(elem) {
	  const rect = elem.getBoundingClientRect();
	  const x = rect.x + (rect.height / 2);
	  const y = rect.y + (rect.height / 2);
	  return {x, y, top: rect.top};
	}
	
	du.scroll.can = function (elem) {
	    const horizontallyScrollable = elem.scrollWidth > elem.clientWidth;
	    const verticallyScrollable = elem.scrollHeight > elem.clientHeight;
	    return elem.scrollWidth > elem.clientWidth || elem.scrollHeight > elem.clientHeight;
	};
	
	du.scroll.parents = function (elem) {
	  let scrollable = [];
	  if (elem instanceof HTMLElement) {
	    if (du.scroll.can(elem)) {
	      scrollable.push(elem);
	    }
	    return du.scroll.parents(elem.parentNode).concat(scrollable);
	  }
	  return scrollable;
	}
	
	du.scroll.intoView = function(elem, divisor, delay, scrollElem) {
	  let scrollPidCounter = 0;
	  const lastPosition = {};
	  let highlighted = false;
	  function scroll(scrollElem) {
	    return function() {
	      const scrollCenter = center(scrollElem);
	      const elemCenter = center(elem);
	      const fullDist = Math.abs(scrollCenter.y - elemCenter.y);
	      const scrollDist = fullDist > 5 ? fullDist/divisor : fullDist;
	      const yDiff = scrollDist * (elemCenter.y < scrollCenter.y ? -1 : 1);
	      scrollElem.scroll(0, scrollElem.scrollTop + yDiff);
	      if (elemCenter.top !== lastPosition[scrollElem.scrollPid]
	            && (scrollCenter.y < elemCenter.y - 2 || scrollCenter.y > elemCenter.y + 2)) {
	        lastPosition[scrollElem.scrollPid] = elemCenter.top;
	        setTimeout(scroll(scrollElem), delay);
	      } else if(!highlighted) {
	        highlighted = true;
	        du.style.temporary(elem, 2000, {
	          borderStyle: 'solid',
	          borderColor: '#07ff07',
	          borderWidth: '5px'
	        });
	      }
	    }
	  }
	  const scrollParents = du.scroll.parents(elem);
	  scrollParents.forEach((scrollParent) => {
	    scrollParent.scrollPid = scrollPidCounter++;
	    setTimeout(scroll(scrollParent), 100);
	  });
	}
	
	du.fade.out = (elem, disapearAt, func) => {
	  const origOpacity = elem.style.opacity;
	  let stopFade = false;
	  function reduceOpacity () {
	    if (stopFade) return;
	    elem.style.opacity -= .005;
	    if (elem.style.opacity <= 0) {
	      elem.style.opacity = origOpacity;
	      func(elem);
	    } else {
	      setTimeout(reduceOpacity, disapearAt * 2 / 600 * 1000);
	    }
	  }
	
	  elem.style.opacity = 1;
	  setTimeout(reduceOpacity, disapearAt / 3 * 1000);
	  return () => {
	    stopFade = true;
	    elem.style.opacity = origOpacity;
	  };
	}
	
	
	
	du.cookie.remove = function (name) {
	  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:01 GMT;`;
	}
	
	let copyTextArea;
	du.copy = (textOelem) => {
	  if (copyTextArea === undefined) {
	    copyTextArea = du.create.element('textarea', {id: 'du-copy-textarea'});
	    document.body.append(copyTextArea);
	  }
	
	  copyTextArea.value = textOelem;
	  copyTextArea.innerText = textOelem;
	
	  copyTextArea.select();
	  document.execCommand("copy");
	}
	
	try {
	  module.exports = du;
	} catch (e) {}
	
});


RequireJS.addFunction('../../public/js/utils/expression-definition.js',
function (require, exports, module) {
	

	
	
	let idCount = 0;
	class ExprDef {
	  constructor(name, options, notify, stages, alwaysPossible) {
	    this.id = idCount++;
	    let id = this.id;
	    let string;
	    let modified = '';
	    let start;
	    let end;
	    alwaysPossible = alwaysPossible ? alwaysPossible : [];
	    stages = stages ? stages : {};
	    let currStage = stages;
	
	    function getRoutes(prefix, stage) {
	      let routes = [];
	      let keys = Object.keys(stage);
	      for (let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        if (key !== '_meta') {
	          let newPrefix;
	          if (prefix) {
	            newPrefix = `${prefix}.${key}`;
	          } else {
	            newPrefix = key;
	          }
	          const deepRoutes = getRoutes(newPrefix, stage[key]);
	          if (deepRoutes.length > 0) {
	            routes = routes.concat(deepRoutes);
	          }
	          if (stage[key]._meta && stage[key]._meta.end) {
	            routes.push(newPrefix + '.end');
	          }
	          if (stage[key]._meta && stage[key]._meta.repeat) {
	            routes.push(newPrefix + '.repeat');
	          }
	        }
	      }
	      return routes;
	    }
	
	    this.always = function () {
	      for (let index = 0; index < arguments.length; index += 1) {
	        alwaysPossible.push(arguments[index]);
	      }
	    };
	    this.getAlways = function (exprDef) {return alwaysPossible;};
	
	    this.allRoutes = function () {
	      return getRoutes(null, stages);
	    }
	
	    function getNotice (exprDef) {
	      let isInAlways = false;
	      alwaysPossible.map(function (value) {if (value.getName() === exprDef.getName()) isInAlways = true;});
	      if (isInAlways) return;
	      if (!exprDef.closed()) {
	        if (currStage[exprDef.getName()] === undefined) {
	          throw new Error(`Invalid Stage Transition ${currStage._meta.expr.getName()} -> ${exprDef.getName()}\n${currStage._meta.expr.allRoutes()}`)
	        }
	        currStage = currStage[exprDef.getName()];
	      }
	    }
	    this.getNotice = getNotice;
	
	    function getName () {return name;};
	    this.getName = getName;
	    this.onClose = function (start, end) {
	      return function (str, start, end) {
	        if (notify) notify(this);
	        options.onClose(str, start, end);
	      }
	    }
	
	    function setMeta(targetNodes, attr, value) {
	      return function () {
	        for (let lIndex = 0; lIndex < targetNodes.length; lIndex += 1) {
	          targetNodes[lIndex]._meta[attr] = value;
	        }
	      }
	    }
	
	    function then (targetNodes) {
	      return function () {
	        const createdNodes = [];
	        for (let lIndex = 0; lIndex < targetNodes.length; lIndex += 1) {
	          const targetNode = targetNodes[lIndex];
	          for (let index = 0; index < arguments.length; index += 1) {
	            const exprDef = arguments[index];
	            if (!exprDef instanceof ExprDef) {
	              throw new Error(`Argument is not an instanceof ExprDef`);
	            }
	            const nextExpr = exprDef.clone(getNotice);
	            if (targetNode[nextExpr.getName()] === undefined) {
	              targetNode[nextExpr.getName()] = {
	                _meta: {
	                  expr: nextExpr
	                }
	              };
	            }
	            createdNodes.push(targetNode[nextExpr.getName()]);
	          }
	        }
	        return {
	          then: then(createdNodes),
	          repeat: setMeta(createdNodes, 'repeat', true),
	          end: setMeta(createdNodes, 'end', true),
	        };
	      }
	    }
	
	    this.if = function () {return then([stages]).apply(this, arguments);}
	
	    function isEscaped(str, index) {
	      if (options.escape === undefined) {
	        return false;
	      }
	      let count = -1;
	      let firstIndex, secondIndex;
	      do {
	        count += 1;
	        firstIndex = index - (options.escape.length * (count + 1));
	        secondIndex = options.escape.length;
	      } while (str.substr(firstIndex, secondIndex) === options.escape);
	      return count % 2 == 0;
	    }
	
	    function foundCall(onFind, sub) {
	      if ((typeof notify) === 'function') {
	        notify(this);
	      }
	      if ((typeof onFind) === 'function') {
	        return onFind(sub);
	      } else {
	        return sub;
	      }
	    }
	
	    this.find = function (str, index) {
	      let startedThisCall = false;
	      let needle = options.closing;
	      let starting = false;
	      if (start === undefined) {
	        needle = options.opening;
	        starting = true;
	      }
	      const sub = str.substr(index);
	      let needleLength;
	      if (needle instanceof RegExp) {
	        const match = sub.match(needle);
	        if (match && match.index === 0) {
	          needleLength = match[0].length;
	        }
	      } else if ((typeof needle) === 'string') {
	        if (sub.indexOf(needle) === 0 && !isEscaped(str, index))
	          needleLength = needle.length;
	      } else if (needle === undefined || needle === null) {
	        needleLength = 0;
	      } else {
	        throw new Error('Opening or closing type not supported. Needs to be a RegExp or a string');
	      }
	      needleLength += options.tailOffset ? options.tailOffset : 0;
	      let changes = '';
	      if (start === undefined && starting && (needleLength || needle === null)) {
	        string = str;
	        start = index;
	        startedThisCall = true;
	        if (needle === null) {
	          if ((typeof notify) === 'function') {
	            notify(this);
	          }          return {index, changes}
	        } else {
	          changes += foundCall.apply(this, [options.onOpen, str.substr(start, needleLength)]);
	        }
	      }
	      if ((!startedThisCall && needleLength) ||
	            (startedThisCall && options.closing === undefined) ||
	            (!startedThisCall && options.closing === null)) {
	        if (str !== string) {
	          throw new Error ('Trying to apply an expression to two different strings.');
	        }
	        end = index + needleLength;
	        if (options.closing === null) {
	          return {index, changes}
	        }
	        if (!startedThisCall) {
	          changes += foundCall.apply(this, [options.onClose, str.substr(end - needleLength, needleLength)]);
	        }
	        return { index: end, changes };
	      }
	
	      return start !== undefined ? { index: start + needleLength, changes } :
	                      { index: -1, changes };
	    }
	
	    this.clone = function (notify) {
	      return new ExprDef(name, options, notify, stages, alwaysPossible);
	    };
	    this.name = this.getName();
	    this.canEnd = function () {return (currStage._meta && currStage._meta.end) || options.closing === null};
	    this.endDefined = function () {return options.closing !== undefined && options.closing !== null};
	    this.location = function () {return {start, end, length: end - start}};
	    this.closed = function () {return end !== undefined;}
	    this.open = function () {return start !== undefined;}
	    this.next =  function () {
	      const expressions = [];
	      if (currStage._meta && currStage._meta.repeat) {
	        currStage = stages;
	      }
	      Object.values(currStage).map(
	        function (val) {if (val._meta) expressions.push(val._meta.expr);}
	      )
	      return alwaysPossible.concat(expressions);
	    };
	  }
	}
	
	function parse(exprDef, str) {
	  exprDef = exprDef.clone();
	  let index = 0;
	  let modified = '';
	  const breakDown = [];
	  const stack = [];
	
	  function topOfStack() {
	    return stack[stack.length - 1];
	  }
	
	  function closeCheck(exprDef) {
	    if (exprDef && (exprDef.canEnd() || exprDef.endDefined())) {
	      let result = exprDef.find(str, index);
	      if (result.index) {
	        modified += result.changes;
	        return result.index;
	      }
	    }
	  }
	
	  function checkArray(exprDef, array) {
	    if (exprDef.endDefined()) {
	      let nextIndex = closeCheck(exprDef);
	      if (nextIndex) return nextIndex;
	    }
	    for (let aIndex = 0; aIndex < array.length; aIndex += 1) {
	      const childExprDef = array[aIndex].clone(exprDef.getNotice);
	      const result = childExprDef.find(str, index);
	      if (result.index !== -1) {
	        modified += result.changes;
	        if (childExprDef.closed()) {
	          breakDown.push(childExprDef);
	        } else {
	          stack.push(childExprDef);
	        }
	        return result.index;
	      }
	    }
	    if (exprDef.canEnd()) {
	      nextIndex = closeCheck(exprDef);
	      if (nextIndex) return nextIndex;
	    }
	    throw new Error(`Invalid string @ index ${index}\n'${str.substr(0, index)}' ??? '${str.substr(index)}'`);
	  }
	
	  function open(exprDef, index) {
	    const always = exprDef.getAlways();
	    while (!exprDef.open()) {
	      let result = exprDef.find(str, index);
	      modified += result.changes;
	      if(result.index === -1) {
	        let newIndex = checkArray(exprDef, always);
	        index = newIndex;
	      } else {
	        if (exprDef.closed()) {
	          breakDown.push(exprDef);
	        } else {
	          stack.push(exprDef);
	        }
	        index = result.index;
	      }
	    }
	    return index;
	  }
	
	  let loopCount = 0;
	  index = open(exprDef, index);
	  progress = [-3, -2, -1];
	  while (topOfStack() !== undefined) {
	    const tos = topOfStack();
	    if (progress[0] === index) {
	      throw new Error(`ExprDef stopped making progress`);
	    }
	    let stackIds = '';
	    let options = '';
	    stack.map(function (value) {stackIds+=value.getName() + ','});
	    tos.next().map(function (value) {options+=value.getName() + ','})
	    index = checkArray(tos, tos.next());
	    if (tos.closed()) {
	      stack.pop();
	    }
	    loopCount++;
	  }
	  // if (index < str.length) {
	  //   throw new Error("String not fully read");
	  // }
	  return modified;
	}
	
	
	ExprDef.parse = parse;
	
	module.exports = ExprDef;
	
	
	
	
	
});


RequireJS.addFunction('../../public/js/utils/request.js',
function (require, exports, module) {
	

	Request = {
	    onStateChange: function (success, failure, id) {
	      return function () {
	        if (this.readyState === 4) {
	          if (this.status == 200) {
	            try {
	              resp = JSON.parse(this.responseText);
	            } catch (e){
	              resp = this.responseText;
	            }
	            if (success) {
	              success(resp, this);
	            }
	          } else if (failure) {
	            const errorMsgMatch = this.responseText.match(Request.errorMsgReg);
	            if (errorMsgMatch) {
	              this.errorMsg = errorMsgMatch[1].trim();
	            }
	            const errorCodeMatch = this.responseText.match(Request.errorCodeReg);
	            if (errorCodeMatch) {
	              this.errorCode = errorCodeMatch[1];
	
	            }
	            failure(this);
	          }
	          var resp = this.responseText;
	        }
	      }
	    },
	
	    id: function (url, method) {
	      return `request.${method}.${url.replace(/\./g, ',')}`;
	    },
	
	    get: function (url, success, failure) {
	      const xhr = new Request.xmlhr();
	      xhr.open("GET", url, true);
	      const id = Request.id(url, 'GET');
	      xhr.setRequestHeader('Content-Type', 'text/pdf');
	      xhr.setRequestHeader('Access-Control-Allow-Origin', '*');
	      Request.setGlobalHeaders(xhr);
	      if (success === undefined && failure === undefined) return xhr;
	      xhr.onreadystatechange =  Request.onStateChange(success, failure, id);
	      xhr.send();
	      return xhr;
	    },
	
	    hasBody: function (method) {
	      return function (url, body, success, failure) {
	        const xhr = new Request.xmlhr();
	        xhr.open(method, url, true);
	        const id = Request.id(url, method);
	        xhr.setRequestHeader('Content-Type', 'application/json');
	        Request.setGlobalHeaders(xhr);
	        if (success === undefined && failure === undefined) return xhr;
	        xhr.onreadystatechange =  Request.onStateChange(success, failure, id);
	        xhr.send(JSON.stringify(body));
	        return xhr;
	      }
	    },
	
	    post: function () {return Request.hasBody('POST')(...arguments)},
	    delete: function () {return Request.hasBody('DELETE')(...arguments)},
	    options: function () {return Request.hasBody('OPTIONS')(...arguments)},
	    head: function () {return Request.hasBody('HEAD')(...arguments)},
	    put: function () {return Request.hasBody('PUT')(...arguments)},
	    connect: function () {return Request.hasBody('CONNECT')(...arguments)},
	}
	
	Request.errorCodeReg = /Error Code:([a-zA-Z0-9]*)/;
	Request.errorMsgReg = /[a-zA-Z0-9]*?:([a-zA-Z0-9 ]*)/;
	const globalHeaders = {};
	Request.globalHeader = (header, funcOval) => {
	  globalHeaders[header] = funcOval;
	}
	Request.setGlobalHeaders = (xhr) => {
	  const headers = Object.keys(globalHeaders);
	  headers.forEach((header) => {
	    const value = (typeof globalHeaders[header]) === 'function' ? globalHeaders[header]() : globalHeaders[header];
	    xhr.setRequestHeader(header, value, xhr);
	  });
	}
	try {
	  Request.xmlhr = XMLHttpRequest;
	} catch (e) {
	  Request.xmlhr = require('xmlhttprequest').XMLHttpRequest;
	}
	
	try {
	  module.exports = Request;
	} catch (e) {}
	
});


RequireJS.addFunction('../../public/js/utils/services/function-cache.js',
function (require, exports, module) {
	
const cacheState = {};
	const cacheFuncs = {};
	
	class FunctionCache {
	  constructor(func, context, group, assem) {
	    if ((typeof func) !== 'function') return func;
	    group ||= 'global';
	    let cache = {};
	
	    function cacheFunc() {
	      if (FunctionCache.isOn(group)) {
	        // if (assem.constructor.name === 'DrawerFront') {
	        //   console.log('df mfer');
	        // }
	        let c = cache;
	        for (let index = 0; index < arguments.length; index += 1) {
	          if (c[arguments[index]] === undefined) c[arguments[index]] = {};
	          c = c[arguments[index]];
	        }
	        if (c[arguments[index]] === undefined) c[arguments[index]] = {};
	
	        if (c.__FunctionCache === undefined) {
	          FunctionCache.notCahed++
	          c.__FunctionCache = func.apply(context, arguments);
	        } else FunctionCache.cached++;
	        return c.__FunctionCache;
	      }
	      FunctionCache.notCahed++
	      return func.apply(context, arguments);
	    }
	    cacheFunc.clearCache = () => cache = {};
	    if (cacheFuncs[group] === undefined) cacheFuncs[group] = [];
	    cacheFuncs[group].push(cacheFunc);
	    return cacheFunc;
	  }
	}
	
	FunctionCache.cached = 0;
	FunctionCache.notCahed = 0;
	FunctionCache.on = (group) => {
	  FunctionCache.cached = 0;
	  FunctionCache.notCahed = 0;
	  cacheState[group] = true;
	}
	FunctionCache.off = (group) => {
	  const cached = FunctionCache.cached;
	  const total = FunctionCache.notCahed + cached;
	  const percent = (cached / total) * 100;
	  console.log(`FunctionCache report: ${cached}/${total} %${percent}`);
	  cacheState[group] = false;
	  cacheFuncs[group].forEach((func) => func.clearCache());
	}
	let disabled = false;
	FunctionCache.isOn = (group) => !disabled && cacheState[group];
	FunctionCache.disable = () => disabled = true;
	FunctionCache.enable = () => disabled = false;
	module.exports = FunctionCache;
	
});


RequireJS.addFunction('../../public/js/utils/services/state-history.js',
function (require, exports, module) {
	
class StateHistory {
	  constructor(getState, setState, minTimeInterval) {
	    let states = [];
	    let index = 0;
	    minTimeInterval = minTimeInterval || 400;
	    const instance = this;
	    let lastStateReqTime;
	
	
	    const indexHash = () => states[index].hash;
	    this.states = () => JSON.clone(states);
	    this.toString = () => {
	      let str = ''
	      states.forEach((s, i) => i === index ?
	                        str += `(${s.hash}),` :
	                        str += `${s.hash},`);
	      return str.substr(0, str.length - 1);
	    }
	
	    function getNewState(reqTime) {
	      if (reqTime === lastStateReqTime) {
	        const currState = getState();
	        const currHash = JSON.stringify(currState).hash();
	        if (states.length === 0 || currHash !== indexHash()) {
	          if (states && states.length - 1 > index) states = states.slice(0, index + 1);
	          states.push({hash: currHash, json: currState});
	          index = states.length - 1;
	          console.log(instance.toString());
	        }
	      }
	    }
	    getNewState();
	
	    this.index = (i) => {
	      if (i > -1 && i < states.length) index = i;
	      return index;
	    }
	
	    // this.clone = (getState) => {
	    //   const sh = new StateHistory(getState, minTimeInterval, this.states());
	    //   sh.index(index);
	    //   return sh;
	    // }
	
	    this.newState = () => {
	      const thisReqTime = new Date().getTime();
	      lastStateReqTime = thisReqTime;
	      setTimeout(() => getNewState(thisReqTime), minTimeInterval);
	    }
	
	    this.forceState = () => {
	      lastStateReqTime = 0;
	      getNewState(0);
	    }
	
	    this.canGoBack = () => index > 0;
	    this.canGoForward = () => index < states.length - 1;
	
	    this.back = () => {
	      if (this.canGoBack()) {
	        const state = states[--index];
	        lastStateReqTime = 0;
	        console.log(this.toString());
	        setState(state.json);
	        return state.json;
	      }
	    }
	
	    this.forward = () => {
	      if (this.canGoForward()) {
	        const state = states[++index];
	        lastStateReqTime = 0;
	        console.log(this.toString());
	        setState(state.json);
	        return state.json;
	      }
	    }
	  }
	}
	
	module.exports = StateHistory;
	
});


RequireJS.addFunction('../../public/js/utils/lists/expandable-list.js',
function (require, exports, module) {
	

	
	const CustomEvent = require('../custom-event.js');
	const du = require('../dom-utils.js');
	const $t = require('../$t.js');
	const Expandable = require('./expandable');
	
	class ExpandableList extends Expandable {
	  constructor(props) {
	    super(props);
	    const superRemove = this.remove;
	    this.remove = (index) => {
	      superRemove(props.list.splice(index, 1)[0]);
	      this.refresh();
	    }
	  }
	}
	
	module.exports = ExpandableList
	
});


RequireJS.addFunction('../../public/js/utils/collections/collection.js',
function (require, exports, module) {
	

	
	
	class Collection {
	  constructor(members) {
	    const list = [];
	    const instance = this;
	
	    function runForEach(func) {
	      let bool = true;
	      for (let index = 0; index < members.length; index += 1) {
	        bool = func(members[index]) && bool;
	      }
	      return bool;
	    }
	    function refMember(name) {
	      instance[name] = () => {
	        const attrId = list[0][name]();
	        return attrId;
	      }
	    };
	    runForEach(refMember);
	
	    this.options = () => list[0].options() || [];
	    this.cost = () => {
	      let totalCost = 0;
	      list.forEach((el) => totalCost += el.cost());
	      return totalCost;
	    }
	    this.belongs = (el) =>
	      list.length === 0 ||
	        runForEach((member) => el[member]() === list[0][member]());
	
	    this.add = (elem) => {
	      if (!this.belongs(elem)) throw new Error ('Cannot add element that does not belong.');
	      list.push(elem);
	      runForEach(refMember);
	    }
	    this.list = list;
	    this.typeId = () => {
	      let typeId = '';
	      runForEach((member) => typeId += `:${list[0][member]()}`);
	      return typeId;
	    }
	  }
	}
	
	Collection.create = function (members, objs) {
	  let collections = {};
	  for (let index = 0; index < objs.length; index += 1) {
	    let collection = new Collection(members);
	    collection.add(objs[index]);
	    const typeId = collection.typeId();
	    if (collections[typeId] === undefined) {
	      collections[typeId] = collection;
	    } else {
	      collections[typeId].add(objs[index]);
	    }
	  }
	  return Object.values(collections);
	}
	
	module.exports = Collection;
	
	
	
	
	
});


RequireJS.addFunction('../../public/js/utils/lists/expandable-object.js',
function (require, exports, module) {
	

	
	const CustomEvent = require('../custom-event.js');
	const du = require('../dom-utils.js');
	const $t = require('../$t.js');
	const Expandable = require('./expandable');
	
	
	class ExpandableObject extends Expandable {
	  constructor(props) {
	    props.list = props.list || {};
	    let idAttr, mappedObject;
	    if (props.idAttribute) {
	      idAttr = props.idAttribute;
	      mappedObject = props.mappedObject || {}
	    }
	    super(props);
		//TODO: Set aciveKey
	
	    const superRemove = this.remove;
	    this.remove = (key) => {
	      const removed = props.list[key];
	      delete props.list[key];
	      superRemove(removed);
	    }
	
	    function undefinedAttr(attr, object) {
	      if (object === undefined) return attr;
	      let currAttr = attr;
	      let count = 1;
	      while(object[currAttr] !== undefined) {
	        if (object[currAttr] === object) return currAttr;
	        currAttr = `${attr}-${count++}`;
	      }
	      return currAttr;
	    }
	
	    const valOfunc = (obj, attr) => (typeof obj[attr]) === 'function' ? obj[attr]() : obj[attr];
	    this.updateMapped = (obj) => {
	      if (idAttr === undefined) return;
	      obj = obj || props.list[this.activeKey()];
	      if (obj) {
	        const name = undefinedAttr(valOfunc(obj, idAttr), mappedObject);
	        if (name !== obj._EXPAND_LAST_OBJECT_NAME) {
	          mappedObject[name] = mappedObject[obj._EXPAND_LAST_OBJECT_NAME];
	          delete mappedObject[obj._EXPAND_LAST_OBJECT_NAME];
	          obj._EXPAND_LAST_OBJECT_NAME = name;
	        }
	      }
	    }
	    this.getMappedObject = () => mappedObject;
	
	    this.getKey = (values, object) => {
	      if (object && object._EXPAND_KEY === undefined) {
	        object._EXPAND_KEY = String.random();
	        object._EXPAND_LAST_OBJECT_NAME = undefinedAttr(valOfunc(object, idAttr), mappedObject);
	        if (idAttr !== undefined) mappedObject[object._EXPAND_LAST_OBJECT_NAME] = object;
	      }
	      if (!props.dontOpenOnAdd && object) this.activeKey(object._EXPAND_KEY);
	      if (idAttr) this.updateMapped(object);
	      return this.activeKey() || undefined;
	    }
	  }
	}
	module.exports = ExpandableObject
	
});


RequireJS.addFunction('../../public/js/utils/input/input.js',
function (require, exports, module) {
	

	
	
	
	const $t = require('../$t');
	const du = require('../dom-utils');
	const Lookup = require('../object/lookup')
	/*
	supported attributes: type, placeholder, name, class, value
	label: creates a text label preceeding input.
	clearOnClick: removes value when clicked.
	list: creates a dropdown with list values.
	default: the default value if input is invalid.
	targetAttr: attribute which defines the inputs value.
	format: attribute which defines a function used to format value.
	validation: Accepts
	                Array: value must be included
	                Regex: value must match
	                Function: value is arg1, must return true
	errorMsg: Message that shows when validation fails.
	
	*/
	class Input extends Lookup {
	  constructor(props) {
	    const id = props.id || `input-${String.random(7)}`;
	    super(id);
	    props.hidden = props.hide || false;
	    props.list = props.list || [];
	    this.inline = props.inline;
	    Object.getSet(this, props, 'hidden', 'type', 'label', 'name', 'placeholder',
	                            'class', 'list', 'value');
	
	    const immutableProps = {
	      _IMMUTABLE: true,
	      targetAttr: props.targetAttr || 'value',
	      errorMsg: props.errorMsg || 'Error',
	      errorMsgId: props.errorMsgId || `error-msg-${this.id()}`,
	    }
	    Object.getSet(this, immutableProps)
	
	    this.clone = (properties) => {
	      const json = this.toJson();
	      json.validation = props.validation;
	      delete json.id;
	      delete json.errorMsgId;
	      Object.set(json, properties);
	      return new this.constructor(json);
	    }
	
	    const instance = this;
	    const forAll = Input.forAll(this.id());
	
	    this.hide = () => forAll((elem) => {
	      const cnt = du.find.up('.input-cnt', elem);
	      this.hidden(cnt.hidden = true);
	    });
	    this.show = () => forAll((elem) => {
	      const cnt = du.find.up('.input-cnt', elem);
	      this.hidden(cnt.hidden = false);
	    });
	
	    let valid;
	    let value = props.value;
	
	    const idSelector = `#${this.id()}`;
	
	    const html = this.constructor.html(this);
	    if ((typeof html) !== 'function') throw new Error('props.html must be defined as a function');
	    this.html = () =>
	     html();
	
	    function valuePriority (func) {
	      return (elem, event) => func(elem[instance.targetAttr()], elem, event);
	    }
	    this.attrString = () => Input.attrString(this.targetAttr(), this.value());
	
	    function getElem(id) {return document.getElementById(id);}
	    this.get = () => getElem(this.id());
	
	    this.on = (eventType, func) => du.on.match(eventType, idSelector, valuePriority(func));
	    this.valid = () => this.setValue();
	    function getValue() {
	      const elem = getElem(instance.id());
	      let val = value;
	      if (elem) val = elem[instance.targetAttr()];
	      if (val === undefined) val = props.default;
	      return val;
	    }
	    this.updateDisplay = () => {
	      const elem = getElem(instance.id());
	      if (elem) elem[instance.targetAttr()] = this.value();
	    };
	    this.setValue = (val, force) => {
	      if (val === undefined) val = getValue();
	      if(force || this.validation(val)) {
	        valid = true;
	        value = val;
	        const elem = getElem(instance.id());
	        if (elem) elem.value = value;
	        return true;
	      }
	      valid = false;
	      value = undefined;
	      return false;
	    }
	    this.value = () => {
	      const unformatted = (typeof value === 'function') ? value() : getValue() || '';
	      return (typeof props.format) !== 'function' ? unformatted : props.format(unformatted);
	    }
	    this.doubleCheck = () => {
	      valid = undefined;
	      this.validate();
	      return valid;
	    }
	    this.validation = function(val) {
	      const elem = getElem(instance.id);
	      val = val === undefined && elem ? elem.value : val;
	      if (val === undefined) return false;
	      if (valid !== undefined && val === value) return valid;
	      let valValid = true;
	      if (props.validation instanceof RegExp) {
	        valValid = val.match(props.validation) !== null;
	      }
	      else if ((typeof props.validation) === 'function') {
	        valValid = props.validation.apply(null, arguments);
	      }
	      else if (Array.isArray(props.validation)) {
	        valValid = props.validation.indexOf(val) !== -1;
	      }
	
	      return valValid;
	    };
	
	    this.validate = (target) => {
	      target = target || getElem(instance.id());
	      if (target) {
	        if (this.setValue(target[this.targetAttr()])) {
	          getElem(this.errorMsgId()).hidden = true;
	          valid = true;
	        } else {
	          getElem(this.errorMsgId()).hidden = false;
	          valid = false;
	        }
	      }
	    }
	
	    if (props.clearOnDblClick) {
	      du.on.match(`dblclick`, `#${this.id()}`, () => {
	        const elem = getElem(this.id());
	        if (elem) elem.value = '';
	      });
	    } else if (props.clearOnClick) {
	      du.on.match(`mousedown`, `#${this.id()}`, () => {
	        const elem = getElem(this.id());
	        if (elem) elem.value = '';
	      });
	    }
	  }
	}
	
	function runValidate(elem) {
	  const input = Lookup.get(elem.id);
	  if (input) input.validate(elem);
	}
	
	du.on.match(`change`, `input`, runValidate);
	du.on.match(`keyup`, `input`, runValidate);
	du.on.match(`change`, `select`, runValidate);
	du.on.match(`keyup`, `select`, runValidate);
	
	Input.forAll = (id) => {
	  const idStr = `#${id}`;
	  return (func) => {
	    const elems = document.querySelectorAll(idStr);
	    for (let index = 0; index < elems.length; index += 1) {
	      func(elems[index]);
	    }
	  }
	}
	
	Input.template = new $t('input/input');
	Input.html = (instance) => () => Input.template.render(instance);
	Input.flagAttrs = ['checked', 'selected'];
	Input.attrString = (targetAttr, value) =>{
	  if (Input.flagAttrs.indexOf(targetAttr) !== -1) {
	    return value === true ? targetAttr : '';
	  }
	  return `${targetAttr}='${value}'`
	}
	
	Input.DO_NOT_CLONE = true;
	
	module.exports = Input;
	
});


RequireJS.addFunction('../../public/js/utils/display/catch-all.js',
function (require, exports, module) {
	const du = require('../dom-utils');
	
	class CatchAll {
	  constructor(container) {
	    const instance = this;
	    container = container;
	    let events = Array.from(arguments).splice(1);
	    events = events.length > 0 ? events : CatchAll.allMouseEvents;
	
	    const backdrop = document.createElement('DIV');
	    this.backdrop = backdrop;
	
	    this.hide = () => {
	      backdrop.hidden = true;
	      backdrop.style.zIndex = 0;
	    };
	    this.show = () => {
	      backdrop.hidden = false
	      instance.updateZindex();
	    };
	
	    this.updateZindex = () => setTimeout(() => {
	      if (container) {
	        if (container.style.zIndex === '') {
	          container.style.zIndex = 2;
	        }
	        backdrop.style.zIndex = Number.parseInt(container.style.zIndex) - 1;
	      } else {
	        backdrop.style.zIndex = CatchAll.findHigestZindex() + 1;
	      }
	    }, 200);
	
	    this.on = (eventName, func) => backdrop.addEventListener(eventName, func);
	
	    backdrop.style.position = 'fixed';
	    backdrop.style.backgroundColor = 'transparent';
	
	    // backdrop.style.cursor = 'none';
	    backdrop.style.top = 0;
	    backdrop.style.bottom = 0;
	    backdrop.style.right = 0;
	    backdrop.style.left = 0;
	    const stopPropagation = (e) => e.stopPropagation();
	    events.forEach((eventName) => instance.on(eventName, stopPropagation));
	    CatchAll.container.append(backdrop);
	
	    this.updateZindex();
	    this.hide();
	  }
	}
	
	
	CatchAll.allMouseEvents = ['auxclick', 'click', 'contextmenu', 'dblclick',
	                        'mousedown', 'mouseenter', 'mouseleave', 'mousemove',
	                        'mouseover', 'mouseout', 'mouseup', 'pointerlockchange',
	                        'pointerlockerror', 'select', 'wheel'];
	
	// Ripped off of: https://stackoverflow.com/a/1120068
	CatchAll.findHigestZindex = function () {
	  var elems = document.querySelectorAll('*');
	  var highest = Number.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);
	  for (var i = 0; i < elems.length; i++)
	  {
	    var zindex = Number.parseInt(
	      document.defaultView.getComputedStyle(elems[i], null).getPropertyValue("z-index"),
	      10
	    );
	    if (zindex > highest && zindex !== 2147483647)
	    {
	      highest = zindex;
	    }
	  }
	  return highest;
	}
	
	CatchAll.container = du.create.element('div', {id: 'catch-all-cnt'});
	document.body.append(CatchAll.container);
	
	module.exports = CatchAll;
	
});


RequireJS.addFunction('../../public/js/utils/object/lookup.js',
function (require, exports, module) {
	
class Lookup {
	  constructor(id, attr, singleton) {
	    if (id){
	      const decoded = Lookup.decode(id);
	      if (decoded) {
	        id = decoded.id;
	      } else if (id._TYPE !== undefined) {
	        id = Lookup.decode(id[id[Lookup.ID_ATTRIBUTE]]).id;
	      }
	    }
	    id = id || String.random();
	    const cxtr = this.constructor;
	    const cxtrHash = cxtr.name;
	    let group;
	    let cxtrAndId = `${cxtrHash}_${id}`
	    if (singleton && cxtr.get(id)) return cxtr.get(id);
	
	    let constructedAt = new Date().getTime();
	    let modificationWindowOpen = true;
	    attr = attr || 'id';
	    Object.getSet(this, attr, Lookup.ID_ATTRIBUTE);
	    this.lookupGroup = (g) => {
	      if (group === undefined && g !== undefined) {
	        if (Lookup.groups[g] === undefined) Lookup.groups[g] = [];
	        group = g;
	        Lookup.groups[g].push(this);
	      }
	      return group;
	    }
	
	    this.release = () => {
	      if (cxtr.reusable === true) {
	        if (Lookup.freeAgents[cxtr.name] === undefined) Lookup.freeAgents[cxtr.name] = [];
	        Lookup.freeAgents[cxtr.name].push(this);
	        const index = Lookup.groups[group] ? Lookup.groups[group].indexOf(this) : -1;
	        if (index !== -1) Lookup.groups[group].splice(index, 1);
	      }
	      delete Lookup.byId[cxtr.name][this[attr]];
	    }
	
	
	    this[Lookup.ID_ATTRIBUTE] = () => attr;
	    this[attr] = (initialValue) => {
	      if (modificationWindowOpen) {
	        if ((typeof initialValue) === "string") {
	          Lookup.byId[cxtr.name][id] = undefined;
	          const decoded = Lookup.decode(initialValue);
	          id = decoded ? decoded.id : initialValue;
	          cxtrAndId = `${cxtrHash}_${id}`
	          Lookup.byId[cxtr.name][id] = this;
	          modificationWindowOpen = false;
	        } else if (constructedAt < new Date().getTime() - 200) {
	          modificationWindowOpen = false;
	        }
	      }
	      return cxtrAndId;
	    }
	
	    function registerConstructor() {
	      if (Lookup.byId[cxtr.name] === undefined) {
	        Lookup.byId[cxtr.name] = {};
	        Lookup.constructorMap[cxtr.name] = cxtr;
	      }
	    }
	
	    function addSelectListFuncToConstructor() {
	      if(cxtr.selectList === Lookup.selectList) {
	        cxtr.get = (id) => Lookup.get(id, cxtr);
	        if (cxtr.instance === undefined) cxtr.instance = () => Lookup.instance(cxtr.name);
	        Lookup.byId[cxtr.name] = {};
	        cxtr.selectList = () => Lookup.selectList(cxtr.name);
	      }
	    }
	
	    registerConstructor();
	    addSelectListFuncToConstructor();
	
	
	    Lookup.byId[cxtr.name][id] = this;
	    this.toString = () => this[attr]();
	  }
	}
	
	Lookup.convert = function (obj, attr) {
	  let id = obj.id && obj.id();
	  if (id){
	    const decoded = Lookup.decode(id);
	    if (decoded) {
	      id = decoded.id;
	    } else if (id._TYPE !== undefined) {
	      id = Lookup.decode(id[id[Lookup.ID_ATTRIBUTE]]).id;
	    }
	  }
	  id = id || String.random();
	  const cxtr = obj.constructor;
	  const cxtrHash = cxtr.name;
	  let group;
	  let cxtrAndId = `${cxtrHash}_${id}`
	
	  let constructedAt = new Date().getTime();
	  let modificationWindowOpen = true;
	  attr = attr || 'id';
	  Object.getSet(obj);
	  obj.lookupGroup = (g) => {
	    if (group === undefined && g !== undefined) {
	      if (Lookup.groups[g] === undefined) Lookup.groups[g] = [];
	      group = g;
	      Lookup.groups[g].push(obj);
	    }
	    return group;
	  }
	
	  obj.lookupRelease = () => {
	    if (cxtr.reusable === true) {
	      if (Lookup.freeAgents[cxtr.name] === undefined) Lookup.freeAgents[cxtr.name] = [];
	      Lookup.freeAgents[cxtr.name].push(obj);
	      const index = Lookup.groups[group] ? Lookup.groups[group].indexOf(obj) : -1;
	      if (index !== -1) Lookup.groups[group].splice(index, 1);
	    }
	    delete Lookup.byId[cxtr.name][obj[attr]];
	  }
	
	
	  obj[Lookup.ID_ATTRIBUTE] = () => attr;
	  obj[attr] = (initialValue) => {
	    if (modificationWindowOpen) {
	      if (initialValue) {
	        Lookup.byId[cxtr.name][id] = undefined;
	        const decoded = Lookup.decode(initialValue);
	        id = decoded ? decoded.id : initialValue;
	        cxtrAndId = `${cxtrHash}_${id}`
	        Lookup.byId[cxtr.name][id] = obj;
	        modificationWindowOpen = false;
	      } else if (constructedAt < new Date().getTime() - 200) {
	        modificationWindowOpen = false;
	      }
	    }
	    return cxtrAndId;
	  }
	
	  function registerConstructor() {
	    if (Lookup.byId[cxtr.name] === undefined) {
	      Lookup.byId[cxtr.name] = {};
	      Lookup.constructorMap[cxtr.name] = cxtr;
	    }
	  }
	
	  function addSelectListFuncToConstructor() {
	    if(cxtr.selectList === Lookup.selectList) {
	      cxtr.get = (id) => Lookup.get(id, cxtr);
	      if (cxtr.instance === undefined) cxtr.instance = () => Lookup.instance(cxtr.name);
	      Lookup.byId[cxtr.name] = {};
	      cxtr.selectList = () => Lookup.selectList(cxtr.name);
	    }
	  }
	
	  registerConstructor();
	  addSelectListFuncToConstructor();
	
	
	  Lookup.byId[cxtr.name][id] = obj;
	  if (obj.toString === undefined) obj.toString = () => obj[attr]();
	}
	
	Lookup.ID_ATTRIBUTE = 'ID_ATTRIBUTE';
	Lookup.byId = {Lookup};
	Lookup.constructorMap = {};
	Lookup.groups = {};
	Lookup.freeAgents = {};
	
	Lookup.get = (id, cxtr) => {
	  cxtr = cxtr || Lookup;
	  const decoded = Lookup.decode(id);
	  let decodedId, decodedCxtr;
	  if (decoded) {
	    decodedId = decoded.id;
	    decodedCxtr = decoded.constructor;
	  }
	  id = decodedId || id;
	  cxtr = cxtr || decodedCxtr;
	  const instance = Lookup.byId[cxtr.name][id] || (decodedCxtr && Lookup.byId[decodedCxtr.name][id]);
	  return instance;
	}
	Lookup.selectList = (className) => {
	  return Object.keys(Lookup.byId[className]);
	}
	Lookup.instance = (cxtrName) => {
	  const agents = Lookup.freeAgents[cxtrName];
	  if (!agents || agents.length === 0) {
	    return new (Lookup.constructorMap[cxtrName])();
	  }
	
	  const index = agents.length - 1;
	  const agent = agents[index];
	  agents.splice(index, 1);
	  return agent;
	}
	Lookup.decode = (id) => {
	  if ((typeof id) !== 'string') return;
	  const split = id.split('_');
	  if (split.length === 1) return;
	  return {
	    constructor: Lookup.constructorMap[split[0]],
	    id:  split[1]
	  };
	}
	Lookup.release = (group) => {
	  const groupList = Lookup.groups[group];
	  if (groupList === undefined) return;
	  Lookup.groups[group] = [];
	  for (let index = 0; index < groupList.length; index += 1) {
	    groupList[index].release();
	  }
	}
	
	try {
	  module.exports = Lookup;
	} catch (e) {/* TODO: Consider Removing */}
	
});


RequireJS.addFunction('../../public/js/utils/collections/notification.js',
function (require, exports, module) {
	
const CustomEvent = require('../custom-event');
	
	function searchAndConvert(obj, parentPath, beforeEvent, afterEvent) {
	  const proxy = new Proxy(obj, {set: notify(parentPath, beforeEvent, afterEvent)});
	  const keys = Object.keys(obj);
	  for (let index = 0; index < keys.length; index++) {
	    const key = keys[index];
	    const path = parentPath ? `${parentPath}.${key}` : key;
	    if (obj[key] instanceof Object)
	      obj[key] = new Notifiction(true, obj[key], path, beforeEvent, afterEvent);
	  }
	  return proxy;
	}
	
	function notify(parentPath, beforeEvent, afterEvent) {
	  return (target, key, value) => {
	    const change = target[key] !== value;
	    const path = parentPath ? `${parentPath}.${key}` : key;
	    if (change) {
	      if (target.isRecusive() && value instanceof Object) value = new Notifiction(true, value, path, beforeEvent, afterEvent);
	    }
	    const detail = {target, path, old: target[key], new: value};
	    if (change) beforeEvent.trigger(null, detail);
	    target[key] = value;
	    if (change) afterEvent.trigger(null, detail);
	    return true;
	  }
	}
	
	class Notifiction {
	  constructor(recursive, object, path, beforeChangeEvent, afterChangeEvent) {
	    path ||= '';
	    const instance = this;
	    afterChangeEvent ||= new CustomEvent('afterChange');
	    beforeChangeEvent ||= new CustomEvent('beforeChange');
	    let proxy;
	    if (recursive) {
	      proxy = searchAndConvert(object || this, path, beforeChangeEvent, afterChangeEvent);
	    } else {
	      proxy = new Proxy(object || this, {set: notify(path, beforeChangeEvent, afterChangeEvent)})
	    }
	
	    Object.defineProperty(proxy, "isRecusive", {
	        writable: false,
	        enumerable: false,
	        configurable: false,
	        value: () => recursive === true
	    });
	    Object.defineProperty(proxy, "onAfterChange", {
	        writable: false,
	        enumerable: false,
	        configurable: false,
	        value: afterChangeEvent.on
	    });
	    Object.defineProperty(proxy, "onBeforeChange", {
	        writable: false,
	        enumerable: false,
	        configurable: false,
	        value: beforeChangeEvent.on
	    });
	    Object.defineProperty(proxy, "deleteAll", {
	        writable: false,
	        enumerable: false,
	        configurable: false,
	        value: () => {
	          const keys = Object.keys(instance);
	          for (let index = 0; index < keys.length; index++) {
	            delete instance[keys[index]];
	          }
	        }
	    });
	
	    return proxy;
	  }
	}
	
	class NotifictionArray extends Notifiction {
	  constructor(recursive, array, path, beforeChangeEvent, afterChangeEvent) {
	    super(recursive, array || [], path, beforeChangeEvent, afterChangeEvent);
	  }
	}
	
	const notifyArr = new Notifiction();
	notifyArr.onAfterChange(console.log);
	notifyArr.onBeforeChange(console.error);
	notifyArr[4] = 'poop';
	notifyArr.pickls = 5;
	notifyArr[4] = 'y diapers';
	notifyArr[0] = [];
	notifyArr[0][69] = 'sooo fine'
	notifyArr[0][6] = {}
	notifyArr[0][6].punk = [1,2,3,4,66]
	notifyArr[0][6].punk.skittles = 'taste the rainbow'
	notifyArr[0][6].punk.skittles = 'uck!'
	
	Notifiction.Array = NotifictionArray;
	module.exports = Notifiction;
	
});


RequireJS.addFunction('../../public/js/utils/object/key-value.js',
function (require, exports, module) {
	
const Lookup = require('./lookup');
	const Notifiction = require('../collections/notification.js');
	const NotifictionArray = Notifiction.Array;
	const CustomEvent = require('../custom-event.js');
	
	function updateParent(keyValue) {
	  return (target, detail) => {
	    if (detail.new instanceof KeyValue) {
	      const parentAttr = detail.new.value.parentAttribute();
	      if (parentAttr) detail.new[parentAttr](keyValue);
	    }
	  }
	}
	
	/**
	  properties:
	    @childrenAttribute - Attribute that defines children an object or an array;
	    @object - true iff you want an object for your children
	    @parentAttribute - Attribute that defines parent setting getting function;
	    @keyMapFunction - function will be called to convert keys before processing.
	    @id - Lookup id
	    @idAttr - attribute for Lookup id.
	    @evaluators - an object whos attributes are types and values are functions to resolve said type
	**/
	class KeyValue extends Lookup {
	  constructor(properties) {
	    super(properties.id, properties.idAttr);
	    const childAttr = properties.childrenAttribute;
	    const parentAttr = properties.parentAttribute;
	    const customFuncs = [];
	
	
	    if (childAttr) {
	      if (properties.object) this[childAttr] = new Notifiction(false);
	      else this[childAttr] = new NotifictionArray(false);
	      this[childAttr].onAfterChange(updateParent(this));
	      this.getRoot = () => {
	        let curr = this;
	        while(curr.parentAssembly() !== undefined) curr = curr.parentAssembly();
	        return curr;
	      }
	    }
	
	    function runCustomFunctions(code, value) {
	      for (let index = 0; index < customFuncs; index++) {
	        const customVal = customFuncs[index](code, value);
	        if(customVal) return customVal;
	      }
	    }
	
	    this.value = (key, value) => {
	      try {
	        const formatted = (typeof this.value.keyFormatter) === 'function' ? this.value.keyFormatter(key) : undefined;
	        if (formatted !== undefined) key = formatted;
	        const customVal = runCustomFunctions(key, value)
	        if(customVal !== undefined) return customVal;
	
	        if (value !== undefined) {
	          this.value.values[key] = value;
	        } else {
	          const instVal = this.value.values[key];
	          if (instVal !== undefined && instVal !== null) {
	            const evaluator = this.value.evaluators[(typeof instVal)];
	            if (evaluator) return evaluator(instVal);
	            return instVal;
	          }
	          const parent = this[parentAttr]();
	          if (parent) return parent.value(key);
	          else {
	            const defaultFunction = this.value.defaultFunction;
	            if (defaultFunction) {
	              value = (typeof this.value.defaultFunction) === 'function' ? this.value.defaultFunction(key) : undefined;
	              if (value === undefined) throw new Error();
	              return value;
	            }
	          }
	        }
	      } catch (e) {
	        console.error(`Failed to resolve key: '${key}'`);
	        throw e;
	        return NaN;
	      }
	    }
	
	
	    this.value.values = {};
	    this.value.evaluators = properties.evaluators || {};
	    this.value.defaultFunction = properties.defaultFunction;
	    this.value.keyFormatter = properties.keyFormatter;
	    this.value.parentAttribute = () => parentAttr;
	    this.value.childrenAttribute = () => childAttr;
	    this.value.addCustomFunction = (func) => (typeof func) === 'function' && customFuncs.push(func);
	  }
	}
	
	module.exports = KeyValue;
	
});


RequireJS.addFunction('../../public/js/utils/input/bind.js',
function (require, exports, module) {
	
const du = require('../dom-utils');
	const Input = require('./input');
	
	const defaultDynamInput = (value, type) => new Input({type, value});
	
	module.exports = function(selector, objOrFunc, props) {
	  let lastInputTime = {};
	  props = props || {};
	  const validations = props.validations || {};
	  const inputs = props.inputs || {};
	
	  const resolveTarget = (elem) => du.find.down('[prop-update]', elem);
	  const getValue = (updatePath, elem) => {
	    const input = Object.pathValue(inputs, updatePath);
	    return input ? input.value() : elem.value;
	  }
	  const getValidation = (updatePath) => {
	    let validation = Object.pathValue(validations, updatePath);
	    const input = Object.pathValue(inputs, updatePath);
	    if (input) {
	      validation = input.validation;
	    }
	    return validation;
	  }
	
	  function update(elem) {
	    const target = resolveTarget(elem);
	    elem = du.find.down('input,select,textarea', elem);
	    const updatePath = elem.getAttribute('prop-update') || elem.getAttribute('name');
	    elem.id = elem.id || String.random(7);
	    const thisInputTime = new Date().getTime();
	    lastInputTime[elem.id] = thisInputTime;
	    setTimeout(() => {
	      if (thisInputTime === lastInputTime[elem.id]) {
	        const validation = getValidation(updatePath);
	        if (updatePath !== null) {
	          const newValue = getValue(updatePath, elem);
	          if ((typeof validation) === 'function' && !validation(newValue)) {
	            console.error('badValue')
	          } else if ((typeof objOrFunc) === 'function') {
	            objOrFunc(updatePath, elem.value, elem);
	          } else {
	            Object.pathValue(objOrFunc, updatePath, elem.value);
	          }
	
	          if (target.tagname !== 'INPUT' && target.children.length === 0) {
	            target.innerHTML = newValue;
	          }
	        }
	      }
	    }, 2000);
	  }
	  const makeDynamic = (target) => {
	    target = resolveTarget(target);
	    if (target.getAttribute('resolved') === null) {
	      target.setAttribute('resolved', 'dynam-input');
	      const value = target.innerText;
	      const type = target.getAttribute('type');
	      const updatePath = target.getAttribute('prop-update') || target.getAttribute('name');
	      const input = Object.pathValue(inputs, updatePath) || defaultDynamInput(value, type);
	
	      target.innerHTML = input.html();
	      const id = (typeof input.id === 'function') ? input.id() : input.id;
	      const inputElem = du.find.down(`#${id}`, target);
	      du.class.add(inputElem, 'dynam-input');
	      inputElem.setAttribute('prop-update', updatePath);
	      inputElem.focus();
	    }
	  }
	
	  du.on.match('keyup', selector, update);
	  du.on.match('change', selector, update);
	  du.on.match('click', selector, makeDynamic);
	}
	
	
	const undoDynamic = (target) => {
	  const parent = du.find.up('[resolved="dynam-input"]', target)
	  parent.innerText = target.value;
	  parent.removeAttribute('resolved');
	}
	
	du.on.match('focusout', '.dynam-input', undoDynamic);
	
});


RequireJS.addFunction('../../public/js/utils/test/test.js',
function (require, exports, module) {
	

	
	
	
	Error.stackInfo = (steps) => {
	  steps = steps || 1;
	  const err = new Error();
	  const lines = err.stack.split('\n');
	  const match = lines[steps].match(/at (([a-zA-Z\.]*?) |)(.*\.js):([0-9]{1,}):([0-9]{1,})/);;
	  if (match) {
	    return {
	      filename: match[3].replace(/^\(/, ''),
	      function: match[2],
	      line: match[4],
	      character: match[5]
	    }
	  }
	}
	
	Error.reducedStack = (msg, steps) => {
	  steps = steps || 1;
	  const err = new Error();
	  let lines = err.stack.split('\n');
	  lines = lines.splice(steps);
	  return `Error: ${msg}\n${lines.join('\n')}`;
	}
	
	class ArgumentAttributeTest {
	  constructor(argIndex, value, name, errorCode, errorAttribute) {
	    function fail (ts, func, actualErrorCode, args) {
	      ts.fail('AttributeTest Failed: use null if test was supposed to succeed' +
	      `\n\tFunction: '${func.name}'` +
	      `\n\tArgument Index: '${argIndex}'` +
	      `\n\tName: '${name}'` +
	      `\n\tValue: '${value}'` +
	      `\n\tErrorCode: '${actualErrorCode}' !== '${errorCode}'`);
	    }
	
	    this.run = function (ts, func, args, thiz) {
	      thiz = thiz || null;
	      const testArgs = [];
	      for (let index = 0; index < args.length; index += 1) {
	        const obj = args[index];
	        let arg;
	        if (index === argIndex) {
	          if (name) {
	            arg = JSON.parse(JSON.stringify(obj));
	            arg[name] = value;
	          } else {
	            arg = value;
	          }
	        }
	        testArgs.push(arg);
	      }
	      try {
	        func.apply(thiz, testArgs)
	        if (errorCode || errorCode !== null) fail(ts, func, null, arguments);
	      } catch (e) {
	        errorAttribute = errorAttribute || 'errorCode';
	        const actualErrorCode = e[errorAttribute];
	        if (errorCode !== undefined &&
	              (errorCode === null || actualErrorCode !== errorCode))
	          fail(ts, func, actualErrorCode, arguments);
	      }
	    }
	  }
	}
	
	class FunctionArgumentTestError extends Error {
	  constructor(argIndex, errorAttribute) {
	    super();
	    this.message = 'errorCode should be null if no error thrown and undefined if no errorCode';
	    if (argIndex === undefined) {
	      this.message += '\n\targIndex must be defined.';
	    }
	    if (errorAttribute === undefined) {
	      this.message += '\n\terrorAttribute must be defined.';
	    }
	  }
	}
	
	const failureError = new Error('Test Failed');
	
	class FunctionArgumentTest {
	  constructor(ts, func, args, thiz) {
	    if (!(ts instanceof TestStatus))
	      throw new Error('ts must be a valid instance of TestStatus');
	    if ((typeof func) !== 'function')
	      throw new Error("Function must be defined and of type 'function'");
	    if (!Array.isArray(args) || args.length === 0)
	      throw new Error("This is not a suitable test for a function without arguments");
	    const funcArgTests = [];
	    let argIndex, errorCode;
	    let errorAttribute = 'errorCode';
	    this.setIndex = (i) => {argIndex = i; return this;}
	    this.setErrorCode = (ec) => {errorCode = ec; return this;}
	    this.setErrorAttribute = (ea) => {errorAttribute = ea; return this};
	    const hasErrorCode =  errorCode !== undefined;
	    this.run = () => {
	      funcArgTests.forEach((fat) => {
	        fat.run(ts, func, args, thiz);
	      });
	      return this;
	    }
	    this.add = (name, value) =>  {
	      if (errorAttribute === undefined || argIndex === undefined)
	        throw new FunctionArgumentTestError(argIndex, errorAttribute);
	      const at = new ArgumentAttributeTest(argIndex, value, name, errorCode, errorAttribute);
	      funcArgTests.push(at);
	      return this;
	    }
	  }
	}
	
	function round(value, accuracy) {
	  if (accuracy === undefined) return value;
	  return Math.round(value * accuracy) / accuracy;
	}
	// ts for short
	class TestStatus {
	  constructor(testName) {
	    let assertT = 0;
	    let assertC = 0;
	    let success = false;
	    let fail = false;
	    let failOnError = true;
	    let instance = this;
	    function printError(msg, stackOffset) {
	      stackOffset = stackOffset || 4;
	      console.error(`%c${Error.reducedStack(msg, stackOffset)}`, 'color: red');
	    }
	    function assert(b) {
	      assertT++;
	      if (b) {
	        assertC++;
	        TestStatus.successAssertions++;
	        return true;
	      }
	      TestStatus.failAssertions++;
	      return false;
	    }
	    function successStr(msg) {
	      console.log(`%c ${testName} - Successfull (${assertC}/${assertT})${
	          msg ? `\n\t\t${msg}` : ''}`, 'color: green');
	    }
	    const possiblyFail = (msg) => failOnError ? instance.fail(msg, 6) : printError(msg, 5);
	
	    this.assertTrue = (b, msg) => !assert(b) &&
	                            possiblyFail(`${msg}\n\t\t'${b}' should be true`);
	    this.assertFalse = (b, msg) => !assert(!b) &&
	                            possiblyFail(`${msg}\n\t\t'${b}' should be false`);
	    this.assertEquals = (a, b, msg, acc) => !assert(round(a, acc) === round(b, acc)) &&
	                            possiblyFail(`${msg}\n\t\t'${a}' === '${b}' should be true`);
	    this.assertNotEquals = (a, b, msg, acc) => !assert(round(a, acc) !== round(b, acc)) &&
	                            possiblyFail(`${msg}\n\t\t'${a}' !== '${b}' should be true`);
	    this.assertTolerance = (n1, n2, tol, msg, stackOffset) => {
	      !assert(Math.abs(n1-n2) < tol) &&
	      possiblyFail(`${msg}\n\t\t${n1} and ${n2} are not within tolerance ${tol}`, stackOffset);
	    }
	    this.fail = (msg, stackOffset) => {
	      fail = true;
	      printError(msg, stackOffset);
	      throw failureError;
	    };
	    this.success = (msg, stackOffset) => (success = true) && successStr(msg, stackOffset);
	  }
	}
	
	TestStatus.successCount = 0;
	TestStatus.failCount = 0;
	TestStatus.successAssertions = 0;
	TestStatus.failAssertions = 0;
	
	const Test = {
	  tests: {},
	  add: (name, func) => {
	    if ((typeof func) === 'function') {
	      if (Test.tests[name] ===  undefined) Test.tests[name] = [];
	      Test.tests[name].push(func);
	    }
	  },
	  run: () => {
	    const testNames = Object.keys(Test.tests);
	    for (let index = 0; index < testNames.length; index += 1) {
	      const testName = testNames[index];
	      try {
	        Test.tests[testName].forEach((testFunc) => testFunc(new TestStatus(testName)));
	        TestStatus.successCount++;
	      } catch (e) {
	        TestStatus.failCount++;
	        if (e !== failureError)
	          console.log(`%c ${e.stack}`, 'color: red')
	      }
	    }
	    const failed = (TestStatus.failCount + TestStatus.failAssertions) > 0;
	    console.log(`\n%c Successfull Tests:${TestStatus.successCount} Successful Assertions: ${TestStatus.successAssertions}`, 'color: green');
	    console.log(`%c Failed Tests:${TestStatus.failCount} Failed Assertions: ${TestStatus.failAssertions}`, !failed ? 'color:green' : 'color: red');
	  }
	}
	
	exports.ArgumentAttributeTest = ArgumentAttributeTest;
	exports.FunctionArgumentTestError = FunctionArgumentTestError;
	exports.FunctionArgumentTest = FunctionArgumentTest;
	exports.TestStatus = TestStatus;
	exports.Test = Test;
	
});


RequireJS.addFunction('../../public/js/utils/display/resizer.js',
function (require, exports, module) {
	const CatchAll = require('./catch-all');
	const du = require('../dom-utils');
	const CustomEvent = require('../custom-event');
	
	class Resizer {
	  constructor (elem, axisObj, cursor) {
	    const instance = this;
	    const minimumSize = 40;
	    let resizeId = elem.getAttribute(Resizer.resizeAttr);
	    let sizeLocked = false;
	
	    if (!resizeId) {
	      resizeId = 'resize-' + Math.floor(Math.random() * 1000000);
	      elem.setAttribute(Resizer.resizeAttr, resizeId);
	    }
	
	    this.show = () => {this.container.hidden = false; this.position()};
	    this.hide = () => this.container.hidden = true;
	
	    function updateZindex(zIndex) {
	      if (instance.container.hidden === false) {
	        instance.container.style.zIndex = zIndex;
	        elem.style.zIndex = zIndex;
	        Resizer.backdrop.updateZindex();
	        instance.position();
	      }
	    }
	    this.updateZindex = updateZindex;
	    elem.addEventListener('click', () => Resizer.updateZindex(elem));
	
	
	    if (resizeId) {
	      if (!Resizer.collections[resizeId]) {
	        Resizer.collections[resizeId] = [];
	      }
	      Resizer.collections[resizeId].push(this);
	    }
	    const padding = 8;
	    let resize = false;
	    let lastPosition;
	    this.getPadding = () => padding;
	
	    const attrs = Object.values(axisObj);
	    const top = attrs.indexOf('top') !== -1;
	    const bottom = attrs.indexOf('bottom') !== -1;
	    const left = attrs.indexOf('left') !== -1;
	    const right = attrs.indexOf('right') !== -1;
	
	    this.container = document.createElement('DIV');
	    this.container.style.cursor = cursor;
	    this.container.style.padding = padding/2 + 'px';
	    this.container.style.position = axisObj.position || 'absolute';
	    this.container.style.backgroundColor = 'transparent';
	    Resizer.container.append(this.container);
	
	    function getComputedSize(element, property) {
	      return Number.parseInt(window.getComputedStyle(element).getPropertyValue(property));
	    }
	
	    function resizeCnt (event) {
	      if (resize) {
	        Resizer.updateZindex(elem);
	        let dy = resize.clientY - event.clientY;
	        let dx = resize.clientX - event.clientX;
	        let minHeight = getComputedSize(elem, 'min-height');
	        let minWidth = getComputedSize(elem, 'min-width');
	        if (axisObj.x) {
	          if (left) dx *= -1;
	          const newWidth = lastPosition.width - dx;
	          if (newWidth > minWidth) {
	            if (left) {
	              elem.style.left = lastPosition.left + dx + 'px';
	            }
	            elem.style.width = newWidth + 'px'
	          }
	        }
	        if (axisObj.y) {
	          if (top) dy *= -1;
	          const newHeight = lastPosition.height - dy;
	          if (newHeight > minHeight) {
	            if (top) {
	              elem.style.top = lastPosition.top + window.scrollY + dy + 'px';
	            }
	            elem.style.height = newHeight + 'px'
	          }
	        }
	      }
	    }
	
	    this.container.onmousedown = (e) => {
	      resize = e;
	      Resizer.backdrop.show();
	      lastPosition = elem.getBoundingClientRect();
	      // e.stopPropagation();
	      // e.preventDefault();
	    }
	
	    function stopResizing() {
	      if (resize) {
	        resize = undefined;
	        Resizer.position(elem);
	        Resizer.backdrop.hide();
	        Resizer.events.resize.trigger(elem);
	      }
	    }
	
	    function isFixed() {
	      return axisObj.position && axisObj.position === 'fixed';
	    }
	
	    // this.container.addEventListener('click',
	    // (e) =>
	    // e.stopPropagation()
	    // );
	    Resizer.backdrop.on('mouseup', stopResizing);
	    this.container.onmouseup = stopResizing;
	
	    this.container.onmousemove = resizeCnt;
	    Resizer.backdrop.on('mousemove', (event) =>
	    resizeCnt(event));
	    this.position = function () {
	      const height = document.documentElement.clientHeight;
	      const width = document.documentElement.clientWidth;
	      const rect = elem.getBoundingClientRect();
	      const cntStyle = instance.container.style;
	      const scrollY =  isFixed() ? 0 : window.scrollY;
	      const scrollX =  isFixed() ? 0 : window.scrollX;
	      if (top) {
	        cntStyle.top = rect.top - padding + scrollY + 'px';
	      } else if (!bottom) {
	        cntStyle.top = rect.top + scrollY + 'px';
	      }
	
	      if (bottom) {
	        cntStyle.bottom = (height - rect.bottom) - padding - scrollY + 'px';
	      } else if (!top) {
	        cntStyle.bottom = (height - rect.bottom) - scrollY + 'px';
	      }
	
	      if (right) {
	        cntStyle.right = (width - rect.right) - padding - scrollX + 'px';
	      } else if (!left) {
	        cntStyle.right = (width - rect.right) - scrollX + 'px';
	      }
	
	      if (left) {
	        cntStyle.left = rect.left - padding + scrollX + 'px';
	      } else if (!right) {
	        cntStyle.left = rect.left + scrollX + 'px';
	      }
	    }
	  }
	}
	
	Resizer.container = du.create.element('div', {id: 'resizer-cnt'});
	document.body.append(Resizer.container);
	
	Resizer.lastZindexSearch = new Date().getTime();
	Resizer.zIndex = (zindex) => {
	  const time = new Date().getTime();
	  if (time > Resizer.lastZindexSearch + 500) {
	    Resizer.zed = CatchAll.findHigestZindex();
	    lastZindexSearch = time;
	  }
	  return Resizer.zed;
	}
	Resizer.container.id = 'resize-id-id';
	// Resizer.container.addEventListener('click', (e) => e.stopPropagation());
	Resizer.events = {};
	Resizer.events.resize = new CustomEvent ('resized')
	
	Resizer.backdrop = new CatchAll();
	
	Resizer.resizeAttr = 'resizer-id'
	Resizer.collections = {};
	Resizer.position = function (elem) {
	  const resizeId = elem.getAttribute(Resizer.resizeAttr);
	  const collection = Resizer.collections[resizeId];
	  if (collection) {
	    collection.forEach((item) => item.position());
	  }
	}
	Resizer.onEach = function (elem, func) {
	  const callArgs = Array.from(arguments).splice(2);
	  const resizeId = elem.getAttribute(Resizer.resizeAttr);
	  const collection = Resizer.collections[resizeId];
	  if (collection) {
	    collection.forEach((item) => item[func](...callArgs));
	  }
	}
	Resizer.hide = (elem) => Resizer.onEach(elem, 'hide');
	Resizer.show = (elem) => {
	    if (!Resizer.isLocked(elem)) {
	      Resizer.onEach(elem, 'show');
	      Resizer.updateZindex(elem);
	    }
	};
	Resizer.updateZindex = (elem, callback) => {
	  const highestZIndex = Resizer.zIndex() - 3;
	  if (!elem.style.zIndex ||
	      (elem.style.zIndex.match(/[0-9]{1,}/) &&
	        highestZIndex > Number.parseInt(elem.style.zIndex))) {
	    Resizer.onEach(elem, 'updateZindex', highestZIndex + 4);
	  }
	}
	
	{
	  const locked = {};
	  Resizer.lock = (elem) => locked[elem.getAttribute(Resizer.resizeAttr)] = true;
	  Resizer.unlock = (elem) => locked[elem.getAttribute(Resizer.resizeAttr)] = false;
	  Resizer.isLocked  = (elem) => locked[elem.getAttribute(Resizer.resizeAttr)];
	}
	
	Resizer.all = (elem, position) => {
	  new Resizer(elem, {y: 'top', position}, 'n-resize');
	  new Resizer(elem, {y: 'bottom', position}, 's-resize');
	  new Resizer(elem, {x: 'right', position}, 'e-resize');
	  new Resizer(elem, {x: 'left', position}, 'w-resize', position);
	  new Resizer(elem, {x: 'right', y: 'top', position}, 'ne-resize');
	  new Resizer(elem, {x: 'left', y: 'top', position}, 'nw-resize');
	  new Resizer(elem, {x: 'right', y: 'bottom', position}, 'se-resize');
	  new Resizer(elem, {x: 'left', y: 'bottom', position}, 'sw-resize');
	}
	
	module.exports = Resizer;
	
});


RequireJS.addFunction('../../public/js/utils/display/drag-drop.js',
function (require, exports, module) {
	
const $t = require('../$t');
	const CatchAll = require('./catch-all');
	const du = require('../dom-utils');
	const Resizer = require('./resizer');
	
	class DragDropResize {
	  constructor (props) {
	    props = props || {};
	    const id = Math.floor(Math.random() * 1000000);
	    const POPUP_CNT_ID = 'place-popup-cnt-id-' + id;
	    const POPUP_CONTENT_ID = 'place-popup-content-id-' + id;
	    const POPUP_CONTENT_CNT_ID = 'place-popup-content-cnt-id-' + id;
	    const MAXIMIZE_BTN_ID = 'place-maximize-id-' + id;
	    const POPUP_HEADER_CNT_ID = 'place-header-cnt-id-' + id;
	    const MINIMIZE_BTN_ID = 'place-minimize-id-' + id;
	    const MAX_MIN_CNT_ID = 'place-max-min-id-' + id;
	    const CLOSE_BTN_ID = 'place-close-btn-id-' + id;
	    const MOVE_BTN_ID = 'place-MOVE-btn-id-' + id;
	    const BACK_BTN_ID = 'place-back-btn-id-' + id;
	    const FORWARD_BTN_ID = 'place-forward-btn-id-' + id;
	    const HISTORY_BTN_ID = 'place-history-btn-id-' + id;
	    const position = props.position || 'absolute';
	    const template = new $t('place');
	    let lastMoveEvent, prevLocation, minLocation, selectElem,
	        currElem, hasMoved;
	    const instance = this;
	    const closeFuncs = [];
	
	    let width = props.width || 'fit-content';
	    let height = props.height || 'fit-content';
	    this.getDems = props.getDems || ( () => { return {width, height}; } );
	    this.setDems = props.setDems || ( (w, h) => { width = w; height = h; } );
	
	    this.hasMoved = () => hasMoved;
	    function onResizeEvent() {
	      const rect = popupCnt.getBoundingClientRect();
	      if (!Resizer.isLocked(popupCnt)) instance.setDems({width: rect.width + 'px', height: rect.height + 'px'});
	    }
	
	    const defaultStyle = `position: ${position};`;
	
	    this.close = () => {
	      getPopupElems().cnt.style.display = 'none';
	      Resizer.hide(popupCnt);
	      closeFuncs.forEach((func) => func());
	      middleSize();
	      backdrop.hide();
	      histCnt.hidden = true;
	    }
	    this.hide = this.close;
	
	    this.updateZindex = () => {
	      const highestZ = CatchAll.findHigestZindex();
	      popupCnt.style.zIndex = highestZ + 2;
	      backdrop.backdrop.style.zIndex = highestZ - 1;
	    }
	
	    this.show = () => {
	      if (instance.hidden()) {
	        if (!props.noBackdrop) backdrop.show();
	        updateControls();
	        const css = {display: 'block',
	        height: Resizer.isLocked(popupCnt) ? undefined : instance.getDems().height,
	        width: Resizer.isLocked(popupCnt) ? undefined : instance.getDems().width};
	        if (Number.isFinite(css.height)) css.height = css.height + 'px';
	        if (Number.isFinite(css.width)) css.width = css.width + 'px';
	
	        setCss(css);
	        if (!Resizer.isLocked(popupCnt)) Resizer.show(popupCnt);
	      }
	      this.updateZindex();
	      // updateHistZindex();
	      return instance;
	    };
	
	    this.hidden = () => getPopupElems().cnt.style.display === 'none';
	
	    this.withinPopup = (offset) => {
	      const rect = getPopupElems().cnt.getBoundingClientRect();
	      if (lastMoveEvent) {
	        const withinX = lastMoveEvent.clientX < rect.right - offset && rect.left + offset < lastMoveEvent.clientX;
	        const withinY = lastMoveEvent.clientY < rect.bottom - offset && rect.top + offset < lastMoveEvent.clientY;
	        return withinX && withinY;
	      }
	      return false;
	    }
	
	    function updateHistZindex() {
	      histCnt.style.zIndex = Number.parseInt(popupCnt.style.zIndex) + 1;
	    }
	
	    function getRelitiveRect(elem) {
	      let rect;
	      if (elem instanceof HTMLElement) {
	        rect = elem.getBoundingClientRect();
	      } else if (elem.x !== undefined && elem.y !== undefined) {
	        const x = (typeof elem.x === 'function') ? elem.x() : elem.x;
	        const y = (typeof elem.y === 'function') ? elem.y() : elem.y;
	        return {
	          top: y,
	          bottom: y,
	          right: x,
	          left: x,
	          width: 0,
	          height: 0
	        }
	      } else {
	        rect = {top: 0, bottom: 0, right: 0, left: 0, width: 100, height: 100};
	        console.warn('unknown DragDrops position element:', elem);
	      }
	
	      const absRect = {};
	      const scrollOffset = getScrollOffset();
	      absRect.top = rect.top + scrollOffset.y;
	      absRect.bottom = rect.bottom + scrollOffset.y;
	      absRect.right = rect.right + scrollOffset.x;
	      absRect.left = rect.left + scrollOffset.x;
	      absRect.width = rect.width;
	      absRect.height = rect.height;
	      return absRect
	    }
	
	    this.back = () => setCss(prevLocation);
	
	    function positionOnElement(elem, container) {
	      currElem = elem || currElem;
	      container = container || getPopupElems().cnt;
	      instance.show();
	      let rect = getRelitiveRect(currElem);
	      let popRect = getRelitiveRect(container);
	      let padding = 8;
	
	      let top = `${rect.top}px`;
	      const position = {};
	      position.close = instance.close;
	      position.top = () =>{setCss({top: rect.top - popRect.height - padding + 'px'}, container); return position;};
	      position.bottom = () =>{setCss({top: rect.bottom + padding + 'px'}, container); return position;};
	      position.left = () =>{setCss({left: rect.left - popRect.width - padding + 'px'}, container); return position;};
	      position.right = () =>{setCss({left: rect.right + padding + 'px'}, container); return position;};
	      position.center = () =>{
	              let left = rect.left - (popRect.width / 2) + (rect.width / 2);
	              let top = rect.top - (popRect.height / 2) + (rect.height / 2);
	              setCss({left: left + 'px', top: top + 'px'}, container);
	              return position;};
	      position.inView = () =>{
	        // TODO: Fix or remove
	        let popRect = getRelitiveRect(container || getPopupElems().cnt);
	        const left = (popRect.left > 10 ? popRect.left : 10) + 'px';
	        const right = (popRect.right > 10 ? popRect.right : 10) + 'px';
	        const top = (popRect.top > 10 ? popRect.top : 10) + 'px';
	        const bottom = (popRect.bottom > 10 ? popRect.bottom : 10) + 'px';
	        setCss({left, right, top, bottom}, container);
	        return position;};
	      position.maximize = instance.maximize.bind(position);
	      position.minimize = instance.minimize.bind(position);
	      if (window.innerHeight / 2 > rect.top - window.scrollY) {
	        position.center().bottom().inView();
	      } else {
	        position.center().top().inView();
	      }
	
	      return position;
	    }
	
	    this.position = positionOnElement;
	    this.select = () => {
	      if (window.getSelection().toString().trim()) {
	        selectElem = window.getSelection().getRangeAt(0);
	        currElem = selectElem;
	      }
	      return positionOnElement(selectElem);
	    };
	    this.top = () => setCss({top:0,bottom:''});
	    this.left = () => setCss({right:'',left:0});
	    this.bottom = () => setCss({top:'',bottom:0});
	    this.right = () => setCss({right:0,left:''});
	
	    this.center = function () {
	      const popRect = getPopupElems().cnt.getBoundingClientRect();
	      const top = `${(window.innerHeight / 2) - (popRect.height / 2)}px`;
	      const left = `${(window.innerWidth / 2) - (popRect.width / 2)}px`;
	      setCss({top,left, right: '', bottom: ''});
	      return instance;
	    }
	
	    function showElem(id, show) {
	      popupCnt.hidden = !show;
	    }
	
	    function updateControls() {
	      showElem(MINIMIZE_BTN_ID, !props.hideMin && (isMaximized || props.tabText !== undefined));
	      showElem(MAXIMIZE_BTN_ID, !props.hideMax && !isMaximized());
	      const hasPast = props.hasPast ? props.hasPast() : false;
	      showElem(BACK_BTN_ID, hasPast);
	      const hasFuture = props.hasFuture ? props.hasFuture() : false;
	      showElem(FORWARD_BTN_ID, hasFuture);
	      showElem(HISTORY_BTN_ID, hasFuture || hasPast);
	
	    }
	
	    function middleSize() {
	      if (minLocation) {
	        setCss({position, transform: 'unset', top: 'unset', bottom: 'unset', right: 'unset', left: 'unset', width: instance.getDems().width})
	        setCss(minLocation);
	        showElem(POPUP_HEADER_CNT_ID, false);
	        showElem(POPUP_CONTENT_CNT_ID, true);
	        prevLocation = minLocation;
	        minLocation = undefined;
	        updateControls();
	        return true;
	      }
	      return false;
	    }
	
	    this.maximize = function () {
	      if (!middleSize()) {
	        setCss({position: 'fixed', top: 0, bottom: 0, right: 0, left:0, maxWidth: 'unset', maxHeight: 'unset', width: 'unset', height: '95vh'})
	        minLocation = prevLocation;
	        updateControls();
	      }
	      return this;
	    }
	
	    this.minimize = function () {
	      if (!middleSize() && props.tabText) {
	        console.log('tab-it')
	        tabHeader.innerText = props.tabText();
	        showElem(POPUP_HEADER_CNT_ID, true);
	        showElem(POPUP_CONTENT_CNT_ID, false);
	        setCss({left: 0, right: 0, bottom: 0, maxWidth: 'unset', maxHeight: 'unset', minWidth: 'unset',
	                minHeight: 'unset', width: 'fit-content', height: 'fit-content',
	                transform: 'rotate(90deg)'});
	        minLocation = prevLocation;
	        const rect = popupCnt.getBoundingClientRect();
	        const left = (rect.width - rect.height)/2 + 'px';
	        setCss({left});
	        DragDropResize.events.tabbed.trigger(getPopupElems().cnt);
	      }
	      return this;
	    }
	
	    function setCss(rect, container) {
	      if (container === undefined) {
	        const popRect = getPopupElems().cnt.getBoundingClientRect();
	        const top = getPopupElems().cnt.style.top;
	        const bottom = getPopupElems().cnt.style.bottom;
	        const left = getPopupElems().cnt.style.left;
	        const right = getPopupElems().cnt.style.right;
	        const maxWidth = getPopupElems().cnt.style.maxWidth;
	        const maxHeight = getPopupElems().cnt.style.maxHeight;
	        const width = getPopupElems().cnt.style.width;
	        const height = getPopupElems().cnt.style.height;
	        prevLocation = {top, bottom, left, right, maxWidth, maxHeight, width, height}
	        setTimeout(() => Resizer.position(popupCnt), 0);
	      }
	      du.style(container || getPopupElems().cnt, rect);
	      return instance;
	    }
	    this.setCss = setCss;
	
	    this.onClose = (func) => closeFuncs.push(func);
	
	    function updateContent(html) {
	      du.innerHTML(html, getPopupElems().content);
	      return instance;
	    }
	    this.updateContent = updateContent;
	
	    function isMaximized() {
	      return minLocation !== undefined;
	    }
	    this.isMaximized = isMaximized;
	
	    function getScrollOffset() {
	      let x,y;
	      if (props.position === 'fixed') {
	        y = 0;
	        x = 0;
	      } else {
	        y = window.scrollY;
	        x = window.scrollX;
	      }
	      return {x, y}
	    }
	
	    let moving;
	    function move(e) {
	      console.log('moving!');
	      backdrop.show();
	      Resizer.hide(popupCnt);
	      const rect = popupCnt.getBoundingClientRect();
	      const scrollOffset = getScrollOffset();
	      moving = {clientX: e.clientX + scrollOffset.x,
	                  clientY: e.clientY + scrollOffset.y,
	                  top: rect.top + scrollOffset.y,
	                  left: rect.left + scrollOffset.x};
	      DragDropResize.events.dragstart.trigger(getPopupElems().cnt);
	    }
	
	    function get(name) {
	      const prop = props[name];
	      if ((typeof prop) === 'function') return prop();
	      return prop;
	    }
	
	    function stopMoving() {
	      moving = undefined;
	      backdrop.hide();
	      Resizer.position(popupCnt);
	      DragDropResize.events.dragend.trigger(getPopupElems().cnt);
	      DragDropResize.events.drop.trigger(getPopupElems().cnt);
	      if (!Resizer.isLocked(popupCnt)) Resizer.show(popupCnt);
	    }
	
	    function backdropClick() {
	      if (moving) stopMoving();
	      else instance.close();
	    }
	
	    const tempElem = document.createElement('div');
	    tempElem.append(document.createElement('div'));
	    const tempHtml = template.render({POPUP_CNT_ID, POPUP_CONTENT_ID,
	        MINIMIZE_BTN_ID, MAXIMIZE_BTN_ID, MAX_MIN_CNT_ID, CLOSE_BTN_ID,
	        HISTORY_BTN_ID, FORWARD_BTN_ID, BACK_BTN_ID, MOVE_BTN_ID,
	        POPUP_HEADER_CNT_ID, POPUP_CONTENT_CNT_ID,
	        props});
	    du.innerHTML(tempHtml, tempElem.children[0]);
	    // tempElem.children[0].style = defaultStyle;
	    DragDropResize.container.append(tempElem);
	
	    const popupContent = tempElem.children[0];
	    const popupCnt = tempElem;
	    popupCnt.className = 'drag-drop-popup-cnt';
	    const histCnt = document.createElement('DIV');
	    const tabHeader = du.id(POPUP_HEADER_CNT_ID);
	    if (tabHeader) {
	      tabHeader.onclick = this.maximize;
	    }
	    const histFilter = document.createElement('input');
	    histFilter.placeholder = 'filter';
	    const histDisplayCnt = document.createElement('DIV');
	    histCnt.append(histFilter);
	    histCnt.append(histDisplayCnt);
	    histDisplayCnt.style.maxHeight = '20vh';
	    histDisplayCnt.style.overflow = 'auto';
	    histCnt.style.position = position;
	    histCnt.hidden = true;
	    histCnt.className = 'place-history-cnt';
	    DragDropResize.container.append(histCnt);
	    popupCnt.style = defaultStyle;
	    popupCnt.addEventListener(Resizer.events.resize.name, onResizeEvent);
	    du.on.match('click', `${MAXIMIZE_BTN_ID}`, instance.maximize);
	    du.on.match('click', `${MINIMIZE_BTN_ID}`, instance.minimize);
	    du.on.match('click', `${CLOSE_BTN_ID}`, instance.close);
	    du.on.match('click', `${MOVE_BTN_ID}`, move);
	    // if (props.back) {
	    //   document.getElementById(BACK_BTN_ID).onclick = () => {
	    //     props.back();
	    //     updateControls();
	    //     event.stopPropagation();
	    //     histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //   }
	    // }
	    // if (props.forward) {
	    //   document.getElementById(FORWARD_BTN_ID).onclick = () => {
	    //     props.forward();
	    //     updateControls();
	    //     event.stopPropagation();
	    //     histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //   }
	    // }
	    // if (props.historyDisplay) {
	    //   const historyBtn = document.getElementById(HISTORY_BTN_ID);
	    //   historyBtn.onclick = (event) => {
	    //     histCnt.hidden = false;
	    //     histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //     positionOnElement(historyBtn, histCnt).center().bottom();
	    //     updateHistZindex();
	    //     event.stopPropagation();
	    //   }
	    //   histCnt.onclick = (event) => {
	    //     event.stopPropagation();
	    //   }
	    //   histDisplayCnt.onclick = (event) => {
	    //     event.stopPropagation();
	    //     if ((typeof props.historyClick) === 'function') {
	    //       props.historyClick(event);
	    //       updateControls();
	    //       histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //       histFilter.focus();
	    //     }
	    //   }
	    //   histFilter.onkeyup = () => {
	    //     histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //     histFilter.focus();
	    //   }
	    // }
	
	    popupCnt.onclick = (e) => {
	      histCnt.hidden = true;
	      // if (e.target.tagName !== 'A')
	      // e.stopPropagation()
	    };
	
	    // CssFile.apply('place');
	
	
	    function getPopupElems() {
	      return {cnt: popupCnt, content: popupContent};
	    }
	
	    let lastDragNotification = new Date().getTime()
	    let lastMove = new Date().getTime()
	    function mouseMove(e) {
	      const time = new Date().getTime();
	      const scrollOffset = getScrollOffset();
	      lastMoveEvent = {clientX: e.clientX + scrollOffset.x,
	                      clientY: e.clientY + scrollOffset.y};
	      if (moving && lastMove < time + 100) {
	        console.log('moving')
	        const dy = moving.clientY - lastMoveEvent.clientY;
	        const dx = moving.clientX - lastMoveEvent.clientX;
	        const rect = popupCnt.getBoundingClientRect();
	        popupCnt.style.top = moving.top - dy + 'px';
	        popupCnt.style.left = moving.left - dx + 'px';
	        if (lastDragNotification + 350 < time) {
	          DragDropResize.events.drag.trigger(getPopupElems().cnt);
	          lastDragNotification = time;
	        }
	      }
	    }
	
	    function on(eventName, func) {
	      getPopupElems().content.addEventListener(eventName, func);
	    }
	    this.on = on;
	
	    const cancelFade = du.fade.out(getPopupElems().cnt, 10, instance.close);
	    getPopupElems().cnt.addEventListener('mouseover', cancelFade);
	
	
	    this.container = () => getPopupElems().cnt;
	    this.lockSize = () => Resizer.lock(popupCnt);
	    this.unlockSize = () => Resizer.unlock(popupCnt);
	
	    if (props.resize !== false){
	      Resizer.all(popupCnt, props.position);
	    }
	    const backdrop = new CatchAll(popupCnt);
	    backdrop.on('click', backdropClick);
	    backdrop.on('mousemove', mouseMove);
	
	    Resizer.position(popupCnt);
	  }
	}
	
	DragDropResize.events = {};
	DragDropResize.container = du.create.element('div', {id: 'drag-drop-resize'});
	document.body.append(DragDropResize.container);
	DragDropResize.events.drag = new CustomEvent ('drag');
	DragDropResize.events.dragend = new CustomEvent ('dragend');
	DragDropResize.events.dragstart = new CustomEvent ('dragstart');
	DragDropResize.events.drop = new CustomEvent ('drop');
	DragDropResize.events.tabbed = new CustomEvent ('tabbed');
	
	// drag	An element or text selection is being dragged (fired continuously every 350ms).
	// dragend	A drag operation is being ended (by releasing a mouse button or hitting the escape key).
	// dragstart	The user starts dragging an element or text selection.
	// drop	An element is dropped on a valid drop target.
	
	module.exports = DragDropResize;
	
});


RequireJS.addFunction('../../public/js/utils/display/pop-up.js',
function (require, exports, module) {
	const DragDropResize = require('./drag-drop');
	
	class PopUp {
	  constructor (props) {
	    props = props || {}
	    const instance = this;
	    const htmlFuncs = {};
	    let forceOpen = false;
	    let lockOpen = false;
	    let currFuncs, currElem;
	    let canClose = false;
	
	    const popupCnt = new DragDropResize(props);
	
	    popupCnt.hide();
	
	    this.position = () => popupCnt;
	    this.positionOnElement = popupCnt.position;
	
	
	    this.softClose = () => {
	      if (!lockOpen) {
	        instance.close();
	      }
	    }
	
	    this.close = popupCnt.close;
	
	    this.show = () => {
	      popupCnt.show();
	    };
	
	    function getFunctions(elem) {
	      let foundFuncs;
	      const queryStrs = Object.keys(htmlFuncs);
	      queryStrs.forEach((queryStr) => {
	        if (elem.matches(queryStr)) {
	          if (foundFuncs) {
	            throw new Error('Multiple functions being invoked on one hover event');
	          } else {
	            foundFuncs = htmlFuncs[queryStr];
	          }
	        }
	      });
	      return foundFuncs;
	    }
	
	    function on(queryStr, funcObj) {
	      if (htmlFuncs[queryStr] !== undefined) throw new Error('Assigning multiple functions to the same selector');
	      htmlFuncs[queryStr] = funcObj;
	    }
	    this.on = on;
	
	    this.onClose = popupCnt.onClose;
	
	    function updateContent(html) {
	      popupCnt.updateContent(html);
	      if (currFuncs && currFuncs.after) currFuncs.after();
	      return instance;
	    }
	    this.updateContent = updateContent;
	
	    this.open = (html, positionOn) => {
	      this.updateContent(html);
	      popupCnt.position(positionOn);
	      this.show();
	    }
	
	    this.container = popupCnt.container;
	    this.hasMoved = popupCnt.hasMoved;
	    this.lockSize = popupCnt.lockSize;
	    this.unlockSize = popupCnt.unlockSize;
	
	    document.addEventListener('click', this.forceClose);
	  }
	}
	
	module.exports = PopUp;
	
});


RequireJS.addFunction('../../public/js/utils/lists/expandable.js',
function (require, exports, module) {
	

	
	const CustomEvent = require('../custom-event.js');
	const du = require('../dom-utils.js');
	const $t = require('../$t.js');
	
	// properties
	//  required: {
	//  getHeader: function returns html header string,
	//  getBody: function returns html body string,
	//}
	//  optional: {
	//  list: list to use, creates on undefined
	//  getObject: function returns new list object default is generic js object,
	//  parentSelector: cssSelector only reqired for refresh function,
	//  listElemLable: nameOfElementType changes add button label,
	//  dontOpenOnAdd: by default the active element will be switched to newly added elements.
	//  hideAddBtn: defaults to false,
	//  startClosed: all tabs are closed on list open.
	//  input: true - require user to enter text before adding new
	//  inputOptions: array of autofill inputs
	//  inputs: [{placeholder, autofill},...]
	//  inputValidation: function to validate input fields
	//  type: defaults to list,
	//  selfCloseTab: defalts to true - allows clicking on header to close body,
	//  findElement: used to find elemenents related to header - defaults to closest
	//}
	class Expandable {
	  constructor(props) {
	    const afterRenderEvent = new CustomEvent('afterRender');
	    const afterAddEvent = new CustomEvent('afterAdd');
	    const afterRefreshEvent = new CustomEvent('afterRefresh');
	    const afterRemovalEvent = new CustomEvent('afterRemoval');
	    const instance = this;
	    const renderBodyOnOpen = props.renderBodyOnOpen === false ? false : true;
	    props.getObject = props.getObject || (() => ({}));
	    props.ERROR_CNT_ID = `expandable-error-msg-cnt-${props.id}`;
	    props.inputTreeId = `expandable-input-tree-cnt-${props.id}`;
	    props.type = props.type || 'list';
	    props.findElement = props.findElement || ((selector, target) =>  du.find.closest(selector, target));
	    props.selfCloseTab = props.selfCloseTab === undefined ? true : props.selfCloseTab;
	    props.getObject = props.getObject || (() => {});
	    props.inputs = props.inputs || [];
	    props.list = props.list || [];
	    // props.list.DO_NOT_CLONE = true;
	    this.hasBody = () => (typeof this.getBody) === 'function';
	    this.getHeader = props.getHeader; delete props.getHeader;
	    this.getBody = props.getBody; delete props.getBody;
	    props.id = Expandable.lists.length;
	    props.activeKey = 0; //TODO ???
	    Object.getSet(this, props, 'listElemLable');
	    let pendingRefresh = false;
	    let lastRefresh = new Date().getTime();
	    const storage = {};
	    Expandable.lists[props.id] = this;
	    this.inputTree = () => props.inputTree;
	
	    this.errorCntId = () => props.ERROR_CNT_ID;
	    function setErrorMsg(msg) {
	        du.id(props.ERROR_CNT_ID).innerHTML = msg;
	    }
	
	    function values() {
	      const values = {};
	      props.inputs.forEach((input) =>
	        values[input.placeholder] = du.id(input.id).value);
	      return values;
	    }
	
	    function getCnt() {
	      return document.querySelector(`.expandable-list[ex-list-id='${props.id}']`);
	    }
	
	    function getBodyCnt() {
	      return du.find.down('.expand-body', getCnt());
	    }
	
	    function getInputCnt() {
	      const cnt = du.find.down('.expand-input-cnt', getCnt());
	      return cnt;
	    }
	    //changes....
	    this.values = values;
	    this.getInputCnt = getInputCnt;
	
	    this.add = (vals) => {
	      const inputValues = vals || values();
	      if ((typeof props.inputValidation) !== 'function' ||
	              props.inputValidation(inputValues) === true) {
	          const obj = props.getObject(inputValues, getInputCnt());
	          const key = this.getKey(vals, obj);
	          props.list[key] = obj;
	          if (!props.dontOpenOnAdd) this.activeKey(key);
	          this.refresh();
	          afterAddEvent.trigger();
	      } else {
	        const errors = props.inputValidation(inputValues);
	        let errorStr;
	        if ((typeof errors) === 'object') {
	          const keys = Object.keys(errors);
	          errorStr = Object.values(errors).join('<br>');
	        } else {
	          errorStr = `Error: ${errors}`;
	        }
	        setErrorMsg(errorStr);
	      }
	    };
	    this.hasInputTree = () =>
	      this.inputTree() && this.inputTree().constructor.name === 'LogicWrapper';
	    if (this.hasInputTree())
	      props.inputTree.onSubmit(this.add);
	    props.hasInputTree = this.hasInputTree;
	
	    this.isSelfClosing = () => props.selfCloseTab;
	    this.remove = (removed) => {
	      afterRemovalEvent.trigger(undefined, removed);
	      this.refresh();
	    }
	    this.html = () =>
	      Expandable[`${instance.type().toCamel()}Template`].render(this);
	    this.afterRender = (func) => afterRenderEvent.on(func);
	    this.afterAdd = (func) => afterAddEvent.on(func);
	    this.afterRemoval = (func) => afterRemovalEvent.on(func);
	    this.refresh = (type) => {
	      this.type((typeof type) === 'string' ? type : props.type);
	      if (!pendingRefresh) {
	        pendingRefresh = true;
	        setTimeout(() => {
	          props.inputs.forEach((input) => input.id = input.id || String.random(7));
	          const parent = document.querySelector(props.parentSelector);
	          const html = this.html();
	          if (parent && html !== undefined) {
	            parent.innerHTML = html;
	            afterRefreshEvent.trigger();
	          }
	          pendingRefresh = false;
	        }, 100);
	      }
	    };
	    this.activeKey = (value) => value === undefined ? props.activeKey : (props.activeKey = value);
	    this.getKey = () => this.list().length;
	    this.active = () => props.list[this.activeKey()];
	    // TODO: figure out why i wrote this and if its neccisary.
	    this.value = (key) => (key2, value) => {
	      if (props.activeKey === undefined) props.activeKey = 0;
	      if (key === undefined) key = props.activeKey;
	      if (storage[key] === undefined) storage[key] = {};
	      if (value === undefined) return storage[key][key2];
	      storage[key][key2] = value;
	    }
	    this.inputHtml = () => this.hasInputTree() ?
	          this.inputTree().payload().html() : Expandable.inputRepeatTemplate.render(this);
	    this.set = (key, value) => props.list[key] = value;
	    this.get = (key) => props.list[key];
	    this.renderBody = (target) => {
	      const headerSelector = `.expand-header[ex-list-id='${props.id}'][key='${this.activeKey()}']`;
	      target = target || document.querySelector(headerSelector);
	      if (target !== null) {
	        const id = target.getAttribute('ex-list-id');
	        const list = Expandable.lists[id];
	        const headers = du.find.up('.expandable-list', target).querySelectorAll('.expand-header');
	        const bodys = du.find.up('.expandable-list', target).querySelectorAll('.expand-body');
	        const rmBtns = du.find.up('.expandable-list', target).querySelectorAll('.expandable-item-rm-btn');
	        headers.forEach((header) => header.className = header.className.replace(/(^| )active( |$)/g, ''));
	        bodys.forEach((body) => body.style.display = 'none');
	        rmBtns.forEach((rmBtn) => rmBtn.style.display = 'none');
	        const body = bodys.length === 1 ? bodys[0] : du.find.closest('.expand-body', target);
	        if (this.hasBody()) {
	          body.style.display = 'block';
	        }
	        const key = target.getAttribute('key');
	        this.activeKey(key);
	        if (renderBodyOnOpen) body.innerHTML = this.htmlBody(key);
	        target.parentElement.querySelector('.expandable-item-rm-btn').style.display = 'block';
	        target.className += ' active' + (this.hasBody() ? '' : ' no-body');
	        afterRenderEvent.trigger();
	        // du.scroll.intoView(target.parentElement, 3, 25, document.body);
	      }
	    };
	    afterRefreshEvent.on(() => {if (!props.startClosed)this.renderBody()});
	
	    this.htmlBody = (key) => {
	      getBodyCnt().setAttribute('key', key);
	      return this.hasBody() ? this.getBody(this.list()[key], key) : '';
	    }
	    this.list = () => props.list;
	    this.refresh();
	  }
	}
	Expandable.lists = [];
	Expandable.DO_NOT_CLONE = true;
	Expandable.inputRepeatTemplate = new $t('expandable/input-repeat');
	Expandable.listTemplate = new $t('expandable/list');
	Expandable.pillTemplate = new $t('expandable/pill');
	Expandable.sidebarTemplate = new $t('expandable/sidebar');
	Expandable.topAddListTemplate = new $t('expandable/top-add-list');
	Expandable.getIdAndKey = (target, level) => {
	  level ||= 0;
	  const elems = du.find.upAll('.expand-header,.expand-body', target);
	  if (elems.length < level + 1) return undefined;
	  const cnt = elems[level];
	  const id = Number.parseInt(cnt.getAttribute('ex-list-id'));
	  const key = cnt.getAttribute('key');
	  return {id, key};
	}
	Expandable.getValueFunc = (target) => {
	  const idKey = Expandable.getIdAndKey(target);
	  return Expandable.lists[idKey.id].value(idKey.key);
	}
	
	Expandable.get = (target, level) => {
	  const idKey = Expandable.getIdAndKey(target, level);
	  if (idKey === undefined) return undefined;
	  return Expandable.lists[idKey.id].get(idKey.key);
	}
	
	Expandable.list = (target) => {
	  const idKey = Expandable.getIdAndKey(target);
	  return Expandable.lists[idKey.id];
	}
	
	Expandable.set = (target, value) => {
	  const idKey = Expandable.getIdAndKey(target);
	  Expandable.lists[idKey.id].set(idKey.key, value);
	}
	
	Expandable.value = (key, value, target) => {
	  return Expandable.getValueFunc(target)(key, value);
	}
	du.on.match('click', '.expandable-list-add-btn', (target) => {
	  const id = target.getAttribute('ex-list-id');
	  Expandable.lists[id].add();
	});
	du.on.match('click', '.expandable-item-rm-btn', (target) => {
	  const id = target.getAttribute('ex-list-id');
	  const key = target.getAttribute('key');
	  Expandable.lists[id].remove(key);
	});
	Expandable.closeAll = (header) => {
	  const hello = 'world';
	}
	
	du.on.match('click', '.expand-header', (target, event) => {
	  const isActive = target.matches('.active');
	  const id = target.getAttribute('ex-list-id');
	  const list = Expandable.lists[id];
	  if (list) {
	    if (isActive && !event.target.tagName.match(/INPUT|SELECT/)) {
	      du.class.remove(target, 'active');
	      du.find.closest('.expand-body', target).style.display = 'none';
	      list.activeKey(null);
	      target.parentElement.querySelector('.expandable-item-rm-btn').style.display = 'none';
	    } else if (!isActive) {
	      list.renderBody(target);
	    }
	  }
	});
	
	function getExpandObject(elem) {
	  const exListElem = du.find.up('[ex-list-id]', elem);
	  if (!exListElem) return undefined;
	  const listId = exListElem.getAttribute('ex-list-id');
	  return Expandable.lists[listId];
	}
	
	du.on.match('click', '.input-open-cnt', (target) => {
	  const inputCnts = document.querySelectorAll('.expand-input-cnt');
	  const expandList = getExpandObject(target);
	  if (expandList && !expandList.hasInputTree()) expandList.add();
	  else {
	    const inputOpenCnts = document.querySelectorAll('.input-open-cnt');
	    const closest = du.find.closest('.expand-input-cnt', target);
	    inputCnts.forEach((elem) => elem.hidden = true);
	    inputOpenCnts.forEach((elem) => elem.hidden = false);
	    target.hidden = true;
	    if (closest) closest.hidden = false;
	  }
	});
	
	module.exports = Expandable
	
});


RequireJS.addFunction('../../public/js/utils/input/decision/decision.js',
function (require, exports, module) {
	

	
	
	
	const DecisionTree = require('../../decision-tree.js');
	const LogicTree = require('../../logic-tree.js');
	const LogicWrapper = LogicTree.LogicWrapper
	const Input = require('../input.js');
	const du = require('../../dom-utils');
	const $t = require('../../$t');
	
	const ROOT_CLASS = 'decision-input-tree';
	
	function isComplete(wrapper) {
	  return wrapper.isComplete() && DecisionInputTree.validate(wrapper)
	}
	
	class ValueCondition {
	  constructor(name, accepted, payload) {
	    Object.getSet(this, {name, accepted});
	    this.payload = payload;
	    this.condition = (wrapper) => {
	        let value;
	        wrapper.root().node.forEach((node) => {
	          node.payload().inputArray.forEach((input) => {
	            if (input.name() === name) value = input.value();
	          });
	        });
	        if (Array.isArray(accepted)) {
	          for (let index = 0; index < accepted.length; index +=1) {
	            if (value === accepted[index]) return true;
	          }
	          return false;
	        }
	        return value === accepted;
	    }
	  }
	}
	
	class DecisionInput {
	  constructor(name, inputArrayOinstance, tree, isRoot) {
	    Object.getSet(this, 'name', 'id', 'childCntId', 'inputArray', 'class', 'condition');
	    this.clone = () => this;
	
	    this.tree = () => tree;
	    if (inputArrayOinstance instanceof ValueCondition) {
	      this.condition = inputArrayOinstance.condition;
	      this.isConditional = true;
	      inputArrayOinstance = inputArrayOinstance.payload;
	    }
	    if (inputArrayOinstance !== undefined){
	      this.name = name;
	      this.id = `decision-input-node-${String.random()}`;
	      this.childCntId = `decision-child-ctn-${String.random()}`
	      this.values = tree.values;
	      this.onComplete = tree.onComplete;
	      this.onChange = tree.onChange;
	      this.inputArray = DecisionInputTree.validateInput(inputArrayOinstance, this.values);
	      this.class =  ROOT_CLASS;
	      this.getValue = (index) => this.inputArray[index].value();
	      this.validate = () => DecisionInputTree.validateInput(inputArrayOinstance, this.values);
	    }
	
	    const getWrapper = (wrapperOid) => wrapperOid instanceof LogicWrapper ?
	        wrapperOid : (LogicWrapper.get(wrapperId) || this.root());
	
	    this.branch = (wrapperId, inputs) =>
	            get(wrapperId).branch(String.random(), new DecisionInput(name));
	    this.conditional = (wrapperId, inputs, name, selector) =>
	            get(wrapperId).conditional(String.random(), new DecisionInput(name, relation, formula));
	
	    this.update = tree.update;
	    this.addValues = (values) => {
	      this.inputArray.forEach((input) => values[input.name()] = input.value())
	    }
	
	    this.reachable = () => {
	      const nodeId = this._nodeId;
	      const wrapper = LogicWrapper.get(nodeId);
	      return wrapper.reachable();
	    }
	    this.isValid = () => {
	      let valid = true;
	      this.inputArray.forEach((input) =>
	            valid = valid && input.valid());
	      return valid;
	    }
	    this.isRoot = () => isRoot;
	
	    this.html = (parentCalling) => {
	      if (this.isRoot() && parentCalling !== true) return tree.html();
	      return DecisionInput.template.render(this);
	    }
	    this.treeHtml = (wrapper) => tree.html(wrapper);
	  }
	}
	DecisionInput.template = new $t('input/decision/decision');
	
	
	// properties
	// optional :
	// noSubmission: /[0-9]{1,}/ delay that determins how often a submission will be processed
	// buttonText: determins the text displayed on submit button;
	
	class DecisionInputTree extends LogicTree {
	  constructor(onComplete, props) {
	    const decisionInputs = [];
	    props = props || {};
	    const tree = {};
	
	    tree.buttonText = () => {
	      return props.buttonText || `Create ${root.node.name}`;
	    }
	
	    let disabled;
	    tree.disableButton = (d, elem) => {
	      disabled = d === null || d === true || d === false ? d : disabled;
	      if (elem) {
	        const button = du.find.closest(`button`, elem);
	        if (button) {
	          button.disabled = disabled === null ? !isComplete(root) : disabled;
	        }
	      }
	    }
	
	    function superArgument(onComplete) {
	      const formatPayload = (name, payload) => {
	        decisionInputs.push(new DecisionInput(name, payload, tree, decisionInputs.length === 0));
	        return decisionInputs[decisionInputs.length - 1];
	      }
	      if (onComplete && onComplete._TYPE === 'DecisionInputTree') {
	        onComplete.formatPayload = formatPayload;
	        return onComplete;
	      }
	      return formatPayload;
	    }
	
	    super(superArgument(onComplete));
	    const root = this;
	
	    const onCompletion = [];
	    const onChange = [];
	    const onSubmit = [];
	    tree.html = (wrapper) => {
	      wrapper = wrapper || root;
	      let inputHtml = '';
	      wrapper.forAll((wrapper) => {
	        inputHtml += wrapper.payload().html(true);
	      });
	      const scope = {wrapper, inputHtml, DecisionInputTree, tree};
	      if (wrapper === root) {
	        return DecisionInputTree.template.render(scope);
	      }
	      return inputHtml;
	    };
	
	
	    this.onComplete = (func) => {
	      if ((typeof func) === 'function') onCompletion.push(func);
	    }
	    this.onChange = (func) => {
	      if ((typeof func) === 'function') onChange.push(func);
	    }
	    this.onSubmit = (func) => {
	      if ((typeof func) === 'function') onSubmit.push(func);
	    }
	
	    this.values = () => {
	      const values = {};
	      root.forEach((wrapper) => {
	        wrapper.payload().addValues(values);
	      });
	      return values;
	    }
	    tree.values = root.values;
	    tree.hideButton = props.noSubmission;
	
	    let completionPending = false;
	    this.completed = () => {
	      if (!root.isComplete()) return false;
	      const delay = props.noSubmission || 0;
	      if (!completionPending) {
	        completionPending = true;
	        setTimeout(() => {
	          const values = tree.values();
	          onCompletion.forEach((func) => func(values, this))
	          completionPending = false;
	        }, delay);
	      }
	      return true;
	    }
	
	    let submissionPending = false;
	    this.submit = () => {
	      const delay = props.noSubmission || 0;
	      if (!submissionPending) {
	        submissionPending = true;
	        setTimeout(() => {
	          const values = tree.values();
	          if (!root.isComplete()) return false;
	          onSubmit.forEach((func) => func(values, this))
	          submissionPending = false;
	        }, delay);
	      }
	      return true;
	    }
	
	    let changePending = false;
	    this.changed = (elem) => {
	      const delay = props.noSubmission || 0;
	      if (!changePending) {
	        changePending = true;
	        setTimeout(() => {
	          const values = tree.values();
	          onChange.forEach((func) => func(values, this, elem))
	          changePending = false;
	        }, delay);
	      }
	      return true;
	    }
	
	    this.onComplete(onComplete);
	
	    return this;
	  }
	}
	
	DecisionInputTree.ValueCondition = ValueCondition;
	
	DecisionInputTree.class = 'decision-input-tree';
	DecisionInputTree.buttonClass = 'decision-input-tree-submit';
	
	DecisionInputTree.validate = (wrapper) => {
	  let valid = true;
	  wrapper.forEach((wrapper) => {
	    valid = valid && wrapper.payload().isValid();
	  });
	  return valid;
	}
	
	DecisionInputTree.update = (soft) =>
	  (elem) => {
	    const cnt = du.find.closest('[node-id]', elem);
	    const parent = cnt.parentElement;
	    const nodeId = cnt.getAttribute('node-id');
	    const wrapper = LogicWrapper.get(nodeId);
	    console.log(isComplete(wrapper));
	    if(!soft) {
	      du.find.downAll('.decision-input-cnt', parent).forEach((e) => e.hidden = true)
	      wrapper.forEach((n) => {
	        let selector = `[node-id='${n.nodeId()}']`;
	        elem = du.find.down(selector, parent);
	        if (elem) elem.hidden = false;
	      });
	      wrapper.root().changed();
	      wrapper.root().completed()
	    }
	    wrapper.payload().tree().disableButton(undefined, elem);
	  };
	
	DecisionInputTree.submit = (elem) => {
	  const wrapper = LogicWrapper.get(elem.getAttribute('root-id'));
	  wrapper.submit();
	}
	
	du.on.match('keyup', `.${ROOT_CLASS}`, DecisionInputTree.update(true));
	du.on.match('change', `.${ROOT_CLASS}`, DecisionInputTree.update());
	du.on.match('click', `.${DecisionInputTree.buttonClass}`, DecisionInputTree.submit);
	
	
	DecisionInputTree.DO_NOT_CLONE = true;
	DecisionInputTree.validateInput = (inputArrayOinstance, valuesFunc) => {
	  if (Array.isArray(inputArrayOinstance)) {
	    inputArrayOinstance.forEach((instance) => {
	      instance.childCntId = `decision-child-ctn-${String.random()}`
	    });
	    return inputArrayOinstance;
	  }
	  inputArrayOinstance.childCntId = `decision-child-ctn-${String.random()}`
	  return [inputArrayOinstance];
	}
	
	DecisionInputTree.template = new $t('input/decision/decisionTree');
	
	module.exports = DecisionInputTree;
	
});


RequireJS.addFunction('../../public/js/utils/input/styles/measurement.js',
function (require, exports, module) {
	

	
	
	const Input = require('../input');
	const $t = require('../../$t');
	const Measurement = require('../../measurement');
	
	class MeasurementInput extends Input {
	  constructor(props) {
	    let value = new Measurement(props.value, true);
	    props.value = () => value;
	    super(props);
	    props.validation = (val) =>
	        !Number.isNaN(val && val.display ? value : new Measurement(val).value());
	    props.errorMsg = 'Invalid Mathematical Expression';
	    this.value = () => {
	      return value.display();
	    }
	    const parentSetVal = this.setValue;
	    this.setValue = (val) => {
	      let newVal = props.validation(val) ? ((val instanceof Measurement) ?
	                        val : new Measurement(val, true)) : value;
	      const updated = newVal !== value;
	      value = newVal;
	      return updated;
	    }
	  }
	}
	
	MeasurementInput.template = new $t('input/measurement');
	MeasurementInput.html = (instance) => () => MeasurementInput.template.render(instance);
	
	
	module.exports = MeasurementInput;
	
});


RequireJS.addFunction('../../public/js/utils/input/styles/select.js',
function (require, exports, module) {
	

	
	
	
	const Input = require('../input');
	const $t = require('../../$t');
	
	class Select extends Input {
	  constructor(props) {
	    super(props);
	    const isArray = Array.isArray(props.list);
	    let value;
	    if (isArray) {
	      value = props.index && props.list[props.index] ?
	      props.list[props.index] : props.list[0];
	      value = props.list.indexOf(props.value) === -1 ? props.list[0] : props.value;
	    } else {
	      const key = Object.keys(props.list)[0];
	      value = props.value || key;
	    }
	    props.value = undefined;
	    this.setValue(value);
	    this.isArray = () => isArray;
	    const parentHidden = this.hidden;
	    this.hidden = () => props.list.length < 2 || parentHidden();
	
	    this.selected = (value) => value === this.value();
	  }
	}
	
	Select.template = new $t('input/select');
	Select.html = (instance) => () => Select.template.render(instance);
	
	module.exports = Select;
	
});


RequireJS.addFunction('../../public/js/utils/test/tests/decision-tree.js',
function (require, exports, module) {
	

	// branch structure
	//
	// style
	//   solid
	//     isInset:false
	//     material
	//       mdf
	//         cost
	//         profile
	//       soft maple
	//         cost
	//         profile
	//       walnut
	//         cost
	//         profile
	//       alder
	//         cost
	//         profile
	//   panel
	//     isInset:true
	//     profile
	//       shaker
	//         mdfCore
	//           soft maple
	//         nonMdfCore
	//           soft maple
	//           walnut
	//           alder
	//
	// isInset (type===Inset)
	//   magnet
	
	const Test = require('../test.js').Test;
	const DecisionTree = require('../../decision-tree');
	const states = {};
	
	states[5] = {descriptor: 'style'}
	states[6] = {descriptor: 'solid'}
	states[7] = {descriptor: 'isInset=false'}
	states[8] = {descriptor: 'material'}
	states[9] = {descriptor: 'mdf'}
	states[10] = {descriptor: 'cost'}
	states[11] = {descriptor: 'profile'}
	states[12] = {descriptor: 'soft maple'}
	states[13] = {descriptor: 'cost'}
	states[14] = {descriptor: 'profile'}
	states[15] = {descriptor: 'walnut'}
	states[16] = {descriptor: 'cost'}
	states[17] = {descriptor: 'profile'}
	states[18] = {descriptor: 'alder'}
	states[19] = {descriptor: 'cost'}
	states[20] = {descriptor: 'profile'}
	states[21] = {descriptor: 'panel'}
	states[22] = {descriptor: 'isInset=true'}
	states[23] = {descriptor: 'profile'}
	states[24] = {descriptor: 'shaker'}
	states[25] = {descriptor: 'mdfCore'}
	states[26] = {descriptor: 'soft maple'}
	states[27] = {descriptor: 'nonMdfCore'}
	states[28] = {descriptor: 'soft maple'}
	states[29] = {descriptor: 'walnut'}
	states[30] = {descriptor: 'alder'}
	
	states[32] = {descriptor: 'isInset (type===Inset)'}
	states[33] = {descriptor: 'magnet'}
	
	const dNode = new DecisionTree('root', {_UNIQUE_NAME_GROUP: 'tester'});
	const dNode2 = new DecisionTree('root2', {_UNIQUE_NAME_GROUP: 'tester'});
	const dNode3 = new DecisionTree('root3', {_UNIQUE_NAME_GROUP: 'testerr'});
	const statess = dNode.addStates(states);
	const style = dNode.then(5);
	const solid = style.then(6);
	const material = solid.then([7,8])[1];
	const materials = material.then([9,12,15,18]);
	materials[0].then([10,11]);
	materials[1].then([13,14]);
	materials[2].then([16,17]);
	materials[3].then([19,20]);
	
	
	const panel = style.then(21);
	panel.then(22);
	const profile = panel.then(23);
	const shaker = profile.then(24);
	shaker.then(25).then(26);
	const nonMdfCore = shaker.then(27);
	nonMdfCore.then([28,29,30]);
	
	dNode.then(32).then(33);
	const func = (node) => node.payload().descriptor !== 'cost';
	const subtree = style.subtree({'21': '23', '27': /29|30/, '9': func});
	
	
	Test.add('DecisionTree Subtree',(ts) => {
	  const kept = ['5','6','7','8','9','11','12','13','14','15','16','17',
	                '18','19','20','21','23','24','25','26','27','29','30'];
	  const ignored = ['10','22', '28','32','33','root'];
	  const errors = {
	    '10': 'Function condition did not work',
	    '28': 'Regular expression condition did not work',
	    '22': 'String condition did not work.',
	    '32': 'Subtree is including parents',
	    '33': 'Subtree is including parents',
	    'root': 'Subtree is including parents',
	    'default': 'This should not happen I would check the modification history of this test file.'
	  }
	  let nodeCount = 0;
	  subtree.forEach((node) => {
	    const errorMsg = errors[node.name] || errors.default;
	    ts.assertNotEquals(kept.indexOf(node.name), -1, errorMsg);
	    nodeCount++;
	  });
	  ts.assertEquals(nodeCount, 23, 'Subtree does not include all the nodes it should');
	  ts.success();
	});
	
	Test.add('DecisionTree Leaves', (ts) => {
	  const leaves = subtree.leaves();
	  ts.assertEquals(leaves.length, 11, 'Not plucking all the leaves');
	  ts.assertEquals(dNode.leaves().length, 15, 'Not plucking all the leaves');
	  ts.success();
	});
	
});


RequireJS.addFunction('../../public/js/utils/test/tests/logic-tree.js',
function (require, exports, module) {
	

	// breakfast) Branch
	//   food) Multiselect
	//     bacon) Leaf
	//     eggs) Select
	//       2) Select
	//         over easy) Leaf
	//         sunny side up) Leaf
	//         scramble) Leaf
	//         fried) Leaf
	//       3) Select
	//         over easy) Leaf
	//         sunny side up) Leaf
	//         scramble) Leaf
	//         fried) Leaf
	//       6) Select
	//         over easy) Leaf
	//         sunny side up) Leaf
	//         scramble) Leaf
	//         fried) Leaf
	//     toast) Select
	//       white) Leaf
	//       wheat) Leaf
	//       texas) Leaf
	//     cereal) Branch
	//       milk) Leaf
	//       type) Select
	//         raisin brand) Leaf
	//         cheerios) Leaf
	//         life) Leaf
	//   dishes) Branch
	//     plate) Leaf
	//     fork) Leaf
	//     having cereal) Conditional
	//       bowl) Leaf
	//       spoon) Leaf
	
	
	const Test = require('../test.js').Test;
	const LogicTree = require('../../logic-tree');
	
	class ReferenceableFuctions {
	  constructor(id) {
	    id = id._TYPE === undefined ? id : id.id;
	    Object.getSet(this, {id});
	    this.condition = (tree) => {
	      if (id === 1) {
	        return tree.reachable('bacon') || tree.reachable('eggs');
	      } else if (id === 2) {
	        return tree.reachable('cereal');
	      }
	    }
	    this.LOGIC_TYPE = 'Conditional';
	    this.clone = () => new ReferenceableFuctions(id);
	  }
	}
	
	function createTree(connectEggs, optional, shouldCopy, testFuncs) {
	  const tree = new LogicTree(String.random());
	
	  function runTestFunc(name) {
	    if (testFuncs && testFuncs[name]) {
	      testFuncs[name](tree, name);
	    }
	  }
	
	  const branch = tree.branch('breakfast');
	  const food = branch.multiselect('food');
	  food.optional(optional);
	  food.leaf('bacon', {cost: 1});
	  const eggs = food.select('eggs');
	  const two = eggs.select(2, {multiplier: 2});
	  eggs.optional(optional);
	  two.optional(optional);
	  two.leaf('over easy', {cost: 1.8});
	  two.leaf('sunny side up', {cost: 2.6});
	  two.leaf('scramble', {cost: 3.2});
	  two.leaf('fried', {cost: 1.3});
	  runTestFunc('onlyOne');
	  const three = eggs.select(3, {multiplier: 3}).addChildren('2');
	  runTestFunc('now2');
	  const six = eggs.select(6, {multiplier: 6}).addChildren('2');
	  runTestFunc('now3');
	  const toast = food.select('toast');
	  three.optional(optional);
	  six.optional(optional);
	  toast.optional(optional);
	  toast.leaf('white', {cost: 1.01});
	  toast.leaf('wheat', {cost: 1.24});
	  toast.leaf('texas', {cost: 1.17});
	  const cereal = food.branch('cereal');
	  cereal.leaf('milk', {cost: 8.99});
	  const type = cereal.select('type');
	  type.optional(optional);
	  type.leaf('raisin brand', {cost: -0.55});
	  type.leaf('cheerios', {cost: 1.58});
	  type.leaf('life', {cost: 1.23});
	
	  const dishes = branch.branch('dishes');
	  const needPlate = dishes.conditional('need plate', new ReferenceableFuctions(1));
	  needPlate.leaf('plate', {cost: .14});
	  needPlate.leaf('fork', {cost: .07});
	  const havingCereal = dishes.conditional('having cereal', new ReferenceableFuctions(2));
	  havingCereal.leaf('bowl', {cost: .18});
	  havingCereal.leaf('spoon', {cost: .06});
	  runTestFunc('all');
	
	  if (connectEggs) {
	    two.valueSync(three);
	    two.defaultSync(six);
	  }
	  return shouldCopy ? copy(tree) : tree;
	}
	
	function copy(origTree) {
	    const treeJson = origTree.toJson();
	    return Object.fromJson(treeJson);
	}
	
	function testIsComplete(ts) {
	  return (tree, isComplete) => ts.assertTrue(isComplete === tree.isComplete());
	}
	
	function access(index, returnValue, testFuncs, tree) {
	  const func = testFuncs[index];
	  if ((typeof func === 'function')) {
	    func(tree, returnValue);
	  }
	}
	
	function accessProcess(ts, testFuncs, optional, shouldCopy) {
	  let tree = createTree(true, optional, shouldCopy);
	  access('init', tree, testFuncs, tree);
	  access('dontEat2', tree.setChoice('food', null), testFuncs, tree);
	  if (optional)
	    access('dontEat', tree.setChoice('food', {}), testFuncs, tree);
	
	  access('bacon', tree.setChoice('food', {bacon: true}), testFuncs, tree);
	
	  access('toast', tree.setChoice('food', {toast: true}), testFuncs, tree);
	  access('chooseToast', tree.setChoice('toast', 'white'), testFuncs, tree);
	
	  access('chooseCereal', tree.setChoice('type', 'life'), testFuncs, tree);
	  access('cereal', tree.setChoice('food', {cereal: true}), testFuncs, tree);
	
	  access('eggs', tree.setChoice('food', {eggs: true}), testFuncs, tree);
	  access('2', tree.setChoice('eggs', '2'), testFuncs, tree);
	  access('2value', tree.setChoice('2', 'scramble'), testFuncs, tree);
	  if (optional)
	    access('2NoValue', tree.setChoice('2', null), testFuncs, tree);
	  access('2valueAgain', tree.setChoice('2', 'scramble'), testFuncs, tree);
	  access('2default', tree.setDefault('2', 'fried'), testFuncs, tree);
	  access('3', tree.setChoice('eggs', '3'), testFuncs, tree);
	  access('6', tree.setChoice('eggs', '6'), testFuncs, tree);
	
	
	  access('all', tree.setChoice('food', {eggs: true, bacon: true, toast: true, cereal: true}), testFuncs, tree);
	  return tree;
	}
	
	function LogicTest(tree, ts) {
	  const properStructure = "breakfast) Branch\n  food) Multiselect\n    bacon) Leaf\n    eggs) Select\n      2) Select\n        over easy) Leaf\n        sunny side up) Leaf\n        scramble) Leaf\n        fried) Leaf\n      3) Select\n        over easy) Leaf\n        sunny side up) Leaf\n        scramble) Leaf\n        fried) Leaf\n      6) Select\n        over easy) Leaf\n        sunny side up) Leaf\n        scramble) Leaf\n        fried) Leaf\n    toast) Select\n      white) Leaf\n      wheat) Leaf\n      texas) Leaf\n    cereal) Branch\n      milk) Leaf\n      type) Select\n        raisin brand) Leaf\n        cheerios) Leaf\n        life) Leaf\n  dishes) Branch\n    need plate) Conditional\n      plate) Leaf\n      fork) Leaf\n    having cereal) Conditional\n      bowl) Leaf\n      spoon) Leaf\n";
	  ts.assertEquals(tree.structure(), properStructure);
	  ts.success();
	}
	
	function decisionsTest(ts, copy) {
	  function validateDecisions (tree, ...names) {
	    if (tree.decisions().length !== names.length) {
	      console.log('badd!')
	    }
	    const decisions = tree.decisions();
	    ts.assertEquals(decisions.length, names.length);
	    const decisionNames = decisions.map((elem) => elem.name);
	    for (let index = 0; index < names.length; index += 1) {
	      ts.assertNotEquals(decisionNames.indexOf(names[index]) === -1);
	    }
	  }
	
	  const testFuncs = {
	    init: (tree) => validateDecisions(tree, 'food'),
	    dontEat: (tree) => validateDecisions(tree, 'food'),
	
	    bacon: (tree) => validateDecisions(tree, 'food'),
	
	    toast: (tree) => validateDecisions(tree, 'food', 'toast'),
	    chooseToast: (tree) => validateDecisions(tree, 'food', 'toast'),
	
	    chooseCereal: (tree) => validateDecisions(tree, 'food', 'toast'),
	    cereal: (tree) => validateDecisions(tree, 'food', 'having cereal'),
	
	    eggs: (tree) => validateDecisions(tree, 'food', 'eggs'),
	    "2": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "2value": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "2NoValue": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "2valueAgain": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "2default": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "3": (tree) => validateDecisions(tree, 'food', 'eggs', '3'),
	    "6": (tree) => validateDecisions(tree, 'food', 'eggs', '6'),
	
	    all: (tree) => validateDecisions(tree, 'food', 'eggs', '6', 'having cereal', 'toast')
	  }
	  accessProcess(ts, testFuncs, undefined, copy);
	  ts.success();
	}
	
	function optionalTest(ts, shouldCopy) {
	  const tic = testIsComplete(ts);
	  const testFuncs = {
	    init: (tree) => tic(tree, true),
	    dontEat: (tree) =>  tic(tree, true),
	    dontEat2: (tree) =>  tic(tree, true),
	    bacon: (tree) =>  tic(tree, true),
	    toast: (tree) =>  tic(tree, true),
	    chooseToast: (tree) =>  tic(tree, true),
	    chooseCereal: (tree) =>  tic(tree, true),
	    cereal: (tree) =>  tic(tree, true),
	    eggs: (tree) =>  tic(tree, true),
	    "2": (tree) =>  tic(tree, true),
	    "2value": (tree) =>  tic(tree, true),
	    "2NoValue": (tree) =>  tic(tree, true),
	    "2valueAgain": (tree) =>  tic(tree, true),
	    "2default": (tree) =>  tic(tree, true),
	    "3": (tree) =>  tic(tree, true),
	    "6": (tree) =>  tic(tree, true),
	    all: (tree) =>  tic(tree, true),
	  }
	  accessProcess(ts, testFuncs, true, shouldCopy);
	  ts.success();
	}
	
	function notOptionalTest(ts, shouldCopy) {
	  const tic = testIsComplete(ts);
	  const testFuncs = {
	    init: (tree) => tic(tree, false),
	    dontEat: (tree) =>  tic(tree, false),
	    dontEat2: (tree) =>  tic(tree, false),
	    bacon: (tree) =>  tic(tree, true),
	    toast: (tree) =>  tic(tree, false),
	    chooseToast: (tree) =>  tic(tree, true),
	    chooseCereal: (tree) =>  tic(tree, true),
	    cereal: (tree) =>  tic(tree, true),
	    eggs: (tree) =>  tic(tree, false),
	    "2": (tree) =>  tic(tree, false),
	    "2value": (tree) =>  tic(tree, true),
	    "2NoValue": (tree) =>  tic(tree, false),
	    "2valueAgain": (tree) =>  tic(tree, true),
	    "2default": (tree) =>  tic(tree, true),
	    "3": (tree) =>  tic(tree, true),
	    "6": (tree) =>  tic(tree, true),
	    all: (tree) =>  tic(tree, true),
	  }
	  accessProcess(ts, testFuncs, false, shouldCopy);
	  ts.success();
	}
	
	function instanceCountTest(ts, shouldCopy) {
	  const instanceCountCorrect = (tree, countObj, stage) => {
	    Object.keys(countObj).forEach((name) =>
	      ts.assertEquals(countObj[name], tree.node.instanceCount(name),
	          `@stage=${stage} name=${name} incorrect instance count shouldCopy=${shouldCopy}`)
	    );
	  }
	
	  function instanceCountObj(count, obj, two, three, six) {
	    obj['over easy'] = count;
	    obj['sunny side up'] = count;
	    obj['scramble'] = count;
	    obj['fried'] = count;
	    obj['2'] = two;
	    obj['3'] = three;
	    obj['6'] = six;
	    return obj;
	  }
	  const food = 1;
	  const eggs = 1;
	  const two = 1;
	  const three = 1;
	  const six = 1;
	  const toast = 1
	  const white = 1;
	  const wheat = 1;
	  const texas = 1;
	  const milk = 1;
	  const type = 1;
	  const cheerios = 1;
	  const life = 1;
	  const onlyOneObj = instanceCountObj(1, {food, eggs}, 1, 0, 0);
	  const now2Obj = instanceCountObj(2, {food, eggs}, 1, 1, 0);
	  const now3Obj = instanceCountObj(3, {food, eggs}, 1, 1, 1);
	  const allObj = instanceCountObj(3, {food,eggs,toast,white,wheat,texas,milk,type,cheerios,life}, 1, 1, 1);
	  const testFuncs = {
	    onlyOne: (tree, stage) =>  instanceCountCorrect(tree, onlyOneObj, stage),
	    now2: (tree, stage) =>  instanceCountCorrect(tree, now2Obj, stage),
	    now3: (tree, stage) =>  instanceCountCorrect(tree, now3Obj, stage),
	    all: (tree, stage) =>  instanceCountCorrect(tree, allObj, stage),
	  }
	  createTree(undefined, undefined, shouldCopy, testFuncs)
	  ts.success();
	}
	
	function forPathTest(ts, shouldCopy) {
	    function verifyCost(choices, expectedCost) {
	      const tree = createTree(undefined, undefined, shouldCopy);
	      const keys = Object.keys(choices);
	      keys.forEach((key) => tree.setChoice(key, choices[key]));
	      const data = tree.forPath((wrapper, cost) => {
	        cost = cost || 0;
	        const payload = wrapper.payload();
	        if (payload.cost) cost += payload.cost;
	        if (payload.multiplier) cost *= payload.multiplier;
	        return cost;
	      });
	      let total = 0;
	      data.forEach((cost) => total += cost);
	      ts.assertEquals(Math.round(total * 100) / 100, expectedCost);
	    }
	
	    verifyCost({food: {bacon: true}}, 1.21)
	    verifyCost({food: {bacon: false, eggs: false, cereal:true},
	                type: 'life'}, 10.46);
	    verifyCost({food: {bacon: true, eggs: true},
	                eggs: '2', '2': 'fried'}, 2.51)
	    verifyCost({food: {bacon: true, eggs: false, cereal:true},
	                eggs: '2', '2': 'fried', type: 'life'}, 11.67);
	    verifyCost({food: {bacon: true, eggs: true, cereal:true, toast: true},
	                eggs: '6', '6': 'sunny side up', type: 'life', toast: 'wheat'}, 15.51);
	    ts.success();
	}
	
	function forPathReverseTest(ts, shouldCopy) {
	      function verifyCost(choices, expectedCost) {
	        const tree = createTree(true, undefined, shouldCopy);
	        const keys = Object.keys(choices);
	        keys.forEach((key) => tree.setChoice(key, choices[key]));
	        const data = tree.forPath((wrapper, cost) => {
	          cost = cost || 0;
	          const payload = wrapper.payload();
	          if (payload.cost) cost += payload.cost;
	          if (payload.multiplier) cost *= payload.multiplier;
	          return cost;
	        }, true);
	        let total = 0;
	        data.forEach((cost) => total += cost);
	        ts.assertEquals(Math.round(total * 100) / 100, expectedCost);
	      }
	
	      verifyCost({food: {bacon: true}}, 1.21)
	      verifyCost({food: {bacon: false, eggs: false, cereal:true},
	                  type: 'life'}, 10.46);
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '2', '2': 'fried'}, 3.81)
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '3', '2': 'fried'}, 5.11)
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '6', '2': 'fried'}, 1.21)
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '6', '6': 'scramble'}, 20.41)
	      verifyCost({food: {bacon: true, eggs: false, cereal:true},
	                  eggs: '2', '2': 'fried', type: 'life'}, 11.67);
	      verifyCost({food: {bacon: true, eggs: true, cereal:true, toast: true},
	                  eggs: '6', '6': 'sunny side up', type: 'life', toast: 'wheat'}, 28.51);
	      ts.success();
	}
	
	function leavesTest(ts, shouldCopy) {
	      function verifyCost(choices, expectedCost) {
	        const tree = createTree(undefined, undefined, true);
	        const keys = Object.keys(choices);
	        keys.forEach((key) => tree.setChoice(key, choices[key]));
	        let total = 0;
	        tree.leaves().forEach((wrapper) => {
	          const payload = wrapper.payload();
	          if (payload.cost) total += payload.cost;
	        });
	        ts.assertEquals(Math.round(total * 100) / 100, expectedCost);
	      }
	
	      verifyCost({food: {bacon: true}}, 1.21)
	      verifyCost({food: {bacon: false, eggs: false, cereal:true},
	                  type: 'life'}, 10.46);
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '2', '2': 'fried'}, 2.51)
	      verifyCost({food: {bacon: true, eggs: false, cereal:true},
	                  eggs: '2', '2': 'fried', type: 'life'}, 11.67);
	      verifyCost({food: {bacon: true, eggs: true, cereal:true, toast: true},
	                  eggs: '6', '6': 'sunny side up', type: 'life', toast: 'wheat'}, 15.51);
	      ts.success();
	}
	
	function getNodeByPathTest(ts, shouldCopy) {
	  const tree = createTree(undefined, undefined, shouldCopy)
	
	  const fried2 = tree.root().node.next('food').next('eggs').next('2').next('fried');
	  const fried3 = tree.root().node.next('food').next('eggs').next('3').next('fried');
	  const fried6 = tree.root().node.next('food').next('eggs').next('6').next('fried');
	
	  const friedBy2 = tree.node.getNodeByPath('food', 'eggs', '2', 'fried');
	  const friedBy3 = tree.node.getNodeByPath('food', 'eggs', '3', 'fried');
	  const friedBy6 = tree.node.getNodeByPath('food', 'eggs', '6', 'fried');
	
	  ts.assertEquals(fried2, friedBy2);
	  ts.assertEquals(fried3, friedBy3);
	  ts.assertEquals(fried6, friedBy6);
	
	  ts.assertNotEquals(fried2, friedBy3);
	  ts.assertNotEquals(fried2, friedBy6);
	  ts.assertNotEquals(fried3, friedBy2);
	  ts.assertNotEquals(fried3, friedBy6);
	  ts.assertNotEquals(fried6, friedBy2);
	  ts.assertNotEquals(fried6, friedBy3);
	
	  ts.success();
	}
	
	function removeTest(ts, shouldCopy) {
	    const tree = createTree(null, null, shouldCopy);
	    function checkNodeCounts(tree, nodeCounts) {
	      Object.keys(nodeCounts).forEach((key) =>
	          ts.assertEquals(nodeCounts[key], tree.node.instanceCount(key),
	            `RemoveTest Failed: incorrect instance count for ${key}`));
	    }
	    function nodeCounts(overwrites, eggTypeCount, nuke) {
	      overwrites = overwrites || {};
	      function overVal(id, def) {
	        return overwrites[id] !== undefined ? overwrites[id] :
	                                (nuke !== undefined ? nuke : def);
	      }
	      return {
	        food: overVal("food", 1),
	        eggs: overVal("eggs", 1),
	        '2': overVal("2", 1),
	        '3': overVal("3", 1),
	        '6': overVal("6", 1),
	        toast: overVal("toast", 1),
	        white: overVal("white", 1),
	        wheat: overVal("wheat", 1),
	        texas: overVal("texas", 1),
	        milk: overVal("milk", 1),
	        type: overVal("type", 1),
	        cheerios: overVal("cheerios", 1),
	        life: overVal("life", 1),
	
	        scramble: overVal("scramble", eggTypeCount || 3),
	        fried: overVal("fried", eggTypeCount || 3),
	        "sunny side up": overVal("sunny side up", eggTypeCount || 3),
	        "over easy": overVal("over easy", eggTypeCount || 3)
	      }
	    }
	
	    try {
	      tree.node.addState('food', {hello: 'world'});
	      ts.fail();
	    } catch (e) {}
	
	    checkNodeCounts(tree, nodeCounts());
	    tree.node.getNodeByPath('food', 'eggs', '3', 'fried').remove();
	    checkNodeCounts(tree, nodeCounts({fried: 2}));
	    tree.node.getNodeByPath('food', 'eggs', '3').remove();
	    checkNodeCounts(tree, nodeCounts({'3': 0}, 2))
	    tree.node.getNodeByPath('food', 'eggs', '2').remove();
	    checkNodeCounts(tree, nodeCounts({'3': 0, '2': 0}, 1))
	    tree.node.getNodeByPath('food').remove();
	    checkNodeCounts(tree, nodeCounts(undefined, undefined, 0));
	    ts.assertEquals(tree.node.instanceCount('dishes'), 1);
	
	    const msg = 'hello world';
	    const payload = {msg};
	    tree.node.addState('food', payload);
	    tree.node.then('food');
	    const food = tree.node.getNodeByPath('food');
	    ts.assertEquals(Object.keys(food.payload()).length, 2);
	    ts.assertEquals(food.payload().msg, msg);
	
	    ts.success();
	}
	
	function attachTreeTest(ts) {
	  const orderTree = createTree();
	  const origLeaves = orderTree.node.leaves();
	  let leaveCount = origLeaves.length;
	  const drinkTree = new LogicTree(String.random());
	
	  const type = drinkTree.select('drink type');
	  type.select('alcholic').leaf('beer');
	  type.select('non alcholic').leaf('soda');
	  orderTree.attachTree(drinkTree);
	  let newLeaves = orderTree.node.leaves();
	  ts.assertEquals(leaveCount + 2, newLeaves.length)
	  leaveCount = newLeaves.length;
	
	  const eggs = orderTree.getByPath('food', 'eggs');
	  const nonAlcholic = orderTree.getByPath('drink type', 'non alcholic');
	  nonAlcholic.attachTree(eggs);
	  newLeaves = orderTree.node.leaves();
	  ts.assertEquals(leaveCount + 12, newLeaves.length)
	  leaveCount = newLeaves.length;
	
	  const milk = orderTree.getByPath('food', 'cereal', 'milk');
	  nonAlcholic.attachTree(milk);
	  newLeaves = orderTree.node.leaves();
	  ts.assertEquals(leaveCount + 1, newLeaves.length)
	
	  milk.attachTree(nonAlcholic);
	
	  ts.success();
	}
	
	Test.add('LogicTree structure', (ts) => {
	  LogicTest(createTree(), ts);
	});
	Test.add('LogicTree structure (copy)', (ts) => {
	  LogicTest(createTree(undefined, undefined, true), ts);
	});
	
	Test.add('LogicTree getNodeByPath', (ts) => {
	  getNodeByPathTest(ts);
	});
	Test.add('LogicTree getNodeByPath (copy)', (ts) => {
	  getNodeByPathTest(ts, true);
	});
	
	Test.add('LogicTree remove', (ts) => {
	  removeTest(ts);
	});
	Test.add('LogicTree remove (copy)', (ts) => {
	  removeTest(ts, true);
	});
	
	Test.add('LogicTree decisions', (ts) => {
	  decisionsTest(ts);
	});
	Test.add('LogicTree decisions (copy)', (ts) => {
	  decisionsTest(ts, true);
	});
	
	Test.add('LogicTree isComplete (optional)', (ts) => {
	  optionalTest(ts);
	});
	Test.add('LogicTree isComplete (optional & copy)', (ts) => {
	  optionalTest(ts,true);
	});
	
	Test.add('LogicTree isComplete (!optional)', (ts) => {
	  notOptionalTest(ts);
	});
	Test.add('LogicTree isComplete (!optional & copy)', (ts) => {
	  notOptionalTest(ts, true);
	});
	
	Test.add('LogicTree forPath (forward)', (ts) => {
	  forPathTest(ts);
	});
	Test.add('LogicTree forPath (forward & copy)', (ts) => {
	  forPathTest(ts, true);
	});
	
	Test.add('LogicTree forPath (reverse)', (ts) => {
	  forPathReverseTest(ts);
	});
	Test.add('LogicTree forPath (reverse & copy)', (ts) => {
	  forPathReverseTest(ts, true);
	});
	
	Test.add('LogicTree leaves', (ts) => {
	  leavesTest(ts);
	});
	Test.add('LogicTree leaves (copy)', (ts) => {
	  leavesTest(ts, true);
	});
	
	Test.add('LogicTree instanceCount', (ts) => {
	  instanceCountTest(ts);
	});
	Test.add('LogicTree instanceCount (copy)', (ts) => {
	  instanceCountTest(ts, true);
	});
	
	Test.add('LogicTree attachTree', (ts) => {
	  attachTreeTest(ts);
	});
	Test.add('LogicTree attachTree (copy)', (ts) => {
	  attachTreeTest(ts, true);
	});
	
	Test.add('LogicTree change', (ts) => {
	  let tree = createTree();
	  const food = tree.getByPath('food');
	  const needPlate = tree.getByPath('dishes', 'need plate');
	  food.node.change('needPlate');
	  ts.success();
	});
	
	
	// Test.add('LogicTree ', (ts) => {
	//   function validateDecisions (tree, ...names) {
	//     const decisions = tree.decisions();
	//     ts.assertEquals(decisions.length, names.length);
	//     const decisionNames = decisions.map((elem) => elem.name);
	//     for (let index = 0; index < names.length; index += 1) {
	//       ts.assertNotEquals(decisionNames.indexOf(names[index]) === -1);
	//     }
	//   }
	//
	//   const testFuncs = {
	//     init: (tree) => ,
	//     dontEat: (tree) => ,
	//
	//     bacon: (tree) => ,
	//
	//     toast: (tree) => ,
	//     chooseToast: (tree) => ,
	//
	//     chooseCereal: (tree) => ,
	//     cereal: (tree) => ,
	//
	//     eggs: (tree) => ,
	//     "2": (tree) => ,
	//     "2value": (tree) => ,
	//     "2NoValue": (tree) => ,
	//     "2valueAgain": (tree) => ,
	//     "2default": (tree) => ,
	//     "6": (tree) => ,
	//
	//     all: (tree) =>
	//   }
	//   accessProcess(ts, testFuncs);
	//   ts.success();
	// });
	
});


RequireJS.addFunction('../../public/js/utils/input/styles/select/relation.js',
function (require, exports, module) {
	

	
	const StringMathEvaluator = require('../../../string-math-evaluator.js');
	const Select = require('../select.js');
	
	class RelationInput {
	  constructor(name, searchFunc) {
	    if (RelationInput.relationsObjs[name] !== undefined) throw new Error('Relation Inputs must have a unique name.');
	    this.eval = function(list, value) {
	      let minDiff = Number.MAX_SAFE_INTEGER;
	      let winner;
	
	      if (!Array.isArray(list)) return undefined;
	      for(let index = 0; index < list.length; index += 1) {
	        const evalVal = this.constructor.evaluator.eval(list[index]);
	        const diff =  searchFunc(value, evalVal);
	        if (diff >= 0 && diff < minDiff) {
	          minDiff = diff;
	          winner = index;
	        }
	      }
	      return winner;
	    };
	    RelationInput.relationsObjs[RelationInput.toPascalCase(name)] = this;
	    RelationInput.relations.push(name);
	    RelationInput.relations
	        .sort((a, b) => a.length > b.length ? 1 : -1);
	  }
	}
	
	RelationInput.relationsObjs = {};
	RelationInput.relations = [];
	RelationInput.toPascalCase = (str) => new String(str).replace(/ /g, '_').toUpperCase();
	
	RelationInput.evaluator = new StringMathEvaluator(Math);
	RelationInput.eval = (name, list, value) => {
	  const relation = RelationInput.relationsObjs[RelationInput.toPascalCase(name)];
	  return relation ? relation.eval(list, value) : undefined;
	}
	
	new RelationInput('Equal', (a, b) => a !== b ? -1 : 0);
	new RelationInput('Greater Than', (a, b) => a >= b ? -1 : b - a);
	new RelationInput('Greater Than Or Equal', (a, b) => a > b ? -1 : b - a);
	new RelationInput('Less Than', (a, b) => a <= b ? -1 : a - b);
	new RelationInput('Less Than Or Equal', (a, b) => a < b ? -1 : a - b);
	
	RelationInput.selector = new Select({name: 'relation',
	                            value: 'Equal',
	                            list: RelationInput.relations,
	                            label: 'Auto Select Relation'});
	
	module.exports = RelationInput;
	
	
	
	
	
});


RequireJS.addFunction('./generated/html-templates.js',
function (require, exports, module) {
	
exports['101748844'] = (get, $t) => 
			`<span class='pad ` +
			$t.clean(get("class")) +
			`' index='` +
			$t.clean(get("$index")) +
			`'> ` +
			$t.clean(get("input").html()) +
			` </span>`
	
	exports['115117775'] = (get, $t) => 
			`<div ` +
			$t.clean(get("hideAll")(get("properties")) ? 'hidden' : '') +
			`> <div class="property-container close" radio-id='666'> <div class='` +
			$t.clean(get("key") ? "expand-header" : "") +
			`'> ` +
			$t.clean(get("key")) +
			` </div> <div id='config-expand-list-` +
			$t.clean(get("childIdMap")[get("key")]) +
			`' hidden> ` +
			$t.clean(get("childIdMap")[get("key")]) +
			` </div> </div> </div>`
	
	exports['443122713'] = (get, $t) => 
			`<option value='` +
			$t.clean(get("section").prototype.constructor.name) +
			`' ` +
			$t.clean(get("opening").constructorId === get("section").name ? 'selected' : '') +
			`> ` +
			$t.clean(get("clean")(get("section").name)) +
			` </option>`
	
	exports['550500469'] = (get, $t) => 
			`<span > <input list='auto-fill-list-` +
			$t.clean(get("input").id() +
			get("willFailCheckClassnameConstruction")()) +
			` expand-list-` +
			$t.clean(get("type")()) +
			`-input' id='` +
			$t.clean(get("input").id()) +
			`' placeholder='` +
			$t.clean(get("input").placeholder) +
			`' type='text'> <datalist id="auto-fill-list-` +
			$t.clean(get("input").id()) +
			`"> ` +
			$t.clean( new $t('-1921787246').render(get("input").autofill(), 'option', get)) +
			` </datalist> </span>`
	
	exports['609725186'] = (get, $t) => 
			`<span > <label>` +
			$t.clean(get("i")) +
			`</label> <input type="radio" name="index-` +
			$t.clean(get("obj").id) +
			`" value="` +
			$t.clean(get("i")) +
			`" ` +
			$t.clean(get("state").index === get("i") ? 'checked' : '') +
			`> </span>`
	
	exports['714657883'] = (get, $t) => 
			`<div >` +
			$t.clean(get("groupHtml")(get("group"))) +
			`</div>`
	
	exports['987967094'] = (get, $t) => 
			`<span > <label>` +
			$t.clean(get("property").name()) +
			`</label> <input class='transparent' type='radio' name='UNIT2' prop-radio-update='` +
			$t.clean(get("property").id()) +
			`' value="` +
			$t.clean(get("property").name()) +
			`" ` +
			$t.clean(get("property").value() === true ? 'checked' : '') +
			`> </span>`
	
	exports['990870856'] = (get, $t) => 
			`<div class='inline' > <h3>` +
			$t.clean(get("assem").objId) +
			`</h3> <div> ` +
			$t.clean(get("getFeatureDisplay")(get("assem"))) +
			` </div> </div>`
	
	exports['1036581066'] = (get, $t) => 
			`<div class='tab' > ` +
			$t.clean(get("property").name()) +
			` (` +
			$t.clean(get("property").code()) +
			`) </div>`
	
	exports['1410278299'] = (get, $t) => 
			`<span > <label>` +
			$t.clean(get("property").name()) +
			`</label> <input type='radio' name='` +
			$t.clean(get("key")) +
			`' prop-radio-update='` +
			$t.clean(get("property").id()) +
			`' ` +
			$t.clean(get("property").value() === true ? 'checked' : '') +
			`> </span>`
	
	exports['1417643187'] = (get, $t) => 
			`<li name='` +
			$t.clean(get("property").name()) +
			`'> ` +
			$t.clean(get("property").name()) +
			` </li>`
	
	exports['1447370576'] = (get, $t) => 
			`<div class="expandable-list-body" key='` +
			$t.clean(get("key")) +
			`'> <div class="expand-item"> <button class='expandable-item-rm-btn' ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'>X</button> <div class="expand-header ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> ` +
			$t.clean(get("getHeader")(get("item"), get("key"))) +
			` </div> <div class="expand-body ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> ` +
			$t.clean(get("getBody") && get("getBody")(get("item"), get("key"))) +
			` </div> </div> </div>`
	
	exports['1835219150'] = (get, $t) => 
			`<option value='` +
			$t.clean(get("isArray")() ? get("value") : get("key")) +
			`' ` +
			$t.clean(get("selected")(get("isArray")() ? get("value") : get("key")) ? 'selected' : '') +
			`> ` +
			$t.clean(get("value")) +
			` </option>`
	
	exports['1927703609'] = (get, $t) => 
			`<div > ` +
			$t.clean(get("recurse")(get("key"), get("group"))) +
			` </div>`
	
	exports['2055573719'] = (get, $t) => 
			`<div > ` +
			$t.clean(get("CostManager").headHtml(get("child"))) +
			` ` +
			$t.clean(get("CostManager").bodyHtml(get("child"))) +
			` </div>`
	
	exports['2081934436'] = (get, $t) => 
			`<div part-id='` +
			$t.clean(get("part").id()) +
			`' part-code='` +
			$t.clean(get("part").partCode()) +
			`' class='` +
			$t.clean(get("tdm").isTarget("part-id", get("part").id()) ? "active " : "") +
			` model-label indent' ` +
			$t.clean(get("partList").length > 1 ? "" : "hidden") +
			`> <label type='part-id' part-id='` +
			$t.clean(get("part").id()) +
			`' part-code='` +
			$t.clean(get("part").partCode()) +
			`'> ` +
			$t.clean(get("part").partCode()) +
			`-` +
			$t.clean(get("$index") +
			1) +
			` </label> <input type='checkbox' class='part-id-checkbox' part-id='` +
			$t.clean(get("part").id()) +
			`' part-code='` +
			$t.clean(get("part").partCode()) +
			`' ` +
			$t.clean(!get("tdm").hidePartId(get("part").id()) ? 'checked' : '') +
			`> </div>`
	
	exports['expandable/input-repeat'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('550500469').render(get("inputs")(), 'input', get)) +
			` <button ex-list-id='` +
			$t.clean(get("id")()) +
			`' class='expandable-list-add-btn' ` +
			$t.clean(get("hideAddBtn") ? 'hidden' : '') +
			`> Add ` +
			$t.clean(get("listElemLable")()) +
			` here </button> <div class='error' id='` +
			$t.clean(get("ERROR_CNT_ID")) +
			`'></div> </div> `
	
	exports['-1921787246'] = (get, $t) => 
			`<option value="` +
			$t.clean(get("option")) +
			`" ></option>`
	
	exports['expandable/sidebar'] = (get, $t) => 
			` <div class="expandable-list ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> <div class="expand-list-cnt ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> ` +
			$t.clean( new $t('-688234735').render(get("list")(), 'key, item', get)) +
			` <div class='expand-input-cnt' hidden>` +
			$t.clean(get("inputHtml")()) +
			`</div> <div class='input-open-cnt'><button>Add ` +
			$t.clean(get("listElemLable")()) +
			`</button></div> </div> <div> </div> <div class="expand-body ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> Hello World! </div> </div> `
	
	exports['-688234735'] = (get, $t) => 
			`<div class="expandable-list-body" key='` +
			$t.clean(get("key")) +
			`'> <div class="expand-item"> <div class='expand-rm-btn-cnt'> <button class='expandable-item-rm-btn' ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'>X</button> </div> <div class="expand-header ` +
			$t.clean(get("type")()) +
			` ` +
			$t.clean(get("activeKey")() === get("key") ? ' active' : '') +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> ` +
			$t.clean(get("getHeader")(get("item"), get("key"))) +
			` </div> </div> </div>`
	
	exports['expandable/list'] = (get, $t) => 
			` <div class="expandable-list ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> ` +
			$t.clean( new $t('1447370576').render(get("list")(), 'key, item', get)) +
			` <div class='expand-input-cnt' hidden has-input-tree='` +
			$t.clean(get("hasInputTree")()) +
			`'>` +
			$t.clean(get("inputHtml")()) +
			`</div> <div class='input-open-cnt'><button>Add ` +
			$t.clean(get("listElemLable")()) +
			`</button></div> </div> `
	
	exports['expandable/top-add-list'] = (get, $t) => 
			` <div class="expandable-list ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> <div class='expand-input-cnt' hidden has-input-tree='` +
			$t.clean(get("hasInputTree")()) +
			`'>` +
			$t.clean(get("inputHtml")()) +
			`</div> <div class='input-open-cnt'><button>Add ` +
			$t.clean(get("listElemLable")()) +
			`</button></div> ` +
			$t.clean( new $t('1447370576').render(get("list")(), 'key, item', get)) +
			` </div> `
	
	exports['expandable/pill'] = (get, $t) => 
			` <div class="expandable-list ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> <div class="expand-list-cnt ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> ` +
			$t.clean( new $t('-2108278621').render(get("list")(), 'key, item', get)) +
			` <div class='input-open-cnt'><button>Add ` +
			$t.clean(get("listElemLable")()) +
			`</button></div> </div> <div> <div class='expand-input-cnt' hidden>` +
			$t.clean(get("inputHtml")()) +
			`</div> <br> <div class='error' id='` +
			$t.clean(get("ERROR_CNT_ID")()) +
			`'></div> </div> <div class="expand-body ` +
			$t.clean(get("type")()) +
			`"></div> </div> `
	
	exports['-2108278621'] = (get, $t) => 
			`<div key='` +
			$t.clean(get("key")) +
			`'> <div class="expand-item"> <div class='expand-rm-btn-cnt'> <button class='expandable-item-rm-btn' ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'>X</button> </div> <div class="expand-header ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> ` +
			$t.clean(get("getHeader")(get("item"), get("key"))) +
			` </div> </div> </div>`
	
	exports['input/decision/decision'] = (get, $t) => 
			` <span class='decision-input-cnt' node-id='` +
			$t.clean(get("_nodeId")) +
			`' ` +
			$t.clean(get("reachable")() ? '' : 'hidden') +
			`> <span id='` +
			$t.clean(get("id")) +
			`' class='inline-flex'> ` +
			$t.clean( new $t('101748844').render(get("inputArray"), 'input', get)) +
			` </span> </span> `
	
	exports['input/input'] = (get, $t) => 
			`<` +
			$t.clean(get("inline") ? 'span' : 'div') +
			` class='input-cnt'` +
			$t.clean(get("hidden")() ? ' hidden' : '') +
			`> <label>` +
			$t.clean(get("label")()) +
			`</label> <input class='` +
			$t.clean(get("class")()) +
			`' list='input-list-` +
			$t.clean(get("id")()) +
			`' id='` +
			$t.clean(get("id")()) +
			`' placeholder='` +
			$t.clean(get("placeholder")()) +
			`' type='` +
			$t.clean(get("type")()) +
			`' name='` +
			$t.clean(get("name")()) +
			`' ` +
			$t.clean(get("attrString")()) +
			`> <datalist id="input-list-` +
			$t.clean(get("id")()) +
			`"> ` +
			$t.clean( new $t('-994603408').render(get("list")(), 'item', get)) +
			` </datalist> <div class='error' id='` +
			$t.clean(get("errorMsgId")()) +
			`' hidden>` +
			$t.clean(get("errorMsg")()) +
			`</div> </` +
			$t.clean(get("inline") ? 'span' : 'div') +
			`> `
	
	exports['-994603408'] = (get, $t) => 
			`<option value="` +
			$t.clean(get("item")) +
			`" ></option>`
	
	exports['input/decision/decisionTree'] = (get, $t) => 
			`<div class='` +
			$t.clean(get("DecisionInputTree").class) +
			`' root-id='` +
			$t.clean(get("wrapper").nodeId()) +
			`'> ` +
			$t.clean(get("inputHtml")) +
			` <button class='` +
			$t.clean(get("DecisionInputTree").buttonClass) +
			`' root-id='` +
			$t.clean(get("wrapper").nodeId()) +
			`'' ` +
			$t.clean(get("tree").hideButton ? 'hidden' : '') +
			`> ` +
			$t.clean(get("tree").buttonText()) +
			` </button> </div> `
	
	exports['input/select'] = (get, $t) => 
			`<` +
			$t.clean(get("inline") ? 'span' : 'div') +
			` class='input-cnt'` +
			$t.clean(get("hidden")() ? ' hidden' : '') +
			`> <label>` +
			$t.clean(get("label")()) +
			`</label> <select class='` +
			$t.clean(get("class")()) +
			`' id='` +
			$t.clean(get("id")()) +
			`' name='` +
			$t.clean(get("name")()) +
			`' value='` +
			$t.clean(get("value")()) +
			`'> ` +
			$t.clean( new $t('1835219150').render(get("list")(), 'key, value', get)) +
			` </select> <div class='error' id='` +
			$t.clean(get("errorMsgId")()) +
			`' hidden>` +
			$t.clean(get("errorMsg")()) +
			`</div> </` +
			$t.clean(get("inline") ? 'span' : 'div') +
			`> `
	
	exports['input/measurement'] = (get, $t) => 
			`<div class='fit input-cnt'` +
			$t.clean(get("hidden")() ? ' hidden' : '') +
			`> <label>` +
			$t.clean(get("label")()) +
			`</label> <input class='measurement-input ` +
			$t.clean(get("class")()) +
			`' id='` +
			$t.clean(get("id")()) +
			`' value='` +
			$t.clean(get("value")() ? get("value")() : "") +
			`' placeholder='` +
			$t.clean(get("placeholder")()) +
			`' type='` +
			$t.clean(get("type")()) +
			`' name='` +
			$t.clean(get("name")()) +
			`'> <div class='error' id='` +
			$t.clean(get("errorMsgId")()) +
			`' hidden>` +
			$t.clean(get("errorMsg")()) +
			`</div> </div> `
	
	exports['2d/pop-up/door-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <table> <tr> <td><label>Height</label></td> <td><input class='value-2d' key='height' value='` +
			$t.clean(get("display")(get("target").height())) +
			`'></td> </tr> <tr> <td><label>Width</label></td> <td><input class='value-2d' key='width' value='` +
			$t.clean(get("display")(get("target").width())) +
			`'></td> </tr> <tr> <td><label>Distance From Floor</label></td> <td><input class='value-2d' key='fromFloor' value='` +
			$t.clean(get("display")(get("target").fromFloor())) +
			`'></td> </tr> <tr> <td> <button class='hinge-btn transparent'>Hinge</button> </td> <td><button class='remove-btn-2d transparent'>Remove</button></td> </tr> </table> </div> `
	
	exports['2d/pop-up/line-measurement-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> ` +
			$t.clean( new $t('987967094').render(get("UNITS"), 'property', get)) +
			` <br> <input type='text' class='measurement-mod transparent' value='` +
			$t.clean(get("target").display()) +
			`'> </div> `
	
	exports['2d/pop-up/snap-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").parent().constructor.name) +
			`' id='` +
			$t.clean(get("target").parent().id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <label>Name</label> <input class='value-2d' member='object' type="text" key="name" value="` +
			$t.clean(get("target").parent().name()) +
			`"> <br><br> <label>Width</label> <input class='value-2d' member='cabinet' type="text" key="width" value="` +
			$t.clean(get("display")(get("target").width())) +
			`"> <br> <label>Depth</label> <input class='value-2d' member='cabinet' type="text" key="thickness" value="` +
			$t.clean(get("display")(get("target").height())) +
			`"> <br> <label>Angle</label> <input class='value-2d' member='snap' type="text" convert='false' key="angle" value="` +
			$t.clean(get("target").angle()) +
			`"> <br> <label>X</label> <input class='value-2d' member='snap' type="text" key="x" value="` +
			$t.clean(get("display")(get("target").x())) +
			`"> <br> <label>Y</label> <input class='value-2d' member='snap' type="text" key="y" value="` +
			$t.clean(get("display")(get("target").y())) +
			`"> <br> <button class='remove-btn-2d transparent'>Remove</button> </div> `
	
	exports['2d/pop-up/wall-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <button class='add-door-btn-2d transparent'>Add Door</button> <button class='add-window-btn-2d transparent'>Add Window</button> <button class='add-vertex-btn-2d transparent'>Add Vertex</button> <button class='add-object-btn-2d transparent'>Add Object</button> <button class='remove-btn-2d transparent'>Remove</button> </div> `
	
	exports['2d/pop-up/vertex-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <table> <tr> <td><label>X</label></td> <td><input class='value-2d' key='x' value='` +
			$t.clean(get("display")(get("target").x())) +
			`'></td> </tr> <tr> <td><label>Y</label></td> <td><input class='value-2d' key='y' value='` +
			$t.clean(get("display")(get("target").y())) +
			`'></td> </tr> <tr> <td colspan="2"><button class='remove-btn-2d transparent'>Remove</button></td> </tr> <tr> </table> </div> `
	
	exports['2d/pop-up/window-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <table> <tr> <td><label>Height</label></td> <td><input class='value-2d' key='height' value='` +
			$t.clean(get("display")(get("target").height())) +
			`'></td> </tr> <tr> <td><label>Width</label></td> <td><input class='value-2d' key='width' value='` +
			$t.clean(get("display")(get("target").width())) +
			`'></td> </tr> <tr> <td><label>Distance From Floor</label></td> <td><input class='value-2d' key='fromFloor' value='` +
			$t.clean(get("display")(get("target").fromFloor())) +
			`'></td> </tr> <tr> <td colspan="2"><button class='remove-btn-2d'>Remove</button></td> </tr> </table> </div> `
	
	exports['cabinet/body'] = (get, $t) => 
			`<div> <div class='center'> <div class='left'> <label>Show Left</label> <select class="show-left-select"> ` +
			$t.clean( new $t('-970877277').render(get("showTypes"), 'showType', get)) +
			` </select> </div> <div class='property-id-container center inline-flex'>` +
			$t.clean(get("selectHtml")) +
			`</div> <div class='right'> <select class="show-right-select"> ` +
			$t.clean( new $t('-970877277').render(get("showTypes"), 'showType', get)) +
			` </select> <label>Show Right</label> </div> </div> <br> <div class='center'> <button class='save-cabinet-btn' index='` +
			$t.clean(get("$index")) +
			`'>Save</button> </div> ` +
			$t.clean( new $t('-1304800590').render(get("cabinet").openings, 'opening', get)) +
			` </div> `
	
	exports['-970877277'] = (get, $t) => 
			`<option >` +
			$t.clean(get("showType").name) +
			`</option>`
	
	exports['-1702305177'] = (get, $t) => 
			`<div class='divison-section-cnt'> ` +
			$t.clean(get("OpenSectionDisplay").html(get("opening"))) +
			` </div>`
	
	exports['cabinet/head'] = (get, $t) => 
			`<div class='cabinet-header' cabinet-id='` +
			$t.clean(get("cabinet").id()) +
			`'> ` +
			$t.clean(get("$index")) +
			`) <input class='cabinet-id-input' prop-update='` +
			$t.clean(get("$index")) +
			`.name' index='` +
			$t.clean(get("$index")) +
			`' display-id='` +
			$t.clean(get("displayId")) +
			`' value='` +
			$t.clean(get("cabinet").name()) +
			`'> Size: <div class='cabinet-dem-cnt' cabinet-id='` +
			$t.clean(get("cabinet").id()) +
			`'> <label>W:</label> <input class='cabinet-input dem' prop-update='` +
			$t.clean(get("$index")) +
			`.width' name='width' display-id='` +
			$t.clean(get("displayId")) +
			`' value='` +
			$t.clean(get("displayValue")(get("cabinet").width())) +
			`'> <label>H:</label> <input class='cabinet-input dem' prop-update='` +
			$t.clean(get("$index")) +
			`.length' name='length' display-id='` +
			$t.clean(get("displayId")) +
			`' value='` +
			$t.clean(get("displayValue")(get("cabinet").length())) +
			`'> <label>D:</label> <input class='cabinet-input dem' prop-update='` +
			$t.clean(get("$index")) +
			`.thickness' name='thickness' display-id='` +
			$t.clean(get("displayId")) +
			`' value='` +
			$t.clean(get("displayValue")(get("cabinet").thickness())) +
			`'> </div> </div> `
	
	exports['display-manager'] = (get, $t) => 
			`<div class='display-manager' id='` +
			$t.clean(get("id")) +
			`'> ` +
			$t.clean( new $t('-533097724').render(get("list"), 'item', get)) +
			` </div> `
	
	exports['-533097724'] = (get, $t) => 
			`<span class='display-manager-item'> <button class='display-manager-input` +
			$t.clean(get("$index") === 0 ? " active" : "") +
			`' type='button' display-id='` +
			$t.clean(get("item").id) +
			`' link='` +
			$t.clean(get("link")) +
			`'>` +
			$t.clean(get("item").name) +
			`</button> </span>`
	
	exports['divide/head'] = (get, $t) => 
			`<div> <select value='` +
			$t.clean(get("opening").name) +
			`' class='open-divider-select` +
			$t.clean(get("sections").length === 0 ? ' hidden' : '') +
			`'> ` +
			$t.clean( new $t('443122713').render(get("sections"), 'section', get)) +
			` </select> <div class='open-divider-select` +
			$t.clean(get("sections").length === 0 ? '' : ' hidden') +
			`'> D </div> </div> `
	
	exports['divider-controls'] = (get, $t) => 
			`<div> <label>Dividers:</label> <input class='division-pattern-input' type='text' name='pattern' opening-id='` +
			$t.clean(get("opening").id()) +
			`' value='` +
			$t.clean(get("opening").pattern().str) +
			`'> <span class="open-orientation-radio-cnt"> <label for='open-orientation-horiz-` +
			$t.clean(get("opening").id()) +
			`'>Horizontal:</label> <input type='radio' name='orientation-` +
			$t.clean(get("opening").id()) +
			`' value='horizontal' open-id='` +
			$t.clean(get("opening").id()) +
			`' id='open-orientation-horiz-` +
			$t.clean(get("opening").id()) +
			`' class='open-orientation-radio' ` +
			$t.clean(get("opening").value('vertical') ? '' : 'checked') +
			`> <label for='open-orientation-vert-` +
			$t.clean(get("opening").id()) +
			`'>Vertical:</label> <input type='radio' name='orientation-` +
			$t.clean(get("opening").id()) +
			`' value='vertical' open-id='` +
			$t.clean(get("opening").id()) +
			`' id='open-orientation-vert-` +
			$t.clean(get("opening").id()) +
			`' class='open-orientation-radio' ` +
			$t.clean(get("opening").value('vertical') ? 'checked' : '') +
			`> </span> <div class='open-pattern-input-cnt' opening-id='` +
			$t.clean(get("opening").id()) +
			`' ` +
			$t.clean(get("opening").pattern().equal ? 'hidden' : '') +
			`> ` +
			$t.clean(get("patternInputHtml")) +
			` </div> </div> `
	
	exports['divide/body'] = (get, $t) => 
			`<h2>` +
			$t.clean(get("list").activeKey()) +
			`</h2> val: ` +
			$t.clean(get("list").value()('selected')) +
			` `
	
	exports['group/body'] = (get, $t) => 
			`<div class='group-cnt'> <div class='group-header' cab-style='Inset' ` +
			$t.clean(get("group").propertyConfig.isInset() ? '' : 'hidden') +
			`> <h2>Inset <b class='group-key'>` +
			$t.clean(get("group").propertyConfig('Inset').__KEY) +
			`</b></h2> </div> <div class='group-header' cab-style='Overlay' ` +
			$t.clean(!get("group").propertyConfig.isInset() && !get("group").propertyConfig.isReveal() ? '' : 'hidden') +
			`> <h2>Overlay <b class='group-key'>` +
			$t.clean(get("group").propertyConfig('Overlay').__KEY) +
			`</b></h2> </div> <div class='group-header' cab-style='Reveal' ` +
			$t.clean(get("group").propertyConfig.isReveal() ? '' : 'hidden') +
			`> <h2>Reveal <b class='group-key'>` +
			$t.clean(get("group").propertyConfig('Reveal').__KEY) +
			`</b></h2> </div> ` +
			$t.clean(get("propertyHtml")()) +
			` <div class='cabinet-cnt' group-id='` +
			$t.clean(get("group").id()) +
			`'></div> </div> `
	
	exports['feature'] = (get, $t) => 
			`<h3>Feature Display</h3> `
	
	exports['group/head'] = (get, $t) => 
			`<div group-display-id='` +
			$t.clean(get("groupDisplay").id()) +
			`'> <div class='expand-header group-display-header' group-id='` +
			$t.clean(get("group").id()) +
			`'> ` +
			$t.clean(get("$index")) +
			`<input class='group-input' group-id='` +
			$t.clean(get("group").id()) +
			`' value='` +
			$t.clean(get("group").name()) +
			`' prop-update='name'> </div> <div class='group-display-body' hidden></div> </div> <br> `
	
	exports['index'] = (get, $t) => 
			`<!DOCTYPE html> <html lang="en" dir="ltr"> <head> <meta charset="utf-8"> <style> /* #two-d-model { width: 500px; height:500px;} */ div { font-size:x-small; } </style> <script type="text/javascript" src='/cabinet/js/index.js'></script> <link rel="stylesheet" href="/styles/expandable-list.css"> <link rel="stylesheet" href="/cabinet/styles/estimate.css"> <script src="/js/utility-filter.js" run-type='auto'></script> <title>Estimate</title> </head> <body> <button id='menu-btn'>&#8801;</button> <div id='menu' hidden></div> <div id='login'><div id='login-cnt' class='center-all'></div></div> <div id='display-ctn'> <div id='app' name='Orders' ` +
			$t.clean(get("id") !== 'home' ? "link='/cabinet/home'" : '') +
			` hidden> <div id='order-cnt'></div> <div id='model-cnt'> <div id='display-menu'></div> <div id='model-display-cnt'> <canvas id="two-d-model"></canvas> <div id="three-d-model" class="viewer small"> <span id="model-controller"></span> <span id="three-d-model-display"></span> </div> </div> </div> </div> <div name='Property Manager' ` +
			$t.clean(get("id") !== 'home' ? "link='/cabinet/property'" : '') +
			` id='property-manager-cnt' hidden> <div class='center'> <button id='property-manager-save-all'>Save All</button> </div> <div id='property-manager'></div> </div> <div id='cost-manager' "link='/cabinet/cost'" name='Cost Manager' ` +
			$t.clean(get("id") !== 'cost' ? "link='/cabinet/cost'" : '') +
			` hidden></div> <div id='template-manager' name='Template Manager' ` +
			$t.clean(get("id") !== 'template' ? "link='/cabinet/template'" : '') +
			` hidden>Temp Man</div> <div id='pattern-manager' name='Pattern Manager' ` +
			$t.clean(get("id") !== 'home' ? "link='/cabinet/pattern'" : '') +
			` hidden>Pat Man</div> </div> <div id='property-select-cnt'></div> </body> </html> `
	
	exports['login/confirmation-message'] = (get, $t) => 
			`<h3> Check your email for confirmation. </h3> <button id='resend-activation'>Resend</button> `
	
	exports['login/create-account'] = (get, $t) => 
			`<h3>Create An Account</h3> <input type='text' placeholder="email" name='email' value='` +
			$t.clean(get("email")) +
			`'> <input type='password' placeholder="password" name='password' value='` +
			$t.clean(get("password")) +
			`'> <br><br> <button id='register'>Register</button> <br><br> <a href='#' user-state='RESET_PASSWORD'>Reset Passord</a> | <a href='#' user-state='LOGIN'>Login</a> `
	
	exports['login/login'] = (get, $t) => 
			`<h3>Login</h3> <input type='text' placeholder="email" name='email' value='` +
			$t.clean(get("email")) +
			`'> <input type='password' placeholder="password" name='password' value='` +
			$t.clean(get("password")) +
			`'> <br><br> <button id='login-btn'>Login</button> <br><br> <a href='#' user-state='RESET_PASSWORD'>Reset Passord</a> | <a href='#' user-state='CREATE_ACCOUNT'>Create An Account</a> `
	
	exports['login/reset-password'] = (get, $t) => 
			`<h3>Reset Password</h3> <input type='text' placeholder="email" name='email' value='` +
			$t.clean(get("email")) +
			`'> <input type='password' placeholder="password" name='password' value='` +
			$t.clean(get("password")) +
			`'> <br><br> <button id='reset-password'>Reset</button> <br><br> <a href='#' user-state='LOGIN'>Login</a> | <a href='#' user-state='CREATE_ACCOUNT'>Create An Account</a> `
	
	exports['managers/abstract-manager'] = (get, $t) => 
			`<div> <div class="center"> <h2 id='` +
			$t.clean(get("headerId")) +
			`'> ` +
			$t.clean(get("header")) +
			` <button class='manager-save-btn' id='` +
			$t.clean(get("saveBtnId")) +
			`'>Save</button> </h2> </div> <div id="` +
			$t.clean(get("bodyId")) +
			`"></div> </div> `
	
	exports['managers/cost/head'] = (get, $t) => 
			`<div class='expand-header' node-id='` +
			$t.clean(get("node").nodeId()) +
			`'> <b> ` +
			$t.clean(get("node").payload().name()) +
			` - ` +
			$t.clean(get("node").payload().type()) +
			` </b> <ul> ` +
			$t.clean( new $t('1417643187').render(get("node").payload().requiredProperties, 'property', get)) +
			` </ul> </div> `
	
	exports['managers/cost/body'] = (get, $t) => 
			`<div hidden> <div> <span> ` +
			$t.clean(get("CostManager").nodeInputHtml()) +
			` <button>Add Cost</button> <button>Add Node</button> </span> <span> Cost Display </span> </div> ` +
			$t.clean( new $t('2055573719').render(get("node").children(), 'child', get)) +
			` </div> `
	
	exports['managers/cost/property-select'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('-1569738859').render(get("groups"), 'group, properties', get)) +
			` </div> `
	
	exports['-1569738859'] = (get, $t) => 
			`<div > <b>` +
			$t.clean(get("group")) +
			` (` +
			$t.clean(get("abbriviation")(get("group"))) +
			`)</b> ` +
			$t.clean( new $t('1036581066').render(get("properties"), 'property', get)) +
			` </div>`
	
	exports['managers/cost/main'] = (get, $t) => 
			`<div> <div class="center"> <h2 id='cost-manager-header'> Cost Tree Manager </h2> </div> ` +
			$t.clean( new $t('-496477131').render(get("root")().children(), 'child', get)) +
			` <button id='cost-manager-save-btn'>Save</button> </div> `
	
	exports['-496477131'] = (get, $t) => 
			`<div class='expandable-list cost-tree' radio-id='poo'> ` +
			$t.clean(get("headHtml")(get("child"))) +
			` ` +
			$t.clean(get("bodyHtml")(get("child"))) +
			` </div>`
	
	exports['managers/cost/types/labor'] = (get, $t) => 
			`<div cost-id='` +
			$t.clean(get("cost").id()) +
			`'> <b>Labor</b> <span` +
			$t.clean(get("cost").length() === undefined ? ' hidden' : '') +
			`> <input value='` +
			$t.clean(get("cost").length()) +
			`'> </span> <span` +
			$t.clean(get("cost").width() === undefined ? ' hidden' : '') +
			`> <label>X</label> <input value='` +
			$t.clean(get("cost").width()) +
			`'> </span> <span` +
			$t.clean(get("cost").depth() === undefined ? ' hidden' : '') +
			`> <label>X</label> <input value='` +
			$t.clean(get("cost").depth()) +
			`'> </span> <br> <div> <label>Cost</label> <input value='` +
			$t.clean(get("cost").cost()) +
			`'> <label>Per ` +
			$t.clean(get("cost").unitCost('name')) +
			` = ` +
			$t.clean(get("cost").unitCost('value')) +
			`</label> </div> </div> `
	
	exports['managers/cost/types/material'] = (get, $t) => 
			`<div cost-id='` +
			$t.clean(get("cost").id()) +
			`'> <b>Material</b> <span` +
			$t.clean(get("cost").length() === undefined ? ' hidden' : '') +
			`> <input value='` +
			$t.clean(get("cost").length()) +
			`'> </span> <span` +
			$t.clean(get("cost").width() === undefined ? ' hidden' : '') +
			`> <label>X</label> <input value='` +
			$t.clean(get("cost").width()) +
			`'> </span> <span` +
			$t.clean(get("cost").depth() === undefined ? ' hidden' : '') +
			`> <label>X</label> <input value='` +
			$t.clean(get("cost").depth()) +
			`'> </span> <br> <div> <label>Cost</label> <input value='` +
			$t.clean(get("cost").cost()) +
			`'> <label>Per ` +
			$t.clean(get("cost").unitCost('name')) +
			` = ` +
			$t.clean(get("cost").unitCost('value')) +
			`</label> </div> </div> `
	
	exports['managers/property/body'] = (get, $t) => 
			`<div> No Need </div> `
	
	exports['managers/property/header'] = (get, $t) => 
			`<div> <b>` +
			$t.clean(get("instance").name) +
			` (` +
			$t.clean(get("instance").constructor.code) +
			`) - ` +
			$t.clean(get("instance").value) +
			`</b> </div> `
	
	exports['managers/template/body'] = (get, $t) => 
			`<div class='template-body' template-id=` +
			$t.clean(get("template").id()) +
			`> <div class='inline-flex full-width'> <h4>` +
			$t.clean(get("template").type()) +
			`</h4> <div class='full-width'> <button class='copy-template right'>Copy</button> <button class='paste-template right'>Paste</button> </div> </div> <div></div> <div></div> <input class='cabinet-input dem' type="text" name="width" value="` +
			$t.clean(get("toDisplay")(get("template").width())) +
			`"> X <input class='cabinet-input dem' type="text" name="height" value="` +
			$t.clean(get("toDisplay")(get("template").height())) +
			`"> X <input class='cabinet-input dem' type="text" name="thickness" value="` +
			$t.clean(get("toDisplay")(get("template").thickness())) +
			`"> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Values</div> <div hidden class="` +
			$t.clean(get("containerClasses").values) +
			`"></div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Subassemblies</div> <div hidden class="` +
			$t.clean(get("containerClasses").subassemblies) +
			`">2</div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Joints</div> <div hidden class="` +
			$t.clean(get("containerClasses").joints) +
			`">3</div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Divider Joint</div> <div hidden class="` +
			$t.clean(get("containerClasses").dividerJoint) +
			`"> ` +
			$t.clean(get("dividerJointInput").html()) +
			` </div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Openings</div> <div hidden class="` +
			$t.clean(get("containerClasses").openings) +
			`">5</div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>View Shape</div> <div hidden>` +
			$t.clean(get("templateShapeInput").html()) +
			`</div> </div> </div> `
	
	exports['managers/template/head'] = (get, $t) => 
			`<div> <b>` +
			$t.clean(get("template").type()) +
			`</b> </div> `
	
	exports['managers/template/joints/body'] = (get, $t) => 
			`` +
			$t.clean(get("jointInput").html()) +
			` <input type="text" name="value" disabled > <input type="checkbox" name="convert" checked> `
	
	exports['managers/template/joints/head'] = (get, $t) => 
			`<b> <input class='template-input' value='` +
			$t.clean(get("obj").malePartCode) +
			`' attr='joints' placeholder='Male Part Code' name='malePartCode'> => <input class='template-input' value='` +
			$t.clean(get("obj").femalePartCode) +
			`' attr='joints' placeholder='Female Part Code' name='femalePartCode'> </b> `
	
	exports['managers/template/main'] = (get, $t) => 
			`<div template-manager=` +
			$t.clean(get("id")()) +
			`> <div class='section-properties'> <br> <label>Inset</label> <input class='style-selector' type="radio" name="style" value="Inset" ` +
			$t.clean(get("sectionState").style === 'Inset' ? 'checked' : '') +
			`> <label>overlay</label> <input class='style-selector' type="radio" name="style" value="Overlay" ` +
			$t.clean(get("sectionState").style === 'Overlay' ? 'checked' : '') +
			`> <label>Reveal</label> <input class='style-selector' type="radio" name="style" value="Reveal" ` +
			$t.clean(get("sectionState").style === 'Reveal' ? 'checked' : '') +
			`> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <label>Door</label> <input type="radio" name='sectionType' value="DoorSection"> <label>Drawer</label> <input type="radio" name='sectionType' value="DrawerSection"> <label>Duel Door</label> <input type="radio" name='sectionType' value="DualDoorSection"> <label>False Front</label> <input type="radio" name='sectionType' value="FalseFrontSection"> <label>Open</label> <input type="radio" name='sectionType' value=""> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <label>Divider Count</label> <input id='template-divider-count-input' type="number" name="count" min='0' max='3' value=0> <label>Vertical</label> <input type="checkbox" name="vertical"> <label>Test</label> <input type="checkbox" name="testDividers"> </div> <div id='` +
			$t.clean(get("parentId")()) +
			`'></div> <div class='center center-vert' id='layout-sketch-cnt'></div> </div> `
	
	exports['managers/template/openings/body'] = (get, $t) => 
			`<div> <h4>Opening Border Part Codes</h4> <div class='tab border-part-code-cnt'> ` +
			$t.clean(get("select").html()) +
			` <input class='opening-part-code-input' attr='openings' name='partCode' value="` +
			$t.clean(get("obj")[get("select").value()]) +
			`"> <b>Flip Normal</b> <input type="checkbox" name="flipNormal" ` +
			$t.clean(get("obj").flipNormal ? 'checked' : '') +
			`> </div> <h4>Opening Border Locations</h4> <div class='tab'> Custom Vertex Formula: <input class='opening-type-selector' type="checkbox" name="custom-formula" ` +
			$t.clean(get("obj")._Type === 'location' ? 'checked' : '') +
			`> <div class='border-location-cnt' ` +
			$t.clean(get("obj")._Type === 'location' ? '' : 'hidden') +
			`> <label>Inner</label> <input type="radio" name="innerOouter-` +
			$t.clean(get("obj").id) +
			`" value="true" ` +
			$t.clean(get("state").innerOouter === 'true' ? 'checked' : '') +
			`> <label>Outer</label> <input type="radio" name="innerOouter-` +
			$t.clean(get("obj").id) +
			`" value="false" ` +
			$t.clean(get("state").innerOouter === 'false' ? 'checked' : '') +
			`> <br><br> <label>Vertex:</label> <br> ` +
			$t.clean( new $t('-182533851').render('0..4', 'i', get)) +
			` <br><br> <label>X</label> <input type="radio" name="xOyOz-` +
			$t.clean(get("obj").id) +
			`" value="x" ` +
			$t.clean(get("state").xOyOz === 'x' ? 'checked' : '') +
			`> <label>Y</label> <input type="radio" name="xOyOz-` +
			$t.clean(get("obj").id) +
			`" value="y" ` +
			$t.clean(get("state").xOyOz === 'y' ? 'checked' : '') +
			`> <label>Z</label> <input type="radio" name="xOyOz-` +
			$t.clean(get("obj").id) +
			`" value="z" ` +
			$t.clean(get("state").xOyOz === 'z' ? 'checked' : '') +
			`> <br><br> <input type='text' name='opening-coordinate-value' value=''> </div> <div class='opening-location-value-cnt'></div> <div class='opening-location-description-cnt'></div> </div> </div> `
	
	exports['managers/template/subassemblies/body'] = (get, $t) => 
			`<div template-attr='subassembles'> <div> <label>All</label> <input class='template-include' type='radio' name='is-` +
			$t.clean(get("obj").id) +
			`' value='All' ` +
			$t.clean(get("obj").include === 'All' ? 'checked' : '') +
			`> <label>Overlay</label> <input class='template-include' type='radio' name='is-` +
			$t.clean(get("obj").id) +
			`' value='Overlay' ` +
			$t.clean(get("obj").include === 'Overlay' ? 'checked' : '') +
			`> <label>Reveal</label> <input class='template-include' type='radio' name='is-` +
			$t.clean(get("obj").id) +
			`' value='Reveal' ` +
			$t.clean(get("obj").include === 'Reveal' ? 'checked' : '') +
			`> <label>Inset</label> <input class='template-include' type='radio' name='is-` +
			$t.clean(get("obj").id) +
			`' value='Inset' ` +
			$t.clean(get("obj").include === 'Inset' ? 'checked' : '') +
			`> </div> <label>Name</label> <input class='template-input' attr='subassemblies' name="name" value="` +
			$t.clean(get("obj").name) +
			`"> <br> <div class='sub-demensions-cnt inline-flex'> ` +
			$t.clean(get("demensionXyzSelect").html()) +
			` <input class='template-input' attr='subassemblies' name='demensions' value='` +
			$t.clean(get("getEqn")(get("demensionXyzSelect"), get("obj").demensions)) +
			`'> <input disabled class='measurement-input' name='value'> <input type="checkbox" name="convert" checked> </div> <br> <div class='sub-center-cnt inline-flex'> ` +
			$t.clean(get("centerXyzSelect").html()) +
			` <input class='template-input' attr='subassemblies' name='center' value='` +
			$t.clean(get("getEqn")(get("centerXyzSelect"), get("obj").center)) +
			`'> <input disabled class='measurement-input' name='value'> <input type="checkbox" name="convert" checked> </div> <br> <div class='sub-center-cnt inline-flex'> ` +
			$t.clean(get("rotationXyzSelect").html()) +
			` <input class='template-input' attr='subassemblies' name='rotation' value='` +
			$t.clean(get("getEqn")(get("rotationXyzSelect"), get("obj").rotation)) +
			`'> <input disabled class='measurement-input' name='value'> </div> </div> `
	
	exports['managers/template/openings/head'] = (get, $t) => 
			`<div class='inline-flex' opening-id='` +
			$t.clean(get("obj").id) +
			`'> Openings </div> `
	
	exports['managers/template/subassemblies/head'] = (get, $t) => 
			`<label>Part Code</label> <input class='template-input' attr='subassemblies' name='code' value="` +
			$t.clean(get("obj").code) +
			`"> ` +
			$t.clean(get("typeInput").html()) +
			` `
	
	exports['managers/template/values/head'] = (get, $t) => 
			`<div template-attr='values'> <input class='template-input' attr='values' type='text' name='name' value='` +
			$t.clean(get("obj").key) +
			`' placeholder="Variable Name"> <input class='measurement-input' type='text' name='value' value='` +
			$t.clean(get("obj").eqn) +
			`' placeholder="Value" disabled> <input type="checkbox" name="convert" checked> <br> <input class='template-input full-width' attr='values' type='text' name='eqn' value='` +
			$t.clean(get("obj").eqn) +
			`' placeholder="Equation"> </div> `
	
	exports['opening'] = (get, $t) => 
			`<div class='opening-cnt' opening-id='` +
			$t.clean(get("opening").id()) +
			`'> <div class='divider-controls'> </div> </div> <div id='` +
			$t.clean(get("openDispId")) +
			`'> </div> `
	
	exports['model-controller'] = (get, $t) => 
			`<div> <div class='model-selector'> <div ` +
			$t.clean(get("group").level === -1 ? 'hidden' : '') +
			`> <div class='` +
			$t.clean(get("tdm").isTarget("prefix", get("group").prefix) ? "active " : "") +
			` ` +
			$t.clean(get("label") ? "prefix-switch model-label" : "") +
			`' ` +
			$t.clean(!get("label") ? 'hidden' : '') +
			`> <label type='prefix'>` +
			$t.clean(get("label")) +
			`</label> <input type='checkbox' class='prefix-checkbox' prefix='` +
			$t.clean(get("group").prefix) +
			`' ` +
			$t.clean(!get("tdm").hidePrefix(get("label")) ? 'checked' : '') +
			`> </div> <div class='` +
			$t.clean(get("label") ? "prefix-body indent" : "") +
			`' ` +
			$t.clean(get("label") ? 'hidden' : '') +
			`> ` +
			$t.clean( new $t('-13082682').render(get("group").parts, 'partName, partList', get)) +
			` </div> </div> ` +
			$t.clean( new $t('model-controller').render(get("group").groups, 'label, group', get)) +
			` </div> </div> `
	
	exports['-13082682'] = (get, $t) => 
			`<div class='model-label` +
			$t.clean(get("tdm").isTarget("part-name", get("partName")) ? " active" : "") +
			`' > <label type='part-name'>` +
			$t.clean(get("partName")) +
			`</label> <input type='checkbox' class='part-name-checkbox' part-name='` +
			$t.clean(get("partName")) +
			`' ` +
			$t.clean(!get("tdm").hidePartName(get("partName")) ? 'checked' : '') +
			`> ` +
			$t.clean( new $t('2081934436').render(get("partList"), 'part', get)) +
			` </div>`
	
	exports['order/body'] = (get, $t) => 
			`<div order-id='` +
			$t.clean(get("order").id()) +
			`'> <b>` +
			$t.clean(get("order").name()) +
			`</b> <ul id='order-nav' class='center toggle-display-list'> <li class='toggle-display-item active' display-id='builder-display-` +
			$t.clean(get("order").id()) +
			`'>Builder</li> <li class='toggle-display-item' display-id='information-display-` +
			$t.clean(get("order").id()) +
			`'>Information</li> </ul> <div id='builder-display-` +
			$t.clean(get("order").id()) +
			`'> <b>` +
			$t.clean(get("order").name()) +
			`</b> <button class='save-order-btn' index='` +
			$t.clean(get("$index")) +
			`'>Save</button> <div id='room-pills'>RoomPills!</div> </div> <div id='information-display-` +
			$t.clean(get("order").id()) +
			`' hidden> <utility-filter id='uf-info-` +
			$t.clean(get("order").id()) +
			`' edit='true'> [ {"ID":1,"NAME":"Linktype","LEGAL_NAME":"Telephone and Data Systems, Inc.","LOGO_URI":"http://dummyimage.com/349x31.jpg/dddddd/000000","OWNER_ID":988}, {"ID":2,"NAME":"Eare","LEGAL_NAME":"Zymeworks Inc.","LOGO_URI":null,"OWNER_ID":933}, {"ID":3,"NAME":"Ainyx","LEGAL_NAME":"Pacira Pharmaceuticals, Inc.","LOGO_URI":null,"OWNER_ID":960}, {"ID":4,"NAME":"Photobean","LEGAL_NAME":"ArQule, Inc.","LOGO_URI":null,"OWNER_ID":443}, {"ID":5,"NAME":"Zoombeat","LEGAL_NAME":"Domtar Corporation","LOGO_URI":"http://dummyimage.com/83x401.bmp/5fa2dd/ffffff","OWNER_ID":739}] </utility-filter> </div> </div> `
	
	exports['order/builder/body'] = (get, $t) => 
			`<div> <b>` +
			$t.clean(get("order").name) +
			`</b> <button class='save-order-btn' index='` +
			$t.clean(get("$index")) +
			`'>Save</button> <div id='room-pills'>RoomPills!</div> </div> `
	
	exports['order/head'] = (get, $t) => 
			`<h3 class='margin-zero'> ` +
			$t.clean(get("order").name()) +
			` </h3> `
	
	exports['order/builder/head'] = (get, $t) => 
			`<h3 class='margin-zero'> ` +
			$t.clean(get("order").name) +
			` </h3> `
	
	exports['order/information/body'] = (get, $t) => 
			`<utility-filter hidden> [ {"ID":1,"NAME":"Linktype","LEGAL_NAME":"Telephone and Data Systems, Inc.","LOGO_URI":"http://dummyimage.com/349x31.jpg/dddddd/000000","OWNER_ID":988}, {"ID":2,"NAME":"Eare","LEGAL_NAME":"Zymeworks Inc.","LOGO_URI":null,"OWNER_ID":933}, {"ID":3,"NAME":"Ainyx","LEGAL_NAME":"Pacira Pharmaceuticals, Inc.","LOGO_URI":null,"OWNER_ID":960}, {"ID":4,"NAME":"Photobean","LEGAL_NAME":"ArQule, Inc.","LOGO_URI":null,"OWNER_ID":443}, {"ID":5,"NAME":"Zoombeat","LEGAL_NAME":"Domtar Corporation","LOGO_URI":"http://dummyimage.com/83x401.bmp/5fa2dd/ffffff","OWNER_ID":739}] </utility-filter> `
	
	exports['order/information/head'] = (get, $t) => 
			`<b>Information</b> `
	
	exports['properties/config-body0'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('-179269626').render(get("properties"), 'property', get)) +
			` <button class='save-change' properties-id='` +
			$t.clean(get("properties")._ID) +
			`' ` +
			$t.clean(get("changed")(get("properties")._ID) ? '' : 'hidden') +
			`> Save </button> </div> `
	
	exports['-179269626'] = (get, $t) => 
			`<div class='property-cnt' > <label>` +
			$t.clean(get("property").name()) +
			`</label> <input type="text" prop-value-update='` +
			$t.clean(get("property").id()) +
			`' value="` +
			$t.clean(get("property").display()) +
			`" measurement-id='` +
			$t.clean(get("property").measurementId()) +
			`'> </div>`
	
	exports['properties/config-body'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('-302479018').render(get("properties"), 'property', get)) +
			` <button class='save-change' properties-id='` +
			$t.clean(get("properties")._ID) +
			`' ` +
			$t.clean(get("changed")(get("properties")._ID) ? '' : 'hidden') +
			`> Save </button> </div> `
	
	exports['-302479018'] = (get, $t) => 
			`<div class='property-cnt' > <label>` +
			$t.clean(get("property").name()) +
			`</label> <span ` +
			$t.clean(get("property").measurementId() ? '' : 'hidden') +
			`> <input type="text" prop-value-update='` +
			$t.clean(get("property").id()) +
			`' value="` +
			$t.clean(get("property").display()) +
			`" measurement-id='` +
			$t.clean(get("property").measurementId()) +
			`'> </span> <span ` +
			$t.clean((typeof (get("property").value())) === 'boolean' ? '' : 'hidden') +
			`> <input type="checkbox" prop-boolean-update='` +
			$t.clean(get("property").id()) +
			`' ` +
			$t.clean(get("property").value() === true ? 'checked' : '') +
			`> </span> </div>`
	
	exports['properties/config-head'] = (get, $t) => 
			`` +
			$t.clean(get("name")) +
			` `
	
	exports['properties/config-head0'] = (get, $t) => 
			`` +
			$t.clean(get("name")) +
			` `
	
	exports['properties/properties'] = (get, $t) => 
			`<div class='center'> <div class='center'> <label>UNIT :&nbsp;&nbsp;&nbsp;&nbsp;</label> ` +
			$t.clean( new $t('-766481261').render(get("Properties").UNITS, 'property', get)) +
			` </div> ` +
			$t.clean( new $t('115117775').render(get("values"), 'key, properties', get)) +
			` </div> `
	
	exports['-766481261'] = (get, $t) => 
			`<span > <label>` +
			$t.clean(get("property").name()) +
			`</label> <input type='radio' name='UNIT' prop-radio-update='` +
			$t.clean(get("property").id()) +
			`' value="` +
			$t.clean(get("property").name()) +
			`" ` +
			$t.clean(get("property").value() === true ? 'checked' : '') +
			`> </span>`
	
	exports['properties/properties0'] = (get, $t) => 
			`<div class='center'> <div class='` +
			$t.clean(get("key") ? "property-container close" : "") +
			`' radio-id='` +
			$t.clean(get("radioId")) +
			`' ` +
			$t.clean(get("noChildren")() ? 'hidden' : '') +
			`> <div class='` +
			$t.clean(get("key") ? "expand-header" : "") +
			`'> ` +
			$t.clean(get("label")) +
			` </div> <div` +
			$t.clean(get("key") ? ' hidden' : '') +
			`> <div` +
			$t.clean(get("branch") ? ' hidden' : '') +
			`> <div id='config-expand-list-` +
			$t.clean(get("id")) +
			`'></div> ` +
			$t.clean( new $t('1927703609').render(get("groups"), 'key, group', get)) +
			` </div> </div> </div> </div> `
	
	exports['properties/radio'] = (get, $t) => 
			`<div class='center'> <label>` +
			$t.clean(get("key")) +
			`:&nbsp;&nbsp;&nbsp;&nbsp;</label> ` +
			$t.clean( new $t('1410278299').render(get("values"), 'property', get)) +
			` </div> `
	
	exports['properties/property-menu'] = (get, $t) => 
			` <div class='cabinet-style-selector-cnt'>` +
			$t.clean(get("styleSelector")()) +
			`</div> Property MeNu `
	
	exports['properties/unit'] = (get, $t) => 
			`<div> <label>Standard</label> <input type='radio' name='unit' ` +
			$t.clean(get("unit").value() === 'Imperial (US)' ? 'checked' : '') +
			` value='Imperial (US)'> <label>Metric</label> <input type='radio' name='unit' ` +
			$t.clean(get("unit").value() === 'Metric' ? 'checked' : '') +
			` value='Metric'> </div> `
	
	exports['room/body'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('714657883').render(get("room").groups, 'group', get)) +
			` <div> <button class='group-add-btn' room-id='` +
			$t.clean(get("room").id()) +
			`'>Add Group</button> </div> </div> `
	
	exports['sections/divider'] = (get, $t) => 
			`<h2>Divider: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['room/head'] = (get, $t) => 
			`<b>` +
			$t.clean(get("room").name()) +
			`</b> `
	
	exports['sections/door'] = (get, $t) => 
			`<h2>DoorSection(` +
			$t.clean(get("list").activeKey()) +
			`):</h2> <br><br> <div> ` +
			$t.clean( new $t('990870856').render(get("assemblies"), 'assem', get)) +
			` </div> `
	
	exports['sections/drawer'] = (get, $t) => 
			`<h2>Drawer: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['sections/dual-door'] = (get, $t) => 
			`<h2>Dual Door: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['sections/false-front'] = (get, $t) => 
			`<h2>False Front: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['sections/open'] = (get, $t) => 
			`<h2>Open: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['three-view'] = (get, $t) => 
			`<div class='three-view-cnt' id='` +
			$t.clean(get("id")()) +
			`'> <div class='three-view-three-d-cnt'></div> <div class='three-view-two-d-cnt'> <div class='three-view-canvases-cnt inline-flex' id='` +
			$t.clean(get("id")()) +
			`-cnt'> <div class='part-input-cnt center-vert'> <input type="text" name="partSelector" list='part-list'> <datalist id='part-list'></datalist> </div> <div class='center-vert'>Part Code: <b id='three-view-part-code-` +
			$t.clean(get("id")()) +
			`'></b></div> <span class='three-view-canvas-cnt'> <b>Top</b> <canvas id="three-view-top" width="` +
			$t.clean(get("maxDem")()) +
			`" height="` +
			$t.clean(get("maxDem")()) +
			`"></canvas> </span> <span class='three-view-canvas-cnt'> <b>Left</b> <canvas id="three-view-left" width="` +
			$t.clean(get("maxDem")()) +
			`" height="` +
			$t.clean(get("maxDem")()) +
			`"></canvas> </span> <span class='three-view-canvas-cnt'> <b>Front</b> <canvas id="three-view-front" width="` +
			$t.clean(get("maxDem")()) +
			`" height="` +
			$t.clean(get("maxDem")()) +
			`"></canvas> </span> </div> </div> </div> `
	
	exports['-182533851'] = (get, $t) => 
			`<span class='border-location-cnt'> <label>` +
			$t.clean(get("i")) +
			`</label> <input type="radio" name="index-` +
			$t.clean(get("obj").id) +
			`" value="` +
			$t.clean(get("i")) +
			`" ` +
			$t.clean(get("state").index === get("i") ? 'checked' : '') +
			`> </span>`
	
	exports['managers/template/openings/opening-points'] = (get, $t) => 
			`<<table> <tr> <td>display(coords.outer[0])</td> <td></td> <td></td> <td>display(coords.outer[0])</td> </tr> </table> `
	
	exports['managers/template/openings/points'] = (get, $t) => 
			`<table> <tr> <td` +
			$t.clean(get("target")(4) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").outer[0])) +
			`</td> <td></td> <td></td> <td` +
			$t.clean(get("target")(5) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").outer[1])) +
			`</td> </tr> <tr> <td></td> <td` +
			$t.clean(get("target")(0) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").inner[0])) +
			`</td> <td` +
			$t.clean(get("target")(1) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").inner[1])) +
			`</td> <td></td> </tr> <tr> <td></td> <td` +
			$t.clean(get("target")(3) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").inner[3])) +
			`</td> <td` +
			$t.clean(get("target")(2) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").inner[2])) +
			`</td> <td></td> </tr> <tr> <td` +
			$t.clean(get("target")(7) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").outer[3])) +
			`</td> <td></td> <td></td> <td` +
			$t.clean(get("target")(6) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").outer[2])) +
			`</td> </tr> </table> `
	
	exports['-1304800590'] = (get, $t) => 
			`<div class='divison-section-cnt'> ` +
			$t.clean(get("OpenSectionDisplay").html(get("opening").sectionProperties())) +
			` </div>`
	
});


RequireJS.addFunction('./public/json/cabinets.json',
function (require, exports, module) {
	module.exports = {
	  "corner-wall": {
	  "_TYPE": "CabinetTemplate",
	
	  "ID_ATTRIBUTE": "id",
	  "type": "corner-wall",
	  "values": [
	    {
	      "key": "bo",
	      "eqn": "4*2.54",
	      "id": "pz0usts"
	    },
	    {
	      "key": "fwl",
	      "eqn": "c.w - rw",
	      "id": "v47f8o3"
	    },
	    {
	      "key": "fwr",
	      "eqn": "c.t - lw",
	      "id": "ammy5c5"
	    },
	    {
	      "key": "bottomInsetDepth",
	      "eqn": "0",
	      "id": "h1i4yon"
	    },
	    {
	      "key": "topInsetDepth",
	      "eqn": "0",
	      "id": "r30qsyq"
	    },
	    {
	      "key": "lw",
	      "eqn": "30.48",
	      "id": "r8els3r"
	    },
	    {
	      "key": "rw",
	      "eqn": "30.48",
	      "id": "zoxsnu9"
	    },
	    {
	      "key": "cnrD",
	      "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)",
	      "id": "vju4ekg"
	    },
	    {
	      "key": "pbw",
	      "eqn": "Math.sqrt((bo+pb.t)*(bo+pb.t)*2)",
	      "id": "bg3l1cw"
	    },
	    {
	      "key": "backhyp",
	      "eqn": "Math.sqrt((pl.t*pl.t)*2)",
	      "id": "zmra3po"
	    },
	    {
	      "key": "frontLeftTheta",
	      "eqn": "Math.atan(fwr/fwl)",
	      "id": "woqnfe1"
	    },
	    {
	      "key": "frontHype",
	      "eqn": "Math.sqrt(fwl*fwl + fwr*fwr)",
	      "id": "u1sgalg"
	    },
	    {
	      "key": "cutWidth",
	      "eqn": "frontHype * 2",
	      "id": "egcyi4x"
	    },
	    {
	      "key": "frontHypeCenterD",
	      "eqn": "fwr/2",
	      "id": "fwll2bq"
	    },
	    {
	      "key": "frontHypeCenterX",
	      "eqn": "fwl/2",
	      "id": "c0gj6ud"
	    },
	    {
	      "key": "cutCenterX",
	      "eqn": "frontHypeCenterX - frontHype * Math.sin(frontLeftTheta)",
	      "id": "otayvu9"
	    },
	    {
	      "key": "cutCenterD",
	      "eqn": "frontHypeCenterD - frontHype * Math.cos(frontLeftTheta)",
	      "id": "ekillpb"
	    },
	    {
	      "key": "backCutterDem",
	      "eqn": "bo*2*Math.sin(Math.toRadians(pb.r.y))",
	      "id": "nvnsugh"
	    },
	    {
	      "key": "topInnerLimit",
	      "eqn": "c.h - topInsetDepth - pt.t",
	      "id": "zj8uuj1"
	    },
	    {
	      "key": "topOuterLimit",
	      "eqn": "c.h",
	      "id": "3liro7c"
	    },
	    {
	      "key": "bottomInnerLimit",
	      "eqn": "bottomInsetDepth + pbtm.t",
	      "id": "ddjl8d0"
	    },
	    {
	      "key": "bottomOuterLimit",
	      "eqn": 0,
	      "id": "0y39vqw"
	    },
	    {
	      "key": "leftInnerLimit",
	      "eqn": "pl.t",
	      "id": "oto8hml"
	    },
	    {
	      "key": "leftOuterLimit",
	      "eqn": "0",
	      "id": "s0ynin6"
	    },
	    {
	      "key": "leftCutTheta",
	      "eqn": "Math.PI - frontLeftTheta - Math.PI12",
	      "id": "d91x5l5"
	    },
	    {
	      "key": "leftCutT",
	      "eqn": "pl.t * Math.sin(leftCutTheta)/ Math.sin(Math.PI12 - leftCutTheta)",
	      "id": "c1zmc1s"
	    },
	    {
	      "key": "rightCutTheta",
	      "eqn": "frontLeftTheta",
	      "id": "moxhnw5"
	    },
	    {
	      "key": "rightCutX",
	      "eqn": "pr.t * Math.sin(rightCutTheta)/ Math.sin(Math.PI12 - rightCutTheta)",
	      "id": "476p6b2"
	    },
	    {
	      "key": "rightInnerLimit",
	      "eqn": "fwl",
	      "id": "dnmesi3"
	    },
	    {
	      "key": "rightOuterLimit",
	      "eqn": "fwl",
	      "id": "9syndoq"
	    },
	    {
	      "key": "frontDepthMin",
	      "eqn": 0,
	      "id": "2pfov96"
	    },
	    {
	      "key": "frontDepthMax",
	      "eqn": "fwr",
	      "id": "eflejko"
	    }
	  ],
	  "subassemblies": [
	    {
	      "type": "Panel",
	      "center": [
	        "c.w - bo/2",
	        "c.h/2",
	        "c.t - bo/2"
	      ],
	      "demensions": [
	        "pbw",
	        "c.h",
	        "pwt14"
	      ],
	      "rotation": [
	        0,
	        "45",
	        0
	      ],
	      "name": "Panel.Back",
	      "code": "pb",
	      "id": "ly2p41u"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "c.t",
	        "c.h/2",
	        "c.w"
	      ],
	      "demensions": [
	        "backCutterDem",
	        "c.h",
	        "backCutterDem"
	      ],
	      "rotation": [
	        0,
	        "135",
	        0
	      ],
	      "name": "Cutter.Back",
	      "code": "cb",
	      "id": "ly2p41z"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "pl.w/2",
	        "c.h / 2",
	        "pl.t/2"
	      ],
	      "demensions": [
	        "c.w",
	        "c.h",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        "0",
	        0
	      ],
	      "name": "Panel.Left",
	      "code": "pl",
	      "id": "67tkjp5"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "pr.t/2",
	        "c.h/2",
	        "pr.w/2"
	      ],
	      "demensions": [
	        "c.t",
	        "c.h",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        "90",
	        0
	      ],
	      "name": "Panel.Right",
	      "code": "pr",
	      "id": "kfuwf6d"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "pbl.w / 2 + pl.t ",
	        "c.h/2",
	        "c.t - t / 2"
	      ],
	      "demensions": [
	        "c.w - bo",
	        "c.h",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        0,
	        0
	      ],
	      "name": "Panel.Back.Left",
	      "code": "pbl",
	      "id": "qnpktr8"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "1000",
	        "pbl.c.y",
	        "pbl.c.z + pbl.t"
	      ],
	      "demensions": [
	        "pbl.d.x",
	        "pbl.d.y",
	        "pbl.d.z"
	      ],
	      "rotation": [
	        "pbl.r.x",
	        "pbl.r.y",
	        "pbl.r.z"
	      ],
	      "name": "Cutter.Back.Left",
	      "code": "cpbl",
	      "id": "qnpktr2"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "c.w - pbr.t/2",
	        "c.h/2",
	        "pbr.w/2 + pr.t"
	      ],
	      "demensions": [
	        "c.t - bo",
	        "c.h",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        "90",
	        0
	      ],
	      "name": "Panel.Back.Right",
	      "code": "pbr",
	      "id": "a1yypp5"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "1000",
	        "pbr.c.y",
	        "pbr.c.z"
	      ],
	      "demensions": [
	        "pbr.d.x",
	        "pbr.d.y",
	        "pbr.d.z"
	      ],
	      "rotation": [
	        "pbr.r.x",
	        "pbr.r.y",
	        "pbr.r.z"
	      ],
	      "name": "Cutter.Back.Right",
	      "code": "cpbr",
	      "id": "qnpktw2"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "c.w / 2",
	        "c.h - topInsetDepth - t / 2",
	        "c.t / 2"
	      ],
	      "demensions": [
	        "c.w - pbr.t - pl.t",
	        "c.t - pbl.t - pr.t",
	        "pwt34"
	      ],
	      "rotation": [
	        "90",
	        "0",
	        0
	      ],
	      "name": "Panal.top",
	      "code": "pt",
	      "id": "0p8zyq0"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "c.w / 2",
	        "bottomInsetDepth + t / 2",
	        "c.t / 2"
	      ],
	      "demensions": [
	        "c.w - pbr.t - pl.t",
	        "c.t - pbl.t - pr.t",
	        "pwt34"
	      ],
	      "rotation": [
	        "90",
	        "0",
	        0
	      ],
	      "name": "Panal.top",
	      "code": "pbtm",
	      "id": "uqb7ksc"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "cutCenterX",
	        "c.h/2",
	        "cutCenterD"
	      ],
	      "demensions": [
	        "frontHype * 2",
	        "frontHype*2",
	        "c.h"
	      ],
	      "rotation": [
	        "90",
	        "Math.toDegrees(frontLeftTheta)",
	        0
	      ],
	      "name": "Cutter.Front",
	      "code": "cut",
	      "id": "t2nx210"
	    }
	  ],
	  "joints": [
	    {
	      "malePartCode": "pb",
	      "femalePartCode": "pbtm",
	      "type": "Butt",
	      "id": "jhdiitu"
	    },
	    {
	      "malePartCode": "pb",
	      "femalePartCode": "pbr",
	      "type": "Butt",
	      "id": "tfovv9r"
	    },
	    {
	      "malePartCode": "pb",
	      "femalePartCode": "pbl",
	      "type": "Butt",
	      "id": "i49ifbe"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbtm",
	      "femalePartCode": "pr",
	      "maleOffset": "pr.t / 2",
	      "demensionAxis": "y",
	      "centerAxis": "-z",
	      "id": "0zszlb9"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbtm",
	      "femalePartCode": "pl",
	      "maleOffset": "pl.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "-x",
	      "id": "vbwtc6l"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbtm",
	      "femalePartCode": "pbl",
	      "maleOffset": "pbl.t/2",
	      "demensionAxis": "y",
	      "centerAxis": "+z",
	      "id": "x8qno2z"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbtm",
	      "femalePartCode": "pbr",
	      "maleOffset": "pbr.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "+x",
	      "id": "3zyqkyg"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pt",
	      "femalePartCode": "pr",
	      "maleOffset": "pr.t / 2",
	      "demensionAxis": "y",
	      "centerAxis": "-z",
	      "id": "ho44x8c"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pt",
	      "femalePartCode": "pl",
	      "maleOffset": "pl.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "-x",
	      "id": "f2yqowv"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pt",
	      "femalePartCode": "pbl",
	      "maleOffset": "pbl.t/2",
	      "demensionAxis": "y",
	      "centerAxis": "+z",
	      "id": "xlic9x8"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pt",
	      "femalePartCode": "pbr",
	      "maleOffset": "pbr.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "+x",
	      "id": "dv1u67c"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbl",
	      "femalePartCode": "pl",
	      "maleOffset": "pl.t",
	      "demensionAxis": "x",
	      "centerAxis": "+y",
	      "id": "861ea5i"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbr",
	      "femalePartCode": "pr",
	      "maleOffset": "pr.t",
	      "demensionAxis": "x",
	      "centerAxis": "+y",
	      "id": "t0ywrvc"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "pb",
	      "femalePartCode": "pt",
	      "id": "e3z7qur"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cut",
	      "femalePartCode": "pt",
	      "id": "k0atwnf"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cut",
	      "femalePartCode": "pbtm",
	      "id": "4ke3jn9"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cut",
	      "femalePartCode": "pr",
	      "id": "lr1xqx8"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cut",
	      "femalePartCode": "pl",
	      "id": "bk2rjwz"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "pt",
	      "id": "1l5u1lk"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "pbtm",
	      "id": "1zp5rfv"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "pbr",
	      "id": "rs2316q"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "pbl",
	      "id": "m9e5p7l"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cpbl",
	      "femalePartCode": "pb",
	      "id": "l85jpd3"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cpbr",
	      "femalePartCode": "pb",
	      "id": "h3xmpm4"
	    }
	  ],
	  "dividerJoint": {
	    "type": "Dado",
	    "maleOffset": "33"
	  },
	  "shape": "corner",
	  "width": 50.8,
	  "height": 76.2,
	  "thickness": 91.44,
	  "openings": [
	    {
	      "_Type": "location",
	      "rotation": {
	        "x": 0,
	        "z": 0,
	        "y": "270+ Math.toDegrees(frontLeftTheta)"
	      },
	      "flipNormal": true, 
	      "coordinates": {
	        "inner": [
	          {
	            "x": "rightInnerLimit - leftCutT",
	            "y": "topInnerLimit",
	            "z": "frontDepthMin + pl.t"
	          },
	          {
	            "x": "leftInnerLimit",
	            "y": "topInnerLimit",
	            "z": "frontDepthMax - rightCutX"
	          },
	          {
	            "x": "leftInnerLimit",
	            "y": "bottomInnerLimit",
	            "z": "frontDepthMax - rightCutX"
	          },
	          {
	            "x": "rightInnerLimit - leftCutT",
	            "y": "bottomInnerLimit",
	            "z": "frontDepthMin + pl.t"
	          }
	        ],
	        "outer": [
	          {
	              "x": "rightOuterLimit",
	              "y": "topOuterLimit",
	              "z": "frontDepthMin"
	          },
	          {
	            "x": "leftOuterLimit",
	            "y": "topOuterLimit",
	            "z": "frontDepthMax"
	          },
	          {
	            "x": "leftOuterLimit",
	            "y": "bottomOuterLimit",
	            "z": "frontDepthMax"
	          },
	          {
	            "x": "rightOuterLimit",
	            "y": "bottomOuterLimit",
	            "z": "frontDepthMin"
	          }
	        ]
	      },
	
	      "state": {
	        "innerOouter": true,
	        "index": 0,
	        "xOyOz": "z"
	      }
	    }
	  ]
	},
	"corner-wall(L)": {
	    "_TYPE": "CabinetTemplate",
	    "ID_ATTRIBUTE": "id",
	    "shape": "cornerL",
	    "type": "corner-wall(L)",
	    "width": 60.96,
	    "height": 76.2,
	    "thickness": 60.96,
	    "values": [
	      {
	        "key": "bo",
	        "eqn": "4*2.54"
	      },
	      {
	        "key": "fwl",
	        "eqn": "c.t - rw"
	      },
	      {
	        "key": "fwr",
	        "eqn": "c.w - lw"
	      },
	      {
	        "key": "bottomInsetDepth",
	        "eqn": "0"
	      },
	      {
	        "key": "topInsetDepth",
	        "eqn": "0"
	      },
	      {
	        "key": "lw",
	        "eqn": "12*2.54"
	      },
	      {
	        "key": "rw",
	        "eqn": "12 * 2.54"
	      },
	      {
	        "key": "cnrD",
	        "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)"
	      },
	      {
	        "key": "pbw",
	        "eqn": "Math.sqrt((bo+pb.t)*(bo+pb.t)*2)"
	      },
	      {
	        "key": "plhyp",
	        "eqn": "Math.sqrt((pl.t*pl.t)*2)"
	      },
	      {
	        "key": "backCutterDem",
	        "eqn": "bo*2*Math.sin(Math.toRadians(pb.r.y))",
	        "id": "nvnsugh"
	      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Panel",
	        "center": [
	          "c.t - bo/2",
	          "c.h/2",
	          "c.w - bo/2"
	        ],
	        "demensions": [
	          "pbw",
	          "c.h",
	          "pwt14"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Panel.Back",
	        "code": "pb"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "c.t",
	          "c.h/2",
	          "c.w"
	        ],
	        "demensions": [
	          "backCutterDem",
	          "c.h",
	          "backCutterDem"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Cutter.Back",
	        "code": "cb",
	        "id": "ly2p41z"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "(c.t - rw) + rw / 2",
	          "c.h / 2",
	          "pr.t / 2"
	        ],
	        "demensions": [
	          "rw",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.Right",
	        "code": "pr"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pl.t/2",
	          "c.h/2",
	          "(c.w - lw) + lw/2"
	        ],
	        "demensions": [
	          "lw",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Left",
	        "code": "pl"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pbl.w / 2 + pl.t ",
	          "c.h/2",
	          "c.w - t / 2"
	        ],
	        "demensions": [
	          "c.t - bo",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.back.Left",
	        "code": "pbl"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbl.c.x",
	          "pbl.c.y",
	          "pbl.c.z + pbl.t"
	        ],
	        "demensions": [
	          "pbl.d.x",
	          "pbl.d.y",
	          "pbl.d.z"
	        ],
	        "rotation": [
	          "pbl.r.x",
	          "pbl.r.y",
	          "pbl.r.z"
	        ],
	        "name": "Cutter.Back.Left",
	        "code": "cpbl",
	        "id": "qnpktr2"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "c.t - pbr.t/2",
	          "c.h/2",
	          "pbr.w/2 + pr.t"
	        ],
	        "demensions": [
	          "c.w - bo",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Back.Right",
	        "code": "pbr"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbr.c.x + pbr.t",
	          "pbr.c.y",
	          "pbr.c.z"
	        ],
	        "demensions": [
	          "pbr.d.x",
	          "pbr.d.y",
	          "pbr.d.z"
	        ],
	        "rotation": [
	          "pbr.r.x",
	          "pbr.r.y",
	          "pbr.r.z"
	        ],
	        "name": "Cutter.Back.Right",
	        "code": "cpbr",
	        "id": "qnpktw2"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "c.t / 2",
	          "c.h - topInsetDepth - t / 2",
	          "c.w / 2"
	        ],
	        "demensions": [
	          "c.t - pbr.t - pl.t",
	          "c.w - pbl.t - pr.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panal.top",
	        "code": "pt"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "c.t / 2",
	          "bottomInsetDepth + t / 2",
	          "c.w / 2"
	        ],
	        "demensions": [
	          "c.t - pbr.t - pl.t",
	          "c.w - pbl.t - pr.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panal.top",
	        "code": "pbtm"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "fwl / 2",
	          "c.h/2",
	          "fwr/2"
	        ],
	        "demensions": [
	          "fwl",
	          "fwr",
	          "c.h"
	        ],
	        "rotation": [
	          "90",
	          0,
	          0
	        ],
	        "name": "Cutter.Front",
	        "code": "cut"
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "pb",
	        "femalePartCode": "pbtm",
	        "type": "Butt"
	      },
	      {
	        "malePartCode": "pb",
	        "femalePartCode": "pbr",
	        "type": "Butt"
	      },
	      {
	        "malePartCode": "pb",
	        "femalePartCode": "pbl",
	        "type": "Butt"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbtm",
	        "femalePartCode": "pr",
	        "maleOffset": "pr.t / 2",
	        "demensionAxis": "y",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbtm",
	        "femalePartCode": "pl",
	        "maleOffset": "pl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbtm",
	        "femalePartCode": "pbl",
	        "maleOffset": "pbl.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbtm",
	        "femalePartCode": "pbr",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pt",
	        "femalePartCode": "pr",
	        "maleOffset": "pr.t / 2",
	        "demensionAxis": "y",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pt",
	        "femalePartCode": "pl",
	        "maleOffset": "pl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pt",
	        "femalePartCode": "pbl",
	        "maleOffset": "pbl.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pt",
	        "femalePartCode": "pbr",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbl",
	        "femalePartCode": "pl",
	        "maleOffset": "pl.t",
	        "demensionAxis": "x",
	        "centerAxis": "+y"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbr",
	        "femalePartCode": "pr",
	        "maleOffset": "pr.t",
	        "demensionAxis": "x",
	        "centerAxis": "+y"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "pb",
	        "femalePartCode": "pt"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "pt"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "pbtm"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pt",
	        "id": "1l5u1lk"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbtm",
	        "id": "1zp5rfv"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbr",
	        "id": "rs2316q"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbl",
	        "id": "m9e5p7l"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbl",
	        "femalePartCode": "pb",
	        "id": "5wcdhey"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbr",
	        "femalePartCode": "pb",
	        "id": "30v1e8f"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": "33"
	    },
	    "openings": []
	  },
	  "base": {
	    "type": "base",
	    "width": 45.72,
	    "height": 86.36,
	    "thickness": 60.96,
	    "values": [
	      {"key": "brh", "eqn": "tkb.w + pback.t + brr"},
	      {"key": "innerWidth", "eqn": "c.w - pwt34 * 2"},
	      {"key": "innerWidthCenter", "eqn": "innerWidth + pwt34"}
	    ],
	    "subassemblies": [
	      {
	        "name": "ToeKickBacker",
	        "type": "Panel",
	        "code": "tkb",
	        "center": ["c.w / 2", "w / 2", "tkd + (t / 2)"],
	        "demensions": ["tkh", "innerWidth", "tkbw"],
	        "rotation": [0,0,90]
	      },
	      {
	        "name": "Right",
	        "type": "Panel",
	        "code": "pr",
	        "center": ["c.w - (pr.t / 2)", "l / 2", "(w / 2)"],
	        "demensions": ["c.t", "c.l", "pwt34"],
	        "rotation": [0,90,0]
	      },
	      {
	        "name": "Left",
	        "type": "Panel",
	        "code": "pl",
	        "center": ["(t / 2)", " l / 2", " (w/2)"],
	        "demensions": ["c.t", "c.l", "pwt34"],
	        "rotation": [0,90,0]
	      },
	      {
	        "name": "Back",
	        "type": "Panel",
	        "code": "pback",
	        "center": ["l / 2 + pl.t", " (w / 2) + tkb.w", " c.t - (t / 2)"],
	        "demensions": ["c.l - tkb.w", "innerWidth", "pwt34"],
	        "rotation": [0,0,90]
	      },
	      {
	        "name": "Bottom",
	        "type": "Panel",
	        "code": "pb",
	        "center": ["c.w / 2", "tkh + (t/2)", "w / 2"],
	        "demensions": ["c.t - pback.t", "innerWidth", "pwt34"],
	        "rotation": [90,90, 0]
	      },
	      {
	        "name": "Top",
	        "type": "Panel",
	        "code": "pt",
	        "center": ["c.w / 2", "c.h - pwt34/2", "(w / 2)"],
	        "demensions": ["(c.t - pback.t) * .2", "innerWidth", "pwt34"],
	        "rotation": [90,90, 0]
	      },
	      {
	        "name": "Top",
	        "type": "Panel",
	        "code": "pt2",
	        "center": ["c.w / 2", "c.h - pwt34/2", "c.t - pback.t - (w / 2)"],
	        "demensions": ["(c.t - pback.t) * .2", "innerWidth", "pwt34"],
	        "rotation": [90,90, 0]
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "pt",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "pt",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis":"y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "pt2",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "pt2",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis":"y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "pback",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "pback",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis":"y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis":"y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis":"y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "pb",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis":"y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "pb",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis":"y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "pb",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis":"x",
	        "centerAxis": "+y"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": 0.9525,
	    },
	    "openings": [
	      {
	        "top": "pt",
	        "bottom": "pb",
	        "left": "pl",
	        "right": "pr",
	        "back": "pback"
	      }
	    ]
	  },
	  "wall": {
	    "_TYPE": "CabinetTemplate",
	    "ID_ATTRIBUTE": "id",
	    "width": 45.72,
	    "height": 76.2,
	    "thickness": 30.48,
	    "type": "wall",
	    "values": [
	      {
	        "key": "bottomInsetDepth",
	        "eqn": "0"
	      },
	      {
	        "key": "topInsetDepth",
	        "eqn": "0"
	      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - pr.t/2",
	          "c.h / 2",
	          "pr.w / 2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Right",
	        "code": "pr"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pl.t/2",
	          "c.h/2",
	          "pl.w/2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Left",
	        "code": "pl"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pl.t + pb.w/2",
	          "pb.h/2 + pbtm.t",
	          "c.t - pb.t /2"
	        ],
	        "demensions": [
	          "c.w - pl.t - pr.t",
	          "c.h - pbtm.t -pt.t",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.back",
	        "code": "pb"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pl.t + pt.w / 2",
	          "c.h - pt.t/2",
	          "pt.l/2 "
	        ],
	        "demensions": [
	          "c.w - pl.t - pr.t",
	          "c.t ",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panal.top",
	        "code": "pt"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pbtm.w /2 + pl.t",
	          "pbtm.t/2",
	          "pbtm.h / 2"
	        ],
	        "demensions": [
	          "c.w - pl.t - pr.t",
	          "c.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panal.Bottom",
	        "code": "pbtm"
	      }
	    ],
	    "joints": [
	      {
	        "type": "Dado",
	        "malePartCode": "pb",
	        "femalePartCode": "pt",
	        "maleOffset": "pt.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+y"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pb",
	        "femalePartCode": "pr",
	        "maleOffset": "pr.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pb",
	        "femalePartCode": "pbtm",
	        "maleOffset": "pbtm.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "-y"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pb",
	        "femalePartCode": "pl",
	        "maleOffset": "pl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": "33"
	    },
	    "openings": []
	  },
	  "corner-base(L)": {
	  "_TYPE": "CabinetTemplate",
	  "width": 91.44,
	  "height": 86.36,
	  "thickness": 91.44,
	  "ID_ATTRIBUTE": "id",
	  "shape": "cornerL",
	  "type": "corner-base(L)",
	  "values": [
	    {
	      "key": "bo",
	      "eqn": "4*2.54"
	    },
	    {
	      "key": "fwl",
	      "eqn": "c.t - rw"
	    },
	    {
	      "key": "fwr",
	      "eqn": "c.w - lw"
	    },
	    {
	      "key": "bottomInsetDepth",
	      "eqn": "0"
	    },
	    {
	      "key": "topInsetDepth",
	      "eqn": "0"
	    },
	    {
	      "key": "lw",
	      "eqn": "24*2.54"
	    },
	    {
	      "key": "rw",
	      "eqn": "24 * 2.54"
	    },
	    {
	      "key": "cnrD",
	      "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)"
	    },
	    {
	      "key": "pbw",
	      "eqn": "Math.sqrt((bo+pb.t)*(bo+pb.t)*2)"
	    },
	    {
	      "key": "plhyp",
	      "eqn": "Math.sqrt((pl.t*pl.t)*2)"
	    },
	    {
	      "key": "backCutterDem",
	      "eqn": "bo*2*Math.sin(Math.toRadians(pb.r.y))",
	      "id": "nvnsugh"
	    }
	  ],
	  "subassemblies": [
	    {
	      "type": "Panel",
	      "center": [
	        "c.t - bo/2",
	        "c.h/2",
	        "c.w - bo/2"
	      ],
	      "demensions": [
	        "pbw",
	        "c.h",
	        "pwt14"
	      ],
	      "rotation": [
	        0,
	        "135",
	        0
	      ],
	      "name": "Panel.Back",
	      "code": "pb"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "c.t",
	        "c.h/2",
	        "c.w"
	      ],
	      "demensions": [
	        "backCutterDem",
	        "c.h",
	        "backCutterDem"
	      ],
	      "rotation": [
	        0,
	        "135",
	        0
	      ],
	      "name": "Cutter.Back",
	      "code": "cb",
	      "id": "ly2p41z"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "(c.t - rw) + rw / 2",
	        "c.h / 2",
	        "pr.t / 2"
	      ],
	      "demensions": [
	        "rw",
	        "c.h",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        0,
	        0
	      ],
	      "name": "Panel.Right",
	      "code": "pr"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "pl.t/2",
	        "c.h/2",
	        "(c.w - lw) + lw/2"
	      ],
	      "demensions": [
	        "lw",
	        "c.h",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        "90",
	        0
	      ],
	      "name": "Panel.Left",
	      "code": "pl"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "pbl.w / 2 + pl.t ",
	        "c.h/2",
	        "c.w - t / 2"
	      ],
	      "demensions": [
	        "c.t - bo",
	        "c.h",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        0,
	        0
	      ],
	      "name": "Panel.back.Left",
	      "code": "pbl"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "pbl.c.x",
	        "pbl.c.y",
	        "pbl.c.z + pbl.t"
	      ],
	      "demensions": [
	        "pbl.d.x",
	        "pbl.d.y",
	        "pbl.d.z"
	      ],
	      "rotation": [
	        "pbl.r.x",
	        "pbl.r.y",
	        "pbl.r.z"
	      ],
	      "name": "Cutter.Back.Left",
	      "code": "cpbl",
	      "id": "qnpktr2"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "c.t - pbr.t/2",
	        "c.h/2",
	        "pbr.w/2 + pr.t"
	      ],
	      "demensions": [
	        "c.w - bo",
	        "c.h",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        "90",
	        0
	      ],
	      "name": "Panel.Back.Right",
	      "code": "pbr"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "pbr.c.x + pbr.t",
	        "pbr.c.y",
	        "pbr.c.z"
	      ],
	      "demensions": [
	        "pbr.d.x",
	        "pbr.d.y",
	        "pbr.d.z"
	      ],
	      "rotation": [
	        "pbr.r.x",
	        "pbr.r.y",
	        "pbr.r.z"
	      ],
	      "name": "Cutter.Back.Right",
	      "code": "cpbr",
	      "id": "qnpktw2"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "c.t / 2",
	        "c.h - topInsetDepth - t / 2",
	        "c.w / 2"
	      ],
	      "demensions": [
	        "c.t - pbr.t - pl.t",
	        "c.w - pbl.t - pr.t",
	        "pwt34"
	      ],
	      "rotation": [
	        "90",
	        "0",
	        0
	      ],
	      "name": "Panal.top",
	      "code": "pt"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "c.t / 2",
	        "tkh + t / 2",
	        "c.w / 2"
	      ],
	      "demensions": [
	        "c.t - pbr.t - pl.t",
	        "c.w - pbl.t - pr.t",
	        "pwt34"
	      ],
	      "rotation": [
	        "90",
	        "0",
	        0
	      ],
	      "name": "Panal.top",
	      "code": "pbtm"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "fwl / 2",
	        "c.h/2",
	        "fwr/2"
	      ],
	      "demensions": [
	        "fwl",
	        "fwr",
	        "c.h"
	      ],
	      "rotation": [
	        "90",
	        0,
	        0
	      ],
	      "name": "Cutter.Front",
	      "code": "cut",
	
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "pl.t + tkbl.l/2",
	        "tkh/2",
	        "fwr + tkbl.t/2 + tkd"
	      ],
	      "demensions": [
	        "tkh",
	        "fwl + tkd - tkbr.t/2",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        0,
	        "90"
	      ],
	
	      "name": "Panel.ToeKick.Backer.Left",
	      "code": "tkbl"
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "fwl + pl.t + tkd",
	        "tkh/2",
	        "tkbr.l/2 + pr.t "
	      ],
	      "demensions": [
	        "tkh",
	        "fwr + tkd",
	        "pwt34"
	      ],
	      "rotation": [
	        "90",
	        "0",
	        "90"
	      ],
	
	      "name": "Panel.ToeKick.Backer.Right",
	      "code": "tkbr"
	    }
	  ],
	  "joints": [
	    {
	      "malePartCode": "pb",
	      "femalePartCode": "pbtm",
	      "type": "Butt"
	    },
	    {
	      "malePartCode": "pb",
	      "femalePartCode": "pbr",
	      "type": "Butt"
	    },
	    {
	      "malePartCode": "pb",
	      "femalePartCode": "pbl",
	      "type": "Butt"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbtm",
	      "femalePartCode": "pr",
	      "maleOffset": "pr.t / 2",
	      "demensionAxis": "y",
	      "centerAxis": "-z"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbtm",
	      "femalePartCode": "pl",
	      "maleOffset": "pl.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "-x"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbtm",
	      "femalePartCode": "pbl",
	      "maleOffset": "pbl.t/2",
	      "demensionAxis": "y",
	      "centerAxis": "+z"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbtm",
	      "femalePartCode": "pbr",
	      "maleOffset": "pbr.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "+x"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pt",
	      "femalePartCode": "pr",
	      "maleOffset": "pr.t / 2",
	      "demensionAxis": "y",
	      "centerAxis": "-z"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pt",
	      "femalePartCode": "pl",
	      "maleOffset": "pl.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "-x"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pt",
	      "femalePartCode": "pbl",
	      "maleOffset": "pbl.t/2",
	      "demensionAxis": "y",
	      "centerAxis": "+z"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pt",
	      "femalePartCode": "pbr",
	      "maleOffset": "pbr.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "+x"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbl",
	      "femalePartCode": "pl",
	      "maleOffset": "pl.t",
	      "demensionAxis": "x",
	      "centerAxis": "+y"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "pbr",
	      "femalePartCode": "pr",
	      "maleOffset": "pr.t",
	      "demensionAxis": "x",
	      "centerAxis": "+y"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "pb",
	      "femalePartCode": "pt"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cut",
	      "femalePartCode": "pt",
	
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cut",
	      "femalePartCode": "pbtm",
	
	    },
	    {
	
	      "type": "Dado",
	      "malePartCode": "tkbl",
	      "femalePartCode": "tkbr",
	      "maleOffset": "tkbr.t/2",
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	
	      "type": "Dado",
	      "malePartCode": "tkbl",
	      "femalePartCode": "pl",
	      "maleOffset": "pl.t/2",
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "tkbr",
	      "femalePartCode": "pr",
	      "maleOffset": "pr.t/2",
	      "demensionAxis": "y",
	      "centerAxis": "-z"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "pt",
	      "id": "1l5u1lk"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "pbtm",
	      "id": "1zp5rfv"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "pbr",
	      "id": "rs2316q"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "pbl",
	      "id": "m9e5p7l"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cpbl",
	      "femalePartCode": "pb",
	      "id": "5wcdhey"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cpbr",
	      "femalePartCode": "pb",
	      "id": "30v1e8f"
	    }
	  ],
	  "dividerJoint": {
	    "type": "Dado",
	    "maleOffset": "33"
	  },
	  "openings": []
	},
	  "corner-base-blind (R)": {
	  "_TYPE": "CabinetTemplate",
	  "width": 121.92,
	  "height": 86.36,
	  "thickness": 60.96,
	  "ID_ATTRIBUTE": "id",
	  "type": "corner-base-blind",
	  "values": [
	    {
	      "key": "brh",
	      "eqn": "tkb.w + pback.t + brr",
	
	    },
	    {
	      "key": "innerWidth",
	      "eqn": "c.w - pwt34 * 2",
	
	    },
	    {
	      "key": "innerWidthCenter",
	      "eqn": "innerWidth + pwt34",
	
	    },
	    {
	
	      "key": "blindDepth",
	      "eqn": "24*2.54"
	    },
	    {
	
	      "key": "innerHeight",
	      "eqn": "c.h - tkh - pb.t"
	    }
	  ],
	  "subassemblies": [
	    {
	      "name": "ToeKickBacker",
	      "type": "Panel",
	      "code": "tkb",
	      "center": [
	        "c.w / 2",
	        "w / 2",
	        "tkd + (t / 2)"
	      ],
	      "demensions": [
	        "tkh",
	        "innerWidth",
	        "tkbw"
	      ],
	      "rotation": [
	        0,
	        0,
	        90
	      ],
	
	    },
	    {
	      "name": "Right",
	      "type": "Panel",
	      "code": "pr",
	      "center": [
	        "c.w - (pr.t / 2)",
	        "l / 2",
	        "(w / 2)"
	      ],
	      "demensions": [
	        "c.t",
	        "c.l",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        90,
	        0
	      ],
	
	    },
	    {
	      "name": "Left",
	      "type": "Panel",
	      "code": "pl",
	      "center": [
	        "(t / 2)",
	        " l / 2",
	        " (w/2)"
	      ],
	      "demensions": [
	        "c.t",
	        "c.l",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        90,
	        0
	      ],
	
	    },
	    {
	      "name": "Back",
	      "type": "Panel",
	      "code": "pback",
	      "center": [
	        "l / 2 + pl.t",
	        " (w / 2) + tkb.w",
	        " c.t - (t / 2)"
	      ],
	      "demensions": [
	        "c.l - tkb.w",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        0,
	        90
	      ],
	
	    },
	    {
	      "name": "Bottom",
	      "type": "Panel",
	      "code": "pb",
	      "center": [
	        "c.w / 2",
	        "tkh + (t/2)",
	        "w / 2"
	      ],
	      "demensions": [
	        "c.t - pback.t",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        90,
	        0
	      ],
	
	    },
	    {
	      "name": "Top",
	      "type": "Panel",
	      "code": "pt",
	      "center": [
	        "c.w / 2",
	        "c.h - pwt34/2",
	        "(w / 2)"
	      ],
	      "demensions": [
	        "(c.t - pback.t) * .2",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        90,
	        0
	      ],
	
	    },
	    {
	      "name": "Top2",
	      "type": "Panel",
	      "code": "pt2",
	      "center": [
	        "c.w / 2",
	        "c.h - pwt34/2",
	        "c.t - pback.t - (w / 2)"
	      ],
	      "demensions": [
	        "(c.t - pback.t) * .2",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        90,
	        0
	      ],
	
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "blindDepth + 2*2.54 - bms.w/2",
	        "tkh + pb.t + bms.h/2",
	        "bms.t/2"
	      ],
	      "demensions": [
	        "6*2.54",
	        "innerHeight",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        0,
	        0
	      ],
	
	      "name": "Panel.Blind.MiddleSupport",
	      "code": "bms"
	    }
	  ],
	  "joints": [
	    {
	      "malePartCode": "pt",
	      "femalePartCode": "pl",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x",
	
	    },
	    {
	      "malePartCode": "pt",
	      "femalePartCode": "pr",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x",
	
	    },
	    {
	      "malePartCode": "pt2",
	      "femalePartCode": "pl",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x",
	
	    },
	    {
	      "malePartCode": "pt2",
	      "femalePartCode": "pr",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x",
	
	    },
	    {
	      "malePartCode": "pback",
	      "femalePartCode": "pl",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x",
	
	    },
	    {
	      "malePartCode": "pback",
	      "femalePartCode": "pr",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x",
	
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "pl",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x",
	
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "pr",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x",
	
	    },
	    {
	      "malePartCode": "pb",
	      "femalePartCode": "pl",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x",
	
	    },
	    {
	      "malePartCode": "pb",
	      "femalePartCode": "pr",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x",
	
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "pb",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "x",
	      "centerAxis": "+y",
	
	    }
	  ],
	  "dividerJoint": {
	    "type": "Dado",
	    "maleOffset": 0.9525
	  },
	  "openings": [
	    {
	      "top": "pt",
	      "bottom": "pb",
	      "left": "pl",
	      "right": "pr",
	      "back": "pback",
	
	    }
	  ]
	},
	  "ut": {
	    "_TYPE": "CabinetTemplate",
	    "width": 60.96,
	    "height": 243.84,
	    "thickness": 60.96,
	    "ID_ATTRIBUTE": "id",
	    "type": "ut",
	    "values": [
	      {
	        "key": "brh",
	        "eqn": "tkb.w + pback.t + brr",
	
	      },
	      {
	        "key": "innerWidth",
	        "eqn": "c.w - pwt34 * 2",
	
	      },
	      {
	        "key": "innerWidthCenter",
	        "eqn": "innerWidth + pwt34",
	
	      },
	      {
	
	        "key": "insetTop",
	        "eqn": "4*2.54"
	      }
	    ],
	    "subassemblies": [
	      {
	        "name": "ToeKickBacker",
	        "type": "Panel",
	        "code": "tkb",
	        "center": [
	          "c.w / 2",
	          "w / 2",
	          "tkd + (t / 2)"
	        ],
	        "demensions": [
	          "tkh",
	          "innerWidth",
	          "tkbw"
	        ],
	        "rotation": [
	          0,
	          0,
	          90
	        ],
	
	      },
	      {
	        "name": "Right",
	        "type": "Panel",
	        "code": "pr",
	        "center": [
	          "c.w - (pr.t / 2)",
	          "l / 2",
	          "(w / 2)"
	        ],
	        "demensions": [
	          "c.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          90,
	          0
	        ],
	
	      },
	      {
	        "name": "Left",
	        "type": "Panel",
	        "code": "pl",
	        "center": [
	          "(t / 2)",
	          " l / 2",
	          " (w/2)"
	        ],
	        "demensions": [
	          "c.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          90,
	          0
	        ],
	
	      },
	      {
	        "name": "Back",
	        "type": "Panel",
	        "code": "pback",
	        "center": [
	          "l / 2 + pl.t",
	          " (w / 2) + tkb.w",
	          " c.t - (t / 2)"
	        ],
	        "demensions": [
	          "c.l - tkb.w - pt.t - insetTop",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          90
	        ],
	
	      },
	      {
	        "name": "Bottom",
	        "type": "Panel",
	        "code": "pb",
	        "center": [
	          "c.w / 2",
	          "tkh + (t/2)",
	          "w / 2"
	        ],
	        "demensions": [
	          "c.t - pback.t",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          90,
	          0
	        ],
	
	      },
	      {
	        "name": "Top",
	        "type": "Panel",
	        "code": "pt",
	        "center": [
	          "c.w / 2",
	          "c.h - pwt34/2 - insetTop",
	          "(w / 2)"
	        ],
	        "demensions": [
	          "c.t",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          90,
	          0
	        ],
	
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pl.t + innerWidth/2",
	          "c.h - insetTop/2",
	          "tf.t/2"
	        ],
	        "demensions": [
	          "insetTop",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "0",
	          "90"
	        ],
	
	        "name": "Panel.Top.Filler",
	        "code": "tf"
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "pt",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x",
	
	      },
	      {
	        "malePartCode": "pt",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x",
	
	      },
	      {
	        "malePartCode": "pback",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x",
	
	      },
	      {
	        "malePartCode": "pback",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x",
	
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x",
	
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x",
	
	      },
	      {
	        "malePartCode": "pb",
	        "femalePartCode": "pl",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x",
	
	      },
	      {
	        "malePartCode": "pb",
	        "femalePartCode": "pr",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x",
	
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "pb",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "x",
	        "centerAxis": "+y",
	
	      },
	      {
	
	        "type": "Dado",
	        "malePartCode": "pback",
	        "femalePartCode": "pt",
	        "maleOffset": "pt.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+y"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": 0.9525
	    },
	    "openings": [
	      {
	        "top": "pt",
	        "bottom": "pb",
	        "left": "pl",
	        "right": "pr",
	        "back": "pback",
	
	      }
	    ]
	  },
	}
	
});


RequireJS.addFunction('./app-src/position.js',
function (require, exports, module) {
	

	
	const getDefaultSize = require('./utils.js').getDefaultSize;
	const FunctionCache = require('../../../public/js/utils/services/function-cache.js');
	
	class Position {
	  constructor(assembly, sme) {
	
	    function getSme(attr, obj) {
	      if (attr === undefined) {
	        return {x: sme.eval(obj.x),
	          y: sme.eval(obj.y),
	          z: sme.eval(obj.z)}
	      } else {
	        return sme.eval(obj[attr], assembly);
	      }
	    }
	
	    let center, demension, rotation;
	    let demCoords = {};
	    let centerCoords = {};
	
	    if ((typeof assembly.rotationConfig) !== 'function') {
	      const rotCoords = Position.parseCoordinates(assembly.rotationConfig, '0,0,0');
	      rotation = (attr) => getSme(attr, rotCoords);
	    } else {
	      rotation = assembly.rotationConfig;
	    }
	
	    if ((typeof assembly.centerConfig) !== 'function') {
	      centerCoords = Position.parseCoordinates(assembly.centerConfig, '0,0,0');
	      center = (attr) => getSme(attr, centerCoords);
	    } else {
	      center = assembly.centerConfig;
	    }
	
	    if ((typeof assembly.demensionConfig) !== 'function') {
	      const defSizes = getDefaultSize(assembly);
	      demCoords = Position.parseCoordinates(assembly.demensionConfig,
	      `${defSizes.width},${defSizes.length},${defSizes.thickness}`,
	      '0,0,0');
	      demension = (attr) => getSme(attr, demCoords);
	    } else new Promise(function(resolve, reject) {
	      demension = assembly.demensionConfig
	    });
	
	
	
	    function get(func, sme) {
	      if ((typeof func) === 'function' && (typeof func()) === 'object') return func;
	      return sme;
	    }
	
	
	    const rootAssembly = assembly.getRoot();
	    if (rootAssembly.constructor.name === 'Cabinet') {
	      const cacheId = rootAssembly.id();
	      this.rotation = new FunctionCache((attr) => rotation(attr), null, cacheId, assembly);
	      this.center = new FunctionCache((attr) => center(attr), null, cacheId, assembly);
	      this.demension = new FunctionCache((attr) => demension(attr), null, cacheId, assembly);
	    } else {
	      this.rotation = (attr) => rotation(attr);
	      this.center = (attr) => center(attr);
	      this.demension = (attr) => demension(attr);
	    }
	
	    this.current = () => {
	      const position = {
	        center: this.center(),
	        demension: this.demension(),
	        rotation: this.rotation()
	      };
	      assembly.getJoints().male.forEach((joint) =>
	        joint.updatePosition(position)
	      );
	      return position;
	    }
	
	    this.centerAdjust = (center, direction) => {
	      const magnitude = direction[0] === '-' ? -1 : 1;
	      const axis = direction.replace(/\+|-/, '');
	      return this.center(center) + (magnitude * this.demension(axis) / 2);
	    }
	
	    this.limits = (targetStr) => {
	      if (targetStr !== undefined) {
	        const match = targetStr.match(/^(\+|-|)([xyz])$/)
	        const attr = match[2];
	        const d = this.demension(attr)/2;
	        const pos = `+${attr}`;
	        const neg = `-${attr}`;
	        const limits = {};
	        limits[pos] = d;
	        if (match[1] === '+') return limits[pos];
	        limits[neg] = -d;
	        if (match[1] === '-') return limits[neg];
	        return  limits;
	      }
	      const d = this.demension();
	      return  {
	        x: d.x / 2,
	        '-x': -d.x / 2,
	        y: d.y / 2,
	        '-y': -d.y / 2,
	        z: d.z / 2,
	        '-z': -d.z / 2,
	      }
	    }
	
	    this.set = (obj, type, value) => {
	      if (value !== undefined) obj[type] = value;
	      return demension(type);
	    }
	
	    this.setDemension = (type, value) => this.set(demCoords, type, value);
	    this.setCenter = (type, value) => this.set(centerCoords, type, value);
	  }
	}
	
	Position.targeted = (attr, x, y, z) => {
	  const all = attr === undefined;
	  const dem = {
	    x: all || attr === 'x' && x(),
	    y: all || attr === 'y' && y(),
	    z: all || attr === 'z' && z()
	  };
	  return all ? {x,y,z} : dem[attr];
	}
	Position.axisStrRegex = /(([xyz])(\(([0-9]*)\)|))/;
	Position.rotateStrRegex = new RegExp(Position.axisStrRegex, 'g');
	Position.touching = (pos1, pos2) => {
	  const touchingAxis = (axis) => {
	    if (pos1[`${axis}1`] === pos2[`${axis}0`])
	      return {axis: `${axis}`, direction: '+'};
	    if (pos1[`${axis}0`] === pos2[`${axis}1`])
	      return {axis: `${axis}`, direction: '-'};
	  }
	  if (!Position.within(pos1, pos2)) return null;
	  return touchingAxis('x') || touchingAxis('y') || touchingAxis('z') || null;
	}
	Position.within = (pos1, pos2, axises) => {
	  const axisTouching = (axis) => {
	    if (axises !== undefined && axises.index(axis) === -1) return true;
	    const p10 = pos1[`${axis}0`];
	    const p11 = pos1[`${axis}1`];
	    const p20 = pos2[`${axis}0`];
	    const p21 = pos2[`${axis}1`];
	    return (p10 >= p20 && p10 <= p21) ||
	            (p11 <= p21 && p11 >= p20);
	  }
	  return axisTouching('x') && axisTouching('y') && axisTouching('z');
	}
	
	Position.parseCoordinates = function() {
	  let coordinateMatch = null;
	  for (let index = 0; coordinateMatch === null && index < arguments.length; index += 1) {
	    const str = arguments[index];
	    if (index > 0 && arguments.length - 1 === index) {
	      //console.error(`Attempted to parse invalid coordinateStr: '${JSON.stringify(arguments)}'`);
	    }
	    if (typeof str === 'string') {
	      coordinateMatch = str.match(Position.demsRegex);
	    }
	  }
	  if (coordinateMatch === null) {
	    throw new Error(`Unable to parse coordinates`);
	  }
	  return {
	    x: coordinateMatch[1],
	    y: coordinateMatch[2],
	    z: coordinateMatch[3]
	  }
	}
	Position.demsRegex = /([^,]{1,}?),([^,]{1,}?),([^,]{1,})/;
	module.exports = Position
	
});


RequireJS.addFunction('./app-src/init.js',
function (require, exports, module) {
	

	
	require('../../../public/js/utils/utils.js');
	const $t = require('../../../public/js/utils/$t');
	$t.loadFunctions(require('../generated/html-templates'));
	require('./displays/user.js');
	
	// Object Classes
	// require('./bind.js');
	require('./objects/assembly/init-assem');
	require('./objects/joint/init');
	require('./two-d/objects/snap/init');
	const Order = require('./objects/order.js');
	const Assembly = require('./objects/assembly/assembly.js');
	const Properties = require('./config/properties.js');
	const PopUp = require('../../../public/js/utils/display/pop-up.js');
	
	// Display classes
	const du = require('../../../public/js/utils/dom-utils.js');
	const EPNTS = require('../generated/EPNTS.js');
	const Displays = require('./services/display-svc.js');
	const OrderDisplay = require('./displays/order.js');
	const TwoDLayout = require('./two-d/layout.js');
	const ThreeDMainModel = require('./displays/three-d-main.js');
	const PropertyDisplay = require('./displays/property.js');
	const DisplayManager = require('./display-utils/displayManager.js');
	const utils = require('./utils.js');
	
	// Run Tests
	if (EPNTS.getEnv() === 'local') {
	  require('../test/run');
	}
	
	function updateDivisions (target) {
	  const name = target.getAttribute('name');
	  const index = Number.parseInt(target.getAttribute('index'));
	  const value = Number.parseFloat(target.value);
	  const inputs = target.parentElement.parentElement.querySelectorAll('.division-pattern-input');
	  const id = du.find.up('.opening-cnt', target).getAttribute('opening-id');
	  const opening = Assembly.get(id);
	  const values = opening.dividerLayout().fill;
	  for (let index = 0; values && index < inputs.length; index += 1){
	    const value = values[index];
	    if(value) inputs[index].value = value;
	  }
	  ThreeDMainModel.update(opening);
	}
	
	function getValue(code, obj) {
	  if ((typeof obj) === 'object' && obj[code] !== undefined) return obj[code];
	  return CONSTANTS[code].value;
	}
	
	
	const urlSuffix = du.url.breakdown().path.split('/')[2];
	const pageId = {template: 'template-manager', cost: 'cost-manager', home: 'app',
	                pattern: 'pattern-manager', property: 'property-manager-cnt'
	              }[urlSuffix] || 'app';
	function init(body){
	  Properties.load(body);
	  let roomDisplay;
	  let order;
	
	  const propertyDisplay = new PropertyDisplay('#property-manager');
	  Displays.register('propertyDisplay', propertyDisplay);
	  require('./cost/init-costs.js');
	  const mainDisplayManager = new DisplayManager('display-ctn', 'menu', 'menu-btn', pageId);
	  const modelDisplayManager = new DisplayManager('model-display-cnt', 'display-menu');
	  if (urlSuffix === 'cost') {
	    const CostManager = require('./displays/managers/cost.js');
	    const costManager = new CostManager('cost-manager', 'cost');
	  } else if (urlSuffix === 'template') {
	    const TemplateManager = require('./displays/managers/template.js');
	    const templateDisplayManager = new TemplateManager('template-manager');
	  } else {
	    du.on.match('change', '.open-orientation-radio,.open-division-input', updateDivisions);
	    orderDisplay = new OrderDisplay('#order-cnt');
	    setTimeout(TwoDLayout.init, 1000);
	    setTimeout(ThreeDMainModel.init, 1000);
	  }
	}
	
	Request.get(EPNTS.config.get(), init, console.error);
	
	const popUp = new PopUp({resize: false, noBackdrop: true});
	
	du.on.match('click', '*', (elem, event) => {
	  const errorMsg = elem.getAttribute('error-msg');
	  if (errorMsg) {
	    popUp.positionOnElement(elem).bottom();
	    popUp.updateContent(errorMsg);
	    popUp.show();
	    event.stopPropagation();
	  } else popUp.close();
	});
	
});


RequireJS.addFunction('./app-src/show.js',
function (require, exports, module) {
	

	
	const Panel = require('./objects/assembly/assemblies/panel.js');
	
	class Show {
	  constructor(name) {
	    this.name = name;
	    Show.types[name] = this;
	  }
	}
	Show.types = {};
	Show.listTypes = () => Object.values(Show.types);
	new Show('None');
	new Show('Flat');
	new Show('Inset Panel');
	module.exports = Show
	
	
	
	
	
});


RequireJS.addFunction('./app-src/error.js',
function (require, exports, module) {
	

	
	
	
	class InvalidComputation {
	  constructor(attributes) {
	    this.errorCode = 400;
	    this.message = 'Error within input parameters';
	    const keys = Object.keys(attributes);
	    for (let index = 0; index < keys.length; index += 1) {
	      const key = keys[index];
	      this.message += `\n\t${key}: '${value}'`;
	    }
	  }
	}
	module.exports = InvalidComputation
	
	
	
	
	
});


RequireJS.addFunction('./app-src/division-patterns.js',
function (require, exports, module) {
	
const Measurement = require('../../../public/js/utils/measurement.js')
	
	class Pattern {
	  constructor(str) {
	    this.str = str;
	    let unique = {};
	    for (let index = 0; index < str.length; index += 1) {
	      const char = str[index];
	      if (unique[char] === undefined) {
	        unique[char] = {char, count: 1};
	      } else {
	        unique[char].count++;
	      }
	    }
	    const uniqueStr = Object.keys(unique).join('');
	    this.unique = () => uniqueStr;
	    this.equal = this.unique.length === 1;
	    class Element {
	      constructor(id, index, count) {
	        let value;
	        this.id = id;
	        this.count = count || 1;
	        this.indexes = [index];
	        this.value = (val) => {
	          if (val !== undefined) {
	            Pattern.mostResent[id] = val;
	            value = new Measurement(val);
	          }
	          return value;
	        }
	      }
	    }
	
	    if ((typeof str) !== 'string' || str.length === 0)
	      throw new Error('Must define str (arg0) as string of length > 1');
	
	    const elements = {};
	    const values = {};
	    const updateOrder = [];
	    for (let index = 0; index < str.length; index += 1) {
	      const char = str[index];
	      if (elements[char]) {
	        elements[char].count++;
	        elements[char].indexes.push(index);
	      } else {
	        elements[char] = new Element(char, index);
	        if (Pattern.mostResent[char] !== undefined) {
	          elements[char].value(Pattern.mostResent[char]);
	          updateOrder.push(char);
	        }
	      }
	    }
	
	    this.ids = Object.keys(elements);
	    this.size = str.length;
	    let lastElem;
	    this.satisfied = () => updateOrder.length === uniqueStr.length - 1;
	
	    const numbersOnlyReg = /^[0-9]{1,}$/;
	    const calc = (dist) => {
	      const values = {};
	
	      const uniqueVals = Object.values(unique);
	      if (uniqueVals.length === 1) {
	        const count = uniqueVals[0].count;
	        const value = dist / count;
	        const str = uniqueVals.char;
	        //Cant remember exactly what values is used for... bad naming
	        const values = new Array(count).fill(value);
	        const list = new Array(count).fill(value);
	        const fill = [value];
	        return {values, list, fill, str};
	      }
	
	      if (str.trim().match(numbersOnlyReg)) {
	        let count = 0;
	        for (let index = 0; index < str.length; index += 1) {
	          count += Number.parseInt(str.charAt(index));
	        }
	        const unitDist = dist / count;
	        let retObj = {list: [], fill: [], str, values: {}};
	        for (let index = 0; index < str.length; index += 1) {
	          const char = str.charAt(index);
	          const units = Number.parseInt(char);
	          const value = units * unitDist;
	          retObj.list[index] = value;
	          if (retObj.values[char] === undefined) {
	            retObj.values[char] = value;
	            retObj.fill[retObj.list.fill.length] = value;
	          }
	        }
	        return retObj;
	      }
	      updateOrder.forEach((id) => {
	        const elem = elements[id];
	        dist -= elem.count * elem.value().decimal();
	        values[elem.id] = elem.value().value();
	      });
	      if (lastElem === undefined) {
	        for (let index = 0; index < uniqueVals.length; index += 1) {
	          const char = uniqueVals[index].char;
	          if (!values[char]) {
	            if (lastElem === undefined) lastElem = elements[char];
	            else {lastElem = undefined; break;}
	          }
	        }
	      }
	      if (lastElem !== undefined) {
	        lastElem.value(new Measurement(dist / lastElem.count).value());
	        values[lastElem.id] = lastElem.value().value();
	      }
	      const list = [];
	      const fill = [];
	      if (lastElem){
	        for (let index = 0; index < uniqueVals.length; index += 1) {
	          fill[index] = elements[uniqueVals[index].char].value().display();
	        }
	      }
	      for (let index = 0; index < str.length; index += 1)
	        list[index] = values[str[index]];
	      const retObj = {values, list, fill, str};
	      return retObj;
	    }
	
	    this.value = (id, value) => {
	      if (value !== undefined) {
	        const index = updateOrder.indexOf(id);
	        if (index !== -1) updateOrder.splice(index, 1);
	        updateOrder.push(id);
	        if (updateOrder.length === this.ids.length) {
	          lastElem = elements[updateOrder[0]];
	          updateOrder.splice(0, 1);
	        }
	        elements[id].value(value);
	      } else {
	        return elements[id].value().decimal();
	      }
	    }
	
	    this.display = (id) => elements[id].value().display();
	
	    this.toJson = () => {
	      const json = this.calc();
	      delete json.list;
	      delete json.fill;
	      Object.keys(json.values).forEach((key) => {
	        if (Number.isNaN(json.values[key])) {
	          delete json.values[key];
	        }
	      })
	      return json;
	    }
	
	    this.elements = elements;
	    this.calc = calc;
	  }
	}
	
	Pattern.fromJson = (json) => {
	  const pattern = new Pattern(json.str);
	  const keys = Object.keys(pattern.values);
	  keys.foEach((key) => pattern.value(key, pattern.values[key]));
	  return pattern;
	};
	Pattern.mostResent = {};
	
	const p1 = new Pattern('babcdaf');
	p1.value('b', 2);
	p1.value('a', 2);
	p1.value('c', 3);
	p1.value('d', 4);
	p1.value('b', 2);
	p1.value('f', 5);
	p1.calc(20);
	const p2 = new Pattern(' // ^^%');
	module.exports = Pattern
	
});


RequireJS.addFunction('./app-src/utils.js',
function (require, exports, module) {
	

	
	
	const removeSuffixes = ['Part', 'Section'].join('|');
	function formatConstructorId (obj) {
	  return obj.constructor.name.replace(new RegExp(`(${removeSuffixes})$`), '');
	}
	
	function getDefaultSize(instance) {
	  const constructorName = instance.constructor.name;
	  if (constructorName === 'Cabinet') return {length: 24 * 2.54, width: 50*2.54, thickness: 21*2.54};
	  return {length: 0, width: 0, thickness: 0};
	}
	
	exports.formatConstructorId = formatConstructorId;
	exports.getDefaultSize = getDefaultSize;
	
});


RequireJS.addFunction('./app-src/config/cabinet-configs.js',
function (require, exports, module) {
	

	
	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	const cabinetBuildConfig = require('../../public/json/cabinets.json');
	const Select = require('../../../../public/js/utils/input/styles/select.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const Inputs = require('../input/inputs.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const Cabinet = require('../objects/assembly/assemblies/cabinet.js');
	const Request = require('../../../../public/js/utils/request.js');
	const EPNTS = require('../../generated/EPNTS.js');
	const CabinetTemplate = require('./cabinet-template');
	const ValueCondition = require('../../../../public/js/utils/input/decision/decision.js').ValueCondition;
	
	class CabinetConfig {
	  constructor() {
	    let cabinetList = {};
	    let cabinetKeys = {};
	    let configKeys;
	    const updateEvent = new CustomEvent('update');
	    function setLists(cabinets) {
	      const allCabinetKeys = Object.keys(cabinets);
	      allCabinetKeys.forEach((key) => {
	        const type = cabinets[key].partName;
	        if (cabinetKeys[type] === undefined)  cabinetKeys[type] = {};
	        if (cabinetKeys[type][key] === undefined)  cabinetKeys[type][key] = {};
	        cabinetKeys[type][key] = cabinets[key];
	      });
	
	      cabinetList = cabinets;
	      configKeys = Object.keys(cabinetBuildConfig);
	      updateEvent.trigger();
	    }
	
	    this.valid = (type, id) => (!id ?
	    cabinetBuildConfig[type] : cabinetKeys[type][id]) !== undefined;
	
	    this.onUpdate = (func) => updateEvent.on(func);
	    this.inputTree = () => {
	      const types = JSON.parse(JSON.stringify(configKeys));
	      const typeInput = new Select({
	        name: 'type',
	        class: 'center',
	        list: types
	      });
	      const nameInput = new Input({
	        name: 'name',
	        label: 'Name (optional)',
	        class: 'center',
	      });
	      const inputs = [typeInput, nameInput];
	      const inputTree = new DecisionInputTree();
	      inputTree.onSubmit((t) => {
	        inputTree.payload().inputArray[1].setValue('', true)
	        inputTree.children()[0].payload().inputArray[0].setValue('', true)
	      });
	      const cabinet = inputTree.branch('Cabinet', inputs);
	      const cabinetTypes = Object.keys(cabinetKeys);
	      types.forEach((type) => {
	
	        const cabinetInput = new Input({
	          label: 'Layout (Optional)',
	          name: 'id',
	          class: 'center',
	          clearOnDblClick: true,
	          list: [''].concat(cabinetKeys[type] ? Object.keys(cabinetKeys[type]) : [])
	        });
	        cabinet.conditional(type, new ValueCondition('type', type, [cabinetInput]));
	      });
	      return inputTree;
	    };
	    this.get = (group, type, propertyId, id) => {
	      let cabinet;
	      if (!cabinetList || !cabinetList[id]) cabinet = Cabinet.build(type, group);
	      else cabinet = Cabinet.fromJson(cabinetList[id], group);
	      cabinet.name(id);
	      return cabinet;
	    };
	
	    Request.get(EPNTS.cabinet.list(), setLists, setLists);
	  }
	}
	
	CabinetConfig = new CabinetConfig();
	module.exports = CabinetConfig
	
});


RequireJS.addFunction('./app-src/config/property.js',
function (require, exports, module) {
	
const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	
	
	
	class Property extends Lookup {
	  // clone constructor(code, value) {
	  constructor(code, name, props) {
	    super();
	    let value;// = (typeof props) === 'object' && props !== null ? props.value : undefined;
	    const children = [];
	
	    const initVals = {
	      code, name, description: props instanceof Object ? props.description : undefined
	    }
	    Object.getSet(this, initVals, 'value', 'code', 'name', 'description', 'properties');
	
	    this.value = (val, notMetric) => {
	      if (val !== undefined && value !== val) {
	        const measurement = new Measurement(val, notMetric);
	        const measurementVal = measurement.value();
	        value = Number.isNaN(measurementVal) ? val : measurement;
	      }
	      return value instanceof Measurement ? value.value() : value;
	    }
	
	    this.display = () => {
	      return value instanceof Measurement ? value.display() : value;
	    }
	
	    this.measurementId = () => value instanceof Measurement ? value.id() : undefined;
	
	    if ((typeof props) !== 'object' ||  props === null) {
	      this.value(props);
	      props = {};
	    }
	    this.properties(props || {});
	
	    const existingProp = Property.list[code];
	    let clone = false;
	    if (this.properties().value !== undefined) {
	      this.value(this.properties().value, this.properties().notMetric);
	    }
	
	    // if (existingProp) {
	    //   value = value || existingProp.value();
	    //   name = existingProp.name();
	    //   this.properties(existingProp.properties());
	    //   clone = true;
	    // }
	
	    if ((typeof value) === 'number')
	      value = new Measurement(value, this.properties().notMetric);
	
	
	    this.addChild = (property) => {
	      if (property instanceof Property && property.code() === this.code()) {
	            if (children.indexOf(property) === -1) children.push(property);
	            else throw new Error('Property is already a child');
	      }
	      else throw new Error('Child is not an instance of Property or Code does not match');
	    }
	
	    this.children = () => JSON.clone(children);
	
	    this.equals = (other) =>
	        other instanceof Property &&
	        this.value() === other.value() &&
	        this.code() === other.code() &&
	        this.name() === other.name() &&
	        this.description() === other.description();
	
	    this.clone = (val) => {
	      const cProps = this.properties();
	      cProps.clone = true;
	      cProps.value = val === undefined ? this.value() : val;
	      cProps.description = this.description();
	      delete cProps.notMetric;
	      return new Property(this.code(), this.name(), cProps);
	    }
	    if(!clone) Property.list[code] = this;
	    else if (!this.properties().copy && Property.list[code]) Property.list[code].addChild(this);
	  }
	}
	Property.list = {};
	Property.DO_NOT_CLONE = true;
	
	new Property();
	
	module.exports = Property
	
});


RequireJS.addFunction('./app-src/displays/layout-sketch.js',
function (require, exports, module) {
	
const du = require('../../../../public/js/utils/dom-utils.js');
	const Draw2D = require('../two-d/draw.js');
	const Line2d = require('../two-d/objects/line.js');
	const Vertex2d = require('../two-d/objects/vertex.js');
	const PanZoom = require('../two-d/pan-zoom.js');
	const LineMeasurement2d = require('../two-d/objects/line-measurement.js');
	
	
	class LayouSketch {
	  constructor(id) {
	    let sketch, panZ, elem, cabinet;
	
	    function getSections(sections, list) {
	      list ||= [];
	      for (let index = 0; index < sections.length; index++) {
	        const section = sections[index];
	        if (sections.length > 0 || sections.cover()) {
	          list.push(section);
	          getSections(section.sections, list);
	        }
	      }
	      return list;
	    }
	
	    function draw() {
	      if (cabinet === undefined) return;
	      // sketch.ctx().drawImage(0,0)
	
	      const allLines = [];
	      for (let index = 0; index < cabinet.openings.length; index++) {
	        const sections = getSections(cabinet.openings[index].sections);
	        for (let si = 0; si < sections.length; si++) {
	          const section = sections[si];
	          if (section.sections.length < 1) {
	            const center = JSON.copy(section.innerCenter());
	            center.y*=-1;
	            sketch.text(section.partCode(), center, 6, 'grey');
	          }
	          const inner = JSON.copy(section.coordinates().inner);
	          // For some reason the sketch canvas is mirrored in the y direction
	          inner[0].y*=-1;inner[1].y*=-1;inner[2].y*=-1;inner[3].y*=-1;
	          let lines = [new Line2d(inner[0], inner[1]),
	                          new Line2d(inner[1], inner[2]),
	                          new Line2d(inner[2], inner[3]),
	                          new Line2d(inner[3], inner[0])];
	          sketch(lines, undefined, .3);
	          const outer = JSON.copy(section.coordinates().outer);
	          // For some reason the sketch canvas is mirrored in the y direction
	          outer[0].y*=-1;outer[1].y*=-1;outer[2].y*=-1;outer[3].y*=-1;
	          lines = [new Line2d(outer[0], outer[1]),
	                          new Line2d(outer[1], outer[2]),
	                          new Line2d(outer[2], outer[3]),
	                          new Line2d(outer[3], outer[0])];
	          sketch(lines, 'green', .3);
	          allLines.concatInPlace(lines);
	        }
	      }
	      const cabLimits = cabinet.position().limits();
	      const cabinetOutline = [
	        new Line2d({x: 0, y: -2*cabLimits['y']}, {x: 2*cabLimits['x'], y: -2*cabLimits['y']}),
	        new Line2d({x: 2*cabLimits['x'], y: -2*cabLimits['y']}, {x: 2*cabLimits['x'], y: 0}),
	        new Line2d({x: 2*cabLimits['x'], y: 0}, {x: 0, y: 0}),
	        new Line2d({x: 0, y: 0}, {x: 0, y: -2*cabLimits['y']}),
	      ];
	      sketch(cabinetOutline, 'red', .3);
	      allLines.concatInPlace(cabinetOutline);
	
	      const measurements = LineMeasurement2d.measurements(allLines);
	      sketch(measurements, 'grey', 1);
	    }
	
	    function init() {
	      elem = du.id(id);
	      const canvas = du.create.element('canvas');
	      elem.append(canvas);
	      sketch = new Draw2D(canvas);
	      panZ = new PanZoom(sketch.canvas(), draw);
	    }
	
	    this.cabinet = (cab) => (cab.constructor.name === 'Cabinet' && (cabinet = cab)) || cabinet;
	
	    setTimeout(init, 500);
	  }
	}
	
	module.exports = LayouSketch;
	
});


RequireJS.addFunction('./app-src/config/properties.js',
function (require, exports, module) {
	

	const Property = require('./property');
	const Defs = require('./property/definitions');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const EPNTS = require('../../generated/EPNTS');
	const Request = require('../../../../public/js/utils/request.js');
	
	let unitCount = 0;
	const UNITS = [];
	Measurement.units().forEach((unit) =>
	      UNITS.push(new Property('Unit' + ++unitCount, unit, unit === Measurement.unit())));
	UNITS._VALUE = Measurement.unit();
	
	const assemProps = {}
	const add = (key, properties) => properties.forEach((prop) => {
	  if (assemProps[key] === undefined) assemProps[key] = {};
	  assemProps[key][prop.code()] = prop;
	});
	
	add('Overlay', [Defs.ov]);
	add('Reveal', [Defs.r,Defs.rvt,Defs.rvb,Defs.rvr,Defs.rvl]);
	add('Inset', [Defs.is]);
	add('Cabinet', [Defs.h,Defs.w,Defs.d,Defs.sr,Defs.sl,Defs.rvibr,Defs.rvdd,
	                Defs.tkbw,Defs.tkd,Defs.tkh,Defs.pbt,Defs.iph, Defs.brr,
	                Defs.frw,Defs.frt]);
	add('Panel', [Defs.h,Defs.w,Defs.t]);
	add('Guides', [Defs.l,Defs.dbtos,Defs.dbsos,Defs.dbbos]);
	add('DoorAndFront', [Defs.daffrw,Defs.dafip])
	add('Door', [Defs.h,Defs.w,Defs.t]);
	add('DrawerBox', [Defs.h,Defs.w,Defs.d,Defs.dbst,Defs.dbbt,Defs.dbid,Defs.dbn]);
	add('DrawerFront', [Defs.h,Defs.w,Defs.t,Defs.mfdfd]);
	add('Frame', [Defs.h,Defs.w,Defs.t]);
	add('Handle', [Defs.l,Defs.w,Defs.c2c,Defs.proj]);
	add('Hinge', [Defs.maxtab,Defs.mintab,Defs.maxol,Defs.minol]);
	add('Opening', []);
	
	function definitionsRequired(group) {
	  const required = [];
	  if (assemProps[group] === undefined) return [];
	  Object.values(assemProps[group]).forEach((prop) => {
	    if (prop instanceof Property && prop.value() !== null) required.push(prop);
	  });
	  return required;
	}
	
	function propertiesToDefine() {
	  const propNames = [];
	  const keys = Object.keys(assemProps);
	  keys.forEach((key) => {
	    if (definitionsRequired(key).length !== 0) {
	      propNames.push(key);
	    }
	  });
	  return propNames;
	}
	
	const excludeKeys = ['_ID', '_NAME', '_GROUP', 'properties'];
	function assemProperties(clazz, filter) {
	  clazz = (typeof clazz) === 'string' ? clazz : clazz.constructor.name;
	  props = assemProps[clazz] || [];
	  if ((typeof filter) != 'function') return props;
	  props = props.filter(filter);
	  return props;
	}
	
	
	let config = {};
	const changes = {};
	const copyMap = {};
	assemProperties.changes = {
	  saveAll: () => Object.values(changes).forEach((list) => assemProperties.changes.save(list._ID)),
	  save: (id) => {
	    const list = changes[id];
	    if (!list) throw new Error(`Unkown change id '${id}'`);
	    const group = list._GROUP;
	    if (config[group] === undefined) config[group] = [];
	    if(copyMap[id] === undefined) {
	      config[group][list._NAME] = {name: list._NAME, properties: JSON.clone(list, excludeKeys, true)};
	      copyMap[list._ID] = config[group][list._NAME].properties;
	    } else {
	      const tempList = changes[id];
	      for (let index = 0; index < tempList.length; index += 1) {
	        const tempProp = tempList[index];
	        const configProp = copyMap[id][index];
	        configProp.value(tempProp.value());
	      }
	    }
	   },
	  deleteAll: () => Object.values(changes).forEach((list) => assemProperties.changes.delete(list._GROUP)),
	  delete: (id) => {
	    delete config[changes[id][0].name()][changes[id]._NAME];
	    delete changes[id];
	    delete copyMap[id];
	  },
	  changed: (id) => {
	    const list = changes[id];
	    if (list === undefined) return false;
	    for (let index = 0; index < list.length; index += 1) {
	      const prop = list[index];
	      if (prop === undefined || (copyMap[list._ID] !== undefined && copyMap[list._ID][index] === undefined)) {
	        console.log('booyacka!');
	      }
	      if (copyMap[list._ID] === undefined || !copyMap[list._ID][index].equals(prop)) {
	        return true;
	      }
	    }
	    return false;
	  },
	  changesExist: () => {
	      const lists = Object.values(changes);
	      for (let index = 0; index < lists.length; index += 1) {
	        if (assemProperties.changes.changed(lists[index]._ID)) {
	          return true;
	        }
	      }
	      return false;
	  }
	}
	
	assemProperties.config = () => {
	  const plainObj = {};
	  const keys = Object.keys(config);
	  for (let index = 0; index < keys.length; index += 1) {
	    const key = keys[index];
	    const lists = config[key];
	    const listKeys = Object.keys(lists);
	    plainObj[key] = {};
	    for (let lIndex = 0; lIndex < listKeys.length; lIndex += 1) {
	      const listKey = listKeys[lIndex];
	      const list = lists[listKey];
	      const propObj = {name: listKey, properties: []};
	      plainObj[key][listKey] = propObj;
	      list.properties.forEach((property) =>
	          propObj.properties.push(property.toJson(excludeKeys, true)))
	    }
	  }
	  return plainObj;
	}
	assemProperties.list = () => Object.keys(assemProps);
	assemProperties.new = (group, name) => {
	  if (assemProps[group]) {
	    const list = [];
	    let addIndex = 0;
	    const ogList = Object.values(assemProps[group]);
	    for (let index = 0; index < ogList.length; index += 1) {
	      if (hasValueFilter(ogList[index])) {
	        list[addIndex++] = ogList[index].clone();
	      }
	    }
	    list._ID = String.random();
	    list._GROUP = group;
	    list._NAME = name;
	    changes[list._ID] = list;
	    return list;
	  }
	  throw new Error(`Requesting invalid Property Group '${group}'`);
	}
	
	assemProperties.instance = () => {
	  const keys = Object.keys(assemProps);
	  const clone = {};
	  keys.forEach((key) => {
	    const props = Object.values(assemProps[key]);
	    if (clone[key] === undefined) clone[key] = {};
	    props[keys] = {};
	    props.forEach((prop) => clone[key][prop.code()] = prop.clone());
	  });
	  return clone;
	};
	
	assemProperties.getSet = (group, setName) => {
	  const clone = {};
	  let propertyObj = config[group][setName];
	  propertyObj.properties.forEach((prop) => clone[prop.code()] = prop.clone());
	  clone.__KEY = setName;
	  return clone;
	}
	
	const dummyFilter = () => true;
	assemProperties.groupList = (group, filter) => {
	  filter = filter || dummyFilter;
	  const groupList = config[group];
	  const changeList = {};
	  if (groupList === undefined) return {};
	  const groupKeys = Object.keys(groupList);
	  for (let index = 0; index < groupKeys.length; index += 1) {
	    const groupKey = groupKeys[index];
	    const list = groupList[groupKey];
	    const properties = groupList[list.name].properties;
	    const codes = properties.map((prop) => prop.code());
	    // const newProps = assemProps[group].filter((prop) => codes.indexOf(prop.code()) === -1)
	    //                   .filter(filter);
	    // newProps.forEach((prop) => properties.push(prop.clone()));
	    changeList[list.name] = {name: list.name, properties: []};
	    for (let pIndex = 0; pIndex < properties.length; pIndex += 1) {
	      const prop = properties[pIndex];
	      changeList[list.name].properties.push(prop.clone());
	    }
	    const id = String.random();
	    const set = changeList[list.name].properties;
	    set._ID = id;
	    set._NAME = list.name;
	    changes[id] = set;
	    copyMap[id] = properties;
	  }
	  return changeList;
	}
	
	const hasValueFilter = (prop) => prop.value() !== null;
	assemProperties.hasValue = (group) => {
	  if (props === undefined) return [];
	  return assemProperties.groupList(group, hasValueFilter);
	}
	
	const list = (key) =>
	    assemProps[key] ? Object.values(assemProps[key]) : [];
	
	const noValueFilter = (prop) => prop.value() === null;
	assemProperties.noValue = (group) => {
	  const props = list(group);
	  if (props === undefined) return [];
	  return props.filter(noValueFilter);
	}
	
	assemProperties.all = () => {
	  const props = {};
	  const keys = Object.keys(assemProps);
	  keys.forEach((key) => {
	    const l = [];
	    list(key).forEach((prop) => l.push(prop));
	    props[key] = l;
	  });
	  return props;
	}
	
	assemProperties.UNITS = UNITS;
	
	assemProperties.load = (body) => {
	  config = Object.fromJson(body);
	}
	
	assemProperties.definitionsRequired = definitionsRequired;
	assemProperties.propertiesToDefine = propertiesToDefine;
	module.exports = assemProperties;
	
});


RequireJS.addFunction('./app-src/displays/open-section.js',
function (require, exports, module) {
	

	
	const SectionProperties = require('../objects/assembly/assemblies/section/section-properties.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const bind = require('../../../../public/js/utils/input/bind.js');
	const ExpandableList = require('../../../../public/js/utils/lists/expandable-list.js');
	const MeasurementInput = require('../../../../public/js/utils/input/styles/measurement.js');
	const ThreeDMain = require('./three-d-main.js');
	const StringMathEvaluator = require('../../../../public/js/utils/string-math-evaluator.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const FeatureDisplay = require('./feature');
	const Inputs = require('../input/inputs.js');
	
	
	class SectionDisplay {
	  constructor (section) {
	    this.render = (scope) => {
	      scope.featureDisplay = new FeatureDisplay(scope.opening).html();
	      const cId = scope.opening.constructor.name;
	      if (cId === 'SectionProperties') {
	        return OpenSectionDisplay.html(scope.opening, scope.list, scope.sections);
	      }
	      return SectionDisplay.template(section).render(scope);
	    }
	  }
	}
	
	const templates = {};
	const fileLocations = {};
	SectionDisplay.template = (section) => {
	  const cName = section.constructor.name;
	  if (fileLocations[cName] === undefined) {
	    const filename = cName.replace(/Section$/, '')
	                            .replace(/([a-z])([A-Z])/g, '$1-$2')
	                            .toLowerCase();
	    fileLocations[cName] = `sections/${filename}`;
	  }
	  const templatePath = fileLocations[cName];
	  if (templates[templatePath] === undefined) templates[templatePath] = new $t(templatePath);
	  return templates[templatePath];
	}
	
	du.on.match('change', '.feature-radio', (target) => {
	  const allRadios = document.querySelectorAll(`[name="${target.name}"]`);
	  allRadios.forEach((radio) => radio.nextElementSibling.hidden = true);
	  target.nextElementSibling.hidden = !target.checked;
	});
	
	displays = {};
	SectionDisplay.render = (scope) => {
	  const uId = scope.opening.id();
	  if (displays[uId] === undefined) displays[uId] = new SectionDisplay(scope.opening);
	  return displays[uId].render(scope);
	}
	
	const OpenSectionDisplay = {};
	
	OpenSectionDisplay.html = (opening) => {
	  const openDispId = OpenSectionDisplay.getId(opening);
	  opening.init();
	  OpenSectionDisplay.sections[opening.id()] = opening;
	  setTimeout(() => OpenSectionDisplay.refresh(opening), 100);
	  const patternInputHtml = OpenSectionDisplay.patterInputHtml(opening);
	  return OpenSectionDisplay.template.render({opening, openDispId, patternInputHtml});
	}
	
	OpenSectionDisplay.getSelectId = (opening) => `opin-division-pattern-select-${opening.id()}`;
	OpenSectionDisplay.template = new $t('opening');
	OpenSectionDisplay.listBodyTemplate = new $t('divide/body');
	OpenSectionDisplay.listHeadTemplate = new $t('divide/head');
	OpenSectionDisplay.sections = {};
	OpenSectionDisplay.lists = {};
	OpenSectionDisplay.getId = (opening) => `open-section-display-${opening.id()}`;
	
	OpenSectionDisplay.getList = (root) => {
	  let openId = root.id();
	  if (OpenSectionDisplay.lists[openId]) return OpenSectionDisplay.lists[openId];
	  const sections = SectionProperties.sections();
	  const getObject = (target) => sections[Math.floor(Math.random()*sections.length)];
	  const parentSelector = `#${OpenSectionDisplay.getId(root)}`
	  const list = root.sections;
	  const hideAddBtn = true;
	  const selfCloseTab = true;
	  let exList;
	  const clean = (name) => name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/ Section$/, '');
	  const getHeader = (opening, index) => {
	    const sections = index % 2 === 0 ? SectionProperties.sections() : [];
	    return OpenSectionDisplay.listHeadTemplate.render({opening, sections, clean});
	  }
	  const getBody = (opening) => {
	    const list = OpenSectionDisplay.getList(root);
	    const getFeatureDisplay = (assem) => new FeatureDisplay(assem).html();
	    const assemblies = opening.getSubassemblies();
	    return SectionDisplay.render({assemblies, getFeatureDisplay, opening, list, sections});
	  }
	  const findElement = (selector, target) => du.find.down(selector, du.find.up('.expandable-list', target));
	  const expListProps = {
	    parentSelector, getHeader, getBody, getObject, list, hideAddBtn,
	    selfCloseTab, findElement, startClosed: true
	  }
	  exList = new ExpandableList(expListProps);
	  OpenSectionDisplay.lists[openId] = exList;
	  return exList;
	}
	OpenSectionDisplay.dividerControlTemplate = new $t('divider-controls');
	OpenSectionDisplay.updateDividers = (opening) => {
	  const selector = `[opening-id="${opening.id()}"].opening-cnt > .divider-controls`;
	  const dividerControlsCnt = document.querySelector(selector);
	  const selectPatternId = OpenSectionDisplay.getSelectId(opening);
	  bind(`#${selectPatternId}`, (g, p) => opening.pattern(p), /.*/);
	  const patternInputHtml = OpenSectionDisplay.patterInputHtml(opening);
	  dividerControlsCnt.innerHTML = OpenSectionDisplay.dividerControlTemplate.render(
	          {opening, selectPatternId, patternInputHtml});
	}
	
	OpenSectionDisplay.changeIds = {};
	OpenSectionDisplay.refresh = (opening) => {
	  let changeId = (OpenSectionDisplay.changeIds[opening.id()] || 0) + 1;
	  OpenSectionDisplay.changeIds[opening.id()] = changeId;
	  setTimeout(()=> {
	    if (changeId === OpenSectionDisplay.changeIds[opening.id()]) {
	      const id = OpenSectionDisplay.getId(opening);
	      const target = du.id(id);
	      const listCnt = du.find.up('.expandable-list', target);
	      if (!listCnt) return;
	      const listId = Number.parseInt(listCnt.getAttribute('ex-list-id'));
	
	      const type = opening.isVertical() === true ? 'pill' : 'sidebar';
	      OpenSectionDisplay.updateDividers(opening);
	      OpenSectionDisplay.getList(opening).refresh(type);
	      const dividerSelector = `[opening-id='${opening.id()}'].division-count-input`;
	      // listCnt.querySelector(dividerSelector).focus();
	    }
	  }, 500);
	}
	
	OpenSectionDisplay.patternContainerSelector = (opening) =>
	  `.open-pattern-input-cnt[opening-id='${opening.id()}']`;
	
	OpenSectionDisplay.lastInputValues = {};
	OpenSectionDisplay.patterInputHtml = (opening) => {
	  const pattern = opening.pattern();
	  const patCntSelector = OpenSectionDisplay.patternContainerSelector(opening);
	
	  let inputHtml = '';
	  const unique = pattern.unique();
	  for (let index = 0; index < unique.length; index += 1) {
	    const id = unique[index];
	    let fill = opening.dividerLayout().fill;
	    const measInput = Inputs('pattern', {
	      label: id,
	      placeholder: id,
	      name: id,
	      value: fill[index]
	    });
	    measInput.on('keyup', (value, target) => {
	      opening.pattern().value(target.name, Measurement.decimal(target.value));
	      fill = opening.dividerLayout().fill;
	      const patternCnt = document.querySelector(patCntSelector);
	      const inputs = patternCnt.querySelectorAll('input');
	      fill.forEach((value, index) => {
	        if (inputs[index] !== target)
	          inputs[index].value = value;
	      });
	      if (opening.pattern().satisfied()) {
	        const cabinet = opening.getAssembly('c');
	        ThreeDMain.update(cabinet);
	      }
	    });
	    inputHtml += measInput.html();
	  }
	  return inputHtml;
	};
	
	OpenSectionDisplay.getOpening = (target) => {
	  const openId = target.getAttribute('opening-id');
	  return OpenSectionDisplay.sections[openId];
	}
	
	OpenSectionDisplay.evaluator = new StringMathEvaluator();
	
	OpenSectionDisplay.patternInputSelector = (opening) =>
	  `[name='pattern'][opening-id='${opening.id()}']`;
	
	OpenSectionDisplay.onPatternChange = (target) => {
	  const opening = OpenSectionDisplay.getOpening(target);
	  const newVal = target.value || 'a';
	  const cntSelector = OpenSectionDisplay.patternContainerSelector(opening);
	  const inputCnt = document.querySelector(OpenSectionDisplay.patternContainerSelector(opening));
	  if (opening.pattern().str !== newVal) {
	    opening.pattern(newVal).str;
	    const html = OpenSectionDisplay.patterInputHtml(opening);
	    document.querySelector(cntSelector).innerHTML = html;
	    OpenSectionDisplay.refresh(opening);
	    const cabinet = opening.getAssembly('c');
	    ThreeDMain.update(cabinet);
	  }
	  if (inputCnt !== null) {
	    inputCnt.hidden = opening.pattern().equal;
	  }
	}
	
	OpenSectionDisplay.onOrientation = (target) => {
	  const openId = target.getAttribute('open-id');
	  const value = target.value;
	  const opening = OpenSectionDisplay.sections[openId];
	  opening.vertical(value === 'vertical');
	  OpenSectionDisplay.refresh(opening);
	};
	
	OpenSectionDisplay.onSectionChange = (target) => {
	  ExpandableList.value('selected', target.value, target);
	  const section = ExpandableList.get(target);
	  const index = ExpandableList.getIdAndKey(target).key;
	  section.parentAssembly().setSection(target.value, index);
	  OpenSectionDisplay.refresh(section.parentAssembly());
	  ThreeDMain.update(section);
	}
	
	du.on.match('keyup', '.division-pattern-input', OpenSectionDisplay.onPatternChange);
	du.on.match('click', '.open-orientation-radio', OpenSectionDisplay.onOrientation);
	du.on.match('change', '.open-divider-select', OpenSectionDisplay.onSectionChange)
	module.exports = OpenSectionDisplay
	
});


RequireJS.addFunction('./app-src/displays/order.js',
function (require, exports, module) {
	

	
	const du = require('../../../../public/js/utils/dom-utils.js');
	const UFObj = require('./information/utility-filter.js');
	const RoomDisplay = require('./room.js');
	const Order = require('../objects/order.js');
	const Request = require('../../../../public/js/utils/request.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const ExpandableObject = require('../../../../public/js/utils/lists/expandable-object.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const EPNTS = require('../../generated/EPNTS.js')
	const ToggleDisplayList = require('../../app-src/display-utils/toggle-display-list');
	const Inputs = require('../input/inputs.js');
	
	class OrderDisplay {
	  constructor(parentSelector, orders) {
	    const roomDisplays = {};
	    let active;
	    const getHeader = (order, $index) =>
	        OrderDisplay.headTemplate.render({order, $index});
	
	    const setInfo = (order, index) => () => {
	      console.log('oid:', order.id());
	      const elem = du.id(`uf-info-${order.id()}`);
	      if (elem)
	        UTF.buildDisplay(elem, new UFObj(order));
	    }
	
	    function initOrder(order, index) {
	      roomDisplays[order.id()] = new RoomDisplay('#room-pills', order);
	      ToggleDisplayList.onShow(`information-display-${order.id()}`, setInfo(order, index));
	      // expandList.afterRender(setInfo(order, index));
	      return order;
	    }
	
	    function loadOrder(index, start) {
	      return function (orderData) {
	        const order = new Order().fromJson(orderData);
	        initOrder(order, index);
	        expandList.set(index, order);
	        expandList.refresh();
	        console.log('load Time:', new Date().getTime() - start);
	      }
	    }
	
	    const getBody = (order, $index) => {
	      if (order.loaded) {
	        let propertyTypes = Object.keys(['insetfordabet', 'pickles']);
	        active = roomDisplays[order.id()];
	        return OrderDisplay.bodyTemplate.render({$index, order, propertyTypes});
	      } else {
	        const start = new Date().getTime();
	        Request.get(EPNTS.order.get(order.name()), loadOrder($index, start), console.error);
	        return 'Loading...';
	      }
	    }
	    const getObject = (values) => initOrder(new Order(values.name));
	    this.active = () => active;
	
	    const expListProps = {
	      list: orders,
	      inputValidation: (values) => values.name ? true :
	          'You must Define a name',
	      parentSelector, getHeader, getBody, getObject,
	      listElemLable: 'Order', type: 'sidebar',
	      inputTree: OrderDisplay.configInputTree()
	    };
	    const expandList = new ExpandableObject(expListProps);
	    expandList.afterRender(() => {if (active !== undefined) active.refresh()});
	
	    const saveSuccess = () => console.log('success');
	    const saveFail = () => console.log('failure');
	    const save = (target) => {
	      const index = target.getAttribute('index');
	      const order = expandList.get(index);
	      Request.post(EPNTS.order.add(order.name()), order.toJson(), saveSuccess, saveFail);
	      console.log('saving');
	    }
	
	    const attrUpdate = (attr) => (target) => {
	      const index = target.getAttribute('index');
	      const order = expandList.get(index);
	      order[attr] = target.value;
	    };
	
	    function addOrders(names) {
	      names.forEach((name) => expListProps.list[name] = new Order(name, null));
	      expandList.refresh();
	    }
	    Request.get(EPNTS.order.list(), addOrders);
	
	    du.on.match('change', '.order-name-input', attrUpdate('name'));
	    du.on.match('click', '.save-order-btn', save);
	  }
	}
	OrderDisplay.bodyTemplate = new $t('order/body');
	OrderDisplay.headTemplate = new $t('order/head');
	OrderDisplay.builderBodyTemplate = new $t('order/builder/body');
	OrderDisplay.builderHeadTemplate = new $t('order/builder/head');
	OrderDisplay.infoBodyTemplate = new $t('order/information/body');
	OrderDisplay.infoHeadTemplate = new $t('order/information/head');
	
	OrderDisplay.configInputTree = () => {
	  const dit = new DecisionInputTree();
	  dit.leaf('Config', [Inputs('name')]);
	  return dit;
	}
	module.exports = OrderDisplay
	
});


RequireJS.addFunction('./app-src/displays/property.js',
function (require, exports, module) {
	

	
	const Properties = require('../config/properties.js');
	const Property = require('../config/property.js');
	const Cost = require('../cost/cost.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const bind = require('../../../../public/js/utils/input/bind.js');
	const RadioDisplay = require('../display-utils/radio-display.js');
	const EPNTS = require('../../generated/EPNTS');
	const $t = require('../../../../public/js/utils/$t.js');
	const Inputs = require('../input/inputs.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const ExpandableObject = require('../../../../public/js/utils/lists/expandable-object.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	
	// TODO: Rewrite program started to have nested properties no longer making display convoluted(SP).
	const changed = (id) => Properties.changes.changed(id);
	const shouldHide = (prop) => prop.value() === null;
	const hideAll = (properties) => {
	  for (let index = 0; index < properties.length; index += 1) {
	    if (properties[index].value() !== null) return false;
	  }
	  return properties.length > 0;
	}
	
	function updateSaveAll() {
	  const saveAllBtn = du.find('#property-manager-save-all');
	  saveAllBtn.hidden = !Properties.changes.changesExist();
	  if (saveAllBtn.hidden) {
	    const saveBtns = du.find.all('.save-change');
	    saveBtns.forEach((saveBtn) => saveBtn.hidden = true);
	  }
	}
	
	function saveAll() {
	  Properties.changes.saveAll();
	  save();
	  updateSaveAll();
	}
	
	
	function save() {
	  Request.post(EPNTS.config.save(), Properties.config(), console.log, console.error);
	}
	
	function get() {
	  Request.get(EPNTS.config.get(), console.log);
	}
	
	class PropertyDisplay {
	  constructor(containerSelector) {
	    let currProps;
	
	    const noChildren = (properties, groups) => () =>
	          properties.length === 0 && Object.keys(groups).length === 0;
	
	    function childScope (key) {
	      const list = Properties.hasValue(key);
	      if (list.length === 0) return;
	
	      const id = String.random();
	      const getObject = (values) => {
	        let properties = Properties.new(key,  values.name);
	        return {name: values.name, id, changed, properties};
	      }
	      const inputTree = PropertyDisplay.configInputTree();
	      const expListProps = {
	        parentSelector: `#config-expand-list-${id}`,
	        getHeader: (scope) =>
	                    PropertyDisplay.configHeadTemplate.render(scope),
	        getBody: (scope) =>
	                    PropertyDisplay.configBodyTemplate.render({
	                      name: scope.name,
	                      properties: scope.properties,
	                      changed
	                    }),
	        inputValidation: inputTree.validate,
	        listElemLable: 'Config',
	        list, getObject, inputTree
	      };
	      setTimeout(() => {
	        const expList = new ExpandableObject(expListProps);
	        expList.afterRemoval((element, detail) => {
	          console.log(detail);
	          console.log('placehoder');
	          Properties.changes.delete(detail.properties._ID);
	        });
	      }, 500);
	      return id;
	    }
	
	    function getScope(key, group) {
	      key = key || '';
	      const id = String.random();
	      let radioId = group.radioId || PropertyDisplay.counter++;
	      const properties = [];
	      const groups = {};
	      const label = key.replace(PropertyDisplay.camelReg, '$1 $2');
	      const scope = {key, label, properties, groups, recurse, radioId, id,
	                      noChildren: noChildren(properties, groups),
	                      branch: key.match(PropertyDisplay.branchReg)};
	      PropertyDisplay.uniqueMap[id] = scope;
	      const keys = Object.keys(group.values);
	      radioId = PropertyDisplay.counter++;
	      for( let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        const value = group.values[key];
	        childScope(key, id);
	      }
	      return scope;
	    }
	
	    this.update = () => {
	      const propKeys = Properties.propertiesToDefine();
	      const propertyObjs = {};
	      const childIdMap = [];
	      for (let index = 0; index < propKeys.length; index += 1) {
	        const key = propKeys[index];
	        const props = Properties(key);
	        const propObj = props;
	        propertyObjs[key] = propObj;
	        childIdMap[key] = childScope(key);
	      }
	      const id = String.random();
	      const values = {values: propertyObjs, id, childIdMap, hideAll, Properties};
	      const contianer = document.querySelector(containerSelector);
	      contianer.innerHTML =
	          PropertyDisplay.template.render(values);
	    };
	
	    function updateProperties(name, value) {
	    }
	    bind('property-cnt', updateProperties);
	    new RadioDisplay('property-container', 'radio-id');
	    this.update();
	  }
	}
	
	// bind('property-branch-selector', '');
	
	du.on.match('change', 'select[name="property-branch-selector"]', (target) => {
	  const childTargets = target.parentElement.children[1].children;
	  const childElem = childTargets[target.value];
	  // TODO: set config property: childElem.innerText;
	  du.hide(childTargets);
	  du.show(childElem);
	});
	
	function setPropertyElemValue(elem, idAttr, value) {
	  const id = elem.getAttribute(idAttr);
	  const group = elem.getAttribute('name');
	  const property = Property.get(id);
	  property.value(value, true);
	}
	
	function updateMeasurements () {
	  measureElems = du.find.all('[measurement-id]:not([measurement-id=""])');
	  measureElems.forEach((elem) => {
	    const id = elem.getAttribute('measurement-id');
	    const measurement = Measurement.get(id);
	    elem.value = measurement.display();
	  });
	}
	
	function updateRadio(elem) {
	  const name = elem.getAttribute('name');
	  Properties.config()
	  const elems = du.find.all(`input[type="radio"][name='${name}']`);
	  elems.forEach((elem) => setPropertyElemValue(elem, 'prop-radio-update', false));
	  setPropertyElemValue(elem, 'prop-radio-update', true);
	  if (name.substr(0, 4) === 'UNIT') {
	    Measurement.unit(elem.value);
	    updateMeasurements();
	  }
	}
	
	function updateValueDisplay(elem) {
	  const id = elem.getAttribute('measurement-id');
	  const measurement = Measurement.get(id);
	  elem.value = measurement.display();
	}
	
	function updateValue(elem) {
	  setPropertyElemValue(elem, 'prop-value-update', elem.value);
	  const saveBtn = du.find.closest('.save-change', elem);
	  saveBtn.hidden = !changed(saveBtn.getAttribute('properties-id'));
	  const measurementId = Property.get(elem.getAttribute('prop-value-update')).measurementId();
	  elem.setAttribute('measurement-id', measurementId);
	  updateSaveAll();
	}
	
	function updateBoolean(elem) {
	  setPropertyElemValue(elem, 'prop-boolean-update', elem.checked);
	  const saveBtn = du.find.closest('.save-change', elem);
	  saveBtn.hidden = !changed(saveBtn.getAttribute('properties-id'));
	  updateSaveAll();
	}
	
	function saveChange(elem) {
	  const id = elem.getAttribute('properties-id');
	  Properties.changes.save(id);
	  elem.hidden = true;
	  updateSaveAll();
	  save();
	}
	
	
	du.on.match('keyup', '[prop-value-update]', updateValue);
	du.on.match('change', '[prop-boolean-update]', updateBoolean);
	du.on.match('focusout', '[measurement-id]', updateValueDisplay);
	du.on.match('change', '[prop-radio-update]', updateRadio);
	du.on.match('click', '#property-manager-save-all', saveAll);
	du.on.match('click', '[properties-id]:not([properties-id=""])', saveChange);
	
	PropertyDisplay.attrReg = /^_[A-Z_]{1,}/;
	PropertyDisplay.branchReg = /^OR_(.{1,})/;
	PropertyDisplay.camelReg = /([a-z])([A-Z])/g;
	PropertyDisplay.counter = 0;
	PropertyDisplay.template = new $t('properties/properties');
	PropertyDisplay.configBodyTemplate = new $t('properties/config-body');
	PropertyDisplay.configHeadTemplate = new $t('properties/config-head');
	PropertyDisplay.radioTemplate = new $t('properties/radio');
	PropertyDisplay.uniqueMap = {};
	PropertyDisplay.configMap = {};
	
	PropertyDisplay.configInputTree = () => {
	  const dit = new DecisionInputTree(console.log);
	  dit.leaf('Config', [Inputs('name')]);
	  return dit;
	}
	
	module.exports = PropertyDisplay
	
});


RequireJS.addFunction('./app-src/displays/room.js',
function (require, exports, module) {
	

	
	const Room = require('../objects/room.js');
	const CabinetDisplay = require('./cabinet.js');
	const GroupDisplay = require('./group.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const ExpandableObject = require('../../../../public/js/utils/lists/expandable-object.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const Inputs = require('../input/inputs.js');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const TwoDLayout = require('../two-d/layout');
	
	class RoomDisplay extends Lookup {
	  constructor(parentSelector, order) {
	    super(order.id());
	    const groupDisplays = {};
	    const getHeader = (room, $index) =>
	        RoomDisplay.headTemplate.render({room, $index});
	
	    const getBody = (room, $index) => {
	      TwoDLayout.set(room.layout());
	      return RoomDisplay.bodyTemplate.render({$index, room, groupHtml});
	    }
	
	    const groupHtml = (group) => {
	      if (groupDisplays[group.id()] === undefined) {
	        groupDisplays[group.id()] = new GroupDisplay(group);
	      }
	      return groupDisplays[group.id()].html();
	    }
	
	    const getObject = (values) => {
	      const room = new Room(values.name);
	      return room;
	    }
	    this.active = () => expandList.active();
	
	    const expListProps = {
	      list: order.rooms,
	      parentSelector, getHeader, getBody, getObject,
	      inputValidation: (values) => values.name !== '' ? true : 'name must be defined',
	      listElemLable: 'Room', type: 'pill',
	      inputTree: RoomDisplay.configInputTree()
	    };
	    const expandList = new ExpandableObject(expListProps);
	    this.refresh = () => expandList.refresh();
	  }
	}
	
	du.on.match('click', '.group-add-btn', (target) => {
	  const id = target.getAttribute('room-id');
	  const room = Room.get(id);
	  const orderId = du.find.up('[order-id]', target).getAttribute('order-id');
	  const roomDisplay = RoomDisplay.get(orderId);
	  roomDisplay.refresh();
	  room.addGroup();
	});
	
	RoomDisplay.configInputTree = () => {
	  const dit = new DecisionInputTree(console.log);
	  dit.leaf('Room', [Inputs('name')]);
	  return dit;
	}
	RoomDisplay.bodyTemplate = new $t('room/body');
	RoomDisplay.headTemplate = new $t('room/head');
	module.exports = RoomDisplay
	
});


RequireJS.addFunction('./app-src/displays/section.js',
function (require, exports, module) {
	

});


RequireJS.addFunction('./app-src/displays/three-d-main.js',
function (require, exports, module) {
	

	const CSG = require('../../public/js/3d-modeling/csg');
	
	const Assembly = require('../objects/assembly/assembly');
	const Handle = require('../objects/assembly/assemblies/hardware/pull.js');
	const DrawerBox = require('../objects/assembly/assemblies/drawer/drawer-box.js');
	const pull = require('../three-d/models/pull.js');
	const drawerBox = require('../three-d/models/drawer-box.js');
	const Viewer = require('../../public/js/3d-modeling/viewer.js').Viewer;
	const addViewer = require('../../public/js/3d-modeling/viewer.js').addViewer;
	const du = require('../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const ThreeDModel = require('../three-d/three-d-model.js');
	const ThreeView = require('three-view');
	
	
	const cube = new CSG.cube({radius: [3,5,1]});
	const consts = require('../../globals/CONSTANTS');
	let viewer, threeView;
	function init() {
	  // const p = pull(5,2);
	  const p = CSG.sphere({center: {x:0, y:0, z: 0}, radius: 10});
	  p.setColor('black')
	  // const db = drawerBox(10, 15, 22);
	  const canvas2d = du.id('two-d-model');
	  viewer = new Viewer(p, canvas2d.height, canvas2d.width, 50);
	  addViewer(viewer, '#three-d-model');
	  threeView = new ThreeView(viewer);
	
	  const setZFunc = setGreaterZindex('order-cnt', 'model-cnt', `${threeView.id()}-cnt`);
	  du.on.match('click', '#model-cnt', setZFunc);
	  du.on.match('click', '#order-cnt', setZFunc);
	  du.on.match('click', `#${threeView.id()}-cnt`, setZFunc);
	}
	
	// TODO: ????
	function displayPart(part) {
	  return true;
	}
	
	function groupParts(cabinet) {
	  const grouping = {displayPart, group: {groups: {}, parts: {}, level: 0}};
	  const parts = cabinet.getParts();
	  for (let index = 0; index < parts.length; index += 1) {
	    const part = parts[index];
	    const namePieces = part.partName().split('.');
	    let currObj = grouping.group;
	    let level = 0;
	    let prefix = '';
	    for (let nIndex = 0; nIndex < namePieces.length - 1; nIndex += 1) {
	      const piece = namePieces[nIndex];
	      prefix += piece;
	      if (currObj.groups[piece] === undefined) currObj.groups[piece] = {groups: {}, parts: {}};
	      currObj = currObj.groups[piece];
	      currObj.level = ++level;
	      currObj.prefix = prefix;
	      prefix += '.'
	    }
	    if (currObj.parts[part.partName()] === undefined) currObj.parts[part.partName()] = [];
	    currObj.parts[part.partName()].push(part);
	  }
	  return grouping;
	}
	
	const modelContTemplate = new $t('model-controller');
	
	du.on.match('click', '.model-label', (target) => {
	  if (event.target.tagName === 'INPUT') return;
	  const has = target.matches('.active');
	  deselectPrefix();
	  !has ? du.class.add(target, 'active') : du.class.remove(target, 'active');
	  let label = target.children[0]
	  let type = label.getAttribute('type');
	  let value = type !== 'prefix' ? label.innerText :
	        label.nextElementSibling.getAttribute('prefix');
	  const cabinet = lastRendered;
	  const tdm = ThreeDModel.get(cabinet, viewer);
	  let partCode = target.getAttribute('part-code');
	  let partId = target.getAttribute('part-id');
	  if (partId) {
	    if (!has) {
	      tdm.inclusiveTarget(type, partId);
	      threeView.isolatePart(partCode, cabinet);
	    }
	  } else {
	    tdm.inclusiveTarget(type, has ? undefined : value);
	    const elem = du.find.closest('[part-code]', target);
	    partCode = elem.getAttribute('part-code');
	    threeView.isolatePart(partCode, cabinet);
	  }
	  tdm.render();
	});
	
	function deselectPrefix() {
	  document.querySelectorAll('.model-label')
	    .forEach((elem) => du.class.remove(elem, 'active'));
	  const cabinet = lastRendered;
	  const tdm = ThreeDModel.get(cabinet, viewer);
	  tdm.inclusiveTarget(undefined, undefined);
	}
	
	function setGreaterZindex(...ids) {
	  return (target) => {
	    const zMap = [];
	    let zIndexes = [];
	    for (let index = 0; index < ids.length; index += 1) {
	      const id = ids[index];
	      const elem = du.id(id);
	      const zIndex = du.zIndex(elem);
	      zIndexes.push(zIndex);
	      zMap[zIndex] = elem;
	    }
	    zIndexes.sort().reverse();
	    target.style.zIndex = zIndexes[0];
	    for (let index = 0; index < zIndexes.length; index += 1) {
	      const elem = zMap[zIndexes[index]];
	      if (elem === target) {
	        break;
	      } else {
	        elem.style.zIndex = zIndexes[index + 1];
	      }
	    }
	  };
	}
	
	du.on.match('click', '.prefix-switch', (target, event) => {
	  const eventTarg = event.target;
	  const active = du.find.upAll('.model-selector', target);
	  active.push(target.parentElement.parentElement);
	  const all = document.querySelectorAll('.prefix-body');
	  all.forEach((pb) => pb.hidden = true);
	  active.forEach((ms) => ms.children[0].children[1].hidden = false);
	});
	
	du.on.match('change', '.prefix-checkbox', (target) => {
	  const cabinet = lastRendered;
	  const attr = target.getAttribute('prefix');
	  deselectPrefix();
	  ThreeDModel.get(cabinet, viewer).hidePrefix(attr, !target.checked);
	});
	
	du.on.match('change', '.part-name-checkbox', (target) => {
	  const cabinet = lastRendered;
	  const attr = target.getAttribute('part-name');
	  deselectPrefix();
	  const tdm = ThreeDModel.get(cabinet, viewer);
	  tdm.hidePartName(attr, !target.checked);
	  tdm.render();
	});
	
	du.on.match('change', '.part-id-checkbox', (target) => {
	  const cabinet = lastRendered;
	  const attr = target.getAttribute('part-id');
	  deselectPrefix();
	  const tdm = ThreeDModel.get(cabinet, viewer);
	  tdm.hidePartId(attr, !target.checked);
	  tdm.render();
	})
	
	let controllerModel;
	function updateController() {
	  if (controllerModel !== lastRendered) {
	    controllerModel = lastRendered;
	    const controller = du.id('model-controller');
	    const grouping = groupParts(controllerModel);
	    grouping.tdm = ThreeDModel.get(controllerModel, viewer);
	    controller.innerHTML = modelContTemplate.render(grouping);
	    controller.hidden = false;
	  }
	}
	
	
	let lastRendered;
	function update(part) {
	  if (part) lastRendered = part.getAssembly('c');
	  const threeDModel = ThreeDModel.get(lastRendered, viewer);
	  if (threeDModel) {
	    threeDModel.update(lastRendered);
	    updateController();
	  }
	}
	
	module.exports = {init, update}
	
});


RequireJS.addFunction('./app-src/displays/three-view.js',
function (require, exports, module) {
	
const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils');
	const Viewer = require('../../public/js/3d-modeling/viewer.js').Viewer;
	const addViewer = require('../../public/js/3d-modeling/viewer.js').addViewer;
	const pull = require('../three-d/models/pull.js');
	const ThreeDModel = require('../three-d/three-d-model.js');
	const Layout2D = require('../objects/layout.js')
	const Draw2D = require('../two-d/draw.js');
	const Polygon2d = require('../two-d/objects/polygon.js');
	const Polygon3D = require('../three-d/objects/polygon.js');
	const BiPolygon = require('../three-d/objects/bi-polygon.js');
	const Line2d = require('../two-d/objects/line.js');
	const LineMeasurement2d = require('../two-d/objects/line-measurement.js');
	const PanZoom = require('../two-d/pan-zoom.js');
	
	const CSG = require('../../public/js/3d-modeling/csg');
	
	function csgVert(pos, normal) {
	  return new CSG.Vertex(pos, normal);
	}
	
	function normalize (verts, normal, reverse) {
	  const returnValue = [];
	  for (let index = 0; index < verts.length; index++)
	    returnValue[index] = new CSG.Vertex(verts[index], normal);
	  return reverse ? returnValue.reverse() : returnValue;
	}
	
	function door(face1, face2) {
	  const front = new CSG.Polygon(normalize(face1, [+1, 0, 0]));
	  front.plane.normal = new CSG.Vector([0,0+1, 0,0]);
	  const back = new CSG.Polygon(normalize(face2, [-1, 0, 0], true));
	  back.plane.normal = new CSG.Vector([0,0,1,0,0]);
	  const top = new CSG.Polygon(normalize([face1[0], face1[1], face2[1], face2[0]], [0,1,0], true));
	  top.plane.normal = new CSG.Vector([0, 1, 0]);
	  const left = new CSG.Polygon(normalize([face2[3], face2[0], face1[0], face1[3]], [-1,0,0]));
	  left.plane.normal = new CSG.Vector([-1, 0, 0]);
	  const right = new CSG.Polygon(normalize([face1[1], face1[2], face2[2], face2[1]], [1,0,0], true));
	  right.plane.normal = new CSG.Vector([1, 0, 0]);
	  const bottom = new CSG.Polygon(normalize([face1[3], face1[2], face2[2], face2[3]], [0,-1,0]));
	  bottom.plane.normal = new CSG.Vector([0, -1, 0]);
	
	  const poly = CSG.fromPolygons([front, back, top, left, right, bottom]);
	  return poly;
	}
	
	class ThreeView extends Lookup {
	  constructor(viewer) {
	    super();
	    const instance = this;
	    const maxDem = window.innerHeight * .45;
	    const cnt = du.create.element('div');
	    // const p = pull(5,2);
	    const p = new BiPolygon(new Polygon3D([{x:0, y: 4, z: 0}, {x:4, y: 4, z: 0}, {x:4, y: 0, z: 0}, {x:0, y: 0, z: 0}]),
	          new Polygon3D([{x:2, y: 4, z: 4}, {x:6, y: 4, z: 4}, {x:6, y: 0, z: 4}, {x:2, y: 0, z: 4}])).toModel();
	    // const p = door([{x:0, y: 4, z: 0}, {x:4, y: 4, z: 0}, {x:4, y: 0, z: 0}, {x:0, y: 0, z: 0}],
	    //       [{x:0, y: 4, z: 4}, {x:4, y: 4, z: 4}, {x:4, y: 0, z: 4}, {x:0, y: 0, z: 4}]);
	    // console.log(JSON.stringify(new CSG.cube({radius: 2, center: [2,2,2]}), null, 2));
	    // const p = CSG.sphere({center: {x:0, y:0, z: 0}, radius: 10});
	    p.setColor([0, 255, 0])
	    let front, left, top;
	    let panzFront, panzLeft, panzTop;
	    let threeDModel;
	    document.body.append(cnt);
	    this.maxDem = () => maxDem;
	    cnt.innerHTML = ThreeView.template.render(this);
	
	    const color = 'black';
	    const width = .2;
	    const cache = {front: {}, left: {}, top: {}};
	
	    const drawFront = (refresh) => {
	      Layout2D.release('three-view-front');
	        const lm = this.lastModel();
	        if (lm === undefined) return;
	        const xy = lm.xy;
	        const twoDmap = Polygon2d.lines(...xy);
	        if (twoDmap.length < 100) {
	          const measurements = LineMeasurement2d.measurements(twoDmap);
	          cache.front.twoDmap = twoDmap;
	          cache.front.measurements = measurements;
	        }
	      front(cache.front.twoDmap, color, width);
	      front(cache.front.measurements, 'grey');
	    }
	    const drawLeft = (refresh) => {
	      Layout2D.release('three-view-left');
	      const lm = this.lastModel();
	      if (lm === undefined) return;
	      const twoDmap = Polygon2d.lines(...lm.zy);
	      if (twoDmap.length < 100) {
	        left(twoDmap, color, width);
	        const measurements = LineMeasurement2d.measurements(twoDmap);
	        left(measurements, 'grey');
	      }
	    }
	    const drawTop = (refresh) => {
	      Layout2D.release('three-view-top');
	      const lm = this.lastModel();
	      if (lm === undefined) return;
	      const twoDmap = Polygon2d.lines(...lm.xz);
	      if (twoDmap.length < 100) {
	        top(twoDmap, color, width);
	        const measurements = LineMeasurement2d.measurements(twoDmap);
	        top(measurements, 'grey');
	      }
	    }
	
	    function onPartSelect(elem) {
	      console.log(elem.value);
	      instance.isolatePart(elem.value);
	      elem.value = '';
	    }
	
	    function init() {
	      if (viewer === undefined) {
	        viewer = new Viewer(p, maxDem, maxDem, 50);
	        addViewer(viewer, `#${instance.id()}>.three-view-three-d-cnt`);
	      }
	      front = new Draw2D(du.id('three-view-front'));
	      left = new Draw2D(du.id('three-view-left'));
	      top = new Draw2D(du.id('three-view-top'));
	
	      panzFront = new PanZoom(front.canvas(), drawFront);
	      panzLeft = new PanZoom(left.canvas(), drawLeft);
	      panzTop = new PanZoom(top.canvas(), drawTop);
	      panzFront.centerOn(0, 0);
	      panzLeft.centerOn(0, 0);
	      panzTop.centerOn(0, 0);
	
	      du.on.match('change', '[name="partSelector"]', onPartSelect);
	    }
	
	    this.update = (cabinet) => {
	      if (threeDModel === undefined) threeDModel = new ThreeDModel(cabinet, viewer);
	      threeDModel.assembly(cabinet, viewer);
	      threeDModel.update(cabinet);
	      front.clear();left.clear();top.clear();
	      setTimeout(() => {
	        drawTop(true);drawLeft(true);drawFront(true);
	      }, 1000);
	    }
	
	    this.isolatePart = (partCode) => {
	      threeDModel = ThreeDModel.get();
	      threeDModel.setTargetPartCode(partCode);
	      threeDModel.update();
	      setTimeout(() => {
	        panzFront.once();
	        panzLeft.once();
	        panzTop.once();
	      }, 500);
	      du.id(`three-view-part-code-${this.id()}`).innerText = partCode;
	    }
	
	    this.threeDModel = () => threeDModel;
	    this.lastModel = () => threeDModel ? threeDModel.lastModel() : undefined;
	    this.partMap = () => threeDModel ? threeDModel.partMap() : {};
	
	    setTimeout(init, 1000);
	  }
	}
	
	ThreeView.template = new $t('three-view');
	
	module.exports = ThreeView;
	
});


RequireJS.addFunction('./app-src/displays/user.js',
function (require, exports, module) {
	
const du = require('../../../../public/js/utils/dom-utils.js');
	const APP_ID = require('../../globals/CONSTANTS.js').APP_ID;
	const Request = require('../../../../public/js/utils/request.js');
	const EPNTS = require('../../generated/EPNTS');
	const $t = require('../../../../public/js/utils/$t.js');
	
	class User {
	  constructor() {
	    const stateAttr = 'user-state';
	    let state, cnt, email, password;
	
	    function updateDisplay(s) {
	      state = s ? User.states[s] : state;
	      cnt = cnt || du.id('login-cnt');
	      cnt.innerHTML = state.template.render({email, password});
	    }
	
	    const hideLogin = () => du.id('login').hidden = true;
	    const showLogin = () => du.id('login').hidden = false;
	    function successfulRegistration(body) {
	      updateDisplay('CONFIRMATION_MESSAGE');
	    }
	
	    function register(target) {password
	      const fail = du.appendError(target, 'Registration Failed: Email already registered');
	      const body = {email, password};
	      document.cookie = `${APP_ID}=${email}:invalid`;
	      Request.post(EPNTS.user.register(), body, successfulRegistration, fail);
	    }
	
	    function successfulLogin(body, res) {
	      const newAuth = res.getResponseHeader('authorization');
	      document.cookie = `${APP_ID}=${newAuth}`;
	      hideLogin();
	    }
	
	    const getEmail = () => du.cookie.get(APP_ID, ':', 'email').email;
	    this.credential = User.credential;
	
	    function login(target) {
	      const fail = du.appendError(target, 'Login Failed: Invalid Email and/or Password');
	      const body = {email, password};
	      Request.post(EPNTS.user.login(), body, successfulLogin, fail);
	    }
	
	    function resendActivation(target) {
	      const fail = du.appendError(target, 'Email Not Registered Or Already Active');
	      const body = {email: getEmail()};
	      Request.post(EPNTS.user.resendActivation(), body, successfulRegistration, fail);
	    }
	
	    function logout() {
	      du.cookie.remove(APP_ID);
	      showLogin();
	      updateDisplay('LOGIN')
	    }
	
	    function resetPassword(target) {
	      const fail = du.appendError(target, 'Server Error Must have occured... try again in a few minutes');
	      const body = {email, newPassword: password};
	      Request.post(EPNTS.user.resetPasswordRequest(), body, successfulRegistration, fail);
	    }
	
	    du.on.match('click', `[${stateAttr}]`, (elem) => {
	      const stateId = elem.getAttribute(stateAttr);
	      if (User.states[stateId]) {
	        updateDisplay(stateId);
	      } else console.error(`Invalid State: '${stateId}'`);
	    });
	
	    du.on.match('click', '#register', register);
	    du.on.match('click', '#login-btn', login);
	    du.on.match('click', '#resend-activation', resendActivation);
	    du.on.match('click', '#reset-password', resetPassword);
	    du.on.match('click', '#logout-btn', logout);
	
	    du.on.match('change', 'input[name="email"]', (elem) => email = elem.value);
	    du.on.match('change', 'input[name="password"]', (elem) => password = elem.value);
	
	    function statusCheck(body) {
	      switch (body) {
	        case 'Not Registered':
	          updateDisplay('LOGIN')
	          break;
	        case 'Not Activated':
	          updateDisplay('CONFIRMATION_MESSAGE');
	          break;
	        case 'Logged In':
	          hideLogin();
	          break;
	        case 'Logged Out':
	          updateDisplay('LOGIN')
	          break;
	        default:
	
	      }
	    }
	
	    Request.globalHeader('Authorization', this.credential);
	    if (this.credential()) Request.get(EPNTS.user.status(), statusCheck);
	    else updateDisplay('LOGIN');
	  }
	}
	
	User.states = {};
	User.states.LOGIN = {
	  template: new $t('login/login')
	};
	User.states.CONFIRMATION_MESSAGE = {
	  template: new $t('login/confirmation-message')
	};
	User.states.CREATE_ACCOUNT = {
	  template: new $t('login/create-account')
	};
	User.states.RESET_PASSWORD = {
	  template: new $t('login/reset-password')
	};
	
	User.credential = () => du.cookie.get(APP_ID);
	
	
	User = new User();
	module.exports = User
	
});


RequireJS.addFunction('./app-src/objects/company.js',
function (require, exports, module) {
	

	
	const Door = require('./assembly/assemblies/door/door.js');
	
	class Company {
	  constructor(properties) {
	    if (!properties.name) throw new Error('Company name must be defined')
	    if (Company.list[properties.name] !== undefined) throw new Error('Company name must be unique: name already registered');
	    this.name = () => properties.name;
	    this.email = () => properties.email;
	    this.address = () => properties.address;
	    Company.list[this.name()] = this;
	  }
	}
	
	Company.list = {};
	new Company({name: 'Central Door'});
	new Company({name: 'Central Wood'});
	new Company({name: 'ADC'});
	new Company({name: 'Accessa'});
	new Company({name: 'Top Knobs'});
	new Company({name: 'Richelieu'});
	module.exports = Company
	
	
	
	
	
});


RequireJS.addFunction('./app-src/objects/group.js',
function (require, exports, module) {
	
const PropertyConfig = require('../config/property/config');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	
	class Group extends Lookup {
	  constructor(room, name, id) {
	    super(id);
	    const initialVals = {
	      name: name || 'Group',
	    }
	    Object.getSet(this, initialVals);
	    this.propertyConfig = new PropertyConfig();
	    this.objects = [];
	    this.room = () => room;
	    this.toJson = () => {
	      const json = {objects: [], _TYPE: 'Group'};
	      this.objects.forEach((obj) => json.objects.push(obj.toJson()));
	      json.name = this.name();
	      json.id = this.id();
	      json.roomId = this.room().id();
	      json.propertyConfig = this.propertyConfig.toJson();
	      return json;
	    }
	  }
	}
	
	Group.count = 0;
	new Group();
	
	Group.fromJson = (json) => {
	  const room = Lookup.get(json.roomId);
	  const group = new Group(room, json.name, json.id);
	  group.propertyConfig = PropertyConfig.fromJson(json.propertyConfig);
	  json.objects.forEach((objJson) => {
	    const jsonClazz = Object.class.get(json.objects[0]._TYPE);
	    const obj = jsonClazz.fromJson(objJson, group);
	    group.objects.push(obj);
	    obj.group(group);
	  });
	  return group;
	}
	
	module.exports = Group;
	
});


RequireJS.addFunction('./app-src/cost/cost-tree.js',
function (require, exports, module) {
	
const Properties = require('../config/properties.js');
	const Assembly = require('../objects/assembly/assembly.js');
	const LogicTree = require('../../../../public/js/utils/logic-tree.js');
	const LogicWrapper = LogicTree.LogicWrapper;
	
	class CostDecision {
	  constructor(type, name, relation, formula) {
	    Object.getSet(this, {type, name, costs: [], relation, isChoice: false});
	    this.requiredProperties = Properties.noValue(name);
	    if (this.relation) {
	      if (formula) {
	        function makeDecision(wrapper) {
	          return true;
	        }
	        this.relation = RelationInput.relationsObjs[relation](makeDecision);
	        this.condition = (wrapper) => this.relation.eval(wrapper.children(), wrapper.payload.value());
	      } else {
	        this.isChoice(true);
	      }
	    }
	  }
	}
	
	class CostTree {
	  constructor(logicTree) {
	    const idMap = {};
	    logicTree = CostTree.suplement(logicTree);
	    this.tree = () => logicTree;
	    this.root = () => logicTree.root();
	    const getWrapper = (wrapperId) => (LogicWrapper.get(wrapperId) || this.root());
	
	    this.branch = (wrapperId, name) =>
	            get(wrapperId).branch(String.random(), new CostDecision('Branch', name));
	    this.leaf = (wrapperId, name) =>
	            get(wrapperId).leaf(String.random(), new CostDecision('Leaf', name));
	    this.select = (wrapperId, name, relation, formula) =>
	            get(wrapperId).select(String.random(), new CostDecision('Select', name, relation, formula));
	    this.multiselect = (wrapperId, name, relation, formula) =>
	            get(wrapperId).multiselect(String.random(), new CostDecision('Multiselect', name, relation, formula));
	    this.conditional = (wrapperId, name, relation, formula) =>
	            get(wrapperId).conditional(String.random(), new CostDecision('Conditional', name, relation, formula));
	
	  }
	}
	
	
	CostTree.propertyList = Properties.all();
	CostTree.types = ['branch', 'select', 'conditional', 'multiselect', 'leaf'];
	CostTree.suplement = (logicTree) => {
	  if (!(logicTree instanceof LogicWrapper)) {
	    logicTree = new LogicTree();
	    logicTree.branch('root');
	  }
	  const root = logicTree.root();
	  const assemClassIds = Properties.list();
	  assemClassIds.forEach((classId) => {
	    if (root.node.getNodeByPath(classId) === undefined)
	      root.branch(classId, new CostDecision('Branch', classId));
	  });
	  return logicTree;
	}
	CostTree.choices = [];
	
	
	CostTree.CostDecision = CostDecision;
	module.exports = CostTree;
	
});


RequireJS.addFunction('./app-src/cost/init-costs.js',
function (require, exports, module) {
	

	
	
	const Cost = require('./cost.js');
	const Material = require('./types/material.js');
	const Labor = require('./types/labor.js');
	
	Cost.register(Material);
	Cost.register(Labor);
	
});


RequireJS.addFunction('./app-src/cost/cost.js',
function (require, exports, module) {
	

	
	const Company = require('../objects/company.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const StringMathEvaluator = require('../../../../public/js/utils/string-math-evaluator.js');
	const Assembly = require('../objects/assembly/assembly.js');
	
	
	// constructors
	// Cost({name, Method: Cost.methods.LINEAR_FEET, cost, length})
	// Cost({name, Method: Cost.methods.SQUARE_FEET, cost, length, width})
	// Cost({name, Method: Cost.methods.CUBIC_FEET, cost, length, width, depth})
	// Cost({name, Method: Cost.methods.UNIT, cost})
	// Cost((name, Cost, formula));
	// props. - (optional*)
	// id - Cost identifier
	// method - Method for calculating cost
	// length - length of piece used to calculate unit cost
	// width - width of piece used to calculate unit cost
	// depth - depth of piece used to calculate unit cost
	// cost - cost of piece used to calculate unit cost
	// formula* - formula used to apply cost to part
	// company* - Company to order from.
	// partNumber* - Part number to order part from company
	// Cost* - Reference Cost.
	
	class Cost extends Lookup {
	  //constructor(id, Cost, formula)
	  constructor(props) {
	    super(props.name);
	    props = props || {};
	    this.props = () => props;
	    let deleted = false;
	    const instance = this;
	    const lastUpdated = props.lastUpdated || new Date().getTime();
	    props.requiredBranches = props.requiredBranches || [];
	    this.lastUpdated = new Date(lastUpdated).toLocaleDateString();
	    Object.getSet(this, props, 'group', 'objectId', 'id', 'parent');
	    this.level = () => {
	      let level = -1;
	      let curr = this;
	      while(curr instanceof Cost) {
	        level++;
	        curr = curr.parent();
	      }
	      return level;
	    }
	  }
	}
	
	Cost.types = {};
	
	Cost.freeId = (group, id) => Object.values(Cost.group(group).defined).indexOf(id) === -1;
	Cost.remove = (id) => Cost.get(id).remove();
	
	Cost.constructorId = (name) => name.replace(/Cost$/, '');
	Cost.register = (clazz) => {
	  Cost.types[Cost.constructorId(clazz.prototype.constructor.name)] = clazz;
	  Cost.typeList = Object.keys(Cost.types).sort();
	}
	
	Cost.evaluator = new StringMathEvaluator(null, (attr, assem) => Assembly.resolveAttr(assem, attr))
	
	module.exports = Cost
	
});


RequireJS.addFunction('./app-src/input/validation.js',
function (require, exports, module) {
	

	
	const InvalidComputation = require('./error.js');
	
	class ObjectValidator {
	  constructor() {
	    const validators =  {};
	    this.add = (name, validator) => {
	      if (!(validator instanceof ObjectValidator) && !(validator instanceof Validator)) {
	        throw new Error('Invalid Validator');
	      }
	      validator[name] = validator;
	    }
	    this.validate = (obj) => {
	      if (typeof obj !== 'object') throw new InvalidComputation()
	      const keys = Object.keys(validators);
	    }
	  }
	}
	
	
	class Validator {
	  constructor(validator, props, info) {
	    let type, validate;
	    const complement = props.explanation;
	
	    let defaultExpl;
	    if (validator instanceof Regex) {
	      type = 'Regex';
	      if (props.complement) {
	        defaultExpl = 'Value must fit regex expression';
	        validate = (value) => validator.match('value');
	      } else {
	        defaultExpl = 'Value must not fit regex expression';
	        validate = (value) => !validator.match('value');
	      }
	    } else if (Array.isArray(validator)) {
	      if (props.complement) {
	        defaultExpl = 'Value must exist within array';
	        validate = (value) => validator.indexOf(value) !== -1;
	      } else {
	        defaultExpl = 'Value must not exist within array';
	        validate = (value) => validator.indexOf(value) === -1;
	      }
	    }
	
	    props.explanation = props.explanation || defaultExpl;
	
	    val = val === undefined && elem ? elem.value : val;
	    if (val === undefined) return false;
	    if (valid !== undefined && val === value) return valid;
	    let valValid = true;
	    if (props.validation instanceof RegExp) {
	      valValid = val.match(props.validation) !== null;
	    }
	    else if ((typeof props.validation) === 'function') {
	      valValid = props.validation.apply(null, arguments);
	    }
	    else if (Array.isArray(props.validation)) {
	      valValid = props.validation.indexOf(val) !== -1;
	    }
	
	    return valValid;
	  }
	}
	exports.ObjectValidator = ObjectValidator
	exports.Validator = Validator
	
	
	
	
	
});


RequireJS.addFunction('./app-src/input/inputs.js',
function (require, exports, module) {
	const MeasurementInput = require('../../../../public/js/utils/input/styles/measurement.js');
	const Cost = require('../cost/cost.js');
	const Select = require('../../../../public/js/utils/input/styles/select.js');
	const Material = require('../cost/types/material.js');
	const Company = require('../objects/company.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const Labor = require('../cost/types/labor.js');
	
	
	const defined = {};
	function add (name, input) {
	  if (defined[name]) {
	    throw new Error(`Input by the name of '${name}' is already defined`)
	  }
	  defined[name] = input;
	}
	
	module.exports = (name, properties) => defined[name].clone(properties);
	
	
	add('length', new MeasurementInput({
	  type: 'text',
	  placeholder: 'Length',
	  name: 'length',
	  class: 'center'
	}));
	
	add('width', new MeasurementInput({
	  type: 'text',
	  label: 'x',
	  placeholder: 'Width',
	  name: 'width',
	  class: 'center'
	}));
	
	add('depth', new MeasurementInput({
	  type: 'text',
	  label: 'x',
	  placeholder: 'Depth',
	  name: 'depth',
	  class: 'center'
	}));
	
	add('cost', new MeasurementInput({
	  type: 'number',
	  label: '$',
	  placeholder: 'Cost',
	  name: 'cost'
	}));
	
	add('pattern', new MeasurementInput({
	  type: 'text',
	  class: 'pattern-input',
	}));
	
	
	add('offsetLen', new MeasurementInput({
	  type: 'text',
	  label: 'Offset',
	  placeholder: 'Length',
	  name: 'offsetLength',
	  class: 'center',
	}));
	
	add('offsetWidth', new MeasurementInput({
	  type: 'text',
	  label: 'x',
	  placeholder: 'Width',
	  name: 'offsetWidth',
	  class: 'center',
	}));
	
	add('offsetDepth', new MeasurementInput({
	  type: 'text',
	  label: 'x',
	  placeholder: 'Depth',
	  name: 'offsetDepth',
	  class: 'center',
	}));
	
	
	add('costType', new Select({
	  placeholder: 'Type',
	  name: 'type',
	  class: 'center',
	  list: Cost.typeList
	}));
	
	add('method', new Select({
	  name: 'method',
	  class: 'center',
	  list: Material.methodList,
	}));
	
	add('company', new Select({
	  name: 'company',
	  label: 'Company',
	  class: 'center',
	  list: [''].concat(Object.keys(Company.list)),
	  value: ''
	}));
	
	add('childCost', new Select({
	    name: 'child',
	    label: 'Default',
	    class: 'center',
	}));
	
	
	add('id', new Input({
	  type: 'text',
	  placeholder: 'Id',
	  name: 'id',
	  class: 'center',
	  validation: /^\s*[^\s]{1,}\s*$/,
	  errorMsg: 'You must enter an Id'
	}));
	
	add('propertyId', new Input({
	  type: 'text',
	  placeholder: 'Property Id',
	  name: 'propertyId',
	  class: 'center',
	  validation: /^[a-zA-Z\.]{1}$/,
	  errorMsg: 'Alpha Numeric Value seperated by \'.\'.<br>I.E. Cabinet=>1/2 Overlay = Cabinet.12Overlay'
	}));
	
	add('propertyValue', new Input({
	  type: 'text',
	  placeholder: 'Property Value',
	  name: 'propertyValue',
	  class: 'center'
	}));
	
	add('costId', new Input({
	  type: 'text',
	  placeholder: 'Id',
	  name: 'id',
	  class: 'center',
	  validation: (id, values) =>
	      id !== '' && (!values.referenceable || Object.values(Cost.defined).indexOf(id) === -1),
	  errorMsg: 'You must an Id: value must be unique if Referencable.'
	}));
	
	add('name', new Input({
	  type: 'text',
	  placeholder: 'Name',
	  name: 'name',
	  value: 'peach',
	  class: 'center',
	  validation: /^\s*[^\s].*$/,
	  errorMsg: 'You must enter a Name'
	}));
	
	add('color', new Input({
	  type: 'color',
	  validation: /.*/,
	  placeholder: 'color',
	  name: 'color',
	  class: 'center'
	}));
	
	add('optional', new Input({
	  label: 'Optional',
	  name: 'optional',
	  type: 'checkbox',
	  default: false,
	  validation: [true, false],
	  targetAttr: 'checked'
	}));
	
	add('modifyDemension', new Input({
	  label: 'Modify Demension',
	  name: 'modifyDemension',
	  type: 'checkbox',
	  default: false,
	  validation: [true, false],
	  targetAttr: 'checked'
	}));
	
	add('partNumber', new Input({
	  label: 'Part Number',
	  name: 'partNumber',
	  type: 'text'
	}));
	
	add('count', new Input({
	  label: 'Count',
	  name: 'count',
	  type: 'number',
	  value: 1
	}));
	
	add('quantity', new Input({
	  label: 'Quantity',
	  name: 'quantity',
	  type: 'number',
	  value: 0
	}));
	
	add('hourlyRate', new Input({
	  label: 'Hourly Rate',
	  name: 'hourlyRate',
	  type: 'number',
	}));
	
	add('hours', new Input({
	  label: 'Hours',
	  name: 'hours',
	  type: 'number',
	  value: 0
	}));
	
	add('laborType', new Input({
	  name: 'laborType',
	  placeholder: 'Labor Type',
	  label: 'Type',
	  class: 'center',
	  clearOnClick: true,
	  list: Labor.types
	}));
	
	add('formula', new Input({
	  name: 'formula',
	  placeholder: 'Formula',
	  label: 'Formula',
	  class: 'center'
	}));
	
});


RequireJS.addFunction('./app-src/config/cabinet-template.js',
function (require, exports, module) {
	
const cabinetsJson = require('../../public/json/cabinets.json');
	const Cabinet = require('../objects/assembly/assemblies/cabinet.js')
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const PropertyConfig = require('./property/config');
	
	class CabinetTemplate extends Lookup {
	  constructor(type) {
	    super();
	    const instance = this;
	    const initialVals = (typeof type) === 'object' ? type : {
	      type, values: [], subassemblies: [], joints: [], dividerJoint: {},
	      shape: 'square',
	      width: 18 * 2.54,
	
	      height: 34 * 2.54,
	      thickness: 24 * 2.54,
	      openings: [CabinetTemplate.defaultPartCodeOpening()]
	    };
	    Object.getSet(this, initialVals);
	    CabinetTemplate.map[type] = this;
	
	    function getCabinet(length, width, thickness, pc) {
	      const cabinet = Cabinet.build(instance.type(), undefined, instance.toJson());
	      cabinet.length(length);
	      cabinet.width(width);
	      cabinet.thickness(thickness);
	
	      cabinet.propertyConfig(pc instanceof PropertyConfig ? pc : new PropertyConfig());
	      return cabinet;
	    }
	    this.getCabinet = getCabinet;
	
	    this.codeMap = () => {
	      let codeMap = {};
	      Object.values(this.subassemblies()).forEach((sa) => codeMap[sa.code] = sa);
	      return codeMap;
	    }
	
	    this.validPartCode = (code) => this.codeMap()[code] !== undefined;
	    const vpc = this.validPartCode;
	
	    this.validOpenings = () => {
	      const bms = this.openings();
	      for (let index = 0; index < bms.length; index += 1) {
	        const bm = bms[index];
	        if (!(vpc(bm.top) && vpc(bm.bottom) && vpc(bm.right) &&
	                vpc(bm.left) && vpc(bm.bottom))) {
	          return false;
	        }
	      }
	      return true;
	    }
	    this.validateDividerJoint = () => {
	      const j = this.dividerJoint();
	      return j.type === 'Butt' || (j.type === 'Dado' && j.maleOffset > 0);
	    }
	
	    const offsetReg = /(-|\+|)[xyz]/;
	    this.validOffset = (offset) => offset && offset.match(offsetReg) !== null;
	    const vo = this.validOffset;
	
	    this.validateJoint = (joint, malePartCode, femalePartCode) => {
	      let isValid = vpc(malePartCode) && vpc(femalePartCode);
	      switch (joint.type) {
	        case "Dado":
	          return isValid && joint.maleOffset > 0 && vo(joint.demensionToOffset) &&
	                  vo(joint.centerOffset);
	        default:
	          return true;
	      }
	    }
	    this.validateJoints = () => {
	      let joints = this.joints();
	      for (let index = 0; index < joints.length; index += 1) {
	        if (!this.validateJoint(joints[index])) return false;
	      }
	      return true;
	    }
	
	    this.evalEqn = (eqn, cab) => {
	      cab ||= getCabinet();
	      return cab.eval(eqn);
	    }
	
	    this.evalObject = (eqn, cab) => {
	      cab ||= getCabinet();
	      return cab.evalObject(eqn);
	    }
	
	    this.validateEquation = (eqn, cab) => {
	      return !Number.isNaN(this.evalEqn(eqn, cab));
	    }
	    const veq = this.validateEquation;
	
	    this.validateValues = (cab) => {
	      try {
	        cab ||= getCabinet();
	      } catch (e) {
	        return false;
	      }
	      const values = Object.values(this.values());
	      for (let index = 0; index < values.length; index += 1) {
	        if (!veq(values[index].eqn, cab)) return false;
	      }
	      return true;
	    }
	
	    this.validateSubassembly = (subAssem, cab) => {
	      try {
	        cab ||= getCabinet();
	      } catch (e) {
	        return false;
	      }
	
	      const c = subAssem.center;
	      const d = subAssem.demensions;
	      const r = subAssem.rotation;
	      return vpc(subAssem.code) &&
	              r.length === 3 && veq(r[0], cab) && veq(r[1], cab) && veq(r[2], cab) &&
	              veq(c[0], cab) && veq(c[1], cab) && veq(c[2], cab) &&
	              veq(d[0], cab) && veq(d[1], cab) && veq(d[2], cab);
	    }
	
	    this.validateSubassemblies = (cab) => {
	      try {
	        cab ||= getCabinet();
	      } catch (e) {
	        return false;
	      }      const subAssems = Object.values(this.subassemblies());
	      for (let index = 0; index < subAssems.length; index += 1) {
	        if (!this.validateSubassembly(subAssems[index])) return false;
	      }
	      return true;
	    }
	
	    this.valid = () => {
	      let cab;
	      try {
	        cab ||= getCabinet();
	      } catch (e) {
	        return false;
	      }
	      return this.validateValues(cab) && this.validOpenings() &&
	              this.validateDividerJoint() && this.validateJoints() &&
	              this.validateSubassemblies(cab);
	    }
	  }
	}
	
	CabinetTemplate.map = {};
	CabinetTemplate.defaultList = () => {
	  const list = [];
	  const keys = Object.keys(cabinetsJson);
	  // comment out to get corner-wall to be the first.
	  keys.sort();
	  for (let index = 0; index < keys.length; index += 1) {
	    list.push(new CabinetTemplate().fromJson(cabinetsJson[keys[index]]));
	  }
	  return list;
	}
	
	CabinetTemplate.typeUndefined = (type) => CabinetTemplate.map[type] === undefined;
	CabinetTemplate.defaultPartCodeOpening = () => ({
	    _Type: "part-code",
	    top: "pt",
	    bottom: "pb",
	    left: "pl",
	    right: "pr",
	    back: "pback"
	  }
	);
	
	CabinetTemplate.defaultLocationOpening = () => ({
	  _Type: "location",
	  zRotation: 0,
	  inner: {
	    top: {left: {x: 0, y: 0, z: 0}, right: {x: 0, y: 0, z: 0}},
	    bottom: {right:{x: 0, y: 0, z: 0}, left: {x: 0, y: 0, z: 0}}
	  },
	  outer: {
	    top: {left: {x: 0, y: 0, z: 0}, right: {x: 0, y: 0, z: 0}},
	    bottom: {right:{x: 0, y: 0, z: 0}, left: {x: 0, y: 0, z: 0}}
	  }
	});
	
	module.exports = CabinetTemplate;
	
});


RequireJS.addFunction('./app-src/objects/layout.js',
function (require, exports, module) {
	
const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const StateHistory = require('../../../../public/js/utils/services/state-history');
	const approximate = require('../../../../public/js/utils/approximate.js').new(1);
	const Vertex2d = require('../two-d/objects/vertex.js');
	const Line2d = require('../two-d/objects/line.js');
	const Square2d = require('../two-d/objects/square.js');
	const Circle2d = require('../two-d/objects/circle.js');
	const Snap2d = require('../two-d/objects/snap.js');
	const SnapSquare = require('../two-d/objects/snap/square.js');
	const cabinetBuildConfig = require('../../public/json/cabinets.json');
	// const SnapSquare = require('../two-d/objects/snap/corner-l.js');
	const Cabinet = require('../objects/assembly/assemblies/cabinet');
	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	
	const pushVertex = (x, y, arr) => {
	  if (Number.isNaN(x) || Number.isNaN(y)) return;
	  arr.push(new Vertex2d({x, y}));
	}
	
	
	const vertexMap = {};
	function getVertex(point, wall1, wall2) {
	  const mapId = `${wall1.id()}->${wall2.id()}`;
	  if (vertexMap[mapId] === undefined) {
	    vertexMap[mapId] = new Vertex2d(point);
	    wall1.startVertex(vertexMap[mapId]);
	    wall2.endVertex(vertexMap[mapId]);
	  }
	  else vertexMap[mapId].point(point);
	  return vertexMap[mapId];
	}
	
	class OnWall extends Lookup {
	  constructor(wall, fromPreviousWall, fromFloor, height, width) {
	    super();
	    Object.getSet(this, {width, height, fromFloor, fromPreviousWall}, 'wallId');
	    let start = new Vertex2d();
	    let end = new Vertex2d();
	    this.wallId = () => wall.id();
	    this.endpoints2D = () => {
	      const wallStartPoint = wall.startVertex();
	      const dist = this.fromPreviousWall();
	      const total = dist + this.width();
	      const theta = wall.radians();
	      const startPoint = {};
	      startPoint.x = wallStartPoint.x() + dist * Math.cos(theta);
	      startPoint.y = wallStartPoint.y() + dist * Math.sin(theta);
	      start.point(startPoint);
	
	      const endPoint = {};
	      endPoint.x = (wallStartPoint.x() + total * Math.cos(theta));
	      endPoint.y = (wallStartPoint.y() + total * Math.sin(theta));
	      end.point(endPoint);
	
	      return { start, end, toString: () => `${start.toString()} => ${end.toString()}`};
	    }
	    this.fromPreviousWall = (value) => {
	      value = Number.parseFloat(value);
	      if (!Number.isNaN(value)) fromPreviousWall = value;
	      return fromPreviousWall;
	    }
	    this.fromNextWall = (value) => {
	      value = Number.parseFloat(value);
	      if (value) {
	        this.fromPreviousWall(wall.length() - this.width() - value);
	      }
	      return wall.length() - this.width() - this.fromPreviousWall();
	    }
	    this.wall = () => wall;
	    this.setWall = (w) => wall = w;
	    this.move = (center) => {
	      const point = wall.closestPointOnLine(center);
	      const onLine = wall.closestPointOnLine(point, true);
	      let distanceStart = wall.startVertex().distance(point);
	      if (!onLine) {
	        let distanceEnd = wall.endVertex().distance(point);
	        if (distanceStart < distanceEnd) this.fromPreviousWall(0);
	        else this.fromPreviousWall(wall.length() - this.width());
	      } else {
	        const max = wall.length() - this.width();
	        distanceStart = distanceStart > max ? max : distanceStart;
	        this.fromPreviousWall(distanceStart);
	      }
	    };
	    this.toString = () => `${this.constructor.name}:${wall}, ${fromPreviousWall}, ${fromFloor}, ${height}, ${width}`
	  }
	}
	OnWall.sort = (ow1, ow2) => ow1.fromPreviousWall() - ow2.fromPreviousWall();
	OnWall.fromJson = (json) => {
	  const cxtr = Lookup.decode(json.id).constructor;
	  const instance = new cxtr(null, json.fromPreviousWall, json.fromFloor, json.height, json.width);
	  instance.id(json.id);
	  return instance;
	}
	
	class Door2D extends OnWall {
	  constructor() {
	    super(...arguments);
	    this.width(this.width() || 91.44);
	    this.height(this.height() || 198.12);
	    this.fromPreviousWall(this.fromPreviousWall() || 150);
	    this.fromFloor(this.fromFloor() || 0);
	    let hinge = 0;
	    Object.getSet(this, 'hinge');
	    this.toString = () => `${this.id()}:${this.endpoints2D().toString()}:${hinge}`;
	    this.remove = () => this.wall().removeDoor(this);
	    this.hinge = (val) => val === undefined ? hinge :
	      hinge = ((typeof val) === 'number' ? val : hinge + 1) % 5;
	  }
	}
	
	Door2D.fromJson = (json) => {
	  const inst = OnWall.fromJson(json);
	  inst.hinge(json.hinge);
	  return inst;
	}
	
	class Window2D extends OnWall {
	  constructor(wall, fromPreviousWall, fromFloor, height, width) {
	    width = width || 81.28;
	    height = height || 91.44;
	    fromFloor = fromFloor || 101.6;
	    fromPreviousWall = fromPreviousWall || 20;
	    super(wall, fromPreviousWall, fromFloor, height, width);
	    this.remove = () => this.wall().removeWindow(this);
	    this.toString = () => `${this.id()}:${this.endpoints2D().toString()}`;
	  }
	}
	
	function modifyVertex(vertex) {
	  return (props) => {
	      console.log('DummyFuncNotIntendedToBeCalled');
	  }
	}
	
	class Wall2D extends Line2d {
	  constructor(startVertex, endVertex, height, windows, doors) {
	    super(startVertex, endVertex);
	    this.startVertex().modificationFunction(modifyVertex(this.startVertex()));
	    this.endVertex().modificationFunction(modifyVertex(this.endVertex()));
	    Lookup.convert(this);
	    windows = windows || [];
	    windows.forEach((win) => win.setWall(this));
	    doors = doors || [];
	    doors.forEach((door) => door.setWall(this));
	    const wall = this;
	
	    height = height || 243.84;
	    Object.getSet(this, {height, windows, doors});
	    // this.copy = () => new Wall2D(this.length(), this.radians());
	    this.windows = () => windows;
	    this.addWindow = (fromPreviousWall) => windows.push(new Window2D(this, fromPreviousWall));
	    this.doors = () => doors;
	    this.addDoor = (fromPreviousWall) => doors.push(new Door2D(this, fromPreviousWall));
	    this.verticies = () => {
	      const verts = [this.startVertex()];
	      const doorsAndWindows = doors.concat(windows);
	      doorsAndWindows.sort(OnWall.sort);
	      doorsAndWindows.forEach((onWall) => {
	        const endpoints = onWall.endpoints2D();
	        verts.push(endpoints.start);
	        verts.push(endpoints.end);
	      });
	      verts.push(this.endVertex());
	      return verts;
	    }
	
	    this.remove = () => {
	        const prevWall = this.startVertex().prevLine();
	        const nextLine = this.endVertex().nextLine();
	        const startVertex = this.startVertex();
	        nextLine.startVertex(startVertex);
	        startVertex.nextLine(nextLine);
	    }
	
	    this.removeDoor = (door) => doors.splice(doors.indexOf(door), 1);
	    this.removeWindow = (window) => windows.splice(windows.indexOf(window), 1);
	  }
	}
	Wall2D.fromJson = (json, vertexMap) => {
	  vertexMap ||= {};
	  const newSv = Object.fromJson(json.startVertex);
	  const svStr = newSv.toString();
	  const newEv = Object.fromJson(json.endVertex);
	  const evStr = newEv.toString();
	  if (vertexMap[svStr] === undefined) vertexMap[svStr] = newSv;
	  if (vertexMap[evStr] === undefined) vertexMap[evStr] = newEv;
	  const sv = vertexMap[svStr];
	  const ev = vertexMap[evStr];
	  const windows = Object.fromJson(json.windows);
	  const doors = Object.fromJson(json.doors);
	  const inst = new Wall2D(sv, ev, json.height, windows, doors);
	  inst.id(json.id);
	  return inst;
	}
	
	class Object2d extends Lookup {
	  constructor(center, layout, payload, name) {
	    super(undefined, undefined, true);
	    center = new Vertex2d(center);
	    let payloadId;
	    this.layout = () => layout;
	    Object.getSet(this, {name, center}, 'payloadId');
	    this.payload = () => {
	      if (payload === undefined) payload = Lookup.get(this.payloadId());
	      return payload;
	    };
	
	    // Ids should only be equal if one object was built using the other as a replacement
	    this.equals = (obj) => this.id() === obj.id();
	
	    this.payloadId = (pId) => {
	      if ((typeof pId) === 'string') payloadId = pId;
	      if (!payload) return payloadId;
	      if (payload.ID_ATTRIBUTE) return payload[payload.ID_ATTRIBUTE()]();
	      return (typeof payload.id) === 'function' ? payload.id() : payload.id;
	    }
	
	    this.name = (val) => {
	      if (val) name = val;
	      if (this.payload() === undefined) return name;
	      if ((typeof this.payload().name) === 'function') return this.payload().name(val);
	      return this.payload.name;
	    }
	
	    function topMoved(position) {
	      console.log('topMoved', position);
	    }
	
	
	    const p = this.payload();
	    const topType = p ? cabinetBuildConfig[p.partName()].shape : 'square';
	    const topview = Snap2d.get[topType || 'square'](this, 30);
	    // const bottomview = new SnapSquare(this, 30);
	    // const leftview = new SnapSquare(this, 30);
	    // const rightview = new SnapSquare(this, 30);
	    // const frontview = new SnapSquare(this, 30);
	    // const backView = new SnapSquare(this, 30);
	
	    this.topview = () => topview;
	    // this.bottomview = () => bottomview;
	    // this.leftview = () => leftview;
	    // this.rightview = () => rightview;
	    // this.frontview = () => frontview;
	    // this.backview = () => backview;
	
	    if ((typeof name) === 'function') this.name = name;
	    this.toString = () => `Object2d: ${center}`;
	  }
	}
	
	const ww = 500;
	class Layout2D extends Lookup {
	  constructor(walls, objects) {
	    super();
	    let history;
	    const addEvent = new CustomEvent('add');
	    const removeEvent = new CustomEvent('remove');
	    const stateChangeEvent = new CustomEvent('stateChange');
	    this.onAdd = (func) => addEvent.on(func);
	    this.onRemove = (func) => removeEvent.on(func);
	    this.onStateChange = (func) => stateChangeEvent.on(func);
	
	    walls = walls || [];
	    objects = objects || [];
	    Object.getSet(this, {objects, walls});
	    const initialized = walls.length > 0;
	    const instance = this;
	
	    this.startLine = () => this.walls()[0];
	    this.endLine = () => this.walls()[this.walls().length - 1];
	
	    function sortByAttr(attr) {
	      function sort(obj1, obj2) {
	        if (obj2[attr] === obj1[attr]) {
	          return 0;
	        }
	        return obj2[attr] < obj1[attr] ? 1 : -1;
	      }
	      return sort;
	    }
	
	    this.wallIndex = (wallOrIndex) => {
	      if (wallOrIndex instanceof Wall2D) {
	        for (let index = 0; index < walls.length; index += 1) {
	          if (walls[index] === wallOrIndex) return index;
	        }
	        return -1;
	      } else {
	        while(wallOrIndex < 0) wallOrIndex += walls.length;
	        return wallOrIndex % walls.length;
	      }
	    }
	
	    function relitiveWall(wall, i) {
	      let position = instance.wallIndex(wall);
	      if (position === undefined) return null;
	      const relitiveList = walls.slice(position).concat(walls.slice(0, position));
	      return relitiveList[instance.wallIndex(i)];
	    }
	    this.relitiveWall = relitiveWall;
	    this.nextWall = (wall) => relitiveWall(wall, 1);
	    this.prevWall = (wall) => relitiveWall(wall, -1);
	
	    function reconsileLength (wall) {
	      return (newLength) => {
	        const moveVertex = wall.endVertex();
	        const nextLine = instance.nextWall(wall);
	        if (nextLine === undefined) wall.length(newLength);
	
	        const vertex1 = nextLine.endVertex();
	        const circle1 = new Circle2d(nextLine.length(), vertex1);
	        const vertex2 = wall.startVertex();
	        const circle2 = new Circle2d(newLength, vertex2);
	        const intersections = circle1.intersections(circle2);
	
	        const useFirst = (intersections.length !== 0 && intersections.length === 1) ||
	                  moveVertex.distance(intersections[0]) < moveVertex.distance(intersections[1]);
	        if (intersections.length === 0) {
	          wall.length(newLength);
	        } else if (useFirst) {
	          moveVertex.point(intersections[0]);
	        } else {
	          moveVertex.point(intersections[1]);
	        }
	      }
	    }
	    this.reconsileLength = reconsileLength;
	
	    const sortById = sortByAttr('id');
	    this.toJson = () => {
	      const objs = this.objects();
	      const json = {walls: []};
	      json.id = this.id();
	      json.objects = Array.toJson(objs);
	      this.walls().forEach((wall) => {
	        json.walls.push(wall.toJson());
	      });
	      // json.walls.sort(sortById);
	      json.objects.sort(sortById);
	      const snapMap = {};
	      objs.forEach((obj) => {
	        const snapLocs = obj.topview().snapLocations.paired();
	        snapLocs.forEach((snapLoc) => {
	          const snapLocJson = snapLoc.toJson();
	          if (snapMap[snapLocJson.UNIQUE_ID] === undefined) {
	            snapMap[snapLocJson.UNIQUE_ID] = snapLocJson;
	          }
	        });
	      });
	      json.snapLocations = Object.values(snapMap);
	      json._TYPE = this.constructor.name;
	      delete json.id;
	      return json;
	    }
	
	    this.push = (...points) => {
	      if (this.startLine() === undefined) {
	        const walls = this.walls();
	        if (points.length < 3) throw Error('Layout must be initialized with atleast three vertices');
	        walls[0] = new Wall2D(points[0], points[1]);
	      }
	      for (let index = 1; index < points.length; index += 1) {
	        const endLine = this.endLine();
	        const startV = endLine.endVertex();
	        const endV = new Vertex2d(points[(index + 1) % points.length]);
	        walls.push(new Wall2D(startV, endV));
	      }
	    }
	
	    this.addObject = (id, payload, name) => {
	      const center = Vertex2d.center.apply(null, this.verticies())
	      const obj = new Object2d(center, this, payload, name);
	      obj.id(id);
	      this.objects().push(obj);
	      history.newState();
	      addEvent.trigger(undefined, payload);
	      return obj;
	    }
	
	    this.removeObject = (obj) => {
	      for (index = 0; index < objects.length; index += 1) {
	        if (objects[index] === obj) {
	          const obj = objects.splice(index, 1);
	          removeEvent.trigger(undefined, obj.payload());
	          return obj;
	        }
	      }
	      return null;
	    }
	
	    this.removeByPayload = (payload) => {
	      for (index = 0; index < objects.length; index += 1) {
	        if (objects[index].payload() === payload) {
	          const obj = objects.splice(index, 1);
	          removeEvent.trigger(undefined, payload);
	          return obj;
	        }
	      }
	      return null;
	    }
	
	    this.idMap = () => {
	      const idMap = {};
	      const walls = this.walls();
	      idMap[walls[0].startVertex().id()] = walls[0].startVertex();
	      walls.forEach((wall) => {
	        idMap[wall.id()] = wall;
	        const endV = wall.endVertex();
	        idMap[endV.id()] = endV;
	        wall.windows().forEach((window) => idMap[window.id()] = window);
	        wall.windows().forEach((window) => idMap[window.id()] = window);
	        wall.doors().forEach((door) => idMap[door.id()] = door);
	      });
	      objects.forEach((obj) => idMap[obj.id()] = obj);
	      return idMap;
	    }
	
	    this.removeWall = (wall) => {
	      if (!(wall instanceof Wall2D)) return undefined;
	      const walls = this.walls();
	      for (index = 0; index < walls.length; index += 1) {
	        const currWall = walls[index];
	        if (currWall === wall) {
	          const nextWallSv = walls[this.wallIndex(index + 1)].startVertex();
	          walls[this.wallIndex(index - 1)].endVertex(nextWallSv);
	          walls.splice(index, 1);
	          return currWall;
	        }
	      }
	      return null;
	    }
	
	    this.addVertex = (vertex, wall) => {
	      vertex = new Vertex2d(vertex);
	      let wallIndex = this.wallIndex(wall);
	      if (wallIndex === -1) {
	        wall = walls[walls.length - 1];
	        wallIndex = this.wallIndex(wall);
	      }
	      let newWall = new Wall2D(vertex, wall.endVertex());
	      wall.endVertex(vertex);
	
	      const tail = [newWall].concat(walls.slice(wallIndex + 1));
	      walls = walls.slice(0, wallIndex + 1).concat(tail);
	    }
	
	    this.removeVertex = (vertex) => {
	      if (!(vertex instanceof Vertex2d)) return undefined;
	      const walls = this.walls();
	      for (index = 0; index < walls.length; index += 1) {
	        const wall = walls[index];
	        if (wall.startVertex() === vertex) {
	          walls[this.wallIndex(index - 1)].endVertex(walls[this.wallIndex(index + 1)].startVertex());
	          return walls.splice(index, 1);
	        }
	        if (wall.endVertex() === vertex) {
	          walls[this.wallIndex(index + 1)].startVertex(walls[this.wallIndex(index - 1)].endVertex());
	          return walls.splice(index, 1);
	        }
	      }
	      return null;
	    }
	
	    this.remove = (id) => {
	      id = id instanceof Lookup ? id.id() : id;
	      const idMap = this.idMap();
	      const walls = this.walls();
	      const wallCount = walls.length;
	      const item = idMap[id];
	      if (item === undefined) throw new Error(`Unknown id: ${id}`);
	      if (wallCount < 3 && (item instanceof Wall2D || item instanceof Vertex2d))
	          throw new Error('Cannot Remove any more verticies or walls');
	
	      return this.removeVertex(item) || this.removeWall(item) ||
	              this.removeObject(item) || item.remove();
	    }
	
	    this.verticies = (target, before, after) => {
	      const lines = this.walls();
	      if (lines.length === 0) return [];
	      const fullList = [];
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        fullList.push(line.startVertex());
	      }
	      if (target) {
	        const verticies = [];
	        const index = fullList.indexOf(target);
	        if (index === undefined) return null;
	        for (let i = before; i < before + after + 1; i += 1)
	            verticies.push(fullList[Math.mod(i, fullList.length)]);
	        return verticies;
	      } else return fullList;
	
	      return verticies;
	    }
	
	    this.within = (vertex) => {
	      vertex = new Vertex2d(vertex);
	      const endpoint = {x: 0, y: 0};
	      this.verticies().forEach(v => {
	        endpoint.x -= v.x();
	        endpoint.y -= v.y();
	      });
	      const escapeLine = new Line2d(vertex, endpoint);
	      const intersections = [];
	      let onLine = false;
	      const allIntersections = [];
	      this.walls().forEach((wall) => {
	
	        const intersection = wall.findSegmentIntersection(escapeLine);
	        allIntersections.push(intersection);
	        if (intersection) {
	          // Todo make more accurate
	          const xEqual = approximate.eq(intersection.x(), vertex.x());
	          const yEqual = approximate.eq(intersection.y(), vertex.y());
	          if (xEqual && yEqual) onLine = true;
	          intersections.push(intersection);
	        }
	      });
	
	      return onLine || intersections.length % 2 === 1;
	    }
	
	    this.connected = () => {
	      for (let index = 0; index < walls.length; index += 1) {
	        const wall = walls[index];
	        const prevWall = this.prevWall(wall);
	        if (wall.startVertex() !== prevWall.endVertex()) return false;
	      }
	      return true;
	    }
	
	    this.payloads = () => {
	      const payloads = [];
	      this.objects().forEach((obj) => {
	        const center = obj.center();
	        const payload = obj.payload();
	        payloads.push({center, payload});
	      });
	      return payloads;
	    }
	
	    function filterCompare(list) {
	      list = list.map((o) => o.payload());
	      return list.filter((o) => o);
	    }
	
	    this.fromJson = (json) => {
	      const layout = Layout2D.fromJson(json);
	      const origWalls = this.walls();
	      const newWalls = layout.walls();
	      const wallCompare = Array.compare(origWalls, newWalls, true);
	
	      const origObjects = this.objects();
	      const newObjects = layout.objects();
	      const objCompare = Array.compare(origObjects, newObjects, true);
	
	      if (objCompare || wallCompare) {
	        const detail = {layout, objects: {added: [], removed: []}, walls: {added: [], removed: []}};
	        if (objCompare) {
	          detail.objects.added = filterCompare(objCompare.added);
	          detail.objects.removed = filterCompare(objCompare.removed);
	        }
	        if (wallCompare) {
	          detail.walls.added = filterCompare(wallCompare.added);
	          detail.walls.removed = filterCompare(wallCompare.removed);
	        }
	        stateChangeEvent.trigger(undefined, detail);
	      }
	    }
	
	    if (!initialized) this.push({x:1, y:1}, {x:ww, y:0}, {x:ww,y:ww}, {x:0,y:ww});
	    this.walls = () => walls;
	
	    history = new StateHistory(this.toJson, this.fromJson);
	    this.history = () => history;
	  }
	}
	
	// Needs to be internal!!!!
	Layout2D.fromJson = (json) => {
	  const walls = [];
	  const vertexMap = {};
	  json.walls.forEach((wallJson) => walls.push(Wall2D.fromJson(wallJson, vertexMap)));
	
	  const layout = new Layout2D(walls);
	  layout.id(json.id);
	
	  const objects = [];
	  json.objects.forEach((o) => {
	    const center = Vertex2d.fromJson(o.center);
	    let obj = Object2d.get(o.id);
	    if (obj === undefined) {
	      obj = new Object2d(center, layout, undefined, o.name);
	      obj.payloadId(o.payloadId);
	      obj.id(o.id);
	    } else obj.fromJson(o);
	    objects.push(obj);
	  });
	  layout.objects(objects);
	  json.snapLocations.forEach((snapLocJson) => {
	    const view = snapLocJson.view;
	    const obj1 = Lookup.get(snapLocJson[0].objectId);
	    const obj2 = Lookup.get(snapLocJson[1].objectId);
	    const snapLoc1 = obj1[view]().position[snapLocJson[0].location]();
	    const snapLoc2 = obj2[view]().position[snapLocJson[1].location]();
	    snapLoc2.pairWith(snapLoc1);
	  });
	
	  console.log('isConnected:', layout.connected());
	  return layout;
	}
	
	function locateGap(line, point, theta, distance, gap, gaptheta) {
	  const bysector = Line2d.startAndTheta(point, theta);
	  const perpLine = line.perpendicular(distance, point, true);
	  const parrelleLine = perpLine.perpendicular(distance, perpLine.endVertex(), true);
	  const midPoint = bysector.findIntersection(parrelleLine);
	  const halfLine1 = Line2d.startAndTheta(midPoint, gaptheta, gap/2);
	  const halfLine2 = Line2d.startAndTheta(midPoint, gaptheta, gap/-2);
	  const gapLine = halfLine1.combine(halfLine2);
	  return gapLine;
	}
	
	new Layout2D();
	new Object2d();
	new Door2D();
	new Window2D();
	
	Layout2D.Wall2D = Wall2D;
	Layout2D.Window2D = Window2D;
	Layout2D.Object2d = Object2d;
	Layout2D.Door2D = Door2D;
	module.exports = Layout2D;
	
});


RequireJS.addFunction('./app-src/objects/room.js',
function (require, exports, module) {
	

	
	const Cabinet = require('./assembly/assemblies/cabinet.js');
	const Group = require('./group.js');
	const Lookup = require('../../../../public/js/utils/object/lookup');
	const Layout2D = require('../objects/layout');
	
	
	class Room extends Lookup {
	  constructor(name, id) {
	    super(id || String.random(32));
	    const instance = this;
	
	    function groupMap(map, detailLists, listId) {
	      for(let index = 0; index < detailLists[listId].length; index += 1) {
	        const cabinet = detailLists[listId][index];
	        const groupId = cabinet.group().id();
	        if (map[groupId] === undefined) map[groupId] = {added: [], removed: []};
	        map[groupId][listId].push(cabinet);
	      }
	    }
	
	    function onLayoutChange(elem, detail) {
	      const cabGroupMap = {};
	      groupMap(cabGroupMap, detail.objects, 'removed');
	      groupMap(cabGroupMap, detail.objects, 'added');
	
	      instance.groups.forEach((g) => {
	        if (cabGroupMap[g.id()]) {
	          g.objects.removeAll(cabGroupMap[g.id()].removed);
	          g.objects.concatInPlace(cabGroupMap[g.id()].added);
	        }
	      });
	      console.log('onlaychan', detail);
	    }
	    const initialVals = {
	      name: name || `Room ${Room.count++}`,
	      layout: new Layout2D()
	    }
	    initialVals.layout.onStateChange(onLayoutChange);
	    Object.getSet(this, initialVals, 'groups');
	    this.groups = [new Group(this)];
	    this.addGroup = () => this.groups.push(new Group(this));
	  }
	};
	Room.count = 0;
	new Room();
	
	module.exports = Room;
	
});


RequireJS.addFunction('./app-src/objects/order.js',
function (require, exports, module) {
	

	
	const Room = require('./room.js');
	
	class Order {
	  constructor(name, id) {
	    if (id === null) this.loaded = false;
	    else this.loaded = true;
	    const initialVals = {
	      name: name || ++Order.count,
	      id: id || String.random(32),
	    }
	    Object.getSet(this, initialVals, 'rooms');
	    this.rooms = {};
	  }
	}
	
	Order.count = 0;
	module.exports = Order
	
});


RequireJS.addFunction('./app-src/services/history.js',
function (require, exports, module) {
	
class History {
	  constructor() {
	    let changes = [];
	    let changesIndex = [];
	
	      this.addChange = (forward, back) => {
	        changes = changes.slice(0, changesIndex);
	        changes.push({forward, back});
	        changesIndex++;
	      }
	
	    this.getSet = (obj, initialVals, ...attrs) => {
	      attrs = Object.getSet(obj, initialVals, ...attrs);
	      const objFuncs = {};
	      attrs.forEach((attr) => {
	        objFuncs[attr] = obj[attr];
	        obj[attr] = (value) => {
	          if (value !== undefined) {
	            const oldValue = objFuncs[attr]();
	            const back = () => objFuncs[attr](oldValue);
	            const forward = () => objFuncs[attr](value);
	            this.addChange(obj, forward, back);
	          }
	          return objFuncs[attr](value);
	        }
	      });
	    }
	
	    this.undo = () => {
	      const change = changes[--changesIndex];
	      change.back();
	    }
	
	    this.redo = () => {
	      const change = changes[++changesIndex];
	      change.forward();
	    }
	
	    this.canUndo =() => changesIndex > 0;
	    this.canRedo = () => changeIndex < changes.length - 1;
	  }
	}
	
	module.exports = History;
	
});


RequireJS.addFunction('./app-src/services/display-svc.js',
function (require, exports, module) {
	class Register {
	  constructor() {
	    const registered = {};
	    this.register = function (nameOobj, obj) {
	      if ((typeof nameOobj) !== 'object') {
	        registered[nameOobj] = obj;
	      } else {
	        const keys = Object.keys(nameOobj);
	        for (let index = 0; index < keys.length; index += 1) {
	          const key = keys[index];
	          registered[key] = nameOobj[key];
	        }
	      }
	    }
	    this.get = (name) => registered[name];
	  }
	}
	
	module.exports = new Register();
	
});


RequireJS.addFunction('./app-src/services/divide-properties.js',
function (require, exports, module) {
	

	class DivideProperties {
	  constructor(length, center, rotation) {
	    Object.getSet(this, {length, center, rotation})
	  }
	}
	
});


RequireJS.addFunction('./app-src/services/cabinet-opening-coordinates.js',
function (require, exports, module) {
	
class CabinetOpeningCorrdinates {
	  constructor(cabinet, config, sectionProperties) {
	
	    this.divide = sectionProperties.divide;
	    this.setSection = sectionProperties.setSection;
	    this.sections = sectionProperties.sections;
	    this.vertical = sectionProperties.vertical;
	    this.sectionProperties = () => sectionProperties;
	    this.update = () => {
	      let coords;
	      if (config._Type === 'location') {
	        coords = cabinet.evalObject(config.coordinates);
	      } else {
	        const right = cabinet.getAssembly(config.right);
	        const left = cabinet.getAssembly(config.left);
	        const top = cabinet.getAssembly(config.top);
	        const bottom = cabinet.getAssembly(config.bottom);
	
	        const topMax = top.position().centerAdjust('y', '+z');
	        const topMin = top.position().centerAdjust('y', '-z');
	        const leftMax = left.position().centerAdjust('x', '+z');
	        const leftMin = left.position().centerAdjust('x', '-z');
	        const rightMin = right.position().centerAdjust('x', '-z');
	        const rightMax = right.position().centerAdjust('x', '+z');
	        const bottomMin = bottom.position().centerAdjust('y', '-z');
	        const bottomMax = bottom.position().centerAdjust('y', '+z');
	
	        coords = {
	          inner: [
	            {x: leftMax, y: topMin, z: 0},
	            {x: rightMin, y: topMin, z: 0},
	            {x: rightMin, y: bottomMax, z: 0},
	            {x: leftMax, y: bottomMax, z: 0}
	          ],
	          outer: [
	            {x: leftMin, y: topMax, z: 0},
	            {x: rightMax, y: topMax, z: 0},
	            {x: rightMax, y: bottomMin, z: 0},
	            {x: leftMin, y: bottomMin, z: 0}
	          ]
	        }
	      }
	      sectionProperties.updateCoordinates(coords);
	      return coords;
	    }
	  }
	}
	
	module.exports = CabinetOpeningCorrdinates;
	
});


RequireJS.addFunction('./app-src/display-utils/displayManager.js',
function (require, exports, module) {
	

	
	const du = require('../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../public/js/utils/$t.js');
	
	class DisplayManager {
	  constructor(displayId, listId, switchId, selected) {
	    if (switchId && !listId) throw new Error('switchId can be defined iff listId is defined');
	    const id = String.random();
	    const instance = this;
	    this.list = (func) => {
	      const list = [];
	      const runFunc = (typeof func) === 'function';
	      const displayElems = du.id(displayId).children;
	      for (let index = 0; index < displayElems.length; index += 1) {
	        const elem = displayElems[index];
	        let id = elem.id || String.random(7);
	        elem.id = id;
	        name = elem.getAttribute('name') || id;
	        const item = {id, name, link: elem.getAttribute('link')};
	        if (runFunc) func(elem);
	        list.push(item);
	      }
	      return list;
	    }
	
	    function updateActive(id) {
	      const items = document.querySelectorAll('.display-manager-input');
	      for (let index = 0; index < items.length; index += 1) {
	        const elem = items[index];
	        elem.getAttribute('display-id') === id ?
	              du.class.add(elem, 'active') : du.class.remove(elem, 'active');
	      }
	    }
	
	    function open(id) {
	      const displayElems = du.id(displayId).children;
	      for (let index = 0; index < displayElems.length; index += 1) {
	        const elem = displayElems[index];
	        if (elem.id === id) {
	          const link = elem.getAttribute('link');
	          if (link) {
	            window.location.href = link;
	            return;
	          }
	          elem.hidden = false;
	        }
	        else elem.hidden = true;
	      }
	      updateActive(id);
	    }
	
	    this.open = open;
	
	    const children = du.id(displayId).children;
	
	    if (switchId) {
	      du.on.match('click', `#${switchId}`, (target, event) => {
	        const listElem = du.id(listId);
	        listElem.hidden = !listElem.hidden;
	      });
	      document.addEventListener('click', (event) => {
	        const listElem = du.id(listId);
	        const target = event.target;
	        const withinList = du.find.up(`#${listId}`, target) !== undefined;
	        if (!withinList && target.id !== switchId &&listElem)
	          listElem.hidden = true;
	      });
	    }
	    DisplayManager.instances[id] = this
	    if ((typeof selected) === 'string') setTimeout(() => open(selected), 100);
	    else if (children.length > 0) {
	      this.list();
	      open(children[0].id);
	    }
	    if (listId) {
	      du.id(listId).innerHTML = DisplayManager.template.render({id, switchId, list: this.list()});
	    }
	  }
	}
	
	DisplayManager.instances = {};
	DisplayManager.template = new $t('display-manager');
	
	du.on.match('click', '.display-manager-input', (target, event) => {
	  const displayManager = du.find.up('.display-manager', target);
	  const displayManagerId = displayManager.id;
	  const displayId = target.getAttribute('display-id');
	  DisplayManager.instances[displayManagerId].open(displayId);
	});
	module.exports = DisplayManager
	
});


RequireJS.addFunction('./app-src/display-utils/information-bar.js',
function (require, exports, module) {
	

	
	const du = require('../../../../public/js/utils/dom-utils.js');
	
	class InformationBar {
	  constructor() {
	    const container = du.create.element('div');
	    container.className = 'information-bar';
	
	    this.show = () => container.hidden = false;
	    this.hide = () => container.hidden = true;
	    this.update = (html) => container.innerHTML = html;
	
	    document.body.append(container);
	  }
	}
	module.exports = InformationBar
	
	
	
	
	
});


RequireJS.addFunction('./app-src/display-utils/radio-display.js',
function (require, exports, module) {
	

	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	const InformationBar = require('./information-bar.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	
	class RadioDisplay {
	  constructor(radioClass, groupAttr, alternateToggleClass) {
	    const afterSwitchEvent = new CustomEvent('afterSwitch');
	    const beforeSwitchEvent = new CustomEvent('beforeSwitch');
	    const selector = (attrVal) => {
	      return groupAttr ? `.${radioClass}[${groupAttr}="${attrVal}"]` : `.${radioClass}`;
	    }
	
	    const infoBar = new InformationBar();
	
	    function path () {
	      let path = '';
	      const info = du.find.downInfo(`.${radioClass}.open`, document.body, null, `.${radioClass}.close`);
	      info.matches.forEach((obj) => {
	        const header = obj.node.children[0];
	        if (header && header.getBoundingClientRect().y < 8) {
	          path += `${header.innerText}=>`
	        }
	      });
	      return path;
	    }
	
	    function triggerAlternateToggles(target) {
	      if (alternateToggleClass) {
	        const alterToggles = document.querySelectorAll(alternateToggleClass);
	        alterToggles.forEach((elem) => elem.hidden = false);
	        const closest = du.closest(alternateToggleClass, target);
	        if (closest) closest.hidden = true;
	      }
	    }
	    this.beforeSwitch = (func) => beforeSwitchEvent.on(func);
	    this.afterSwitch = (func) => afterSwitchEvent.on(func);
	
	
	    du.on.match('scroll', `*`, (target, event) => {
	      infoBar.update(path());
	    });
	
	    let previousHeader;
	    du.on.match('click', `.${radioClass} > .expand-header`, (targetHeader, event) => {
	      const target = targetHeader.parentElement;
	      const attrVal = target.getAttribute(groupAttr);
	      const targetBody = target.children[1];
	      const hidden = targetBody.hidden;
	      targetBody.hidden = !hidden;
	      beforeSwitchEvent.trigger(previousHeader, {previousHeader, targetHeader});
	      if (hidden) {
	        du.class.add(targetHeader, 'active');
	        du.class.swap(target, 'open', 'close');
	        const siblings = document.querySelectorAll(selector(attrVal));
	        for (let index = 0; index < siblings.length; index += 1) {
	          if (siblings[index] !== target) {
	            const sibHeader = siblings[index].children[0];
	            const sibBody = siblings[index].children[1];
	            du.class.swap(siblings[index], 'close', 'open');
	            sibBody.hidden = true;
	            du.class.remove(sibHeader, 'active');
	          }
	        }
	        afterSwitchEvent.trigger(targetHeader, {previousHeader, targetHeader});
	        previousHeader = targetHeader;
	      } else {
	        du.class.swap(target, 'close', 'open');
	        du.class.remove(targetHeader, 'active');
	        afterSwitchEvent.trigger(targetHeader, {previousHeader, targetHeader});
	        previousHeader = null;
	      }
	      infoBar.update(path());
	    });
	  }
	}
	module.exports = RadioDisplay
	
});


RequireJS.addFunction('./app-src/display-utils/toggle-display-list.js',
function (require, exports, module) {
	

	
	const du = require('../../../../public/js/utils/dom-utils.js');
	
	
	const ToggleDisplayList = {};
	ToggleDisplayList.class = 'toggle-display-list';
	ToggleDisplayList.funcs = {};
	
	ToggleDisplayList.onShow = (displayId, func) => {
	  if ((typeof func) === 'function') {
	    if (ToggleDisplayList.funcs[displayId] === undefined) {
	      ToggleDisplayList.funcs[displayId] = [];
	    }
	    ToggleDisplayList.funcs[displayId].push(func);
	  }
	}
	
	ToggleDisplayList.runFuncs = (displayId) => {
	  if (ToggleDisplayList.funcs[displayId] === undefined) return;
	  ToggleDisplayList.funcs[displayId].forEach((func) => func(displayId));
	}
	
	ToggleDisplayList.toggle = function (elem, event) {
	  const target = event.target;
	  const children = elem.children;
	  for (let index = 0; index < children.length; index += 1) {
	    const child = children[index];
	    if (target === child) {
	      du.class.add(child, 'active');
	      const displayId = child.getAttribute('display-id');
	      du.id(displayId).hidden = false;
	      ToggleDisplayList.runFuncs(displayId);
	    } else {
	      du.class.remove(child, 'active');
	      du.id(child.getAttribute('display-id')).hidden = true;
	    }
	  }
	}
	
	du.on.match('click', `.${ToggleDisplayList.class}`, ToggleDisplayList.toggle);
	
	module.exports = ToggleDisplayList;
	
});


RequireJS.addFunction('./app-src/displays/feature.js',
function (require, exports, module) {
	

	const $t = require('../../../../public/js/utils/$t');
	
	class FeatureDisplay {
	  constructor(assembly, parentSelector) {
	    this.html = () => FeatureDisplay.template.render({features: assembly.features, id: 'root'});
	    this.refresh = () => {
	      const container = document.querySelector(parentSelector);
	      container.innerHTML = this.html;
	    }
	  }
	}
	FeatureDisplay.template = new $t('features');
	module.exports = FeatureDisplay
	
});


RequireJS.addFunction('./app-src/displays/cabinet.js',
function (require, exports, module) {
	

	
	const Show = require('../show.js');
	const Select = require('../../../../public/js/utils/input/styles/select.js');
	const ThreeDMain = require('../displays/three-d-main.js');
	const TwoDLayout = require('../two-d/layout');
	const OpenSectionDisplay = require('./open-section.js');
	const CabinetConfig = require('../config/cabinet-configs.js');
	const Cabinet = require('../objects/assembly/assemblies/cabinet.js');
	const ExpandableList = require('../../../../public/js/utils/lists/expandable-list.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const Request = require('../../../../public/js/utils/request.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const bind = require('../../../../public/js/utils/input/bind.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const { Object2d } = require('../objects/layout.js');//.Object2d;
	const Inputs = require('../input/inputs.js');
	const EPNTS = require('../../generated/EPNTS');
	
	
	function getHtmlElemCabinet (elem) {
	  const cabinetId = du.find.up('[cabinet-id]', elem).getAttribute('cabinet-id');
	  return Cabinet.get(cabinetId);
	}
	
	class CabinetDisplay {
	  constructor(parentSelector, group) {
	    let propId = 'Half Overlay';
	    let displayId = String.random();
	    const instance = this;
	    this.propId = (id) => {
	      if (id ===  undefined) return propId;
	      propId = id;
	    }
	    function displayValue(val) {
	      return new Measurement(val).display();
	    }
	    const getHeader = (cabinet, $index) =>
	        CabinetDisplay.headTemplate.render({cabinet, $index, displayValue, displayId});
	    const showTypes = Show.listTypes();
	    const getBody = (cabinet, $index) => {
	      if (expandList.activeKey() === $index) {
	        TwoDLayout.panZoom.once();
	        ThreeDMain.update(cabinet);
	      }
	      const scope = {$index, cabinet, showTypes, OpenSectionDisplay};
	      return CabinetDisplay.bodyTemplate.render(scope);
	    }
	
	    function inputValidation(values) {
	      // const validName = values.name !== undefined;
	      // const validType = CabinetConfig.valid(values.type, values.id);
	      if(true) return true;
	      return {type: 'You must select a defined type.'};
	    }
	
	    function updateLayout(target) {
	      setTimeout(() => {
	        const attr = target.name === 'thickness' ? 'height' : 'width';
	        const cabinet = getHtmlElemCabinet(target);
	        const obj2d = Object2d.get(cabinet.id());
	        const value = new Measurement(target.value, true).decimal();
	        console.log('new cab val', value);
	        obj2d.topview()[attr](value);
	        TwoDLayout.panZoom.once();
	      }, 1000);
	    }
	
	    du.on.match('change', '.cabinet-input.dem[name="width"],.cabinet-input.dem[name="thickness"', updateLayout);
	    du.on.match('blur', '.cabinet-input.dem[name="width"],.cabinet-input.dem[name="thickness"', updateLayout);
	
	    function updateCabValue(cabinet, attr) {
	      const inputCnt = du.find(`[cabinet-id='${cabinet.id()}']`);
	      const input = du.find.down(`[name='${attr}']`, inputCnt);
	      input.value = displayValue(cabinet[attr]());
	    }
	
	    function removeFromLayout(elem, cabinet) {
	      group.room().layout().removeByPayload(cabinet);
	      TwoDLayout.panZoom.once();
	    }
	
	    function linkLayout(cabinet, obj2d) {
	      const topview = obj2d.topview();
	      if (topview.width() !== cabinet.width()) {
	        cabinet.width(topview.width());
	        updateCabValue(cabinet, 'width');
	      }
	      if (topview.height() !== cabinet.thickness()) {
	        cabinet.thickness(topview.height());
	        updateCabValue(cabinet, 'thickness');
	      }
	    }
	
	    function updateObjLayout(cabinet) {
	      const obj2d = group.room().layout().addObject(cabinet.id(), cabinet, cabinet.name);
	      obj2d.topview().onChange(() => linkLayout(cabinet, obj2d));
	    }
	
	    const getObject = (values) => {
	      const cabinet = CabinetConfig.get(group, values.type, values.propertyId, values.name || values.id);
	      setTimeout(() => updateObjLayout(cabinet));
	      return cabinet;
	    };
	    this.active = () => expandList.active();
	    const expListProps = {
	      list: group.objects,
	      dontOpenOnAdd: true,
	      type: 'top-add-list',
	      inputTree:   CabinetConfig.inputTree(),
	      parentSelector, getHeader, getBody, getObject, inputValidation,
	      listElemLable: 'Cabinet'
	    };
	    const expandList = new ExpandableList(expListProps);
	    expandList.afterRemoval(removeFromLayout);
	    this.refresh = () => expandList.refresh();
	
	    const cabinetKey = (path) => {
	      const split = path.split('.');
	      const index = split[0];
	      const key = split[1];
	      const cabinet = expListProps.list[index];
	      return {cabinet, key};
	    }
	
	    const valueUpdate = (path, value) => {
	      const cabKey = cabinetKey(path);
	      const decimal = new Measurement(value, true).decimal();
	      cabKey.cabinet.value(cabKey.key, !Number.isNaN(decimal) ? decimal : val);
	      TwoDLayout.panZoom.once();
	      ThreeDMain.update(cabKey.cabinet);
	    }
	
	    const attrUpdate = (path, value) => {
	      const cabKey = cabinetKey(path);
	      cabKey.cabinet[cabKey.key](value);
	      TwoDLayout.panZoom.once();
	    }
	
	    const saveSuccess = () => console.log('success');
	    const saveFail = () => console.log('failure');
	    const save = (target) => {
	      const index = target.getAttribute('index');
	      const cabinet = expListProps.list[index];
	      if (cabinet.name !== undefined) {
	        Request.post(EPNTS.cabinet.add(cabinet.name()), cabinet.toJson(), saveSuccess, saveFail);
	        console.log('saving');
	      } else {
	        alert('Please enter a name if you want to save the cabinet.')
	      }
	    }
	
	    CabinetConfig.onUpdate(() => props.inputOptions = CabinetConfig.list());
	    bind(`.cabinet-input`, valueUpdate,
	                  {validation: Measurement.validation('(0,)')});
	    bind(`[display-id="${displayId}"].cabinet-id-input`, attrUpdate);
	    du.on.match('click', '.save-cabinet-btn', save);
	  }
	}
	CabinetDisplay.bodyTemplate = new $t('cabinet/body');
	CabinetDisplay.headTemplate = new $t('cabinet/head');
	module.exports = CabinetDisplay
	
});


RequireJS.addFunction('./app-src/displays/group.js',
function (require, exports, module) {
	

	
	const Group = require('../objects/group.js');
	const PropertyConfig = require('../config/property/config.js');
	const Properties = require('../config/properties.js');
	const CabinetDisplay = require('./cabinet.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const Select = require('../../../../public/js/utils/input/styles/select.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const bind = require('../../../../public/js/utils/input/bind.js');
	const ThreeDMain = require('../displays/three-d-main.js');
	
	const currentStyleState = {};
	
	function disableButton(values, dit, elem) {
	  const nId = dit.node.constructor.decode(dit.root().id()).id;
	  const currState = currentStyleState[nId];
	  const rootId = dit.node.constructor.decode(dit.root().id()).id;
	  const button = du.find(`button[root-id='${rootId}']`);
	  if (button) button.hidden = Object.equals(currState, values);
	  const headers = du.find.downAll('.group-header', du.find.up('.group-cnt', button));
	  headers.forEach((header) => {
	    header.hidden = currState.style !== header.getAttribute("cab-style");
	    if (!header.hidden) du.find.down('.group-key', header).innerText = currState.subStyle;
	  });
	}
	
	class GroupDisplay extends Lookup {
	  constructor(group) {
	    super();
	    function setCurrentStyleState(values) {
	      values = values || dit.values();
	      const nId = dit.node.constructor.decode(dit.root().id()).id;
	      currentStyleState[nId] = values;
	      disableButton(values, dit);
	      return values;
	    }
	    function onCabinetStyleSubmit(values) {
	      setCurrentStyleState(values);
	      group.propertyConfig.set(values.style, values.subStyle);
	      ThreeDMain.update();
	    }
	
	    let initialized = false;
	    function initializeDitButton() {
	      if (initialized) disableButton(dit.values(), dit);
	      else {
	        disableButton(setCurrentStyleState(), dit);
	        initialized = true;
	      }
	    }
	    const dit = GroupDisplay.DecisionInputTree(onCabinetStyleSubmit, group.propertyConfig);
	    function styleSelector() {
	      return dit.root().payload().html();
	    }
	    function propertyHtml() {return GroupDisplay.propertyMenuTemplate.render({styleSelector})};
	    this.html = () => {
	      return GroupDisplay.headTemplate.render({group, propertyHtml, groupDisplay: this});
	    }
	    this.bodyHtml = () =>  {
	      setTimeout(initializeDitButton, 200);
	      return GroupDisplay.bodyTemplate.render({group, propertyHtml});
	    }
	
	    this.cabinetDisplay = new CabinetDisplay(`[group-id="${group.id()}"].cabinet-cnt`, group);
	    this.cabinet = () => this.cabinetDisplay().active();
	  }
	}
	
	GroupDisplay.DecisionInputTree = (onSubmit, propertyConfigInst) => {
	  const dit = new DecisionInputTree(undefined, {buttonText: 'Change'});
	  dit.onChange(disableButton);
	  dit.onSubmit(onSubmit);
	  const propertyConfig = new PropertyConfig();
	  const styles = propertyConfig.cabinetStyles();
	  const cabinetStyles = new Select({
	    name: 'style',
	    list: styles,
	    label: 'Style',
	    value: propertyConfigInst.cabinetStyle()
	  });
	
	  const hasFrame = new Select({
	      name: 'FrameStyle',
	      list: ['Frameless', 'Framed', 'Frame Only'],
	      value: 'Frameless'
	    });
	
	  const style = dit.branch('style', [hasFrame, cabinetStyles]);
	  styles.forEach((styleName) => {
	    const properties = Properties.groupList(styleName);
	    const selectObj = Object.keys(properties);
	    const select = new Select({
	      name: 'subStyle',
	      list: selectObj,
	      value: propertyConfigInst.cabinetStyleName()
	    });
	    const condtionalPayload = new DecisionInputTree.ValueCondition('style', [styleName], [select]);
	    style.conditional(styleName, condtionalPayload);
	  });
	
	  return dit;
	}
	
	du.on.match('click', `.group-display-header`, (target) => {
	  const allBodys = du.find.all('.group-display-body');
	  for (let index = 0; index < allBodys.length; index += 1) {
	    allBodys[index].hidden = true;
	  }
	  const allHeaders = du.find.all('.group-display-header');
	  for (let index = 0; index < allHeaders.length; index += 1) {
	    du.class.remove(allHeaders[index], 'active');
	  }
	  du.class.add(target, 'active');
	  const body = du.find.closest('.group-display-body', target);
	  const groupDisplayId = du.find.up('[group-display-id]', target).getAttribute('group-display-id');
	  const groupDisplay = GroupDisplay.get(groupDisplayId);
	  body.innerHTML = groupDisplay.bodyHtml();
	  groupDisplay.cabinetDisplay.refresh();
	  body.hidden = false;
	});
	
	GroupDisplay.valueUpdate = (target) => {
	  const group = Group.get(target.getAttribute('group-id'));
	  const value = target.value;
	  group.name(value);
	}
	
	du.on.match('change', `[group-id].group-input`, GroupDisplay.valueUpdate);
	
	GroupDisplay.headTemplate = new $t('group/head');
	GroupDisplay.bodyTemplate = new $t('group/body');
	GroupDisplay.propertyMenuTemplate = new $t('properties/property-menu');
	module.exports = GroupDisplay
	
});


RequireJS.addFunction('./app-src/two-d/pan-zoom.js',
function (require, exports, module) {
	
// Took thiss code from https://stackoverflow.com/a/33929456
	function panZoom(canvas, draw) {
	  let mrx, mry;
	  const eventFuncs = [];
	  const instance = this;
	
	  this.on = (eventName) => {
	    if (eventFuncs[eventName] === undefined) eventFuncs[eventName] = [];
	    return (func) => {
	      if ((typeof func) === 'function') {
	        eventFuncs[eventName].push(func);
	      }
	    }
	  }
	  let sleeping = null;
	  let nextUpdateId = 0;
	  this.sleep = () => sleeping = true;
	  this.wake = () => {
	    if (sleeping) {
	      sleeping = false;
	      requestAnimationFrame(() => update(nextUpdateId));
	    }
	  };
	  this.once = () => {
	    requestAnimationFrame(() => update(nextUpdateId, true))
	  };
	
	  this.onMove = this.on('move');
	  this.onClick = this.on('click');
	  this.onMousedown = this.on('mousedown');
	  this.onMouseup = this.on('mouseup');
	
	  function eventObject(eventName, event) {
	    let x  =  mouse.rx;
	    let y = mouse.ry;
	    const dt = displayTransform;
	    x -= dt.x;
	    y -= dt.y;
	    // screenX and screen Y are the screen coordinates.
	    screenX = event.pageX;//dt.scale*(x * dt.matrix[0] + y * dt.matrix[2])+dt.cox;
	    screenY = event.pageY;//dt.scale*(x * dt.matrix[1] + y * dt.matrix[3])+dt.coy;
	    return {
	      eventName, screenX, screenY,
	      imageX: mouse.rx,
	      imageY: mouse.ry,
	      dx: mrx,
	      dy: mry,
	    };
	  }
	
	  function runOn(type, event) {
	    const dt = displayTransform;
	    let performingFunction = false;
	    const funcs = eventFuncs[type];
	    const eventObj  = eventObject(type, event);
	    for (let index = 0; !performingFunction && index < funcs.length; index += 1) {
	      performingFunction = funcs[index](eventObj, event);
	    }
	    return performingFunction;
	  }
	
	  var ctx = canvas.getContext("2d");
	  var mouse = {
	      x : 0,
	      y : 0,
	      w : 0,
	      alt : false,
	      shift : false,
	      ctrl : false,
	      buttonLastRaw : 0, // user modified value
	      buttonRaw : 0,
	      over : false,
	      buttons : [1, 2, 4, 6, 5, 3], // masks for setting and clearing button raw bits;
	  };
	  let lastMouseMovementId = 0;
	  function mouseMove(event) {
	      const mouseMovementId = ++lastMouseMovementId;
	      mouse.x = event.offsetX;
	      mouse.y = event.offsetY;
	      if (mouse.x === undefined) {
	          mouse.x = event.clientX;
	          mouse.y = event.clientY;
	      }
	      runOn('move', event);
	      mouse.alt = event.altKey;
	      mouse.shift = event.shiftKey;
	      mouse.ctrl = event.ctrlKey;
	      if (event.type === "mousedown") {
	        if (!runOn('mousedown', event))  {
	          event.preventDefault()
	          mouse.buttonRaw |= mouse.buttons[event.which-1];
	        }
	      } else if (event.type === "mouseup") {
	        if (!runOn('mouseup', event)) {
	          mouse.buttonRaw &= mouse.buttons[event.which + 2];
	        }
	      } else if (event.type === "mouseout") {
	          mouse.buttonRaw = 0;
	          mouse.over = false;
	      } else if (event.type === "mouseover") {
	          mouse.over = true;
	      } else if (event.type === "mousewheel") {
	          event.preventDefault()
	          mouse.w = event.wheelDelta;
	      } else if (event.type === "DOMMouseScroll") { // FF you pedantic doffus
	         mouse.w = -event.detail;
	      }
	      instance.wake();
	      setTimeout(() => {
	        if (mouseMovementId === lastMouseMovementId) instance.sleep()
	      }, 500);
	  }
	
	  function setupMouse(e) {
	      e.addEventListener('mousemove', mouseMove);
	      e.addEventListener('mousedown', mouseMove);
	      e.addEventListener('mouseup', mouseMove);
	      e.addEventListener('mouseout', mouseMove);
	      e.addEventListener('mouseover', mouseMove);
	      e.addEventListener('mousewheel', mouseMove);
	      e.addEventListener('DOMMouseScroll', mouseMove); // fire fox
	
	      e.addEventListener("contextmenu", function (e) {
	          e.preventDefault();
	      }, false);
	  }
	  setupMouse(canvas);
	
	  let transformCount = 0;
	  const round = (val) => Math.round((val*100)/displayTransform.scale) / 100;
	  const print = (...attrs) => {
	    if (transformCount++ % 100 !== 0) return;
	    let str = '';
	    for (let index = 0; index < attrs.length; index += 1) {
	      const attr = attrs[index];
	      str += `${attr}: ${round(displayTransform[attr])} `;
	    }
	  }
	  this.displayTransform = displayTransform;
	  // terms.
	  // Real space, real, r (prefix) refers to the transformed canvas space.
	  // c (prefix), chase is the value that chases a requiered value
	  var displayTransform = {
	      x:0,
	      y:0,
	      ox:0,
	      oy:0,
	      scale:1,
	      rotate:0,
	      cx:0,  // chase values Hold the actual display
	      cy:0,
	      cox:0,
	      coy:0,
	      cscale:1,
	      crotate:0,
	      dx:0,  // deltat values
	      dy:0,
	      dox:0,
	      doy:0,
	      dscale:1,
	      drotate:0,
	      drag:0.2,  // drag for movements
	      accel:0.7, // acceleration
	      matrix:[0,0,0,0,0,0], // main matrix
	      invMatrix:[0,0,0,0,0,0], // invers matrix;
	      mouseX:0,
	      mouseY:0,
	      ctx:ctx,
	      setTransform:function(){
	          var m = this.matrix;
	          var i = 0;
	          const dt = displayTransform;
	          print('x', 'y',  'dx', 'dy', 'mouseX', 'mouseY', 'scale');
	          this.ctx.setTransform(m[i++],m[i++],m[i++],m[i++],m[i++],m[i++]);
	      },
	      setHome:function(){
	          this.ctx.setTransform(1,0,0,1,0,0);
	
	      },
	      update:function(){
	          // smooth all movement out. drag and accel control how this moves
	          // acceleration
	          this.dx += (this.x-this.cx)*this.accel;
	          this.dy += (this.y-this.cy)*this.accel;
	          this.dox += (this.ox-this.cox)*this.accel;
	          this.doy += (this.oy-this.coy)*this.accel;
	          this.dscale += (this.scale-this.cscale)*this.accel;
	          this.drotate += (this.rotate-this.crotate)*this.accel;
	          // drag
	          this.dx *= this.drag;
	          this.dy *= this.drag;
	          this.dox *= this.drag;
	          this.doy *= this.drag;
	          this.dscale *= this.drag;
	          this.drotate *= this.drag;
	          // set the chase values. Chase chases the requiered values
	          this.cx += this.dx;
	          this.cy += this.dy;
	          this.cox += this.dox;
	          this.coy += this.doy;
	          this.cscale += this.dscale;
	          this.crotate += this.drotate;
	
	          // create the display matrix
	          this.matrix[0] = Math.cos(this.crotate)*this.cscale;
	          this.matrix[1] = Math.sin(this.crotate)*this.cscale;
	          this.matrix[2] =  - this.matrix[1];
	          this.matrix[3] = this.matrix[0];
	
	          // set the coords relative to the origin
	          this.matrix[4] = -(this.cx * this.matrix[0] + this.cy * this.matrix[2])+this.cox;
	          this.matrix[5] = -(this.cx * this.matrix[1] + this.cy * this.matrix[3])+this.coy;
	
	
	          // create invers matrix
	          var det = (this.matrix[0] * this.matrix[3] - this.matrix[1] * this.matrix[2]);
	          this.invMatrix[0] = this.matrix[3] / det;
	          this.invMatrix[1] =  - this.matrix[1] / det;
	          this.invMatrix[2] =  - this.matrix[2] / det;
	          this.invMatrix[3] = this.matrix[0] / det;
	
	          // check for mouse. Do controls and get real position of mouse.
	          if(mouse !== undefined){  // if there is a mouse get the real cavas coordinates of the mouse
	              let mdx = mouse.x-mouse.oldX; // get the mouse movement
	              let mdy = mouse.y-mouse.oldY;
	              mrx = (mdx * this.invMatrix[0] + mdy * this.invMatrix[2]);
	              mry = (mdx * this.invMatrix[1] + mdy * this.invMatrix[3]);
	              if(mouse.oldX !== undefined && (mouse.buttonRaw & 1)===1){ // check if panning (middle button)
	                  // get the movement in real space
	                  this.x -= mrx;
	                  this.y -= mry;
	              }
	              // do the zoom with mouse wheel
	              if(mouse.w !== undefined && mouse.w !== 0){
	                  this.ox = mouse.x;
	                  this.oy = mouse.y;
	                  this.x = this.mouseX;
	                  this.y = this.mouseY;
	                  /* Special note from answer */
	                  // comment out the following is you change drag and accel
	                  // and the zoom does not feel right (lagging and not
	                  // zooming around the mouse
	                  /*
	                  this.cox = mouse.x;
	                  this.coy = mouse.y;
	                  this.cx = this.mouseX;
	                  this.cy = this.mouseY;
	                  */
	                  if(mouse.w > 0){ // zoom in
	                      this.scale *= 1.1;
	                      mouse.w -= 20;
	                      if(mouse.w < 0){
	                          mouse.w = 0;
	                      }
	                  }
	                  if(mouse.w < 0){ // zoom out
	                      this.scale *= 1/1.1;
	                      mouse.w += 20;
	                      if(mouse.w > 0){
	                          mouse.w = 0;
	                      }
	                  }
	
	              }
	              // get the real mouse position
	              var screenX = (mouse.x - this.cox);
	              var screenY = (mouse.y - this.coy);
	              this.screenX = screenX;
	              this.screenY = screenY;
	              this.mouseX = this.cx + (screenX * this.invMatrix[0] + screenY * this.invMatrix[2]);
	              this.mouseY = this.cy + (screenX * this.invMatrix[1] + screenY * this.invMatrix[3]);
	              mouse.rx = this.mouseX;  // add the coordinates to the mouse. r is for real
	              mouse.ry = this.mouseY;
	              // save old mouse position
	              mouse.oldX = mouse.x;
	              mouse.oldY = mouse.y;
	          }
	
	      }
	  }
	  // image to show
	  var img = new Image();
	  img.src = "https://upload.wikimedia.org/wikipedia/commons/e/e5/Fiat_500_in_Emilia-Romagna.jpg"
	  // set up font
	  ctx.font = "14px verdana";
	  ctx.textAlign = "center";
	  ctx.textBaseline = "middle";
	  // timer for stuff
	  var timer =0;
	  function update(updateId, once){
	    if (nextUpdateId !== updateId) return;
	      nextUpdateId++;
	      timer += 1; // update timere
	      // update the transform
	      displayTransform.update();
	      // set home transform to clear the screem
	      displayTransform.setHome();
	      ctx.clearRect(0,0,canvas.width,canvas.height);
	      // if the image loaded show it
	      if(img.complete){
	        displayTransform.setTransform();
	        draw(canvas);
	        ctx.fillStyle = "white";
	        // if(Math.floor(timer/100)%2 === 0){
	        //     ctx.fillText("Left but to pan",mouse.rx,mouse.ry);
	        // }else{
	        //     ctx.fillText("Wheel to zoom",mouse.rx,mouse.ry);
	        // }
	    }else{
	        // waiting for image to load
	        displayTransform.setTransform();
	        ctx.fillText("Loading image...",100,100);
	
	    }
	    if(mouse.buttonRaw === 4){ // right click to return to homw
	         displayTransform.x = 0;
	         displayTransform.y = 0;
	         displayTransform.scale = 1;
	         displayTransform.rotate = 0;
	         displayTransform.ox = 0;
	         displayTransform.oy = 0;
	     }
	    // reaquest next frame
	    if (sleeping === false) {
	      if (once) sleeping = true;
	      setTimeout(() => requestAnimationFrame(() => update(nextUpdateId)), 10);
	    }
	  }
	  update(nextUpdateId); // start it happening
	
	  this.centerOn = function(x, y) {
	    displayTransform.scale = 1;
	    displayTransform.x = x - (canvas.width / 2) - displayTransform.x - displayTransform.dx;
	    displayTransform.y = y - (canvas.height / 2) - displayTransform.y - displayTransform.dy;
	  };
	
	  return this;
	}
	
	module.exports = panZoom;
	
});


RequireJS.addFunction('./app-src/two-d/draw.js',
function (require, exports, module) {
	
const Circle2d = require('./objects/circle');
	const Line2d = require('./objects/line');
	const LineMeasurement2d = require('./objects/line-measurement');
	
	class Draw2d {
	  constructor(canvas) {
	    const ctx = canvas.getContext('2d');
	
	    function draw(object, color, width) {
	      if (object === undefined) return;
	      if (Array.isArray(object)) {
	        for (let index = 0; index < object.length; index += 1)
	          draw(object[index], color, width);
	        return;
	      }
	      switch (object.constructor.name) {
	        case 'Line2d':
	          draw.line(object, color, width);
	          break;
	        case 'Circle2d':
	          draw.circle(object, color, width);
	          break;
	        case 'Plane2d':
	          draw.plane(object, color, width);
	          break;
	        case 'Polygon2d':
	          draw.polygon(object, color, width);
	          break;
	        case 'Square2d':
	          draw.square(object, color, width);
	          break;
	        case 'LineMeasurement2d':
	          draw.measurement(object, color, width);
	          break;
	        default:
	          console.error(`Cannot Draw '${object.constructor.name}'`);
	      }
	    }
	
	    draw.canvas = () => canvas;
	    draw.ctx = () => ctx;
	    draw.beginPath = () => ctx.beginPath();
	    draw.moveTo = () => ctx.moveTo();
	
	    draw.clear = () => {
	      ctx.save();
	      ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.clearRect(0, 0, canvas.width, canvas.height);
	      ctx.restore();
	    }
	    draw.line = (line, color, width, doNotMeasure) => {
	      if (line === undefined) return;
	      color = color ||  'black';
	      width = width || 10;
	      const measurePoints = line.measureTo();
	      ctx.beginPath();
	      ctx.strokeStyle = color;
	      ctx.lineWidth = width;
	      ctx.moveTo(line.startVertex().x(), line.startVertex().y());
	      ctx.lineTo(line.endVertex().x(), line.endVertex().y());
	      ctx.stroke();
	    }
	
	    draw.plane = (plane, color, width) => {
	      if (plane === undefined) return;
	      color = color ||  'black';
	      width = width || .1;
	      plane.getLines().forEach((line) => draw.line(line, color, width));
	    }
	
	    draw.polygon = (poly, color, width) => {
	      if (poly === undefined) return;
	      color = color ||  'black';
	      width = width || .1;
	      poly.lines().forEach((line) => draw.line(line, color, width));
	      if ((typeof poly.getTextInfo) === 'function') {
	        ctx.save();
	        const info = poly.getTextInfo();
	        ctx.translate(info.center.x(), info.center.y());
	        ctx.rotate(info.radians);
	        ctx.beginPath();
	        ctx.lineWidth = 4;
	        ctx.strokeStyle = 'black';
	        ctx.fillStyle =  'black';
	        const text = info.limit === undefined ? info.text : info.text.substring(0, info.limit);
	        ctx.fillText(text, info.x, info.y, info.maxWidth);
	        ctx.stroke()
	        ctx.restore();
	      }
	    }
	
	    draw.square = (square, color, text) => {
	      ctx.save();
	      ctx.beginPath();
	      ctx.lineWidth = 2;
	      ctx.strokeStyle = 'black';
	      ctx.fillStyle = color;
	
	      const center = square.center();
	      ctx.translate(center.x(), center.y());
	      ctx.rotate(square.radians());
	      ctx.rect(square.offsetX(true), square.offsetY(true), square.width(), square.height());
	      ctx.stroke();
	      ctx.fill();
	
	      if (text) {
	        ctx.beginPath();
	        ctx.lineWidth = 4;
	        ctx.strokeStyle = 'black';
	        ctx.fillStyle =  'black';
	        ctx.fillText(text, 0, square.height() / 4, square.width());
	        ctx.stroke()
	      }
	
	      ctx.restore();
	    }
	
	    draw.text = (text, center, width, color, maxWidth) => {
	      ctx.beginPath();
	      ctx.lineWidth = width || 4;
	      ctx.strokeStyle = color || 'black';
	      ctx.fillStyle =  color || 'black';
	      ctx.font = width + "px Arial";
	      ctx.fillText(text, center.x, center.y, maxWidth);
	      ctx.stroke()
	    }
	
	    draw.circle = (circle, lineColor, fillColor, lineWidth) => {
	      const center = circle.center();
	      ctx.beginPath();
	      ctx.lineWidth = lineWidth || 2;
	      ctx.strokeStyle = lineColor || 'black';
	      ctx.fillStyle = fillColor || 'white';
	      ctx.arc(center.x(),center.y(), circle.radius(),0, 2*Math.PI);
	      ctx.stroke();
	      ctx.fill();
	    }
	
	    const blank = 4;
	    const hblank = blank/2;
	    function drawMeasurementLabel(line, measurement) {
	      if (measurement === undefined) return;
	      const ctx = draw.ctx();
	      const midpoint = line.midpoint();
	
	      ctx.save();
	      ctx.lineWidth = 0;
	      const length = measurement.display();
	      const textLength = length.length;
	      ctx.translate(midpoint.x(), midpoint.y());
	      ctx.rotate(line.radians());
	      ctx.beginPath();
	      ctx.fillStyle = "white";
	      ctx.strokeStyle = 'white';
	      ctx.rect((textLength * -3)/14, -4/15, (textLength * 6)/14, 8/15);
	      ctx.fill();
	      ctx.stroke();
	
	      ctx.beginPath();
	      ctx.font = (Math.abs((Math.log(Math.floor(line.length() * 10)))) || .1) + "px Arial";
	      ctx.lineWidth = .2;
	      ctx.strokeStyle = 'black';
	      ctx.fillStyle =  'black';
	      ctx.fillText(length, 0, 0);
	      ctx.stroke()
	      ctx.restore();
	    }
	
	    draw.measurement = (measurement, color, textWidth) => {
	      const measurementColor = color || 'grey';
	      const measurementLineWidth = '.1';
	      const lines = measurement.I();
	      try {
	        const winner = lines.furtherLine();
	        draw.beginPath();
	        draw.line(winner.startLine, measurementColor, measurementLineWidth, true);
	        draw.line(winner.endLine, measurementColor, measurementLineWidth, true);
	        draw.line(winner, measurementColor, measurementLineWidth, true);
	        drawMeasurementLabel(winner, measurement);
	      } catch (e) {
	        console.error('Measurement render error:', e);
	      }
	    }
	
	    return draw;
	  }
	}
	
	module.exports = Draw2d;
	
});


RequireJS.addFunction('./app-src/three-d/three-d-model.js',
function (require, exports, module) {
	

	const CSG = require('../../public/js/3d-modeling/csg');
	
	const FunctionCache = require('../../../../public/js/utils/services/function-cache.js');
	const Polygon3D = require('./objects/polygon');
	const Assembly = require('../objects/assembly/assembly');
	const Handle = require('../objects/assembly/assemblies/hardware/pull.js');
	const DrawerBox = require('../objects/assembly/assemblies/drawer/drawer-box.js');
	const pull = require('./models/pull.js');
	const drawerBox = require('./models/drawer-box.js');
	const Viewer = require('../../public/js/3d-modeling/viewer.js').Viewer;
	const addViewer = require('../../public/js/3d-modeling/viewer.js').addViewer;
	const du = require('../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	
	const colors = {
	  indianred: [205, 92, 92],
	  lightcoral: [240, 128, 128],
	  salmon: [250, 128, 114],
	  darksalmon: [233, 150, 122],
	  lightsalmon: [255, 160, 122],
	  white: [255, 255, 255],
	  silver: [192, 192, 192],
	  gray: [128, 128, 128],
	  black: [0, 0, 0],
	  red: [255, 0, 0],
	  maroon: [128, 0, 0],
	  yellow: [255, 255, 0],
	  olive: [128, 128, 0],
	  lime: [0, 255, 0],
	  green: [0, 128, 0],
	  aqua: [0, 255, 255],
	  teal: [0, 128, 128],
	  blue: [0, 0, 255],
	  navy: [0, 0, 128],
	  fuchsia: [255, 0, 255],
	  purple: [128, 0, 128]
	}
	
	const colorChoices = Object.keys(colors);
	function getColor(name) {
	  if(colors[name]) return colors[name];
	  return colors[colorChoices[Math.floor(Math.random() * colorChoices.length)]];
	}
	
	class ThreeDModel {
	  constructor(assembly, viewer) {
	    const lastModelUpdateEvent = new CustomEvent('lastModelUpdate');
	    const hiddenPartIds = {};
	    const hiddenPartNames = {};
	    const hiddenPrefixes = {};
	    const instance = this;
	    let hiddenPrefixReg;
	    let extraObjects = [];
	    let inclusiveTarget = {};
	    let partMap;
	    let renderId;
	    let targetPartCode;
	    let rootAssembly = assembly.getRoot();
	    this.setTargetPartCode = (id) => targetPartCode = id;
	
	    this.assembly = (a) => {
	      if (a !== undefined) {
	        assembly = a;
	        rootAssembly = a.getRoot();
	      }
	      return assembly;
	    }
	
	    this.partMap = () => partMap;
	    this.isTarget = (type, value) => {
	      return inclusiveTarget.type === type && inclusiveTarget.value === value;
	    }
	    this.inclusiveTarget = function(type, value) {
	      let prefixReg;
	      if (type === 'prefix') prefixReg = new RegExp(`^${value}`)
	      inclusiveTarget = {type, value, prefixReg};
	    }
	
	    function inclusiveMatch(part) {
	      if (!inclusiveTarget.type || !inclusiveTarget.value) return null;
	      switch (inclusiveTarget.type) {
	        case 'prefix':
	          return part.partName().match(inclusiveTarget.prefixReg) !== null;
	          break;
	        case 'part-name':
	          return part.partName() === inclusiveTarget.value;
	        case 'part-id':
	          return part.id() === inclusiveTarget.value;
	        default:
	          throw new Error('unknown inclusiveTarget type');
	      }
	    }
	
	    function manageHidden(object) {
	      return function (attr, value) {
	        if (value === undefined) return object[attr] === true;
	       object[attr] = value === true;
	       instance.render();
	      }
	    }
	
	    // Quick and dirty
	    function centerModel(model) {
	      const offset = model.distCenter();
	      offset.z += 100;
	      offset.y -= 50;
	      offset.x -= 50;
	      model.translate(offset);
	    }
	
	    function buildHiddenPrefixReg() {
	      const list = [];
	      const keys = Object.keys(hiddenPrefixes);
	      for (let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        if (hiddenPrefixes[key] === true) {
	          list.push(key);
	        }
	      }
	      hiddenPrefixReg = list.length > 0 ? new RegExp(`^${list.join('|')}`) : null;
	    }
	
	    this.hidePartId = manageHidden(hiddenPartIds);
	    this.hidePartName = manageHidden(hiddenPartNames);
	    this.hidePrefix = manageHidden(hiddenPrefixes);
	
	    function hasHidden(hiddenObj) {
	      const keys = Object.keys(hiddenObj);
	      for(let i = 0; i < hiddenObj.length; i += 1)
	        if (hidden[keys[index]])return true;
	      return false;
	    }
	    this.noneHidden = () => !hasHidden(hiddenPartIds) &&
	        !hasHidden(hiddenPartNames) && !hasHidden(hiddenPrefixes);
	
	    this.depth = (label) => label.split('.').length - 1;
	
	    function hidden(part, level) {
	      if (!part.included()) return true;
	      const im = inclusiveMatch(part);
	      if (im !== null) return !im;
	      if (instance.hidePartId(part.id())) return true;
	      if (instance.hidePartName(part.partName())) return true;
	      if (hiddenPrefixReg && part.partName().match(hiddenPrefixReg)) return true;
	      return false;
	    }
	
	    function coloring(part) {
	      if (part.partName() && part.partName().match(/.*Frame.*/)) return getColor('blue');
	      else if (part.partName() && part.partName().match(/.*Drawer.Box.*/)) return getColor('green');
	      else if (part.partName() && part.partName().match(/.*Handle.*/)) return getColor('silver');
	      return getColor('red');
	    }
	
	    const randInt = (start, range) => start + Math.floor(Math.random() * range);
	    function debugColoring() {
	      return [randInt(0, 255),randInt(0, 255),randInt(0, 255)];
	    }
	
	    this.addVertex = (center, radius, color) => {
	      radius ||= .5;
	      const vertex = CSG.sphere({center, radius});
	      vertex.setColor(getColor(color));
	      extraObjects.push(vertex);
	    }
	
	    this.removeAllExtraObjects = () => extraObjects = [];
	
	    function getModel(assem) {
	      if (assem.constructor.name === 'Handle') {
	        console.log('here');
	      }
	      let model = assem.toModel && assem.toModel();
	      if (model === undefined) {
	        const pos = assem.position().current();
	        if (pos.rotation.x % 45 !== 0 || pos.rotation.y % 45 !== 0 || pos.rotation.z % 45 !== 0) {
	          console.log('position off')
	        }
	        if (assem instanceof DrawerBox) {
	          model = drawerBox(pos.demension.y, pos.demension.x, pos.demension.z);
	        } else {
	          const radius = [pos.demension.x / 2, pos.demension.y / 2, pos.demension.z / 2];
	          model = CSG.cube({ radius });
	        }
	        model.rotate(pos.rotation);
	        // pos.center.z *= -1;
	        model.center(pos.center);
	      }
	      // serialize({}, model);
	      return model;
	    }
	
	    let lm;
	    this.lastModel = () => {
	      if (lm === undefined) return undefined;
	      const polys = [];
	      const map = {xy: [], xz: [], zy: []};
	      lm.polygons.forEach((p, index) => {
	        const norm = p.vertices[0].normal;
	        const verticies = p.vertices.map((v) => ({x: v.pos.x, y: v.pos.y, z: v.pos.z}));
	        polys.push(new Polygon3D(verticies));
	      });
	      // Polygon3D.merge(polys);
	      const twoDpolys = Polygon3D.toTwoD(polys);
	      return twoDpolys;
	    }
	
	    this.onLastModelUpdate = (func) => lastModelUpdateEvent.on(func);
	
	    this.render = function () {
	      ThreeDModel.lastActive = this;
	      const cacheId = rootAssembly.id();
	      // FunctionCache.on(cacheId);
	      FunctionCache.on('sme');
	
	      const startTime = new Date().getTime();
	      buildHiddenPrefixReg();
	      function buildObject(assem) {
	        let a = getModel(assem);
	        // const c = assem.position().center();
	        const e=1;
	        // a.center({x: c.x * e, y: c.y * e, z: -c.z * e});
	        a.setColor(...getColor());
	        assem.getJoints().female.forEach((joint) => {
	          const male = joint.getMale();
	          const m = getModel(male, male.position().current());
	          a = a.subtract(m);
	        });
	        // else a.setColor(1, 0, 0);
	        return a;
	      }
	      const assemblies = this.assembly().getParts();
	      let a;
	      partMap = {};
	      for (let index = 0; index < assemblies.length; index += 1) {
	        const assem = assemblies[index];
	        partMap[assem.id()] = {path: assem.path(), code: assem.partCode(), name: assem.partName()};
	        if (!hidden(assem)) {
	          const b = buildObject(assem);
	          // const c = assem.position().center();
	          // b.center({x: approximate(c.x * e), y: approximate(c.y * e), z: approximate(-c.z * e)});
	          if (a === undefined) a = b;
	          else if (b && b.polygons.length !== 0) {
	            a = a.union(b);
	          }
	          if (assem.partCode() === targetPartCode) {
	            lm = b.clone();
	            const rotation = assem.position().rotation();
	            rotation.x *=-1;
	            rotation.y = (360 - rotation.y)  % 360;
	            rotation.z *=-1;
	            lm.center({x:0,y:0,z:0})
	            lm.rotate(rotation);
	            const lastModel = this.lastModel();
	            lastModelUpdateEvent.trigger(undefined, lastModel);
	          }
	        }
	      }
	      for (let index = 0; index < extraObjects.length; index++) {
	        a = a.union(extraObjects[index]);
	      }
	      if (a) {
	        // a.polygons.forEach((p) => p.shared = getColor());
	        console.log(`Precalculations - ${(startTime - new Date().getTime()) / 1000}`);
	        centerModel(a);
	        viewer.mesh = a.toMesh();
	        viewer.gl.ondraw();
	        console.log(`Rendering - ${(startTime - new Date().getTime()) / 1000}`);
	      }
	      // FunctionCache.off(cacheId);
	      FunctionCache.off('sme');
	    }
	
	    this.update = () => {
	      const rId = renderId = String.random();
	      ThreeDModel.renderId = renderId;
	      setTimeout(() => {
	        if(renderId === rId) instance.render();
	      }, 250);
	    };
	  }
	}
	
	ThreeDModel.models = {};
	ThreeDModel.get = (assembly, viewer) => {
	  if (assembly === undefined) return ThreeDModel.lastActive;
	  if (ThreeDModel.models[assembly.id()] === undefined) {
	    ThreeDModel.models[assembly.id()] = new ThreeDModel(assembly, viewer);
	  }
	  return ThreeDModel.models[assembly.id()];
	}
	ThreeDModel.render = (part) => {
	  const renderId = String.random();
	  ThreeDModel.renderId = renderId;
	  setTimeout(() => {
	    if(ThreeDModel.renderId === renderId) {
	      const cacheId = part.getRoot().id();
	      FunctionCache.on(cacheId);
	      ThreeDModel.get(part).render();
	      FunctionCache.off(cacheId);
	    }
	  }, 2500);
	};
	
	module.exports = ThreeDModel
	
});


RequireJS.addFunction('./app-src/two-d/layout.js',
function (require, exports, module) {
	const Layout2D = require('../objects/layout');
	const panZoom = require('./pan-zoom');
	const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const PopUp = require('../../../../public/js/utils/display/pop-up');
	const Properties = require('../config/properties');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const StringMathEvaluator = require('../../../../public/js/utils/string-math-evaluator.js');
	const Draw2D = require('./draw.js');
	const Vertex2d = require('../two-d/objects/vertex.js');
	const Line2d = require('../two-d/objects/line.js');
	const Snap2d = require('../two-d/objects/snap.js');
	const Circle2d = require('../two-d/objects/circle.js');
	const SnapLocation2d = require('../two-d/objects/snap-location.js');
	const LineMeasurement2d = require('../two-d/objects/line-measurement');
	
	// TODO: Rename
	const TwoDLayout = {};
	
	let draw;
	const eval = new StringMathEvaluator({Math}).eval;
	const popUp = new PopUp({resize: false});
	
	let layout;
	TwoDLayout.set = (l) => {
	  if (l instanceof Layout2D) {
	    layout = l;
	    panZ.once();
	  }
	}
	
	let hoverMap;
	
	const resetHoverMap = () => hoverMap = {
	    Window2D: {}, Door2D: {}, Wall2D: {}, Vertex2d: {}, LineMeasurement2d: {},
	    Object2d: {}, Square2d: {}, Snap2d: {}, SnapLocation2d: {}
	  };
	
	const windowLineWidth = 8;
	const tolerance = 1;
	let lastImagePoint;
	let hovering;
	let dragging;
	let clickHolding = false;
	let popupOpen = false;
	let measurementModify = false;
	let lastDown = 0;
	const selectTimeBuffer = 200;
	const quickChangeFuncs = {};
	
	function getPopUpAttrs(elem) {
	  const cnt =  du.find.up('[type-2d]', elem);
	  if (cnt === undefined) return {};
	  const type = cnt.getAttribute('type-2d');
	  const key = elem.getAttribute('key');
	  const raw = elem.type === 'input' ? eval(elem.value) : elem.value;
	  let value, display;
	  if (elem.getAttribute('convert') === 'false') {
	    value = raw;
	    display = raw;
	  } else {
	    const measurement = new Measurement(raw, true);
	    value = measurement.decimal();
	    display = measurement.display();
	  }
	  const id = cnt.id;
	  return {
	    type,id,key,value,display,raw,
	    obj:  Layout2D.get(id),
	    point: {
	      x: cnt.getAttribute('x'),
	      y: cnt.getAttribute('y')
	    }
	  };
	}
	
	du.on.match('enter', '.value-2d', (elem) => {
	  const props = getPopUpAttrs(elem);
	  const member = elem.getAttribute('member');
	  switch (member) {
	    case 'object':
	      props.obj[props.key](props.raw);
	      const cab = props.obj.payload();
	      if (cab && cab.constructor.name === 'Cabinet') {
	        const cabDemCnt = du.find(`.cabinet-dem-cnt[cabinet-id='${cab.id()}']`);
	        const idInput = du.find.closest('.cabinet-id-input', cabDemCnt);
	        idInput.value = props.raw;
	      }
	      panZ.once();
	      return;
	    case 'cabinet':
	      const cabinet = props.obj.payload();
	      const cabCnt = du.find(`.cabinet-dem-cnt[cabinet-id='${cabinet.id()}']`);
	      if (cabCnt) {
	        const input = du.find.down(`input[name='${props.key}']`, cabCnt);
	        input.value = props.display;
	      }
	      cabinet[props.key](props.value);
	      const poly = props.obj.topview();
	      poly[props.key === 'thickness' ? 'height' : props.key](props.value);
	      poly.update();
	      panZ.once();
	      return;
	  }
	  if (props.obj.payload && props.obj.payload() === 'placeholder') {
	    if (props.key === 'thickness') props.key = 'height';
	    props.obj = props.obj.topview().object();
	  }
	
	  props.obj.topview()[props.key](props.value);
	  elem.value = props.display;
	  props.obj.topview().update();
	  panZ.once();
	});
	
	du.on.match('change', 'input[name=\'UNIT2\']', (elem) => {
	  const props = getPopUpAttrs(elem);
	  const input = du.find.closest('.measurement-mod', elem);
	  if (input) setTimeout(() =>
	      input.value = props.obj.display(), 0);
	});
	
	function remove() {
	  if (hovering.parent) {
	    if (hovering.parent().payload().constructor.name === 'Cabinet') {
	      const cabinet = hovering.parent().payload();
	      const cabinetHeader = du.find(`.cabinet-header[cabinet-id='${cabinet.id()}']`);
	      const removeButton = du.find.closest('.expandable-item-rm-btn', cabinetHeader)
	      if (removeButton) removeButton.click();
	      else console.warn('Remove button for cabinet should be present but is not present');
	    }
	    layout.remove(hovering.parent().id());
	  } else {
	    layout.remove(hovering.id());
	  }
	  popUp.close();
	  TwoDLayout.panZoom.once();
	}
	
	du.on.match('click', '.remove-btn-2d', remove, popUp.container());
	
	du.on.match('click', '.add-door-btn-2d', (elem) => {
	  const attrs = getPopUpAttrs(elem);
	  const distance = attrs.obj.startVertex().distance(attrs.point);
	  attrs.obj.addDoor(distance);
	  panZ.once();
	});
	
	du.on.match('click', '.hinge-btn', (elem) => {
	  const attrs = getPopUpAttrs(elem);
	  attrs.obj.hinge(true);
	  panZ.once();
	});
	
	du.on.match('click', '.add-window-btn-2d', (elem) => {
	  const attrs = getPopUpAttrs(elem);
	  const distance = attrs.obj.startVertex().distance(attrs.point);
	  attrs.obj.addWindow(distance);
	  panZ.once();
	});
	
	du.on.match('click', '.add-object-btn-2d', (elem) => {
	  const props = getPopUpAttrs(elem);
	  const obj = layout.addObject(props.point, 'placeholder');
	  obj.topview().onChange(console.log);
	  panZ.once();
	});
	
	du.on.match('click', '.add-vertex-btn-2d', (elem) => {
	  const attrs = getPopUpAttrs(elem);
	  const point = hovering.closestPointOnLine(attrs.point);
	  layout.addVertex(point, hovering);
	  panZ.once();
	});
	
	du.on.match('enter', '.measurement-mod', (elem) => {
	  const value = eval(elem.value);
	  getPopUpAttrs(elem).obj.modify(value);
	  panZ.once();
	});
	
	// TODO: define cache better.
	function clearCache() {
	  measurementIs = {};
	}
	
	function undo(target) {
	  layout.history().back();
	  clearCache();
	  panZ.once();
	}
	
	function redo () {
	  layout.history().forward();
	  clearCache();
	  panZ.once();
	}
	
	function registerQuickChangeFunc(type, func) {
	  if ((typeof func) === 'function') quickChangeFuncs[type] = func;
	}
	
	function onMousedown(event, stdEvent) {
	  lastDown = clickHolding ? 0 : new Date().getTime();
	  lastImagePoint = {x: event.imageX, y: event.imageY};
	  if (stdEvent.button == 0) {
	    clickHolding = !popupOpen && (clickHolding || hovering !== undefined);
	    return clickHolding;
	  } else {
	    if (hovering && quickChangeFuncs[hovering.constructor.name]) {
	      quickChangeFuncs[hovering.constructor.name](hovering, event, stdEvent);
	    }
	    return true;
	  }
	}
	
	function addVertex(hovering, event, stdEvent) {
	  const point = {x: event.imageX, y: event.imageY};
	  layout.addVertex(point, hovering);
	}
	
	registerQuickChangeFunc('Wall2D', addVertex);
	registerQuickChangeFunc('Vertex2d', remove);
	registerQuickChangeFunc('Window2D', remove);
	registerQuickChangeFunc('SnapLocation2d', (snapLoc) => snapLoc.disconnect());
	registerQuickChangeFunc('Door2D', (door) => door.hinge(true));
	
	function hoverId () {
	  return hovering ? hovering.toString() : undefined;
	}
	
	const templateMap = {};
	function getTemplate(item) {
	  const isSnap = item instanceof Snap2d;
	  const templateLocation = `2d/pop-up/${isSnap ? 'snap-2d' : item.constructor.name.toKebab()}`;
	  if (templateMap[templateLocation] === undefined) {
	    templateMap[templateLocation] = new $t(templateLocation);
	  }
	  return templateMap[templateLocation];
	}
	
	function display(value) {
	  return new Measurement(value).display();
	}
	
	function openPopup(event, stdEvent) {
	  if (hovering) {
	    if (hovering instanceof Snap2d) hovering.pairWithLast();
	    popupOpen = true;
	    const msg = `${hovering.constructor.name}: ${hoverId()}`;
	    const scope = {display, UNITS: Properties.UNITS, target: hovering, lastImagePoint};
	    const html = getTemplate(hovering).render(scope);
	    popUp.open(html, {x: event.screenX, y: event.screenY});
	  }
	}
	
	popUp.onClose((elem, event) => {
	  setTimeout(() => popupOpen = false, 200);
	  const attrs = getPopUpAttrs(du.find.closest('[type-2d]',popUp.container()));
	  measurementModify = attrs.type === 'LineMeasurement2d';
	  lastDown = new Date().getTime();
	  clickHolding = false;
	  if (layout) layout.history().newState();
	});
	
	function onMouseup(event, stdEvent) {
	  if (stdEvent.button == 0) {
	    if (lastDown > new Date().getTime() - selectTimeBuffer) {
	      if (hovering) {
	        setTimeout(() => openPopup(event, stdEvent), 5);
	      } else {
	        measurementModify = !measurementModify;
	      }
	    } else {
	      const clickWasHolding = clickHolding;
	      clickHolding = false;
	      hovering = undefined;
	      if (layout) layout.history().newState();
	      return clickWasHolding;
	    }
	  } else {
	    console.log('rightClick: do stuff!!');
	    if (layout) layout.history().newState();
	  }
	}
	
	let pending = 0;
	function  drag(event)  {
	  const dragging = !popupOpen && clickHolding && hovering;
	  if (dragging)
	    hovering.move && hovering.move({x: event.imageX, y: event.imageY}, event);
	  return dragging;
	}
	
	function hover(event) {
	  if (clickHolding) return true;
	  let found = false;
	  const tuple = {x: event.imageX, y: event.imageY};
	  function  check(list) {
	    for (let index = 0; index < list.length; index += 1) {
	      if (withinTolerance(tuple, list[index])) {
	        hovering = list[index].item;
	        found = true;
	      }
	    }
	    if (!clickHolding && !found) hovering = undefined;
	  }
	
	  if (measurementModify) {
	    check(Object.values(hoverMap.LineMeasurement2d));
	    found || check(Object.values(hoverMap.SnapLocation2d));
	    found || check(Object.values(hoverMap.Snap2d));
	    found || check(Object.values(hoverMap.Object2d));
	    found || check(Object.values(hoverMap.Square2d));
	  } else {
	    check(Object.values(hoverMap.Vertex2d));
	    found || check(Object.values(hoverMap.Window2D));
	    found || check(Object.values(hoverMap.Door2D));
	    found || check(Object.values(hoverMap.Wall2D));
	  }
	
	  return found;
	}
	
	function onMove(event) {
	  if (layout === undefined) return;
	  const canDrag = !popupOpen && lastDown < new Date().getTime() - selectTimeBuffer * 1.5;
	  return (canDrag && drag(event)) || hover(event);
	}
	
	function withinTolerance(point, map) {
	  const x0 = point.x;
	  const y0 = point.y;
	  const x1 = map.start.x;
	  const y1 = map.start.y;
	  const x2 = map.end.x;
	  const y2 = map.end.y;
	  const num = Math.abs((y2 - y1)*x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1)
	  const denom = Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));
	  return num / denom < map.tolerance;
	}
	
	function withinTolerance(point, map) {
	  const t = map.tolerance;
	  const start = map.start.point ? map.start.point() : map.start;
	  const end = map.end.point ? map.end.point() : map.end;
	  const x0 = point.x;
	  const y0 = point.y;
	  const x1 = start.x > end.x ? end.x : start.x;
	  const y1 = start.y > end.y ? end.y : start.y;
	  const x2 = start.x < end.x ? end.x : start.x;
	  const y2 = start.y < end.y ? end.y : start.y;
	  return x0>x1-t && x0 < x2+t && y0>y1-t && y0<y2+t;
	}
	
	function updateHoverMap(item, start, end, tolerance) {
	  let group;
	  if (item instanceof Snap2d) group = 'Snap2d';
	  else group = item.constructor.name;
	  hoverMap[group][item.toString()] = {start, end, tolerance, item};
	}
	
	let windowCount = 0;
	let getWindowColor = () => {
	  switch (Math.floor(Math.random() * 4)) {
	    case 0: return 'red'; case 1: return 'green';
	    case 2: return 'yellow'; case 3: return 'pink';
	  }
	  return 'white';
	}
	
	const windowDrawMap = {};
	function drawWindow(wallStartPoint, window, wallTheta) {
	  draw.beginPath();
	  const points = window.endpoints2D(wallStartPoint);
	  const lookupKey = window.toString();
	  const ctx = draw.ctx();
	  if (windowDrawMap[lookupKey] === undefined) {
	    windowDrawMap[lookupKey] = () => {
	      ctx.moveTo(points.start.x(), points.start.y());
	      ctx.lineWidth = 8;
	      ctx.strokeStyle = hoverId() === window.toString() ? 'green' : 'blue';
	      ctx.lineTo(points.end.x(), points.end.y());
	      updateHoverMap(window, points.start, points.end, 5);
	      ctx.stroke();
	    }
	  }
	  windowDrawMap[lookupKey]();
	}
	
	function updateDoorHoverMap(door, startpointRight, startpointLeft) {
	  updateHoverMap(door, startpointRight, startpointLeft, 15);
	}
	
	function doorDrawingFunc(startpointLeft, startpointRight) {
	  return (door) => {
	    const ctx = draw.ctx();
	    ctx.beginPath();
	    ctx.strokeStyle = hoverId() === door.toString() ? 'green' : 'black';
	    const hinge = door.hinge();
	
	    if (hinge === 4) {
	      ctx.moveTo(startpointLeft.x, startpointLeft.y);
	      ctx.lineWidth = 8;
	      ctx.strokeStyle = hoverId() === door.toString() ? 'green' : 'white';
	      ctx.lineTo(startpointRight.x, startpointRight.y);
	      updateDoorHoverMap(door, startpointRight, startpointLeft, 10);
	      ctx.stroke();
	    } else {
	      const offset = Math.PI * hinge / 2;
	      const initialAngle = (door.wall().radians() + offset) % (2 * Math.PI);
	      const endAngle = initialAngle + (Math.PI / 2);
	
	      if (hinge === 0 || hinge === 3) {
	        ctx.moveTo(startpointRight.x, startpointRight.y);
	        ctx.arc(startpointRight.x, startpointRight.y, door.width(), initialAngle, endAngle, false);
	        ctx.lineTo(startpointRight.x, startpointRight.y);
	      } else {
	        ctx.moveTo(startpointLeft.x, startpointLeft.y);
	        ctx.arc(startpointLeft.x, startpointLeft.y, door.width(), endAngle, initialAngle, true);
	        ctx.lineTo(startpointLeft.x, startpointLeft.y);
	      }
	
	      ctx.fillStyle = 'white';
	      ctx.fill();
	    }
	    updateHoverMap(door, startpointRight, startpointLeft, 10);
	    ctx.stroke();
	  }
	}
	
	const doorDrawMap = {};
	function drawDoor(startpoint, door, wallTheta) {
	  const lookupKey = door.toString();
	  if (doorDrawMap[lookupKey] === undefined) {
	    const initialAngle = wallTheta;
	    const width = door.width();
	
	    const distLeft = door.fromPreviousWall() + width;
	    const startpointLeft = {x: startpoint.x + distLeft * Math.cos(theta), y: startpoint.y + distLeft * Math.sin(theta)};
	    const distRight = door.fromPreviousWall();
	    const startpointRight = {x: startpoint.x + distRight * Math.cos(theta), y: startpoint.y + distRight * Math.sin(theta)};
	    doorDrawMap[lookupKey] = doorDrawingFunc(startpointLeft, startpointRight, initialAngle);
	  }
	  doorDrawMap[lookupKey](door);
	}
	
	const blank = 40;
	const hblank = blank/2;
	function drawMeasurementValue(line, midpoint, measurement) {
	  if (line === undefined) return;
	  const ctx = draw.ctx();
	  midpoint = line.midpoint();
	
	  ctx.save();
	  ctx.lineWidth = 0;
	  const length = measurement.display();
	  const textLength = length.length;
	  ctx.translate(midpoint.x(), midpoint.y());
	  ctx.rotate(line.radians());
	  ctx.beginPath();
	  ctx.fillStyle = hoverId() === measurement.toString() ? 'green' : "white";
	  ctx.strokeStyle = 'white';
	  ctx.rect(textLength * -3, -8, textLength * 6, 16);
	  ctx.fill();
	  ctx.stroke();
	
	  ctx.beginPath();
	  ctx.lineWidth = 4;
	  ctx.strokeStyle = 'black';
	  ctx.fillStyle =  'black';
	  ctx.fillText(length, 0, 0);
	  ctx.stroke()
	  ctx.restore();
	}
	
	const measurementLineMap = {};
	const getMeasurementLine = (vertex1, vertex2) => {
	  const lookupKey = `${vertex1} => ${vertex2}`;
	  if (measurementLineMap[lookupKey] === undefined) {
	    const line = new Line2d(vertex1, vertex2);
	    measurementLineMap[lookupKey] = new LineMeasurement2d(line)
	  }
	  return measurementLineMap[lookupKey];
	}
	
	let measurementValues = [];
	function measurementValueToDraw(line, midpoint, measurement) {
	  measurementValues.push({line, midpoint, measurement});
	}
	
	function drawMeasurementValues() {
	  let values = measurementValues;
	  measurementValues = [];
	  for (let index = 0; index < values.length; index += 1) {
	    let m = values[index];
	    drawMeasurementValue(m.line, m.midpoint, m.measurement);
	  }
	}
	
	const measurementLineWidth = 3;
	let measurementIs = {};
	function drawMeasurement(measurement, level, focalVertex)  {
	  const lookupKey = `${measurement.toString()}-[${level}]`;
	  // if (measurementIs[lookupKey] === undefined) {
	    measurementIs[lookupKey] = measurement.I(level);
	  // }
	  const lines = measurementIs[lookupKey];
	  const center = layout.verticies(focalVertex, 2, 3);
	  const measurementColor = hoverId() === measurement.toString() ? 'green' : 'grey';
	  try {
	    draw.beginPath();
	    const isWithin = layout.within(lines.furtherLine().midpoint());
	    const line = isWithin ? lines.closerLine() : lines.furtherLine();
	    const midpoint = Vertex2d.center(line.startLine.endVertex(), line.endLine.endVertex());
	    if (measurementModify || popupOpen) {
	      draw.line(line.startLine, measurementColor, measurementLineWidth);
	      draw.line(line.endLine, measurementColor, measurementLineWidth);
	      draw.line(line, measurementColor, measurementLineWidth);
	      updateHoverMap(measurement, midpoint, midpoint, 15);
	    }
	    measurementValueToDraw(line, midpoint, measurement);
	    return line;
	  } catch (e) {
	    console.error('Measurement render error:', e);
	  }
	}
	
	function measureOnWall(list, level) {
	  for (let index = 0; index < list.length; index += 1) {
	    let item = list[index];
	    const wall = item.wall();
	    const points = item.endpoints2D();
	    const measureLine1 = getMeasurementLine(wall.startVertex(), points.start);
	    const measureLine2 = getMeasurementLine(points.end, wall.endVertex());
	    measureLine1.modificationFunction(item.fromPreviousWall);
	    measureLine2.modificationFunction(item.fromNextWall);
	    drawMeasurement(measureLine1, level, wall.startVertex())
	    drawMeasurement(measureLine2, level, wall.startVertex())
	    level += 4;
	  }
	  return level;
	}
	
	function includeDetails() {
	  return !dragging && (measurementModify || popupOpen)
	}
	
	function drawWall(wall) {
	  const ctx = draw.ctx();
	  const startpoint = wall.startVertex().point();
	  r =  wall.length();
	  theta = wall.radians();
	  ctx.beginPath();
	  ctx.moveTo(startpoint.x, startpoint.y);
	  ctx.lineWidth = 10;
	  ctx.strokeStyle = hoverId() === wall.toString() ? 'green' : 'black';
	  const endpoint = wall.endVertex().point();
	  ctx.lineTo(endpoint.x, endpoint.y);
	  ctx.stroke();
	
	  wall.doors().forEach((door) =>
	    drawDoor(startpoint, door, wall.radians()));
	  wall.windows().forEach((window) =>
	    drawWindow(startpoint, window, wall.radians()));
	
	  let level = 8;
	  if (includeDetails()) {
	    const verticies = wall.verticies();
	    let measLines = {};
	    level = measureOnWall(wall.doors(), level);
	    level = measureOnWall(wall.windows(), level);
	  }
	  const measurement = new LineMeasurement2d(wall, undefined, undefined, layout.reconsileLength(wall));
	  drawMeasurement(measurement, level, wall.startVertex());
	
	  updateHoverMap(wall, startpoint, endpoint, 5);
	
	  return endpoint;
	}
	
	function drawVertex(vertex) {
	  const fillColor = hoverId() === vertex.toString() ? 'green' : 'white';
	  const p = vertex.point();
	  const radius = 10;
	  const circle = new Circle2d(radius, p);
	  draw.circle(circle, 'black', fillColor);
	  updateHoverMap(vertex, p, p, 12);
	}
	
	function snapLocColor(snapLoc) {
	  switch (snapLoc.location()) {
	    case "backRight": return 'red';
	    case "frontRight": return 'yellow';
	    case "frontLeft": return 'green';
	    case "backLeft": return 'blue';
	    case "backCenter": return 'purple';
	    case "diagonalRight": return 'lime';
	    case "diagonalLeft": return 'azure';
	    default: return "grey"
	  }
	}
	
	function drawSnapLocation(locations, color) {
	  for (let index = 0; index < locations.length; index += 1) {
	    const loc = locations[index];
	    const c = hoverId() === loc.toString() ? 'green' : (color || snapLocColor(loc));
	    draw.circle(loc.circle(), 'black', c);
	    const vertex = loc.vertex();
	    updateHoverMap(loc, vertex.point(), vertex.point(), 8);
	  }
	}
	
	let showAllSnapLocations = true;
	function drawObject(object) {
	  let center, coolor, potentalSnap;
	  switch (object.object().constructor.name) {
	    case 'Square2d':
	      const square = object.object();
	      center = square.center();
	      updateHoverMap(object, center, center, 30);
	      color = hoverId() === object.toString() ? 'green' : 'white';
	      draw.square(square, color, object.parent().name());
	      potentalSnap = object.potentalSnapLocation();
	      if (showAllSnapLocations)
	        drawSnapLocation(object.snapLocations());
	
	      drawSnapLocation(object.snapLocations.paired(), 'black');
	      if (potentalSnap instanceof SnapLocation2d) drawSnapLocation([potentalSnap], 'white');
	      SnapLocation2d.active(object.snapLocations.notPaired());
	      break;
	    case 'Polygon2d':
	      const poly = object.object();
	      center = poly.center();
	      updateHoverMap(object, center, center, 30);
	      color = hoverId() === object.toString() ? 'green' : 'black';
	      draw(poly, color, object.parent().name());
	      potentalSnap = object.potentalSnapLocation();
	      if (showAllSnapLocations)
	        drawSnapLocation(object.snapLocations());
	
	      drawSnapLocation(object.snapLocations.paired(), 'black');
	      if (potentalSnap instanceof SnapLocation2d) drawSnapLocation([potentalSnap], 'white');
	      SnapLocation2d.active(object.snapLocations.notPaired());
	      break;
	    case 'Line2d':
	      draw.line(object);
	      break;
	    case 'Circle2d':
	      draw.circle(object);
	      break;
	    case 'Layout2d':
	      drawLayout(object); // NOT IMPLEMENTED YET!!!
	      break;
	    default:
	      throw new Error(`Cannot draw object with constructor: ${object.object().constructor.name}`);
	  }
	}
	
	function illustrate(canvas) {
	  if (layout === undefined) return;
	  SnapLocation2d.clear();
	  resetHoverMap();
	  let lastEndPoint = {x: 20, y: 20};
	
	  draw.beginPath();
	  const walls = layout.walls();
	  let previousEndpoint;
	  let wl = walls.length;
	  walls.forEach((wall, index) => {
	    lastEndPoint = drawWall(wall, lastEndPoint);
	    const previousWall = walls[(index - 1) % wl];
	    if (previousEndpoint)
	      drawVertex(wall.startVertex());
	    previousEndpoint = lastEndPoint;
	  }, true);
	  drawVertex(walls[0].startVertex());
	  drawMeasurementValues();
	  layout.objects().forEach((obj) => drawObject(obj.topview()));
	}
	
	function updateCanvasSize(canvas) {
	  canvas.style.width = '80vh';
	  const dem = Math.floor(canvas.getBoundingClientRect().width);
	  canvas.width = dem;
	  canvas.height = dem;
	  canvas.style.width = `${dem}px`;
	  canvas.style.width = `${dem}px`;
	}
	
	let panZ;
	function init() {
	  const canvas = document.getElementById('two-d-model');
	  draw = new Draw2D(canvas);
	  updateCanvasSize(draw.canvas());
	  panZ = panZoom(canvas, illustrate);
	  panZ.onMove(onMove);
	  panZ.onMousedown(onMousedown);
	  panZ.onMouseup(onMouseup);
	  // draw(canvas);
	  TwoDLayout.panZoom = panZ;
	  du.on.match('keycombo:Control,z', '*', undo);
	  du.on.match('keycombo:Control,Shift,Z', '*', redo);
	}
	
	TwoDLayout.init = init;
	module.exports = TwoDLayout;
	
});


RequireJS.addFunction('./app-src/objects/joint/joint.js',
function (require, exports, module) {
	
const Lookup = require('../../../../../public/js/utils/object/lookup.js')
	
	
	class Joint {
	  constructor(malePartCode, femalePartCode) {
	    let parentAssembly;
	    const initialVals = {
	      maleOffset: 0, femaleOffset: 0, parentAssemblyId:  undefined,
	      malePartCode, femalePartCode, demensionAxis: '', centerAxis: ''
	    }
	    Object.getSet(this, initialVals);
	
	    this.parentAssembly = () => {
	      if (!parentAssembly && this.parentAssemblyId()) {
	        parentAssembly = Lookup.get(this.parentAssemblyId());
	        this.parentAssemblyId = () => parentAssembly.id();
	      }
	      return parentAssembly;
	    }
	
	    this.updatePosition = () => {};
	
	    this.getFemale = () => this.parentAssembly().getAssembly(this.femalePartCode());
	    this.getMale = () => this.parentAssembly().getAssembly(this.malePartCode());
	
	    this.getDemensions = () => {
	      const malePos = getMale();
	      const femalePos = getFemale();
	      // I created a loop but it was harder to understand
	      return undefined;
	    }
	    this.toString = () => `${this.constructor.name}:${this.malePartCode()}->${this.femalePartCode()}`;
	
	    if (Joint.list[this.malePartCode()] === undefined) Joint.list[this.malePartCode()] = [];
	    if (Joint.list[this.femalePartCode()] === undefined) Joint.list[this.femalePartCode()] = [];
	    Joint.list[this.malePartCode()].push(this);
	    Joint.list[this.femalePartCode()].push(this);
	  }
	}
	Joint.list = {};
	Joint.regex = /([a-z0-9-_\.]{1,})->([a-z0-9-_\.]{1,})/;
	
	Joint.classes = {};
	Joint.register = (clazz) => {
	  new clazz();
	  Joint.classes[clazz.prototype.constructor.name] = clazz;
	}
	Joint.new = function (id, json) {
	  return new Joint.classes[id]().fromJson(json);
	}
	module.exports = Joint
	
});


RequireJS.addFunction('./app-src/three-d/objects/vertex.js',
function (require, exports, module) {
	
const Matrix = require('./matrix');
	const Vector3D = require('./vector');
	const approximate = require('../../../../../public/js/utils/approximate.js');
	const approx10 = approximate.new(10);
	const CSG = require('../../../public/js/3d-modeling/csg.js');
	
	
	class Vertex3D {
	  constructor(x, y, z) {
	    if (x instanceof Vertex3D) return x;
	    if (x === undefined) {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	    } else if (arguments.length == 3) {
	      this.x = x;
	      this.y = y;
	      this.z = z;
	    } else if ('x' in x) {
	      this.x = x.x;
	      this.y = x.y;
	      this.z = x.z;
	    } else {
	      this.x = x[0];
	      this.y = x[1];
	      this.z = x[2];
	    }
	
	    this.translate = (vector, doNotModify) => {
	      let vertex = this;
	      if (doNotModify === true) vertex = this.copy();
	      vertex.x += vector.i();
	      vertex.y += vector.j();
	      vertex.z += vector.k();
	      return vertex;
	    }
	
	    this.positionAt = (vertex) => {
	      this.x = vertex.x;
	      this.y = vertex.y;
	      this.z = vertex.z;
	    }
	
	    this.usless = () => Number.NaNfinity(x, y, z);
	
	    this.vector = (vector) => {
	      const v = vector;
	      if (v) return new Vector3D(this.x + v.i(), this.y + v.j(), this.z + v.k());
	      return new Vector3D(this.x, this.y, this.z);
	    }
	
	    this.rotate = (rotations, center) => {
	      if (center === undefined) return;
	      CSG.rotatePointAroundCenter(rotations, this, center);
	    }
	
	    this.reverseRotate = (rotations, center) => {
	      if (center === undefined) return;
	      CSG.rotatePointAroundCenter(rotations, this, center, true);
	    }
	
	    this.matrix = () => {
	      return new Matrix([[this.x, this.y, this.z]]);
	    }
	
	    this.distance = (other) => {
	      const xDiff = this.x - other.x;
	      const yDiff = this.y - other.y;
	      const zDiff = this.z - other.z;
	
	      return Math.sqrt(xDiff*xDiff + yDiff*yDiff + zDiff*zDiff);
	    }
	
	    this.distanceVector = (other) => {
	      const xDiff = other.x - this.x;
	      const yDiff = other.y - this.y;
	      const zDiff = other.z - this.z;
	
	      return new Vector3D(xDiff, yDiff, zDiff);
	    }
	
	    this.minus = (other) => {
	      const xDiff = this.x - other.x;
	      const yDiff = this.y - other.y;
	      const zDiff = this.z - other.z;
	
	      return new Vector3D(xDiff, yDiff, zDiff);
	    }
	
	    this.inverseVector = () => {
	      return new Vertex3D(this.x * -1, this.y* -1, this.z * -1);
	    }
	
	    this.copy = () => new Vertex3D(this.x, this.y, this.z);
	    this.clone = this.copy;
	    this.equals = (other) => other && approximate.eq(this.x, other.x) &&
	          approximate.eq(this.y, other.y);
	    this.toString = () => `${approx10(this.x)},${approx10(this.y)},${approx10(this.z)}`;
	  }
	}
	
	// returned direction is of list2 relitive to list 1
	// dirArr = [forward, backward, up, down, left, right];
	Vertex3D.direction = (vertList1, vertList2, tolerance, axisOnly) => {
	  tolerance ||= .1;
	  let dirArr = [true, true, true, true, true, true];
	  for (let i = 0; i < vertList1.length; i++) {
	    const vert1 = vertList1[i];
	    for (let j = 0; j < vertList2.length; j++) {
	      const vert2 = vertList2[j];
	      dirArr[0] &&= vert1.z > vert2.z - tolerance;
	      dirArr[1] &&= vert1.z < vert2.z + tolerance;
	      dirArr[2] &&= vert1.y < vert2.y + tolerance;
	      dirArr[3] &&= vert1.y > vert2.y - tolerance;
	      dirArr[4] &&= vert1.x > vert2.x - tolerance;
	      dirArr[5] &&= vert1.x < vert2.x + tolerance;
	    }
	    if (dirArr[0] && dirArr[1]) dirArr[0] = dirArr[1] = false;
	    if (dirArr[2] && dirArr[3]) dirArr[2] = dirArr[3] = false;
	    if (dirArr[4] && dirArr[5]) dirArr[4] = dirArr[5] = false;
	
	    const zDir = dirArr[0] ? 'forward' : (dirArr[1] ? 'backward' : undefined);
	    const yDir = dirArr[2] ? 'up' : (dirArr[3] ? 'down' : undefined);
	    const xDir = dirArr[4] ? 'left' : (dirArr[5] ? 'right' : undefined);
	
	    if (zDir && yDir && xDir) return axisOnly ? null : `${xDir} ${yDir} ${zDir}`;
	    if (zDir) {
	      if (yDir) return axisOnly ? null : `${yDir} ${zDir}`;
	      if (xDir) return axisOnly ? null : `${xDir} ${zDir}`;
	      return zDir;
	    }
	    if (xDir) {
	      if (yDir) return axisOnly ? null : `${xDir} ${yDir}`;
	      return xDir
	    }
	    return yDir ? yDir : null;
	  }
	}
	
	Vertex3D.center = (...verticies) => {
	  if (Array.isArray(verticies[0])) verticies = verticies[0];
	  let x = 0;
	  let y = 0;
	  let z = 0;
	  let count = 0;
	  verticies.forEach((vertex) => {
	    if (Number.isFinite(vertex.x + vertex.y + vertex.z)) {
	      count++;
	      x += vertex.x;
	      y += vertex.y;
	      z += vertex.z;
	    } else {
	      throw new Error("Vertex contains a non-number");
	    }
	  });
	  return new Vertex3D({x: x/count, y: y/count, z: z/count});
	}
	
	Vertex3D.sortByCenter = (center) => {
	  return (v1, v2) => {
	    const d1 = v1.distance(v2);
	    const d2 = v2.distance(v1);
	    d1 === d2 ? 0 : (d1 < d2 ? -1 : 1);
	  }
	}
	
	module.exports = Vertex3D;
	
});


RequireJS.addFunction('./app-src/two-d/objects/corner.js',
function (require, exports, module) {
	
const Vertex2d = require('vertex');
	
	class Corner {
	  constructor(center, height, width, radians) {
	    width = width === undefined ? 121.92 : width;
	    height = height === undefined ? 60.96 : height;
	    radians = radians === undefined ? 0 : radians;
	    const instance = this;
	    Object.getSet(this, {center: new Vertex2d(center), height, width, radians});
	    if ((typeof center) === 'function') this.center = center;
	    const startPoint = new Vertex2d(null);
	
	    const getterHeight = this.height;
	    this.height = (v) => {
	      notify(getterHeight(), v);
	      return getterHeight(v);
	    }
	    const getterWidth = this.width;
	    this.width = (v) => notify(getterWidth(), v) || getterWidth(v);
	
	    const changeFuncs = [];
	    this.onChange = (func) => {
	      if ((typeof func) === 'function') {
	        changeFuncs.push(func);
	      }
	    }
	
	    let lastNotificationId = 0;
	    function notify(currentValue, newValue) {
	      if (changeFuncs.length === 0 || (typeof newValue) !== 'number') return;
	      if (newValue !== currentValue) {
	        const id = ++lastNotificationId;
	        setTimeout(() => {
	          if (id === lastNotificationId)
	            for (let i = 0; i < changeFuncs.length; i++) changeFuncs[i](instance);
	        }, 100);
	      }
	    }
	
	    this.radians = (newValue) => {
	      if (newValue !== undefined && !Number.isNaN(Number.parseFloat(newValue))) {
	        notify(radians, newValue);
	        radians = newValue;
	      }
	      return radians;
	    };
	    this.startPoint = () => {
	      startPoint.point({x: this.center().x() - width / 2, y: this.center().y() - height / 2});
	      return startPoint;
	    }
	    this.angle = (value) => {
	      if (value !== undefined) this.radians(Math.toRadians(value));
	      return Math.toDegrees(this.radians());
	    }
	
	    // this.x = (val) => notify(this.center().x(), val) || this.center().x(val);
	    // this.y = (val) => notify(this.center().y(), val) || this.center().y(val);
	    this.x = (val) => {
	      if (val !== undefined) this.center().x(val);
	      return this.center().x();
	    }
	    this.y = (val) => {
	      if (val !== undefined) this.center().y(val);
	      return this.center().y();
	    }
	    this.minDem = () => this.width() > this.height() ? this.width() : this.height();
	    this.maxDem = () => this.width() > this.height() ? this.width() : this.height();
	
	    this.shorterSideLength = () => this.height() < this.width() ? this.height() : this.width();
	    this.move = (position, theta) => {
	      const center = position.center instanceof Vertex2d ? position.center.point() : position.center;
	      if (position.maxX !== undefined) center.x = position.maxX - this.offsetX();
	      if (position.maxY !== undefined) center.y = position.maxY - this.offsetY();
	      if (position.minX !== undefined) center.x = position.minX + this.offsetX();
	      if (position.minY !== undefined) center.y = position.minY + this.offsetY();
	      this.radians(position.theta);
	      this.center().point(center);
	      return true;
	    };
	
	    function centerMethod(widthMultiplier, heightMultiplier, position) {
	      const center = instance.center();
	      const rads = instance.radians();
	      const offsetX = instance.width() * widthMultiplier * Math.cos(rads) -
	                        instance.height() * heightMultiplier * Math.sin(rads);
	      const offsetY = instance.height() * heightMultiplier * Math.cos(rads) +
	                        instance.width() * widthMultiplier * Math.sin(rads);
	
	      if (position !== undefined) {
	        const posCenter = new Vertex2d(position.center);
	        return new Vertex2d({x: posCenter.x() + offsetX, y: posCenter.y() + offsetY});
	      }
	      const backLeftLocation = {
	            x: instance.center().x() - offsetX ,
	            y: instance.center().y() - offsetY
	      };
	      return new Vertex2d(backLeftLocation);
	    }
	
	
	    this.frontCenter = (position) => centerMethod(0, -.5, position);
	    this.backCenter = (position) => centerMethod(0, .5, position);
	    this.leftCenter = (position) => centerMethod(.5, 0, position);
	    this.rightCenter = (position) => centerMethod(-.5, 0, position);
	
	    this.backLeft = (position) => centerMethod(.5, .5, position);
	    this.backRight = (position) => centerMethod(-.5, .5, position);
	    this.frontLeft = (position) =>  centerMethod(.5, -.5, position);
	    this.frontRight = (position) => centerMethod(-.5, -.5, position);
	
	    this.offsetX = (negitive) => negitive ? this.width() / -2 : this.width() / 2;
	    this.offsetY = (negitive) => negitive ? this.height() / -2 : this.height() / 2;
	
	    this.toString = () => `[${this.frontLeft()} - ${this.frontRight()}]\n[${this.backLeft()} - ${this.backRight()}]`
	  }
	}
	
	new Square2d();
	
	module.exports = Square2d;
	
});


RequireJS.addFunction('./app-src/two-d/objects/circle.js',
function (require, exports, module) {
	
const Vertex2d = require('./vertex');
	
	class Circle2d {
	  constructor(radius, center) {
	    center = new Vertex2d(center);
	    Object.getSet(this, {radius, center});
	    // ( x - h )^2 + ( y - k )^2 = r^2
	    const instance = this;
	    // Stole the root code from: https://stackoverflow.com/a/37225895
	    function lineIntersects (line, bounded) {
	      const p1 = line.startVertex();
	      const p2 = line.endVertex();
	        var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
	        v1 = {};
	        v2 = {};
	        v1.x = p2.x() - p1.x();
	        v1.y = p2.y() - p1.y();
	        v2.x = p1.x() - instance.center().x();
	        v2.y = p1.y() - instance.center().y();
	        b = (v1.x * v2.x + v1.y * v2.y);
	        c = 2 * (v1.x * v1.x + v1.y * v1.y);
	        b *= -2;
	        d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - instance.radius() * instance.radius()));
	        if(isNaN(d)){ // no intercept
	            return [];
	        }
	        u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line
	        u2 = (b + d) / c;
	        retP1 = {};   // return points
	        retP2 = {}
	        ret = []; // return array
	        if(!bounded || (u1 <= 1 && u1 >= 0)){  // add point if on the line segment
	            retP1.x = p1.x() + v1.x * u1;
	            retP1.y = p1.y() + v1.y * u1;
	            ret[0] = retP1;
	        }
	        if(!bounded || (u2 <= 1 && u2 >= 0)){  // second add point if on the line segment
	            retP2.x = p1.x() + v1.x * u2;
	            retP2.y = p1.y() + v1.y * u2;
	            ret[ret.length] = retP2;
	        }
	        return ret;
	    }
	
	    function circleIntersects(circle) {
	      return Circle2d.intersectionOfTwo(instance, circle);
	    }
	
	    this.toString = () => `(${this.radius()}${this.center()}----)`;
	
	    this.intersections = (input) => {
	      if (input === undefined)
	        console.log('here');
	      if (input instanceof Circle2d) return circleIntersects(input);
	      if (input.constructor.name === 'Line2d') return lineIntersects(input);
	      throw new Error(`Cannot find intersections for ${input.constructor.name}`);
	    }
	  }
	}
	
	// Ripped off from: https://stackoverflow.com/a/12221389
	Circle2d.intersectionOfTwo = (circle0, circle1) => {
	    const x0 = circle0.center().x();
	    const y0 = circle0.center().y();
	    const r0 = circle0.radius();
	
	    const x1 = circle1.center().x();
	    const y1 = circle1.center().y();
	    const r1 = circle1.radius();
	    var a, dx, dy, d, h, rx, ry;
	    var x2, y2;
	
	    /* dx and dy are the vertical and horizontal distances between
	     * the circle centers.
	     */
	    dx = x1 - x0;
	    dy = y1 - y0;
	
	    /* Determine the straight-line distance between the centers. */
	    d = Math.sqrt((dy*dy) + (dx*dx));
	
	    /* Check for solvability. */
	    if (d > (r0 + r1)) {
	        /* no solution. circles do not intersect. */
	        return [];
	    }
	    if (d < Math.abs(r0 - r1)) {
	        /* no solution. one circle is contained in the other */
	        return [];
	    }
	
	    /* 'point 2' is the point where the line through the circle
	     * intersection points crosses the line between the circle
	     * centers.
	     */
	
	    /* Determine the distance from point 0 to point 2. */
	    a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;
	
	    /* Determine the coordinates of point 2. */
	    x2 = x0 + (dx * a/d);
	    y2 = y0 + (dy * a/d);
	
	    /* Determine the distance from point 2 to either of the
	     * intersection points.
	     */
	    h = Math.sqrt((r0*r0) - (a*a));
	
	    /* Now determine the offsets of the intersection points from
	     * point 2.
	     */
	    rx = -dy * (h/d);
	    ry = dx * (h/d);
	
	    /* Determine the absolute intersection points. */
	    var xi = x2 + rx;
	    var xi_prime = x2 - rx;
	    var yi = y2 + ry;
	    var yi_prime = y2 - ry;
	
	    const list = [];
	    return [{x: xi, y: yi}, {x: xi_prime, y: yi_prime}];
	}
	
	Circle2d.reusable = true;
	Circle2d.instance = (radius, center) => {
	  const inst = Lookup.instance(Circle2d.name);
	  inst.radius(radius);
	  inst.center(center);
	  return inst;
	}
	new Circle2d();
	
	module.exports = Circle2d;
	
});


RequireJS.addFunction('./app-src/two-d/objects/line.js',
function (require, exports, module) {
	
const approximate = require('../../../../../public/js/utils/approximate.js');
	const approximate100 = approximate.new(100000000000000);
	const Vertex2d = require('./vertex');
	const Circle2d = require('./circle');
	
	class Line2d {
	  constructor(startVertex, endVertex) {
	    startVertex = new Vertex2d(startVertex);
	    endVertex = new Vertex2d(endVertex);
	    const measureTo = [];
	    const instance = this;
	    Object.getSet(this, {startVertex, endVertex});
	
	    this.startVertex = (newVertex) => {
	      if (newVertex instanceof Vertex2d) {
	        startVertex = newVertex;
	      }
	      return startVertex;
	    }
	    this.endVertex = (newVertex) => {
	      if (newVertex instanceof Vertex2d) {
	        endVertex = newVertex;
	      }
	      return endVertex;
	    }
	
	    this.rise = () => endVertex.y() - startVertex.y();
	    this.run = () =>  endVertex.x() - startVertex.x();
	
	    function changeLength(value) {
	      const circle = new Circle2d(value, instance.startVertex());
	      const points = circle.intersections(instance);
	      const dist0 = instance.endVertex().distance(points[0]);
	      const dist1 = instance.endVertex().distance(points[1]);
	      if (dist1 < dist0) {
	        instance.endVertex().point(points[1]);
	      } else {
	        instance.endVertex(points[0]);
	      }
	    }
	
	    this.withinDirectionalBounds = (point, limit) => {
	      point = new Vertex2d(point);
	      const withinLimit = limit === undefined || (limit > point.y() && limit > point.x());
	      const rise = this.rise();
	      const run = this.run();
	      if (withinLimit && this.withinSegmentBounds(point)) return true;
	      const offsetPoint = {x: point.x() + run, y: point.y() + rise};
	      if (this.startVertex().distance(point) > this.startVertex().distance(offsetPoint)) return false;
	      return withinLimit;
	    }
	
	    this.withinSegmentBounds = (point) => {
	      point = new Vertex2d(point);
	      return approximate100.lteq(this.minX(), point.x()) && approximate100.lteq(this.minY(), point.y()) &&
	            approximate100.gteq(this.maxX(), point.x()) && approximate100.gteq(this.maxY(), point.y());
	    }
	
	
	    function reconsileLength (newLength) {
	      const moveVertex = instance.endVertex();
	      const nextLine = moveVertex.nextLine()
	      if (nextLine === undefined) changeLength(newLength);
	
	      const vertex1 = nextLine.endVertex();
	      const circle1 = new Circle2d(nextLine.length(), vertex1);
	      const vertex2 = instance.startVertex();
	      const circle2 = new Circle2d(newLength, vertex2);
	      const intersections = circle1.intersections(circle2);
	
	      const useFirst = (intersections.length !== 0 && intersections.length === 1) ||
	                moveVertex.distance(intersections[0]) < moveVertex.distance(intersections[1]);
	      if (intersections.length === 0) {
	        changeLength(newLength);
	      } else if (useFirst) {
	        moveVertex.point(intersections[0]);
	      } else {
	        moveVertex.point(intersections[1]);
	      }
	    }
	
	    this.length = (value) => {
	      value = Number.parseFloat(value);
	      if (!Number.isNaN(value)) {
	        const sv = this.startVertex();
	        const x = value * Math.cos(this.radians()) + sv.x();
	        const y = value * Math.sin(this.radians()) + sv.y();
	        this.endVertex().point({x,y});
	      }
	      const a = this.endVertex().x() - this.startVertex().x();
	      const b = this.endVertex().y() - this.startVertex().y();
	      return Math.sqrt(a*a + b*b);
	    }
	
	    function getSlope(v1, v2) {
	      const y1 = v1.y();
	      const y2 = v2.y();
	      const x1 = v1.x();
	      const x2 = v2.x();
	      const slope = (y2 - y1) / (x2 - x1);
	      if (slope > 10000) return Infinity;
	      if (slope < -10000) return -Infinity;
	      if (slope > -0.00001 && slope < 0.00001) return 0;
	      return slope;
	    }
	
	    function getB(x, y, slope) {
	      if (slope === 0) return y;
	      else if (Math.abs(slope) === Infinity) {
	        if (instance.startVertex().x() === 0) return 0;
	        else return Infinity;
	      }
	      else return y - slope * x;
	    }
	
	    function newX(m1, m2, b1, b2) {
	      return (b2 - b1) / (m1 - m2);
	    }
	
	    function getY(x, slope, b) {return slope*x + b}
	    function getX(y, slope, b) {return  (y - b)/slope}
	
	    this.midpoint = () => {
	      const x = (this.endVertex().x() + this.startVertex().x())/2;
	      const y = (this.endVertex().y() + this.startVertex().y())/2;
	      return new Vertex2d({x,y});
	    }
	
	    this.closestEnds = (other) => {
	      const tsv = this.startVertex();
	      const osv = other.startVertex();
	      const tev = this.endVertex();
	      const oev = other.endVertex();
	
	      const ss = tsv.distance(osv);
	      const se = tsv.distance(oev);
	      const ee = tev.distance(oev);
	      const es = tev.distance(osv);
	
	      if (ss <= se && ss <= ee && ss <= es) return [tsv, osv];
	      if (se <= ee && se <= es) return [tsv, oev];
	      if (ee <= es) return [tev, oev];
	      else return [tev, osv]
	    }
	
	    // Always returns left side of intersection path
	    this.thetaBetween = (other) => {
	      if (!(other instanceof Line2d)) throw new Error('Cannot calculate thetaBetween if arg1 is not an instanceof Line2d');
	      let theta;
	      let theta1 = this.radians();
	      let closestEnds = this.closestEnds(other);
	      if (closestEnds.indexOf(this.startVertex()) !== -1) {
	        theta1 += Math.PI;
	      }
	      let theta2 = other.radians();
	      if (closestEnds.indexOf(other.startVertex()) !== -1) {
	        theta2 += Math.PI;
	      }
	
	      if (theta1 > theta2) {
	        theta = theta2 - theta1 + Math.PI * 2;
	      } else {
	        theta = theta2 - theta1;
	      }
	      return theta % (2 * Math.PI)
	    }
	
	    this.yIntercept = () => getB(this.startVertex().x(), this.startVertex().y(), this.slope());
	    this.slope = () => getSlope(this.startVertex(), this.endVertex());
	    this.y = (x) => {
	      x ||= this.startVertex().x();
	      const slope = this.slope();
	      if (Math.abs(slope) === Infinity) return Infinity;
	      if (slope === 0) return this.startVertex().y();
	      return  (this.slope()*x + this.yIntercept());
	    }
	
	    this.x = (y) => {
	      y ||= this.startVertex().y();
	      const slope = this.slope();
	      if (Math.abs(slope) === Infinity) return this.startVertex().x();
	      if (slope === 0) {
	        return Infinity;
	      }
	      return (y - this.yIntercept())/slope;
	    }
	
	    //TODO: fix!!!!
	    this.liesOn = (vertices) => {
	      const liesOn = [];
	      for (let index = 0; index < vertices.length; index += 1) {
	        const v = vertices[index];
	        const y = this.y(v.x());
	        if ((y === v.y() || Math.abs(y) === Infinity) && this.withinSegmentBounds(v)) {
	          liesOn.push(v);
	        }
	      }
	      liesOn.sort(Vertex2d.sort);
	      return liesOn;
	    }
	
	    this.isOn = (vertex) => {
	      const y = this.y(vertex.x());
	      return (y === vertex.y() || Math.abs(y) === Infinity) && this.withinSegmentBounds(vertex);
	    }
	
	    this.measureTo = (verts) => {
	      if (Array.isArray(verts)) {
	        verts = this.liesOn(verts);
	        measureTo.concatInPlace(verts);
	      }
	      return measureTo;
	    }
	
	    this.maxDem = () => this.y() > this.x() ? this.y() : this.x();
	    this.minDem = () => this.y() < this.x() ? this.y() : this.x();
	
	    this.closestPointOnLine = (vertex, segment) => {
	      vertex = (vertex instanceof Vertex2d) ? vertex : new Vertex2d(vertex);
	      const perpLine = this.perpendicular(undefined, vertex, true);
	      const perpSlope = perpLine.slope();
	      const slope = this.slope();
	      let x, y;
	      if (!Number.isFinite(slope)) {
	        x = this.startVertex().x();
	        y = vertex.y();
	      } else if (!Number.isFinite(perpSlope)) {
	        x = vertex.x();
	        y = this.startVertex().y();
	      } else {
	        x = newX(slope, perpSlope, this.yIntercept(), perpLine.yIntercept());
	        y = this.y(x);
	      }
	      const closestPoint = new Vertex2d({x, y});
	      if (!segment || this.withinSegmentBounds(closestPoint)) return closestPoint;
	      return false;
	    }
	
	    this.inverseX = (y) => this.slope()*y + this.yIntercept();
	    this.inverseY = (x) => (x-this.yIntercept())/this.slope();
	    this.perpendicular = (distance, vertex, center) => {
	      distance ||= this.length();
	      const rotated = this.copy().rotate(Math.PI12);
	      const mp = vertex || rotated.midpoint();
	      if (center) {
	        distance = Math.abs(distance);
	        const left = Line2d.startAndTheta(mp, rotated.negitive().radians(), distance/2);
	        const right = Line2d.startAndTheta(mp, rotated.radians(), distance/2);
	        if (right.combine(left) === undefined) {
	          console.log('here');
	        }
	        return right.combine(left);
	      }
	      return Line2d.startAndTheta(mp, rotated.radians(), distance);
	    }
	
	    this.rotate = (radians, pivot) => {
	      pivot ||= this.midpoint();
	
	      const sv = this.startVertex();
	      const spl = new Line2d(pivot, sv);
	      const sRadOffset = radians + spl.radians();
	      const sfl = Line2d.startAndTheta(pivot, sRadOffset, spl.length());
	      sv.point(sfl.endVertex());
	
	      const ev = this.endVertex();
	      const epl = new Line2d(pivot, ev);
	      const eRadOffset = radians + epl.radians();
	      const efl = Line2d.startAndTheta(pivot, eRadOffset, epl.length());
	      ev.point(efl.endVertex());
	      return this;
	    }
	
	    this.vertical = () => Math.abs(this.slope()) === Infinity;
	
	    this.findIntersection = (line) => {
	      if (this.slope() === 0 && line.slope() === 0) {
	        if (this.yIntercept() === line.yIntercept()) return Infinity;
	        return false;
	      }
	      if (this.slope() === 0) return line.findIntersection(this);
	
	      if (this.vertical() && line.vertical()) {
	        if (this.startVertex().x() === line.startVertex().x()) return Infinity;
	        return false;
	      }
	      if (this.slope() === 0) return line.findIntersection(this);
	
	
	      if (approximate.eq(line.radians(), this.radians()) &&
	              approximate.eq(line.yIntercept(), this.yIntercept())) {
	        return Vertex2d.center(line.startVertex(), this.startVertex(), line.endVertex(), this.endVertex());
	      }
	      const slope = this.slope();
	      const lineSlope = line.slope();
	      let x, y;
	      if (!Number.isFinite(slope)) {
	        x = this.startVertex().x();
	        y = line.y(x);
	      } else if (!Number.isFinite(lineSlope)) {
	        x = line.startVertex().x();
	        y = this.y(x);
	      } else {
	        x = newX(slope, lineSlope, this.yIntercept(), line.yIntercept());
	        y = this.y(x);
	      }
	      if (Number.NaNfinity(x,y)) return false;
	
	      return new Vertex2d({x,y});
	    }
	
	    this.findDirectionalIntersection = (line, limit) => {
	      const intersection = this.findIntersection(line);
	      if (intersection && this.withinDirectionalBounds(intersection, limit)) return intersection;
	      return false;
	    }
	
	    this.findSegmentIntersection = (line, both) => {
	      const intersection = this.findIntersection(line);
	      if (!intersection) return false;
	      if (!both && this.withinSegmentBounds(intersection)) {
	        return intersection;
	      }
	      if (this.withinSegmentBounds(intersection) && line.withinSegmentBounds(intersection)) {
	        return intersection;
	      }
	      return false;
	    }
	
	    this.minX = () => this.startVertex().x() < this.endVertex().x() ?
	                        this.startVertex().x() : this.endVertex().x();
	    this.minY = () => this.startVertex().y() < this.endVertex().y() ?
	                        this.startVertex().y() : this.endVertex().y();
	    this.maxX = () => this.startVertex().x() > this.endVertex().x() ?
	                        this.startVertex().x() : this.endVertex().x();
	    this.maxY = () => this.startVertex().y() > this.endVertex().y() ?
	                        this.startVertex().y() : this.endVertex().y();
	    this.angle = () => {
	      return Math.toDegrees(this.radians());
	    }
	    this.radians = () => {
	      const deltaX = this.endVertex().x() - this.startVertex().x();
	      const deltaY = this.endVertex().y() - this.startVertex().y();
	      return Math.atan2(deltaY, deltaX);
	    }
	
	    // Positive returns right side.
	    this.parrelle = (distance, midpoint, length) => {
	      if (distance === 0) return this.copy();
	      if ((typeof distance) !== 'number') throw new Error('distance (arg1) must be of type number && a non-zero value');
	      length ||= this.length();
	      midpoint ||= this.midpoint();
	      const perpLine = this.perpendicular(distance * 2, midpoint, true);
	      let targetPoint = perpLine.startVertex();
	      if (distance < 0) targetPoint = perpLine.endVertex();
	      const radians = this.radians();
	      const halfLine1 = Line2d.startAndTheta(targetPoint, radians, length/2);
	      const halfLine2 = Line2d.startAndTheta(targetPoint, radians, length/-2);
	      const parrelle = halfLine1.combine(halfLine2);
	      return Math.abs(parrelle.radians() - this.radians()) < Math.PI12 ? parrelle : parrelle.negitive();
	    }
	
	    this.isParrelle = (other) => {
	      const posRads = Math.mod(this.radians(), 2*Math.PI);
	      const negRads = Math.mod(this.radians() + Math.PI, 2*Math.PI);
	      const otherRads = Math.mod(other.radians(), 2*Math.PI);
	      return approximate.eq(posRads, otherRads) ||
	              approximate.eq(negRads, otherRads);
	    }
	
	    this.equals = (other) => {
	      if (other === this) return true;
	      const forwardEq = this.startVertex().equal(other.startVertex()) && this.endVertex().equal(other.endVertex());
	      const backwardEq = this.startVertex().equal(other.endVertex()) && this.endVertex().equal(other.startVertex());
	      return forwardEq || backwardEq;
	    }
	
	
	    this.clean = (other) => {
	      if (!(other instanceof Line2d)) return;
	      if (other.startVertex().equal(other.endVertex())) return this;
	      if (this.startVertex().equal(this.endVertex())) return other;
	      if (this.toString() === other.toString() || this.toString() === other.toNegitiveString()) return this;
	    }
	
	    this.copy = () => new Line2d(this.startVertex().copy(), this.endVertex().copy());
	
	    this.combine = (other) => {
	      if (!(other instanceof Line2d)) return;
	      const clean = this.clean(other);
	      if (clean) return clean;
	      if (approximate.neqAbs(this.slope(), other.slope())) return;
	      const otherNeg = other.negitive();
	      const posEq = approximate.eq(this.y(other.x()), other.y()) &&
	                    approximate.eq(this.x(other.y()), other.x());
	      const negEq = approximate.eq(this.y(otherNeg.x()), otherNeg.y()) &&
	                    approximate.eq(this.x(otherNeg.y()), otherNeg.x());
	      if (!posEq && !negEq) return;
	      const v1 = this.startVertex();
	      const v2 = this.endVertex();
	      const ov1 = other.startVertex();
	      const ov2 = other.endVertex();
	      if (!this.withinSegmentBounds(ov1) && !this.withinSegmentBounds(ov2)) return;
	      // Fix sort method
	      const vs = [v1, v2, ov1, ov2].sort(Vertex2d.sortByCenter(Vertex2d.center([v1, v2, ov1, ov2])));
	      const combined = new Line2d(vs[0], vs[1]);
	      return approximate.eq(this.radians(), combined.radians()) ? combined : combined.negitive();
	    }
	
	    this.trimmed = (distance, both) => {
	      if ((typeof distance) !== 'number' || distance === 0) throw new Error('distance (arg1) must be of type number && a non-zero value');
	      const trimBack = distance < 0;
	      distance = Math.abs(distance);
	      const halfLen = this.length() / 2;
	      const halfNewLen = halfLen - distance;
	      const midPoint = this.midpoint();
	      const frontRads = this.radians();
	      const backRads = frontRads + Math.PI;
	      let xOffsetFront, yOffsetFront, xOffsetBack, yOffsetBack;
	      if (both) {
	        xOffsetFront = halfNewLen * Math.cos(frontRads);
	        yOffsetFront = halfNewLen * Math.sin(frontRads);
	        xOffsetBack = halfNewLen * Math.cos(backRads);
	        yOffsetBack = halfNewLen * Math.sin(backRads);
	      } else if (trimBack) {
	        xOffsetFront = halfLen * Math.cos(frontRads);
	        yOffsetFront = halfLen * Math.sin(frontRads);
	        xOffsetBack = halfNewLen * Math.cos(backRads);
	        yOffsetBack = halfNewLen * Math.sin(backRads);
	      } else {
	        xOffsetFront = halfNewLen * Math.cos(frontRads);
	        yOffsetFront = halfNewLen * Math.sin(frontRads);
	        xOffsetBack = halfLen * Math.cos(backRads);
	        yOffsetBack = halfLen * Math.sin(backRads);
	      }
	      const sv = this.startVertex();
	      const ev = this.endVertex();
	      const startVertex = {x: midPoint.x() - xOffsetBack, y: midPoint.y() - yOffsetBack};
	      const endVertex = {x: midPoint.x() - xOffsetFront, y: midPoint.y() - yOffsetFront};
	      const line = new Line2d(startVertex, endVertex);
	      return approximate.eq(line.radians(), this.radians()) ? line : line.negitive();
	    }
	
	    this.move = (center) => {
	      const mouseLocation = new Vertex2d(center);
	      const perpLine = this.perpendicular(undefined, mouseLocation);
	      const interX = this.findIntersection(perpLine);
	      const diffLine = new Line2d(interX, mouseLocation);
	      const rads = diffLine.radians();
	      const xDiff = Math.cos(rads);
	      const yDiff = Math.sin(rads);
	      const sv = this.startVertex();
	      const newStart = {x: sv.x() + xDiff, y: sv.y() + yDiff};
	      const ev = this.endVertex();
	      const newEnd = {x: ev.x() + xDiff, y: ev.y() + yDiff};
	      this.startVertex().point().x = newStart.x;
	      this.startVertex().point().y = newStart.y;
	      this.endVertex().point().x = newEnd.x;
	      this.endVertex().point().y = newEnd.y;
	    };
	
	    this.negitive = () => new Line2d(this.endVertex(), this.startVertex());
	    this.toString = () => `${this.startVertex().toString()} => ${this.endVertex().toString()}`;
	    this.toNegitiveString = () => `${this.endVertex().toString()} => ${this.startVertex().toString()}`;
	    this.approxToString = () => `${this.startVertex().approxToString()} => ${this.endVertex().approxToString()}`;
	  }
	}
	Line2d.reusable = true;
	Line2d.startAndTheta = (startVertex, theta, dist) => {
	  dist ||= 100;
	  startVertex = new Vertex2d(startVertex);
	  const end = {
	    x: startVertex.x() + dist * Math.cos(theta),
	    y: startVertex.y() +dist*Math.sin(theta)
	  };
	  return new Line2d(startVertex.point(), end);
	}
	Line2d.instance = (startV, endV, group) => {
	  const line = Lookup.instance(Line2d.name);
	  line.lookupGroup(group);
	  line.startVertex(new Vertex2d(startV)).lookupGroup(group);
	  line.endVertex(new Vertex2d(endV)).lookupGroup(group);
	  return line;
	}
	
	Line2d.trendLine = (...points) => {
	  const center = Vertex2d.center(...points);
	  let maxArr = [];
	  for (let index = 0; index < points.length; index += 1) {
	    const obj = {};
	    obj.point = new Vertex2d(points[index]);
	    obj.distance = obj.point.distance(center);
	    if (maxArr[0] === undefined || maxArr[0].distance < obj.distance) {
	      maxArr = [obj].concat(maxArr);
	    } else if (maxArr[1] === undefined || maxArr[1].distance < obj.distance) {
	      maxArr = [maxArr[0], obj].concat(maxArr);
	    }
	  }
	  const line = new Line2d(maxArr[0].point, maxArr[1].point);
	  console.log(`trendLine: ${points}\n\t${line}\n\t${center}` );
	  return line;
	}
	
	Line2d.vertices = (lines) => {
	  const verts = {};
	  for (let index = 0; index < lines.length; index += 1) {
	    const line = lines[index];
	    const sv = line.startVertex();
	    const ev = line.endVertex();
	    verts[sv.toString()] = sv;
	    verts[ev.toString()] = ev;
	  }
	  return Object.values(verts);
	}
	
	Line2d.consolidate = (...lines) => {
	  const lineMap = {};
	  for (let index = 0; index < lines.length; index += 1) {
	    const line = lines[index];
	    const slope = approximate.abs(line.slope());
	    if (!Number.isNaN(slope)) {
	      if (lineMap[slope] === undefined) lineMap[slope] = [];
	      lineMap[slope].push(line);
	    }
	  }
	  const keys = Object.keys(lineMap);
	  let minList = [];
	  for (let lIndex = 0; lIndex < keys.length; lIndex += 1) {
	    const list = lineMap[keys[lIndex]];
	    for (let tIndex = 0; tIndex < list.length; tIndex += 1) {
	      let target = list[tIndex];
	      for (let index = 0; index < list.length; index += 1) {
	        if (index !== tIndex) {
	          const combined = target.combine(list[index]);
	          if (combined) {
	            const lowIndex = index < tIndex ? index : tIndex;
	            const highIndex = index > tIndex ? index : tIndex;
	            list.splice(highIndex, 1);
	            list[lowIndex] = combined;
	            target = combined;
	            tIndex--;
	            break;
	          }
	        }
	      }
	    }
	    minList = minList.concat(lineMap[keys[lIndex]]);
	  }
	
	  return minList;
	}
	
	new Line2d();
	
	module.exports = Line2d;
	
});


RequireJS.addFunction('./app-src/two-d/objects/plane.js',
function (require, exports, module) {
	
class Plane2d {
	  constructor(verticies) {
	    this.getLines = () => {
	      const lines = [];
	      for (let index = 0; index < verticies.length; index += 1) {
	        lines.push(new Line2d(verticies[index], verticies[(index + 1) % verticies.length]));
	      }
	      return lines;
	    }
	  }
	}
	
	Plane2d.getPlanes = (planes) => {
	  const ps = [];
	  planes.forEach((p) => ps.push(new Plane2d(p)));
	  return ps;
	}
	
	Plane2d.consolidatePolygons = (polygons) => {
	  const consolidated = {top: {}, left: {}, front: {}};
	  function group(g, poly) {
	
	    map.xy[index].push({x: v.pos.x, y: v.pos.y, level: v.pos.z});
	    map.xz[index].push({x: v.pos.x, y: v.pos.z, level: v.pos.y});
	    map.yz[index].push({x: v.pos.y, y: v.pos.z, level: v.pos.x});
	  }
	  const map = {xy: [], xz: [], yz: []};
	  polygons.forEach((p, index) => {
	    map.xy.push([]);
	    map.xz.push([]);
	    map.yz.push([]);
	    p.vertices.forEach((v) => {
	      map.xy[index].push({x: v.pos.x, y: v.pos.y, level: v.pos.z});
	      map.xz[index].push({x: v.pos.x, y: v.pos.z, level: v.pos.y});
	      map.yz[index].push({x: v.pos.y, y: v.pos.z, level: v.pos.x});
	    });
	  });
	  return map;
	}
	
	new Plane2d();
	module.exports = Plane2d;
	
});


RequireJS.addFunction('./app-src/two-d/objects/line-measurement.js',
function (require, exports, module) {
	
const Circle2d = require('circle');
	const Vertex2d = require('vertex');
	const Line2d = require('line');
	const Lookup = require('../../../../../public/js/utils/object/lookup');
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	const approximate = require('../../../../../public/js/utils/approximate.js');
	
	class LineMeasurement2d {
	  constructor(line, center, layer, modificationFunction) {
	    const offset = 3;
	    this.line = () => line;
	    this.I = (l) => {
	      l = l || layer || 1;
	      const termDist = (l + 1) * offset;
	      const measureDist = l * offset;
	      const startLine = line.perpendicular(termDist * 2, line.startVertex(), true);
	      const endLine = line.perpendicular(termDist * 2, line.endVertex(), true);
	      const startCircle = new Circle2d(measureDist, line.startVertex());
	      const endCircle = new Circle2d(measureDist, line.endVertex());
	      const startTerminationCircle = new Circle2d(termDist - 2.5, line.startVertex());
	      const endTerminationCircle = new Circle2d(termDist - 2.5, line.endVertex());
	      const startVerticies = startCircle.intersections(startLine);
	      const endVerticies = endCircle.intersections(endLine);
	      let l1, l2;
	      if (startVerticies.length > 0 && endVerticies.length > 0) {
	        const startTerminationVerticies = startTerminationCircle.intersections(startLine);
	        const endTerminationVerticies = endTerminationCircle.intersections(endLine);
	        let startTerminationLine, endTerminationLine, measurementLine;
	
	        l1 = new Line2d(startVerticies[1], endVerticies[1]);
	        l1.startLine = new Line2d(line.startVertex(), startTerminationVerticies[1]);
	        l1.endLine = new Line2d(line.endVertex(), endTerminationVerticies[1]);
	
	        l2 = new Line2d(startVerticies[0], endVerticies[0]);
	        l2.startLine = new Line2d(line.startVertex(), startTerminationVerticies[0]);
	        l2.endLine = new Line2d(line.endVertex(), endTerminationVerticies[0]);
	        const furtherLine = (point) => LineMeasurement2d.furtherLine(l1, l2, point || center);
	        const closerLine = (point) => LineMeasurement2d.furtherLine(l1, l2, point || center, true);
	        return {furtherLine, closerLine};
	      } else {
	        return {};
	      }
	    }
	
	    this.copy = (modFunc) => new LineMeasurement2d(line, modFunc);
	    this.modificationFunction = (func) => {
	      if ((typeof func) === 'function') {
	        if ((typeof this.id) !== 'function') Lookup.convert(this);
	        modificationFunction = func;
	      }
	      return modificationFunction;
	    }
	
	    this.toString = () => `|--${this.line()}--|`;
	    this.display = () => new Measurement(line.length()).display();
	
	    this.modify = (value) => modificationFunction(new Measurement(value, true).decimal());
	
	    this.modificationFunction(modificationFunction);
	  }
	}
	
	function measurementLevel(line) {
	  if ((typeof line.length) !== 'function')
	    console.log(line);
	
	  return Math.log(line.length()*line.length())*2;
	}
	
	LineMeasurement2d.measurements = (lines) => {
	  lines.reorder();
	  const verts = Line2d.vertices(lines);
	  const center = Vertex2d.center(...verts);
	  const measurements = [];
	  const lengthMap = {};
	  for (let tIndex = 0; tIndex < lines.length; tIndex += 1) {
	    const tarVerts = lines[tIndex].liesOn(verts);
	    if (tarVerts.length > 2) {
	      for (let index = 1; index < tarVerts.length; index += 1) {
	        const sv = tarVerts[index - 1];
	        const ev = tarVerts[index];
	        const line = new Line2d(sv,ev);
	        const length = approximate(line.length());
	        if (lengthMap[length] === undefined) lengthMap[length] = [];
	        lengthMap[length].push(line);
	        // measurements.push(new LineMeasurement2d(line, center, 1));
	      }
	    }
	    if (tarVerts.length > 1) {
	      const sv = tarVerts[0];
	      const ev = tarVerts[tarVerts.length - 1];
	      const line = new Line2d(sv,ev);
	      const length = approximate(line.length());
	      if (lengthMap[length] === undefined) lengthMap[length] = [];
	      lengthMap[length].push(line);
	      // measurements.push(new LineMeasurement2d(line, center, 2));
	    }
	  }
	
	  const lengths = Object.keys(lengthMap);
	  for (index = 0; index < lengths.length; index += 1) {
	    const slopeMap = {};
	    let lines = lengthMap[lengths[index]];
	    for(let li = 1; li < lines.length; li++) {
	      const line = lines[li];
	      const center2center = new Line2d(lines[li-1].midpoint(), line.midpoint());
	      const slopeMag = approximate.abs(center2center.slope());
	      if (!slopeMap[slopeMag] && approximate(line.length()) !== 0) {
	        for (let si = 0; si < li; si++) {
	          const c2c = new Line2d(lines[si].midpoint(), line.midpoint());
	          const slopeMag = approximate.abs(center2center.slope());
	          slopeMap[slopeMag] = true;
	        }
	      } else {
	        lines.splice(li, 1);
	        li--;
	      }
	    }
	    if (lines.length > 1) lines.splice(0,1);
	    measurements.concatInPlace(lines);
	  }
	
	  for (let index = 0; index < measurements.length; index++)
	    if (approximate.abs(measurements[index].length()) !== 0)
	      measurements[index] = new LineMeasurement2d(measurements[index], center, measurementLevel(measurements[index]));
	
	  return measurements;
	}
	
	LineMeasurement2d.furtherLine = (l1, l2, point, closer) =>
	    point === undefined ? (closer ? l1 : l2) :
	    (l1.midpoint().distance(point) > l2.midpoint().distance(point) ?
	      (closer ? l2 : l1) :
	      (closer ? l1 : l2));
	
	module.exports = LineMeasurement2d;
	
});


RequireJS.addFunction('./app-src/two-d/objects/polygon.js',
function (require, exports, module) {
	const Vertex2d = require('./vertex');
	const Line2d = require('./line');
	
	class Polygon2d {
	  constructor(initialVerticies) {
	    const lines = [];
	    let map;
	
	    this.verticies = (target, before, after) => {
	      if (lines.length === 0) return [];
	      const fullList = [];
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        fullList.push(line.startVertex());
	      }
	      if (target) {
	        const verticies = [];
	        const index = fullList.indexOf(target);
	        if (index === undefined) return null;
	        verticies = [];
	        for (let i = before; i < before + after + 1; i += 1) verticies.push(fullList[i]);
	        return verticies;
	      } else return fullList;
	
	      return verticies;
	    }
	
	    this.lines = () => lines;
	    this.startLine = () => lines[0];
	    this.endLine = () => lines[lines.length - 1];
	
	    this.lineMap = (force) => {
	      if (!force && map !== undefined) return map;
	      if (lines.length === 0) return {};
	      map = {};
	      let lastEnd;
	      if (!lines[0].startVertex().equal(lines[lines.length - 1].endVertex())) throw new Error('Broken Polygon');
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        if (lastEnd && !line.startVertex().equal(lastEnd)) throw new Error('Broken Polygon');
	        lastEnd = line.endVertex();
	        map[line.toString()] = line;
	      }
	      return map;
	    }
	
	    this.equal = (other) => {
	      if (!(other instanceof Polygon2d)) return false;
	      const verts = this.verticies();
	      const otherVerts = other.verticies();
	      if (verts.length !== otherVerts.length) return false;
	      let otherIndex = undefined;
	      let direction;
	      for (let index = 0; index < verts.length * 2; index += 1) {
	        const vIndex = index % verts.length;
	        if (otherIndex === undefined) {
	          if (index > verts.length) {
	            return false
	          } if(verts[index].equal(otherVerts[0])) {
	            otherIndex = otherVerts.length * 2;
	          }
	        } else if (otherIndex === otherVerts.length * 2) {
	          if (verts[vIndex].equal(otherVerts[1])) direction = 1;
	          else if(verts[vIndex].equal(otherVerts[otherVerts.length - 1])) direction = -1;
	          else return false;
	          otherIndex += direction * 2;
	        } else if (!verts[vIndex].equal(otherVerts[otherIndex % otherVerts.length])) {
	          return false;
	        } else {
	          otherIndex += direction;
	        }
	      }
	      return true;
	    }
	
	    function getLine(line) {
	      const lineMap = this.lineMap();
	      return lineMap[line.toString()] || lineMap[line.toNegitiveString()];
	    }
	
	    this.getLines = (startVertex, endVertex, reverse) => {
	      const inc = reverse ? -1 : 1;
	      const subSection = [];
	      let completed = false;
	      const doubleLen = lines.length * 2;
	      for (let steps = 0; steps < doubleLen; steps += 1) {
	        const index =  (!reverse ? steps : (doubleLen - steps - 1)) % lines.length;
	        const curr = lines[index];
	        if (subSection.length === 0) {
	          if (startVertex.equal(!reverse ? curr.startVertex() : curr.endVertex())) {
	            subSection.push(!reverse ? curr : curr.negitive());
	            if (endVertex.equal(reverse ? curr.startVertex() : curr.endVertex())) {
	              completed = true;
	              break;
	            }
	          }
	        } else {
	          subSection.push(!reverse ? curr : curr.negitive());
	          if (endVertex.equal(reverse ? curr.startVertex() : curr.endVertex())) {
	            completed = true;
	            break;
	          }
	        }
	      }
	      if (completed) return subSection;
	    }
	
	    this.center = () => Vertex2d.center(...this.verticies());
	
	    this.addVerticies = (list) => {
	      if (list === undefined) return;
	      if ((lines.length === 0) && list.length < 3) return;//console.error('A Polygon Must be initialized with 3 verticies');
	      const verts = [];
	      const endLine = this.endLine();
	      for (let index = 0; index < list.length + 1; index += 1) {
	        if (index < list.length) verts[index] = new Vertex2d(list[index]);
	        if (index === 0 && endLine) endLine.endVertex() = verts[0];
	        else if (index > 0) {
	          const startVertex = verts[index - 1];
	          const endVertex = verts[index] || this.startLine().startVertex();
	          const line = new Line2d(startVertex, endVertex);
	          lines.push(line);
	        }
	      }
	      if (verts.length > 0 && lines.length > 0) {
	        if (endLine) endline.endVertex() = verts[0];
	      }
	      // this.removeLoops();
	      this.lineMap(true);
	    }
	
	    this.path = () => {
	      let path = '';
	      this.verticies().forEach((v) => path += `${v.toString()} => `);
	      return path.substring(0, path.length - 4);
	    }
	
	    this.toString = this.path;
	
	    this.removeLoops = () => {
	      const map = {}
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        const key = line.toString();
	        const negKey = line.toNegitiveString();
	        if (map[key]) {
	          lines.splice(map[key].index, index - map[key].index + 1);
	        } else if (map[negKey]) {
	          lines.splice(map[negKey].index, index - map[negKey].index + 1);
	        } else {
	          map[key] = {line, index};
	        }
	      }
	    }
	
	    this.addVerticies(initialVerticies);
	  }
	}
	
	Polygon2d.center = (...polys) => {
	  const centers = [];
	  for (let index = 0; index < polys.length; index += 1) {
	    centers.push(polys[index].center());
	  }
	  return Vertex2d.center(...centers);
	}
	
	Polygon2d.lines = (...polys) => {
	  let lines = [];
	  for (let index = 0; index < polys.length; index += 1) {
	    lines = lines.concat(polys[index].lines());
	  }
	  const consolidated = Line2d.consolidate(...Line2d.consolidate(...lines));
	  if (consolidated.length !== Line2d.consolidate(...consolidated).length) {
	    console.error('Line Consolidation malfunction');
	  }
	  return consolidated;
	}
	
	new Polygon2d();
	module.exports = Polygon2d;
	
});


RequireJS.addFunction('./app-src/three-d/objects/bi-polygon.js',
function (require, exports, module) {
	
const CSG = require('../../../public/js/3d-modeling/csg.js');
	const Line3D = require('line');
	const Polygon3D = require('polygon');
	
	class BiPolygon {
	  constructor(polygon1, polygon2) {
	    const face1 = polygon1.verticies();
	    const face2 = polygon2.verticies();
	    if (face1.length !== face2.length) throw new Error('Polygons need to have an equal number of verticies');
	    if (face1.length !== 4) throw new Error('BiPolygon implementation is limited to 4 point polygons. Plans to expand must not have been exicuted yet');
	
	    this.front = () => new Polygon3D(face1);
	    this.back = () => new Polygon3D(face2);
	    this.normal = () => face2[0].distanceVector(face1[0]).unit();
	
	    this.flippedNormal = () => {
	      const face1Norm = new Polygon3D(face1).normal();
	      return this.normal().sameDirection(face1Norm);
	    }
	
	
	    function normalize (verts, reverse) {
	      const normal =  new Polygon3D(verts).normal().toArray();
	      const returnValue = [];
	      for (let index = 0; index < verts.length; index++)
	        returnValue[index] = new CSG.Vertex(verts[index], normal);
	      return reverse ? returnValue.reverse() : returnValue;
	    }
	
	    this.toModel = () => {
	      const flippedNormal = this.flippedNormal();
	      const front = new CSG.Polygon(normalize(face1, !flippedNormal));
	      front.plane.normal = new CSG.Vector([0,1, 0,0]);
	      const back = new CSG.Polygon(normalize(face2, flippedNormal));
	      back.plane.normal = new CSG.Vector([0,0,1,0,0]);
	      const top = new CSG.Polygon(normalize([face1[0], face1[1], face2[1], face2[0]], flippedNormal));
	      top.plane.normal = new CSG.Vector([0, 1, 0]);
	      const left = new CSG.Polygon(normalize([face2[3], face2[0], face1[0], face1[3]], !flippedNormal));
	      left.plane.normal = new CSG.Vector([-1, 0, 0]);
	      const right = new CSG.Polygon(normalize([face1[1], face1[2], face2[2], face2[1]], flippedNormal));
	      right.plane.normal = new CSG.Vector([1, 0, 0]);
	      const bottom = new CSG.Polygon(normalize([face1[3], face1[2], face2[2], face2[3]], !flippedNormal));
	      bottom.plane.normal = new CSG.Vector([0, -1, 0]);
	
	      const poly = CSG.fromPolygons([front, back, top, left, right, bottom]);
	      return poly;
	    }
	
	    this.toString = () =>
	    `(${face1[0].toString()}), (${face1[1].toString()}), (${face1[2].toString()}), (${face1[3].toString()})\n` +
	    `(${face2[0].toString()}), (${face2[1].toString()},${face2[2].toString()}), (${face2[3].toString()})`;
	  }
	}
	
	BiPolygon.fromPolygon = (polygon, distance1, distance2, offset) => {
	  offset ||= {};
	  const verts = polygon.verticies();
	  if (verts.length < 4) return undefined;
	  const verts1 = JSON.clone(verts);
	  Line3D.adjustVerticies(verts1[0], verts1[1], offset.x);
	  Line3D.adjustVerticies(verts1[1], verts1[2], offset.y);
	  Line3D.adjustVerticies(verts1[2], verts1[3], offset.x);
	  Line3D.adjustVerticies(verts1[3], verts1[0], offset.y);
	  const verts2 = JSON.clone(verts1);
	  const poly1 = (new Polygon3D(verts1)).parrelleAt(distance1);
	  const poly2 = (new Polygon3D(verts2)).parrelleAt(distance2);
	  return new BiPolygon(poly1, poly2);
	}
	
	BiPolygon.fromVectorObject =
	    (vectorObj, center, depth, height, width) => {
	      const frontCenter = center.translate(vectorObj.depth.scale(depth/2), true);
	      const front = Polygon3D.fromVectorObject(vectorObj, frontCenter, height, width);
	      const backCenter = center.translate(vectorObj.depth.scale(depth/-2), true);
	      const back = Polygon3D.fromVectorObject(vectorObj, backCenter, height, width);
	      return new BiPolygon(front, back);
	}
	
	module.exports = BiPolygon;
	
});


RequireJS.addFunction('./app-src/three-d/objects/bi-plane.js',
function (require, exports, module) {
	

	class BiPolygon {
	  constructor(polygon1, polygon2) {
	    const face1 = polygon1.verticies();
	    const face2 = polygon.verticies();
	    if (face1.length !== face2.length) throw new Error('Polygons need to have an equal number of verticies');
	
	    this.toModel = () => {
	      const front = new CSG.Polygon(normalize(face1, [+1, 0, 0]));
	      front.plane.normal = new CSG.Vector([0,0+1, 0,0]);
	      const back = new CSG.Polygon(normalize(face2, [-1, 0, 0], true));
	      back.plane.normal = new CSG.Vector([0,0,1,0,0]);
	      const top = new CSG.Polygon(normalize([face1[0], face1[1], face2[1], face2[0]], [0,1,0], true));
	      top.plane.normal = new CSG.Vector([0, 1, 0]);
	      const left = new CSG.Polygon(normalize([face2[3], face2[0], face1[0], face1[3]], [-1,0,0]));
	      left.plane.normal = new CSG.Vector([-1, 0, 0]);
	      const right = new CSG.Polygon(normalize([face1[1], face1[2], face2[2], face2[1]], [1,0,0], true));
	      right.plane.normal = new CSG.Vector([1, 0, 0]);
	      const bottom = new CSG.Polygon(normalize([face1[3], face1[2], face2[2], face2[3]], [0,-1,0]));
	      bottom.plane.normal = new CSG.Vector([0, -1, 0]);
	
	      const poly = CSG.fromPolygons([front, back, top, left, right, bottom]);
	      return poly;
	    }
	  }
	}
	
});


RequireJS.addFunction('./app-src/config/property/config.js',
function (require, exports, module) {
	
const Properties = require('../properties');
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	const IMPERIAL_US = Measurement.units()[1];
	
	class PropertyConfig {
	  constructor(props) {
	    Object.getSet(this);
	    props = props || Properties.instance();
	    let style = props.style || PropertyConfig.lastStyle;
	    let styleName = props.styleName || PropertyConfig.lastStyleName ||
	                    Object.keys(Properties.groupList(style))[0];
	    if (styleName)
	      props[style] = Properties.getSet(style, styleName);
	
	    function isReveal() {return style === 'Reveal';}
	    function isInset() {return style === 'Inset';}
	    function isOverlay() {return !isReveal() && !isInset();}
	    function overlay() {return props['Overlay'].ov.value()}
	    function reveal() {return props['Reveal']};
	
	    function cabinetStyles() {
	      return ['Overlay', 'Inset', 'Reveal'];
	    }
	    function cabinetStyle() {
	      return style;
	    }
	    function cabinetStyleName() {
	      return styleName;
	    }
	
	    function set(group, name) {
	      if (cabinetStyles().indexOf(group) !== -1) {
	        style = group;
	        styleName = name;
	      } else {
	        const newSet = Properties.getSet(group, name);
	        newSet.__KEY = name;
	        if (newSet === undefined) throw new Error(`Attempting to switch '${group}' to unknown property set '${name}'`);
	        props[group] = newSet;
	      }
	    }
	
	    const panelThicknessRegMetric = /^pwt([0-9]{1,})([0-9][0-9])$/;
	    const panelThicknessRegImperial = /^pwt([0-9])([0-9])$/;
	    const resolvePanelThickness = (code) => {
	      let match = code.match(panelThicknessRegImperial);
	      if (match) return new Measurement(match[1]/match[2], IMPERIAL_US).value();
	      match = code.match(panelThicknessRegMetric);
	      if (match) return new Measurement(`${match[1]}.${match[2]}`).value();
	      return undefined;
	    }
	
	    const outerCodeReg = /^(rrv|lrv|brv|trv)$/;
	    const resolveOuterReveal = (code, props) => {
	      if (!code.match(outerCodeReg)) return undefined;
	      switch (code) {
	        case 'rrv':
	          return 0.3175
	        case 'lrv':
	          return 0.3175
	        case 'brv':
	          return 0.3175
	        case 'trv':
	          return 0.3175
	        default:
	          return 0.3175
	      }
	    }
	
	    const resolveStyleStatus = (code) => {
	      switch (code) {
	        case 'isReveal': return isReveal();
	        case 'isInset': return isInset();
	        case 'isOverlay': return isOverlay();
	      }
	    }
	
	    const resolveReveals = (code, props) => {
	      switch (code) {
	        case 'frorl': return new Measurement(1/8, IMPERIAL_US).value();
	        case 'frorr': return new Measurement(1/8, IMPERIAL_US).value();
	        case 'r': if (isInset()) return 0;
	          if (isReveal()) return new Measurement(props.Reveal.r.value()).value();
	          return new Measurement(props.Cabinet.frw.value() - 2 * props.Overlay.ov.value()).value();
	        default: return resolveCostProps(code, props);
	      }
	    }
	
	    const resolveComplexProps = (code, props) => {
	      if (code === undefined) return undefined;
	      let value = resolvePanelThickness(code, props);
	      if (value !== undefined) return value;
	      value = resolveOuterReveal(code, props);
	      if (value !== undefined) return value;
	      console.log(code);
	      value = resolveStyleStatus(code);
	      // if (value !== undefined) return value;
	      // value = resolveReveals(code, props);
	      return value;
	    }
	
	    const excludeKeys = ['_ID', '_NAME', '_GROUP', 'properties'];
	    function getProperties(clazz, code) {
	      clazz = (typeof clazz) === 'string' ? clazz : clazz.constructor.name;
	      const classProps = props[clazz] || {};
	      if (code === undefined) return classProps;
	      return classProps[code] === undefined ? resolveComplexProps(code, props) : classProps[code].value();
	    }
	
	    function toJson() {
	      const json = {style, styleName};
	      const keys = Object.keys(props).filter((key) => key.match(/^[A-Z]/));
	      keys.forEach((key) => {
	        json[key] = [];
	        const propKeys = Object.keys(props[key]);
	        propKeys.forEach((propKey) => {
	          if (props[key][propKey] && (typeof props[key][propKey].toJson) === 'function')
	            json[key].push(props[key][propKey].toJson())
	        });
	      });
	      return json;
	    }
	
	    getProperties.isReveal = isReveal;
	    getProperties.isInset = isInset;
	    getProperties.overlay = overlay;
	    getProperties.reveal = reveal;
	    getProperties.toJson = toJson;
	    getProperties.cabinetStyles = cabinetStyles;
	    getProperties.cabinetStyle = cabinetStyle;
	    getProperties.cabinetStyleName = cabinetStyleName;
	    getProperties.set = set;
	
	    return getProperties;
	  }
	}
	
	PropertyConfig.lastStyle = 'Overlay';
	
	PropertyConfig.fromJson = (json) => {
	  const propConfig = {style: json.style, styleName: json.styleName};
	  const keys = Object.keys(json).filter((key) => key.match(/^[A-Z]/));
	  keys.forEach((key) => {
	    const propKeys = Object.keys(json[key]);
	    propConfig[key] = {};
	    propKeys.forEach((propKey) =>
	                propConfig[key][json[key][propKey].code] = Object.fromJson(json[key][propKey]));
	  });
	  return new PropertyConfig(propConfig);
	}
	
	module.exports = PropertyConfig;
	
});


RequireJS.addFunction('./app-src/config/property/definitions.js',
function (require, exports, module) {
	const Property = require('../property');
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	const IMPERIAL_US = Measurement.units()[1];
	
	const defs = {};
	
	defs.h = new Property('h', 'height', null);
	defs.w = new Property('w', 'width', null);
	defs.d = new Property('d', 'depth', null);
	defs.t = new Property('t', 'thickness', null);
	defs.l = new Property('l', 'length', null);
	
	//   Overlay
	defs.ov = new Property('ov', 'Overlay', {value: 1/2, notMetric: IMPERIAL_US})
	
	//   Reveal
	defs.r = new Property('r', 'Reveal', {value: 1/8, notMetric: IMPERIAL_US}),
	defs.rvr = new Property('rvr', 'Reveal Right', {value: 1/8, notMetric: IMPERIAL_US}),
	defs.rvl = new Property('rvl', 'Reveal Left', {value: 1/8, notMetric: IMPERIAL_US}),
	defs.rvt = new Property('rvt', 'Reveal Top', {value: 1/2, notMetric: IMPERIAL_US}),
	defs.rvb = new Property('rvb', 'Reveal Bottom', {value: 0, notMetric: IMPERIAL_US})
	
	//   Inset
	defs.is = new Property('is', 'Spacing', {value: 3/32, notMetric: IMPERIAL_US})
	
	//   Cabinet
	defs.sr = new Property('sr', 'Scribe Right', {value: 3/8, notMetric: IMPERIAL_US}),
	defs.sl = new Property('sl', 'Scribe Left', {value: 3/8, notMetric: IMPERIAL_US}),
	defs.rvibr = new Property('rvibr', 'Reveal Inside Bottom Rail', {value: 1/8, notMetric: IMPERIAL_US}),
	defs.rvdd = new Property('rvdd', 'Reveal Dual Door', {value: 1/16, notMetric: IMPERIAL_US}),
	defs.tkbw = new Property('tkbw', 'Toe Kick Backer Width', {value: 1/2, notMetric: IMPERIAL_US}),
	defs.tkd = new Property('tkd', 'Toe Kick Depth', {value: 4, notMetric: IMPERIAL_US}),
	defs.tkh = new Property('tkh', 'Toe Kick Height', {value: 4, notMetric: IMPERIAL_US}),
	defs.pbt = new Property('pbt', 'Panel Back Thickness', {value: 1/2, notMetric: IMPERIAL_US}),
	defs.iph = new Property('iph', 'Ideal Handle Height', {value: 42, notMetric: IMPERIAL_US})
	defs.brr = new Property('brr', 'Bottom Rail Reveal', {value: 1/8, notMetric: IMPERIAL_US})
	defs.frw = new Property('frw', 'Frame Rail Width', {value: 1.5, notMetric: IMPERIAL_US})
	defs.frt = new Property('frt', 'Frame Rail Thicness', {value: .75, notMetric: IMPERIAL_US})
	
	// Cabinet.AngledBackCorner
	defs.rbo = new Property('bo', 'Back Offset From Corner', {value: 24, notMetric: IMPERIAL_US})
	defs.lbo = new Property('lbo', 'Left Back Offset From Corner', {value: 24, notMetric: IMPERIAL_US})
	defs.rbo = new Property('rbo', 'Right Back Offset From Corner', {value: 24, notMetric: IMPERIAL_US})
	
	// Cabinet.Lshaped
	defs.lw = new Property('lw', 'Distance from Front to Back on the Left', {value: 24, notMetric: IMPERIAL_US})
	defs.rw = new Property('rw', 'Distance from Front to Back on the Right', {value: 24, notMetric: IMPERIAL_US})
	
	//   Panel
	
	//   Guides
	defs.dbtos = new Property('dbtos', 'Drawer Box Top Offset', null),
	defs.dbsos = new Property('dbsos', 'Drawer Box Side Offest', null),
	defs.dbbos = new Property('dbbos', 'Drawer Box Bottom Offset', null)
	
	//   DoorAndFront
	defs.daffrw = new Property('daffrw', 'Door and front frame rail width', {value: '2 3/8', notMetric: IMPERIAL_US}),
	defs.dafip = new Property('dafip', 'Door and front inset panel', {value: null})
	
	//   Door
	
	//   DrawerBox
	defs.dbst = new Property('dbst', 'Side Thickness', {value: 5/8, notMetric: IMPERIAL_US}),
	defs.dbbt = new Property('dbbt', 'Box Bottom Thickness', {value: 1/4, notMetric: IMPERIAL_US}),
	defs.dbid = new Property('dbid', 'Bottom Inset Depth', {value: 1/2, notMetric: IMPERIAL_US}),
	defs.dbn = new Property('dbn', 'Bottom Notched', {value: true, notMetric: IMPERIAL_US})
	
	//   DrawerFront
	defs.mfdfd = new Property('mfdfd', 'Minimum Framed Drawer Front Height', {value: 6, notMetric: IMPERIAL_US})
	
	//   Frame
	
	//   Handle
	defs.c2c = new Property('c2c', 'Center To Center', null),
	defs.proj = new Property('proj', 'Projection', null),
	
	//   Hinge
	defs.maxtab = new Property('maxtab', 'Max Spacing from bore to edge of door', null),
	defs.mintab = new Property('mintab', 'Minimum Spacing from bore to edge of door', null),
	defs.maxol = new Property('maxol', 'Max Door Overlay', null),
	defs.minol = new Property('minol', 'Minimum Door Overlay', null)
	
	//   Opening
	
	module.exports = defs;
	
});


RequireJS.addFunction('./app-src/two-d/objects/snap.js',
function (require, exports, module) {
	
const Vertex2d = require('vertex');
	const SnapLocation2d = require('snap-location');
	
	class Snap2d {
	  constructor(parent, object, tolerance) {
	    name = 'booyacka';
	    Object.getSet(this, {object, tolerance}, 'layoutId');
	    if (parent === undefined) return;
	    const instance = this;
	    const id = String.random();
	    let start = new Vertex2d();
	    let end = new Vertex2d();
	    let layout = parent.layout();
	
	    this.dl = () => 24 * 2.54;
	    this.dr = () => 24 * 2.54;
	    this.dol = () => 12;
	    this.dor = () => 12;
	    this.toString = () => `SNAP (${tolerance}):${object}`
	    this.position = {};
	    this.id = () => id;
	    this.parent = () => parent;
	    this.x = (val) => {
	      if (val !== undefined) {
	        notify(this.parent().center().x(), val);
	        this.parent().center().x(val);
	      }
	      return this.parent().center().x();
	    }
	    this.y = (val) => {
	      if (val !== undefined) {
	        notify(this.parent().center().y(), val);
	        this.parent().center().y(val);
	      }
	      return this.parent().center().y();
	    }
	
	    this.angle = (value) => {
	      if (value !== undefined) {
	        notify(this.angle(), value);
	        this.radians(Math.toRadians(value));
	      }
	      return Math.toDegrees(this.radians());
	    }
	
	
	    const changeFuncs = [];
	    this.onChange = (func) => {
	      if ((typeof func) === 'function') {
	        changeFuncs.push(func);
	      }
	    }
	
	    let lastNotificationId = 0;
	    function notify(currentValue, newValue) {
	      if (changeFuncs.length === 0 || (typeof newValue) !== 'number') return;
	      if (newValue !== currentValue) {
	        const id = ++lastNotificationId;
	        setTimeout(() => {
	          if (id === lastNotificationId)
	            for (let i = 0; i < changeFuncs.length; i++) changeFuncs[i](instance);
	        }, 100);
	      }
	    }
	
	    let radians = 0;
	    this.radians = (newValue) => {
	      if (newValue !== undefined && !Number.isNaN(Number.parseFloat(newValue))) {
	        notify(radians, newValue);
	        radians = newValue;
	      }
	      return radians;
	    };
	
	    let height = 60.96;
	    let width = 121.92;
	    this.height = (h) => {
	      if ((typeof h) === 'number') {
	        const newVal = h;
	        notify(height, newVal);
	        height = newVal;
	      }
	      return height;
	    }
	    this.width = (w) => {
	      if ((typeof w) === 'number') {
	        const newVal = w;
	        notify(width, newVal);
	        width = newVal;
	      }
	      return width;
	    }
	
	    this.minDem = () => this.width() > this.height() ? this.width() : this.height();
	    this.maxDem = () => this.width() > this.height() ? this.width() : this.height();
	
	    this.view = () => {
	      switch (this) {
	        case parent.topview(): return 'topview';
	        case parent.bottomview(): return 'bottomview';
	        case parent.leftview(): return 'leftview';
	        case parent.rightview(): return 'rightview';
	        case parent.frontview(): return 'frontview';
	        case parent.backview(): return 'backview';
	        default: return null;
	      }
	    }
	
	    const snapLocations = [];
	    this.addLocation = (snapLoc) => {
	      if (snapLoc instanceof SnapLocation2d && this.position[snapLoc.location()] === undefined) {
	        snapLocations.push(snapLoc);
	        this.position[snapLoc.location()] = snapLoc.at;
	      }
	    }
	    function getSnapLocations(func) {
	      const locs = [];
	      for (let index = 0; index < snapLocations.length; index += 1) {
	        const loc = snapLocations[index];
	        if ((typeof func) === 'function') {
	          if (func(loc)) locs.push(loc);
	        } else locs.push(loc);
	      }
	      return locs;
	    }
	
	    this.snapLocations = getSnapLocations;
	    this.snapLocations.notPaired = () => getSnapLocations((loc) => loc.pairedWith() === null);
	    this.snapLocations.paired = () => getSnapLocations((loc) => loc.pairedWith() !== null);
	    this.snapLocations.wallPairable = () => getSnapLocations((loc) => loc.wallThetaOffset() !== undefined);
	    // this.snapLocations.rotate = backCenter.rotate;
	    function resetVertices() {
	      for (let index = 0; index < snapLocations.length; index += 1) {
	        const snapLoc = snapLocations[index];
	        instance.position[snapLoc.location()]();
	      }
	    }
	
	    function calculateMaxAndMin(closestVertex, furthestVertex, wall, position, axis) {
	      const maxAttr = `max${axis.toUpperCase()}`;
	      const minAttr = `min${axis.toUpperCase()}`;
	      if (closestVertex[axis]() === furthestVertex[axis]()) {
	        const perpLine = wall.perpendicular(10, null, true);
	        const externalVertex = !layout.within(perpLine.startVertex()) ?
	                perpLine.endVertex() : perpLine.startVertex();
	        if (externalVertex[axis]() < closestVertex[axis]()) position[maxAttr] = closestVertex[axis]();
	        else position[minAttr] = closestVertex[axis]();
	      } else if (closestVertex[axis]() < furthestVertex[axis]()) position[minAttr] = closestVertex[axis]();
	      else position[maxAttr] = closestVertex[axis]();
	    }
	
	    function findWallSnapLocation(center) {
	      const centerWithin = layout.within(center);
	      let wallObj;
	      layout.walls().forEach((wall) => {
	        const point = wall.closestPointOnLine(center, true);
	        if (point) {
	          const wallDist = point.distance(center);
	          const isCloser = (!centerWithin || wallDist < tolerance*2) &&
	                          (wallObj === undefined || wallObj.distance > wallDist);
	          if (isCloser) {
	            wallObj = {point, distance: wallDist, wall};
	          }
	        }
	      });
	      if (wallObj) {
	        const wall = wallObj.wall;
	        const point = wallObj.point;
	        center = point;
	        let theta = wall.radians();
	
	        let position = {center, theta};
	
	        const wallPairables = instance.snapLocations.wallPairable();
	        let pairWith;
	        if (centerWithin) pairWith = wallPairables[1];
	        else pairWith = wallPairables[0];
	
	        theta += Math.toRadians(pairWith.wallThetaOffset());
	        const objCenter = pairWith.at({center, theta});
	
	        return {center: objCenter, theta, wall, pairWith};
	      }
	    }
	
	    function findObjectSnapLocation (center) {
	      let snapObj;
	      SnapLocation2d.active().forEach((snapLoc) => {
	        const tarVertId = snapLoc.targetVertex();
	        if ((typeof instance.position[tarVertId]) !== 'function') return;
	        const targetSnapLoc = instance.position[tarVertId]();
	        if (snapLoc.isConnected(instance) ||
	            snapLoc.pairedWith() !== null || targetSnapLoc.pairedWith() !== null) return;
	        const vertDist = snapLoc.vertex().distance(center);
	        const vertCloser = (snapObj === undefined && vertDist < tolerance) ||
	        (snapObj !== undefined && snapObj.distance > vertDist);
	        if (vertCloser) snapObj = {snapLoc: snapLoc, distance: vertDist, targetSnapLoc};
	      });
	      if (snapObj) {
	        const snapLoc = snapObj.snapLoc;
	        const tarSnap = snapObj.targetSnapLoc;
	        let theta = snapLoc.parent().radians();
	        const center = snapLoc.vertex();
	        const funcName = snapLoc.targetVertex();
	        theta += Math.toRadians(tarSnap.thetaOffset(snapLoc));
	        lastPotentalPair = [snapLoc, tarSnap];
	        return {snapLoc, center: instance.position[funcName]({center, theta}), theta};
	      }
	    }
	
	    let lastPotentalPair;
	    this.setLastPotentialPair = (lpp) => lastPotentalPair = lpp;
	    function checkPotentialPair() {
	      if (!lastPotentalPair) return;
	      if (!(lastPotentalPair[1] instanceof SnapLocation2d)) return true;
	      const snap1 = lastPotentalPair[0];
	      const snap2 = lastPotentalPair[1];
	      snap1.eval();
	      snap2.eval();
	      if (!snap1.vertex().equal(snap2.vertex())) lastPotentalPair = null;
	      return true;
	    }
	
	    this.potentalSnapLocation = () => checkPotentialPair() && lastPotentalPair && lastPotentalPair[0];
	    this.pairWithLast = () => {
	      if (lastPotentalPair) {
	        if ((typeof lastPotentalPair[0].pairWith) === 'function') {
	          lastPotentalPair && lastPotentalPair[0].pairWith(lastPotentalPair[1])
	        } else {
	          console.log('nope');
	        }
	      }
	      lastPotentalPair = null;
	    };
	
	    let lastValidMove;
	    this.makeMove = (position, force) => {
	      const originalPos = {center: this.parent().center(), theta: this.radians()};
	      instance.parent().center().point(position.center);
	      if (position.theta !== undefined) instance.radians(position.theta);
	      if (!force) {
	        let validMove = true;
	        instance.snapLocations().forEach((l) => validMove &&= layout.within(l.at().vertex()));
	        if (!validMove) return this.makeMove(lastValidMove, true); // No move was made return undefined
	        else lastValidMove = position;
	      }
	      instance.update();
	    }
	    this.move = (center) => {
	      checkPotentialPair();
	      const pairedSnapLocs = this.snapLocations.paired();
	      resetVertices();
	      if (pairedSnapLocs.length > 0) {
	        const snapInfo = findObjectSnapLocation(center);
	        if (snapInfo) {
	          const obj = snapInfo.snapLoc.parent();
	          if (snapInfo.theta !== undefined) {
	            const theta = ((snapInfo.theta + 2 * Math.PI) - this.radians()) % (2*Math.PI);
	            snapInfo.theta = undefined;
	            this.snapLocations.rotate(theta);
	          }
	          const snapLoc = snapInfo.snapLoc;
	          const targetVertex = snapLoc.targetVertex();
	          const targetSnapLoc = this[targetVertex]();
	          lastPotentalPair = [targetSnapLoc, snapLoc];
	          const vertexCenter = snapLoc.parent().position[snapLoc.location()]().vertex();
	          return targetSnapLoc.move(vertexCenter);
	        }
	        const snapLoc = pairedSnapLocs[0];
	        return snapLoc.move(center);
	      }
	      const centerWithin = layout.within(center);
	      let closest = {};
	      const snapLocation = findObjectSnapLocation(center);
	      const wallSnapLocation = findWallSnapLocation(center);
	      if (snapLocation) {
	        return this.makeMove(snapLocation);
	      } else if (wallSnapLocation !== undefined) {
	        const move = this.makeMove(wallSnapLocation);
	        const wallSnapLoc = this.snapLocations.wallPairable()[0];
	        lastPotentalPair = [wallSnapLoc.pairWith, wallSnapLocation.wall];
	        return move;
	      } else if (centerWithin) {
	        return this.makeMove({center});
	      }
	    }
	
	    const objData = (funcName) => {
	      const obj = this.object();
	      return obj && (typeof obj[funcName]) === 'function';
	    }
	    function updateObject() {
	      if (objData('radians')) object.radians(radians);
	      if (objData('height')) object.height(height);
	      if (objData('width')) object.width(width);
	      instance.snapLocations().forEach((snapLoc) => snapLoc.at());
	    }
	
	    this.update = updateObject;
	    this.onChange(updateObject);
	  }
	}
	
	Snap2d.get = {};
	Snap2d.registar = (clazz) => {
	  const instance = new clazz();
	  if (instance instanceof Snap2d) {
	    const name = clazz.prototype.constructor.name.replace(/^Snap/, '').toCamel();
	    if (Snap2d.get[name] === undefined)
	      Snap2d.get[name] = (parent, tolerance) => new clazz(parent, tolerance);
	    else throw new Error(`Double registering Snap2d: ${name}`);
	  }
	}
	
	
	Snap2d.fromJson = (json) => {
	  const layout = Layout2d.get(json.layoutId);
	  const object = Object.fromJson(json.object);
	  const snapObj = new Snap2d(layout, object, json.tolerance);
	  snapObj.id(json.id);
	  return snapObj;
	}
	
	new Snap2d();
	
	module.exports = Snap2d;
	
});


RequireJS.addFunction('./app-src/two-d/objects/snap-location.js',
function (require, exports, module) {
	
const Vertex2d = require('vertex');
	const Circle2d = require('circle');
	
	class SnapLocation2d {
	  constructor(parent, location, vertex, targetVertex, pairedWith) {
	    Object.getSet(this, {location, vertex, targetVertex}, "wallThetaOffset", "parentId", "pairedWithId", "thetaOffset");
	    let locationFunction;
	    const circle = new Circle2d(5, vertex);
	    pairedWith = pairedWith || null;
	
	    const thetaOffset = {_DEFAULT: 0};
	    this.thetaOffset = (cxtrNameOinstance, location, value) => {
	      const cxtrName = cxtrNameOinstance instanceof SnapLocation2d ?
	              cxtrNameOinstance.parent().constructor.name :
	              cxtrNameOinstance ? cxtrNameOinstance : parent.constructor.name;
	      if (cxtrNameOinstance instanceof SnapLocation2d && location === undefined)
	        location = cxtrNameOinstance.location();
	      if (cxtrName !== undefined && Number.isFinite(value)) {
	        if (thetaOffset._DEFAULT === undefined) thetaOffset._DEFAULT = value;
	        if (thetaOffset[cxtrName] === undefined) thetaOffset[cxtrName] = {};
	        if (thetaOffset[cxtrName]._DEFAULT === undefined) thetaOffset[cxtrName]._DEFAULT = value;
	        if (location) thetaOffset[cxtrName][location] = value;
	      }
	      return thetaOffset[cxtrName] === undefined ? thetaOffset._DEFAULT :
	          (thetaOffset[cxtrName][location] === undefined ? thetaOffset[cxtrName]._DEFAULT :
	          thetaOffset[cxtrName][location]);
	    }
	
	    // If position is defined and a Vertex2d:
	    //        returns the position of parents center iff this location was at position
	    // else
	    //        returns current postion based off of the parents current center
	
	    this.at = (position) => (typeof locationFunction) === 'function' ? locationFunction(position) : null;
	    this.locationFunction = (lf) => {
	      if ((typeof lf) === 'function') locationFunction = lf;
	      return lf;
	    }
	    this.circle = () => circle;
	    this.eval = () => this.parent().position[location]();
	    this.parent = () => parent;
	    this.parentId = () => parent.id();
	    this.pairedWithId = () => pairedWith && pairedWith.id();
	    this.pairedWith = () => pairedWith;
	    this.disconnect = () => {
	      if (pairedWith === null) return;
	      const wasPaired = pairedWith;
	      pairedWith = null;
	      if (wasPaired instanceof SnapLocation2d) wasPaired.disconnect();
	    }
	    this.pairWith = (otherSnapLoc) => {
	      const alreadyPaired = otherSnapLoc === pairedWith;
	      if (!alreadyPaired) {
	        pairedWith = otherSnapLoc;
	        if (otherSnapLoc instanceof SnapLocation2d) otherSnapLoc.pairWith(this);
	      }
	    }
	
	    this.forEachObject = (func, objMap) => {
	      objMap = objMap || {};
	      objMap[this.parent().toString()] = this.parent();
	      const locs = this.parent().snapLocations.paired();
	      for (let index = 0; index < locs.length; index += 1) {
	        const loc = locs[index];
	        const connSnap = loc.pairedWith();
	        if (connSnap instanceof SnapLocation2d) {
	          const connObj = connSnap.parent();
	          if (connObj && objMap[connObj.id()] === undefined) {
	            objMap[connObj.id()] = connObj;
	            connSnap.forEachObject(undefined, objMap);
	          }
	        }
	      }
	      if ((typeof func) === 'function') {
	        const objs = Object.values(objMap);
	        for (let index = 0; index < objs.length; index += 1) {
	          func(objs[index]);
	        }
	      } else return objMap;
	    };
	
	    this.forEachConnectedSnap = (func, pairedMap) => {
	      pairedMap ||= {};
	      const locs = this.parent().snapLocations.paired();
	      for (let index = 0; index < locs.length; index += 1) {
	        const loc = locs[index];
	        pairedMap[loc.toString()]  = loc;
	        const connSnap = loc.pairedWith();
	        if (connSnap instanceof SnapLocation2d) {
	          const snapStr = connSnap.toString();
	          if (pairedMap[snapStr] === undefined) {
	            pairedMap[snapStr] = connSnap;
	            connSnap.forEachConnectedSnap(undefined, pairedMap);
	          }
	        }
	      }
	
	      if ((typeof func) === 'function') {
	        const snaps = Object.values(pairedMap);
	        for (let index = 0; index < snaps.length; index += 1) {
	          func(snaps[index]);
	        }
	      } else return pairedMap;
	    }
	
	    this.getNonSnap = () => {
	      let nonSnap = undefined;
	      this.forEachConnectedSnap((snap) => {
	        const pw = snap.pairedWith();
	        if (pw !== undefined && !(pw instanceof SnapLocation2d)) nonSnap = pw;
	      });
	      return nonSnap;
	    }
	
	    this.isConnected = (obj) => {
	      let connected = false;
	      this.forEachObject((connObj) => connected = connected || obj.id() === connObj.id());
	      return connected;
	    }
	
	    this.rotate = (theta) => {
	      this.forEachObject((obj) => obj.radians((obj.radians() + theta) % (2*Math.PI)));
	    }
	
	    let lastMove = 0;
	    this.move = (vertexLocation, moveId) => {
	      moveId = (typeof moveId) !== 'number' ? lastMove + 1 : moveId;
	      if (lastMove === moveId) return;
	      vertexLocation = new Vertex2d(vertexLocation);
	      const parent = this.parent();
	      const thisNewCenterLoc = this.parent().position[location]({center: vertexLocation});
	      parent.parent().center().point(thisNewCenterLoc);
	      parent.update();
	      lastMove = moveId;
	      const pairedLocs = parent.snapLocations.paired();
	      for (let index = 0; index < pairedLocs.length; index += 1) {
	        const loc = pairedLocs[index];
	        const paired = loc.pairedWith();
	        const tarVertexLoc = this.parent().position[loc.location()]().vertex();
	        if (paired instanceof SnapLocation2d) paired.move(tarVertexLoc, moveId);
	      }
	    }
	    this.notPaired = () => pairedWith === null;
	
	    this.instString = () => `${parent.id()}:${location}`;
	    this.toString = () => pairedWith  instanceof SnapLocation2d ?
	                  `${this.instString()}=>${pairedWith && pairedWith.instString()}` :
	                  `${this.instString()}=>${pairedWith}`;
	    this.toJson = () => {
	      const pw = pairedWith;
	      if (pw === undefined) return;
	      const json = [{
	        location, objectId: parent.parent().id()
	      }];
	      json[1] = pw instanceof SnapLocation2d ?
	                  {location: pw.location(), objectId: pw.parent().parent().id()} :
	                  pw.constructor.name;
	      const thisStr = this.toString();
	      const pairStr = pw.toString();
	      json.view = parent.view();
	      json.UNIQUE_ID = thisStr < pairStr ? thisStr : pairStr;;
	      return json;
	    }
	  }
	}
	
	SnapLocation2d.fromJson = (json) => {
	  console.log('jsoned it up!')
	}
	
	let activeLocations = [];
	SnapLocation2d.active = (locs) => {
	  if (Array.isArray(locs)) activeLocations = activeLocations.concat(locs);
	  return activeLocations;
	}
	SnapLocation2d.clear = () => activeLocations = [];
	
	function fromToPoint(snapLoc, xDiffFunc, yDiffFunc) {
	  return (position) => {
	    const xDiff = xDiffFunc();
	    const yDiff = yDiffFunc();
	    const vertex = snapLoc.vertex();
	    if (xDiff === 0 && yDiff === 0) {
	      if (position) return snapLoc.parent().parent().center().clone();
	      vertex.point(snapLoc.parent().parent().center().clone());
	      return snapLoc;
	    }
	    const center = snapLoc.parent().parent().center();
	    const direction = xDiff >= 0 ? 1 : -1;
	    const hypeLen = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
	    let rads = Math.atan(yDiff/xDiff);
	    if (position) {
	      rads += position.theta === undefined ? snapLoc.parent().radians() : position.theta;
	      const newPoint = position.center;
	      return new Vertex2d({
	        x: newPoint.x() - direction * (hypeLen * Math.cos(rads)),
	        y: newPoint.y() - direction * (hypeLen * Math.sin(rads))
	      });
	    } else {
	      rads += snapLoc.parent().radians();
	      vertex.point({
	        x: center.x() + direction * (hypeLen * Math.cos(rads)),
	        y: center.y() + direction * (hypeLen * Math.sin(rads))
	      });
	      return snapLoc;
	    }
	  }
	}
	SnapLocation2d.fromToPoint = fromToPoint;
	
	const f = (snapLoc, attr, attrM, props) => () => {
	  let val = snapLoc.parent()[attr]() * attrM;
	  let keys = Object.keys(props || {});
	  for (let index = 0; index < keys.length; index += 1) {
	    const key = keys[index];
	    val += snapLoc.parent()[key]() * props[key];
	  }
	  return val;
	};
	
	SnapLocation2d.locationFunction = f;
	
	module.exports = SnapLocation2d;
	
});


RequireJS.addFunction('./app-src/two-d/objects/square.js',
function (require, exports, module) {
	
const Vertex2d = require('vertex');
	
	class Square2d {
	  constructor(center, height, width, radians) {
	    width = width === undefined ? 121.92 : width;
	    height = height === undefined ? 60.96 : height;
	    radians = radians === undefined ? 0 : radians;
	    const id = String.random();
	    const instance = this;
	    Object.getSet(this, {center: new Vertex2d(center), height, width, radians});
	    if ((typeof center) === 'function') this.center = center;
	    const startPoint = new Vertex2d(null);
	
	
	    this.radians = (newValue) => {
	      if (newValue !== undefined && !Number.isNaN(Number.parseFloat(newValue))) {
	        radians = newValue;
	      }
	      return radians;
	    };
	    this.startPoint = () => {
	      startPoint.point({x: this.center().x() - width / 2, y: this.center().y() - height / 2});
	      return startPoint;
	    }
	    this.angle = (value) => {
	      if (value !== undefined) this.radians(Math.toRadians(value));
	      return Math.toDegrees(this.radians());
	    }
	
	    this.x = (val) => {
	      if (val !== undefined) this.center().x(val);
	      return this.center().x();
	    }
	    this.y = (val) => {
	      if (val !== undefined) this.center().y(val);
	      return this.center().y();
	    }
	    this.minDem = () => this.width() > this.height() ? this.width() : this.height();
	    this.maxDem = () => this.width() > this.height() ? this.width() : this.height();
	
	    this.shorterSideLength = () => this.height() < this.width() ? this.height() : this.width();
	    this.move = (position, theta) => {
	      const center = position.center instanceof Vertex2d ? position.center.point() : position.center;
	      if (position.maxX !== undefined) center.x = position.maxX - this.offsetX();
	      if (position.maxY !== undefined) center.y = position.maxY - this.offsetY();
	      if (position.minX !== undefined) center.x = position.minX + this.offsetX();
	      if (position.minY !== undefined) center.y = position.minY + this.offsetY();
	      this.radians(position.theta);
	      this.center().point(center);
	      return true;
	    };
	
	    this.offsetX = (negitive) => negitive ? this.width() / -2 : this.width() / 2;
	    this.offsetY = (negitive) => negitive ? this.height() / -2 : this.height() / 2;
	
	    this.toString = () => `Square2d(${id}): ${this.width()} X ${this.height()}] @ ${this.center()}`
	  }
	}
	
	new Square2d();
	
	module.exports = Square2d;
	
});


RequireJS.addFunction('./app-src/two-d/objects/vertex.js',
function (require, exports, module) {
	
const approximate = require('../../../../../public/js/utils/approximate.js').new(1000000);
	const approximate10 = require('../../../../../public/js/utils/approximate.js').new(10);
	
	
	class Vertex2d {
	  constructor(point) {
	    if (Array.isArray(point)) point = {x: point[0], y: point[1]};
	    if (point instanceof Vertex2d) return point;
	    let modificationFunction;
	    point = point || {x:0,y:0};
	    Object.getSet(this, {point});
	    this.layer = point.layer;
	    const instance = this;
	    this.move = (center) => {
	      this.point(center);
	      return true;
	    };
	    this.point = (newPoint) => {
	      newPoint = newPoint instanceof Vertex2d ? newPoint.point() : newPoint;
	      if (newPoint) this.x(newPoint.x);
	      if (newPoint) this.y(newPoint.y);
	      return point;
	    }
	
	    this.modificationFunction = (func) => {
	      if ((typeof func) === 'function') {
	        if ((typeof this.id) !== 'function') Lookup.convert(this);
	        modificationFunction = func;
	      }
	      return modificationFunction;
	    }
	
	    this.equal = (other) => approximate.eq(other.x(), this.x()) && approximate.eq(other.y(), this.y());
	    this.x = (val) => {
	      if ((typeof val) === 'number') point.x = val;
	      return this.point().x;
	    }
	    this.y = (val) => {
	      if ((typeof val) === 'number') this.point().y = val;
	      return this.point().y;
	    }
	
	    const dummyFunc = () => true;
	    this.forEach = (func, backward) => {
	      let currVert = this;
	      let lastVert;
	      do {
	        lastVert = currVert;
	        func(currVert);
	        currVert = backward ? currVert.prevVertex() : currVert.nextVertex();
	      } while (currVert && currVert !== this);
	      return currVert || lastVert;
	    }
	
	    this.distance = (vertex) => {
	      vertex = (vertex instanceof Vertex2d) ? vertex : new Vertex2d(vertex);
	      const xDiff = vertex.x() - this.x();
	      const yDiff = vertex.y() - this.y();
	      return Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
	    }
	
	    this.toString = () => `(${this.x()}, ${this.y()})`;
	    this.approxToString = () => `(${approximate10(this.x())}, ${approximate10(this.y())})`;
	    const parentToJson = this.toJson;
	
	    this.offset = (x, y) => {
	      if (x instanceof Vertex2d) {
	        y = x.y();
	        x = x.x();
	      }
	      const copy = this.toJson().point;
	      if (y !== undefined) copy.y += y;
	      if (x !== undefined) copy.x += x;
	      return new Vertex2d(copy);
	    }
	
	    this.copy = () => new Vertex2d([this.x(), this.y()]);
	
	    this.differance = (x, y) => {
	      if (x instanceof Vertex2d) {
	        y = x.y();
	        x = x.x();
	      }
	      return new Vertex2d({x: this.x() - x, y: this.y() - y});
	    }
	
	    this.point(point);
	  }
	}
	
	Vertex2d.fromJson = (json) => {
	  return new Vertex2d(json.point);
	}
	
	Vertex2d.center = (...verticies) => {
	  if (Array.isArray(verticies[0])) verticies = verticies[0];
	  let x = 0;
	  let y = 0;
	  let count = 0;
	  verticies.forEach((vertex) => {
	    if (Number.isFinite(vertex.x() + vertex.y())) {
	      count++;
	      x += vertex.x();
	      y += vertex.y();
	    }
	  });
	  return new Vertex2d({x: x/count, y: y/count});
	}
	
	Vertex2d.sort = (a, b) =>
	    a.x() === b.x() ? (a.y() === b.y() ? 0 : (a.y() > b.y() ? -1 : 1)) : (a.x() > b.x() ? -1 : 1);
	
	Vertex2d.sortByCenter = (center) => {
	  return (v1, v2) => {
	    const d1 = v1.distance(center);
	    const d2 = v2.distance(center);
	    return d2 - d1;
	  }
	}
	
	
	Vertex2d.reusable = true;
	new Vertex2d();
	
	module.exports = Vertex2d;
	
});


RequireJS.addFunction('./app-src/three-d/objects/vector.js',
function (require, exports, module) {
	
const approximate = require('../../../../../public/js/utils/approximate.js').new(1);
	
	class Vector3D {
	  constructor(i, j, k) {
	    this.i = () => i;
	    this.j = () => j;
	    this.k = () => k;
	
	    this.magnitude = () => Math.sqrt(this.i()*this.i() + this.j()*this.j() + this.k()*this.k());
	    this.minus = (vector) => {
	      if (!(vector instanceof Vector3D)) vector = new Vector3D(vector, vector, vector);
	      return new Vector3D(this.i() - vector.i(), this.j() - vector.j(), this.k() - vector.k());
	    }
	    this.add = (vector) => {
	      if (!(vector instanceof Vector3D)) vector = new Vector3D(vector, vector, vector);
	      return new Vector3D(this.i() + vector.i(), this.j() + vector.j(), this.k() + vector.k());
	    }
	    this.scale = (coef) => {
	      return new Vector3D(coef*this.i(), coef*this.j(), coef*this.k());
	    }
	    this.sameDirection = (otherVect) => {
	      return approximate.sameSign(otherVect.i(), this.i()) &&
	              approximate.sameSign(otherVect.j(), this.j()) &&
	              approximate.sameSign(otherVect.k(), this.k());
	    }
	    this.divide = (vector) => {
	      if (!(vector instanceof Vector3D)) vector = new Vector3D(vector, vector, vector);
	      return new Vector3D(this.i() / vector.i(), this.j() / vector.j(), this.k() / vector.k());
	    }
	    this.toArray = () => [this.i(), this.j(), this.k()];
	    this.dot = (vector) =>
	      this.i() * vector.i() + this.j() * vector.j() + this.k() * vector.k();
	    this.perpendicular = (vector) =>
	      approximate.eq(this.dot(vector), 0);
	    this.parrelle = (vector) => {
	      let coef = approximate(this.i()) / approximate(vector.i()) ||
	                  approximate(this.j()) / approximate(vector.j()) ||
	                  approximate(this.k()) / approximate(vector.k());
	      if (Math.abs(coef) === Infinity || coef === 0 || Number.isNaN(coef)) return null;
	      return approximate.eq(vector.i() * coef, this.i()) &&
	              approximate.eq(vector.j() * coef, this.j()) &&
	              approximate.eq(vector.k() * coef, this.k());
	    }
	    this.crossProduct = (other) => {
	      const i = this.j() * other.k() - this.k() * other.j();
	      const j = this.i() * other.k() - this.k() * other.i();
	      const k = this.i() * other.j() - this.j() * other.i();
	      const mag = Math.sqrt(i*i+j*j+k*k);
	      return new Vector3D(i/mag,j/-mag,k/mag);
	    }
	    this.inverse = () => new Vector3D(this.i()*-1, this.j()*-1, this.k()*-1);
	
	    this.unit = () => {
	      const i = this.i();const j = this.j();const k = this.k();
	      const magnitude = Math.sqrt(i*i+j*j+k*k);
	      return new Vector3D(i/magnitude, j/magnitude, k/magnitude);
	    }
	    this.equals = this.parrelle;
	    this.toString = () => `<${i},  ${j},  ${k}>`;
	  }
	}
	
	module.exports = Vector3D;
	
});


RequireJS.addFunction('./app-src/three-d/objects/plane.js',
function (require, exports, module) {
	const CSG = require('../../../public/js/3d-modeling/csg.js');
	const Vector3D = require('vector');
	const Vertex3D = require('vertex');
	const Matrix = require('matrix');
	const Line2d = require('../../two-d/objects/line.js');
	const Vertex2d = require('../../two-d/objects/vertex.js');
	const approximate = require('../../../../../public/js/utils/approximate.js').new(1000000);
	
	function isDefined(...values) {
	  for (let index = 0; index < values.length; index++) {
	    if (values[index] === undefined) return false;
	  }
	  return true;
	}
	
	class Plane extends Array {
	  constructor(...points) {
	    super();
	    let equation;
	    if (Array.isArray(points[0])) points = points[0];
	    if (isDefined(points[0], points[0].a, points[0].b, points[0].c, points[0].d)) {
	      equation = points[0];
	    }
	    for (let index = 0; index < points.length; index++) {
	      this[index] = new Vertex3D(points[index]);
	    }
	
	    this.equation = () => this.length > 2 ? Plane.equation(this[0], this[1], this[2]) : equation;
	    this.indexOf = (point) => {
	      for (let index = 0; index < points.length; index++) {
	        if (this[index].equals(point)) return index;
	      }
	      return -1;
	    }
	
	    this.points = () => this.length > 2 ? points.slice(0,3) : this.findPoints();
	
	    this.XYrotation = () => {
	      const eqn = this.equation();
	
	      const a2b2 = eqn.a * eqn.a + eqn.b * eqn.b;
	      const a2b2c2 = eqn.a * eqn.a + eqn.b * eqn.b + eqn.c * eqn.c;
	      const roota2b2c2 = Math.sqrt(a2b2c2);
	      const cos = eqn.c / roota2b2c2;
	      const sin = Math.sqrt(a2b2 / a2b2c2);
	      const u1 = eqn.b / Math.sqrt(a2b2);
	      const u2 = - eqn.a / Math.sqrt(a2b2);
	
	      const rotationMatrix = new Matrix([
	        [cos+u1*u1*(1-cos), u1*u2*(1-cos),     u2*sin],
	        [u1*u2*(1-cos),     cos+u2*u2*(1-cos), -u1*sin],
	        [-u2*sin,           u1*sin,             cos],
	      ])
	      return rotationMatrix;
	    }
	
	    this.rotate = (rotation, center) => {
	      center ||= this.center();
	      for (let index = 0; index < this.length; index++) {
	        this[index].rotate(rotation, center);
	      }
	    }
	
	    this.matrixRotation = (rotationMatrix) => {
	      const eqn = this.equation();
	      const planeMatrix = new Matrix([[eqn.a], [eqn.b], [eqn.c]]);
	      const planeMatrix2 = new Matrix([[eqn.a, eqn.b, eqn.c]]);
	      return rotationMatrix.dot(planeMatrix);
	    }
	
	    this.reverseRotate = (rotation, center) => {
	      center ||= this.center();
	      for (let index = 0; index < this.length; index++) {
	        this[index].reverseRotate(rotation, center);
	      }
	    }
	
	    this.x = (y,z, vertex) => {
	      y ||= 0;
	      z ||= 0;
	      const eqn = this.equation();
	      const x = (eqn.b * y + eqn.c * z + eqn.d) / eqn.a
	      if (x) return new Vertex3D(x,y,z);
	      return x;
	    }
	
	    this.y = (x,z, vertex) => {
	      x ||= 0;
	      z ||= 0;
	      const eqn = this.equation();
	      const y = (eqn.a * x + eqn.c * z + eqn.d) / eqn.b
	      if (y) return new Vertex3D(x,y,z);
	      return y;
	    }
	
	    this.z = (x,y, vertex) => {
	      x ||= 0;
	      y ||= 0;
	      const eqn = this.equation();
	      const z = (eqn.b * y + eqn.a * x + eqn.d) / eqn.c;
	      if (z) return new Vertex3D(x,y,z);
	      return z;
	    }
	
	    this.equation = () => {
	      if (equation && this.length < 3) return equation;
	      const pts = this.points();
	      const include = [];
	      const constants = {};
	      if (!this.parrelleTo('x')) include.push({axis: 'x', coef: 'a'});
	      else constants['x'] = pts[0].x;
	      if (!this.parrelleTo('y')) include.push({axis: 'y', coef: 'b'});
	      else constants['y'] = pts[0].y;
	      if (!this.parrelleTo('z')) include.push({axis: 'z', coef: 'c'});
	      else constants['z'] = pts[0].z;
	
	      const systemOfEquations = new Matrix(null, include.length, include.length);
	
	      for (let i = 0; i < include.length; i++) {
	        const point = pts[i];
	        for (let j = 0; j < include.length; j++) {
	          systemOfEquations[i][j] = point[include[j].axis];
	        }
	      }
	
	      let r = systemOfEquations.remove(undefined, 2);
	      let rr = r.remove(0);
	      // console.log(rr.solve([1,1]));
	
	      const answer = systemOfEquations.solve([1,1,1]);
	      const returnValue = {a: 0, b: 0, c: 0, d: 1};
	      for (let i = 0; i < include.length; i++) returnValue[include[i].coef] = answer[i][0];
	      return returnValue;//{a: answer[0][0], b: answer[1][0], c: answer[2][0], d: 1};
	    }
	
	    this.equationEqualToZ = () => {
	      const eqn = this.equation();
	      const a = approximate;
	      return `(${a(eqn.a)}x + ${a(eqn.b)}y + ${a(eqn.d)}) / ${a(eqn.c)}`;
	    }
	
	    this.findPoints = (count) => {
	      count ||= 3;
	      const limit = count * 3 + 11;
	      const points = [];
	      let state = 0;
	      let value = 100000;
	      while (points.length < count) {
	         let func = state === 0 ? this.x : (state === 1 ? this.y : this.z);
	         let point = value % 2 ? func(value * 2, value*-1, true) : func(value, value, true);
	         if (!point.usless() && (points.length === 0 || (points.equalIndexOf(point)))) points.push(point);
	         value += 13;
	         state = ++state % 3;
	         // if (value > limit) throw new Error('Cant find points');
	      }
	      return points;
	    }
	
	    this.parrelleTo = (axis) => {
	      const pts = this.points();
	      return approximate.eq(pts[0][axis], pts[1][axis], pts[2][axis]);
	    }
	
	    this.normal = () => {
	      const points = this.findPoints();
	      const vector1 = points[0].minus(points[1]);
	      const vector2 = points[2].minus(points[1]);
	      const normVect = vector1.crossProduct(vector2);
	      return normVect.scale(1 / normVect.magnitude());
	    }
	
	    this.center = () => Vertex3D.center.apply(null, this);
	
	    this.lineIntersection = (line) => {
	      const eqn = this.equation();
	      const lEqn = line.equation();
	      const x0 = line.startVertex.x;
	      const y0 = line.startVertex.y;
	      const z0 = line.startVertex.z;
	
	      const a1 = eqn.a;
	      const b1 = eqn.b;
	      const c1 = eqn.c;
	      const d = eqn.d;
	
	      const a2 = lEqn.a;
	      const b2 = lEqn.b;
	      const c2 = lEqn.c;
	
	      const sv = line.startVertex;
	      const p = this.points()[0];
	      if (a2 === 0 && b2 === 0 && c1 === 0) return new Vertex3D(sv.x, sv.y, p.z);
	      if (a2 === 0 && c2 === 0 && b1 === 0) return new Vertex3D(sv.x, p.y, sv.z);
	      if (b2 === 0 && c2 === 0 && a1 === 0) return new Vertex3D(p.x, sv.y, sv.z);
	
	      const t = -(a1*x0+b1*y0+c1*z0-d)/(a1*a2+b1*b2+c1*c2);
	
	      const x = x0+t*a2;
	      const y = y0+t*b2;
	      const z = z0+t*c2;
	      return new Vertex3D(x,y,z);
	    }
	
	    this.equals = (other) => {
	      if (!Array.isArray(other) || this.length !== other.length) return false;
	      const startIndex = this.indexOf(other[0]);
	      if (startIndex === -1) return false;
	      for (let index = startIndex; index < this.length + startIndex; index++) {
	        const i = Math.mod(index, this.length);
	        if (!this[i].equals(other[i])) return false;
	      }
	      return true;
	    }
	  }
	}
	
	Plane.makePlane1MeetPlane2 = function (plane1, plane2, rotation) {
	  const centerP1 = Vertex3D.center.apply(null, plane1);
	  const rotated1 = new Plane(JSON.copy(plane1));
	  const rotated2 = new Plane(JSON.copy(plane2));
	  rotated1.reverseRotate(rotation, centerP1);
	  rotated2.reverseRotate(rotation, centerP1);
	  const center1 = Vertex3D.center.apply(null, rotated1);
	  for (let index = 1; index < rotated1.length; index++)
	    if (approximate.neq(rotated1[0].z, rotated1[index].z)) throw new Error('Invalid planeRotation: Rotation reversed should make all z coordinates equal to each other');
	  const zValue = rotated1[0].z;
	  const keep1 = [];
	  const keep2 = [];
	  const intersections = [];
	  const plane2Line2d = new Line2d(rotated2[0], rotated2[1]).combine(new Line2d(rotated2[2], rotated2[3]));
	  const p2l2Midpoint = plane2Line2d.midpoint();
	  const len = rotated1.length;
	  let keep = keep1;
	  for (let index = 0; index < rotated1.length; index++) {
	    rotated1[index] = new Vertex2d(rotated1[index]);
	    const nextIndex = (index + 1) % len;
	    const prevIndex = Math.mod(index - 1, len);
	    const positiveLine = new Line2d(rotated1[nextIndex], rotated1[index]);
	    const negativeLine = new Line2d(rotated1[prevIndex], rotated1[index]);
	    const intersection1 = positiveLine.findDirectionalIntersection(plane2Line2d, 1000);
	    const intersection2 = negativeLine.findDirectionalIntersection(plane2Line2d, 1000);
	    if (intersections.length > 0) keep = keep2;
	    if (!intersection1 && !intersection2) keep.push(rotated1[index]);
	    else if (!intersection1) intersections.push(intersection2);
	    else if (!intersection2) intersections.push(intersection1);
	    else {
	      const dist1 = p2l2Midpoint.distance(intersection1);
	      const dist2 = p2l2Midpoint.distance(intersection2);
	      intersections.push(dist1 > dist2 ? intersection1 : intersection2);
	    }
	  }
	  const newPlaneRotated = keep1.concat(intersections).concat(keep2);
	  for (let index = 0; index < newPlaneRotated.length; index++) {
	    newPlaneRotated[index] = {
	      x: newPlaneRotated[index].x(),
	      y: newPlaneRotated[index].y(),
	      z: zValue
	    }
	  }
	
	  CSG.rotatePointsAroundCenter(rotation, newPlaneRotated, centerP1);
	  return new Plane(...newPlaneRotated);
	}
	
	Plane.bisector = (p1, p2) => {
	  const eq1 = p1.equation();
	  const eq2 = p2.equation();
	
	  const denom1 = Math.sqrt(eq1.a * eq1.a + eq1.b * eq1.b + eq1.c * eq1.c);
	  const denom2 = Math.sqrt(eq2.a * eq2.a + eq2.b * eq2.b + eq2.c * eq2.c);
	
	  const a1 = denom2*eq1.a;
	  const b1 = denom2*eq1.b;
	  const c1 = denom2*eq1.c;
	  const d1 = denom2*eq1.d;
	
	  const a2 = denom1*eq2.a;
	  const b2 = denom1*eq2.b;
	  const c2 = denom1*eq2.c;
	  const d2 = denom1*eq2.d;
	
	  const plane1 = new Plane({a: a1 + a2, b: b1 + b2, c: c1 + c2, d: d1 + d2});
	  const plane2 = new Plane({a: a1 - a2, b: b1 - b2, c: c1 - c2, d: d1 - d2});
	
	  const obtuse = (eq1.a*eq2.a + eq1.b*eq2.b + eq1.c*eq2.c) < 0
	  if (obtuse) return {obtuse: plane1, accute: plane2};
	  return {obtuse: plane2, accute: plane1};
	}
	
	// TODO: not used but could be helpful. - fix
	Plane.fromPointNormal = (point, normal) => {
	  const fixed = [];
	  const a = normal.i();
	  const b = normal.j();
	  const c = normal.k();
	  const vectArray = normal.toArray();
	
	  if (a===0 && b===0 && c===0) return;
	
	  const x0 = point.x;
	  const y0 = point.y;
	  const z0 = point.z;
	  const pointArray = [x0, y0, z0];
	  let startIndex = 0;
	  while (vectArray[startIndex] === 0) startIndex++;
	  const get = (x,y) => {
	    const ansI = startIndex;
	    const aI = (startIndex + 1) % 3;
	    const bI = (startIndex + 2) % 3;
	    const answer = (vectArray[aI]*(x-pointArray[aI])+vectArray[bI]*(y-pointArray[bI])-vectArray[ansI]*pointArray[ansI])/-vectArray[ansI];
	    const p = [];p[ansI] = answer;p[aI] = x;p[bI] = y;
	    return new Vertex3D(...p);
	    // (a*(x-x0)+b*(y-y0)-c*z0)/-c;
	  }
	  // there is a chance that these three points will be colinear.... not likely and I have more important stuff to do.
	
	  const point1 = get(13,677);
	  const point2 = get(127,43);
	  const point3 = get(107,563);
	  return new Plane(point1, point2, point3);
	}
	
	module.exports = Plane;
	
});


RequireJS.addFunction('./app-src/cost/types/labor.js',
function (require, exports, module) {
	

	
	const Material = require('./material.js');
	const Cost = require('../cost.js');
	
	
	// unitCost.value = (hourlyRate*hours)/length
	// calc(assembly) = unitCost.value * formula
	
	class Labor extends Material {
	  constructor (props) {
	    super(props);
	    const type = props.laborType;
	    props.hourlyRate = Labor.hourlyRates[type]
	    const parentCalc = this.calc;
	    this.cost = () => this.hourlyRate() * props.hours;
	    if (Labor.hourlyRates[type] === undefined) Labor.types.push(type);
	    Labor.hourlyRate(type, props.hourlyRate);
	
	    const parentToJson = this.toJson;
	  }
	}
	
	
	Labor.defaultRate = 40;
	Labor.hourlyRate = (type, rate) => {
	  rate = Cost.evaluator.eval(new String(rate));
	  if (!Number.isNaN(rate)) Labor.hourlyRates[type] = rate;
	  return Labor.hourlyRates[type] || Labor.defaultRate;
	}
	Labor.hourlyRates = {};
	Labor.types = [];
	Labor.explanation = `Cost to be calculated hourly`;
	
	module.exports = Labor
	
});


RequireJS.addFunction('./app-src/cost/types/material.js',
function (require, exports, module) {
	

	
	const Cost = require('../cost.js');
	const Assembly = require('../../objects/assembly/assembly.js');
	
	class Material extends Cost {
	  constructor (props) {
	    super(props);
	    props = this.props();
	    props.cost = props.cost / (props.count || 1);
	    const instance = this;
	    Object.getSet(props, 'company', 'formula', 'partNumber',
	                'method', 'length', 'width', 'depth', 'cost');
	
	
	    this.unitCost = (attr) => {
	      const unitCost = Material.configure(instance.method(), instance.cost(),
	        instance.length(), instance.width(), instance.depth());
	      const copy = JSON.parse(JSON.stringify(unitCost));
	      if (attr) return copy[attr];
	      return copy;
	    }
	
	    this.calc = (assemblyOrCount) => {
	      const unitCost = this.unitCost();
	      const formula = this.formula() || unitCost.formula;
	      if (assemblyOrCount instanceof Assembly)
	        return Cost.evaluator.eval(`${unitCost.value}*${formula}`, assemblyOrCount);
	      else if (Number.isFinite(assemblyOrCount))
	        return Cost.evaluator.eval(`${unitCost.value}*${assemblyOrCount}`);
	      else
	        throw new Error('calc argument must be a number or Assembly');
	    }
	  }
	}
	
	Material.methods = {
	  LINEAR_FEET: 'Linear Feet',
	  SQUARE_FEET: 'Square Feet',
	  CUBIC_FEET: 'Cubic Feet',
	  UNIT: 'Unit'
	};
	
	Material.methodList = Object.values(Material.methods);
	
	
	Material.configure = (method, cost, length, width, depth) => {
	  const unitCost = {};
	  switch (method) {
	    case Material.methods.LINEAR_FEET:
	      const perLinearInch = Cost.evaluator.eval(`${cost}/${length}`);
	      unitCost.name = 'Linear Inch';
	      unitCost.value = perLinearInch;
	      unitCost.formula = 'l';
	      return unitCost;
	    case Material.methods.SQUARE_FEET:
	      const perSquareInch = Cost.evaluator.eval(`${cost}/(${length}*${width})`);
	      unitCost.name = 'Square Inch';
	      unitCost.value = perSquareInch;
	      unitCost.formula = 'l*w';
	      return unitCost;
	    case Material.methods.CUBIC_FEET:
	      const perCubicInch = Cost.evaluator.eval(`${cost}/(${length}*${width}*${depth})`);
	      unitCost.name = 'Cubic Inch';
	      unitCost.value = perCubicInch;
	      unitCost.formula = 'l*w*d';
	      return unitCost;
	    case Material.methods.UNIT:
	      unitCost.name = 'Unit';
	      unitCost.value = cost;
	      return unitCost;
	    default:
	      throw new Error('wtf');
	      unitCost.name = 'Unknown';
	      unitCost = -0.01;
	      formula = -0.01;
	      return unitCost;
	  }
	};
	
	Material.explanation = `Cost to be calculated by number of units or demensions`;
	
	module.exports = Material
	
});


RequireJS.addFunction('./app-src/displays/information/utility-filter.js',
function (require, exports, module) {
	

	
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	
	class UFObj {
	  constructor(order) {
	    class Row {
	      constructor(groupName, assembly, index) {
	        this.groupName = groupName;
	        this.type = assembly.constructor.name;
	        const dems = assembly.position().demension();
	        dems.y = new Measurement(dems.y).display();
	        dems.x = new Measurement(dems.x).display();
	        dems.z = new Measurement(dems.z).display();
	        this.size = `${dems.y} x ${dems.x} x ${dems.z}`;
	        this.quantity = 1;
	        this.cost = '$0';
	        this.notes = assembly.notes || '';
	      }
	    }
	    const cabinets = [];
	    const obj = [];
	    Object.values(order.rooms).forEach((room, rIndex) => room.groups.forEach((group, gIndex) => {
	      group.cabinets.forEach((cabinet, index) => {
	        const cabinetId = `${rIndex+1}-${gIndex+1}-${index+1}`;
	        cabinet.getParts().forEach((part) => {
	          const row = new Row(group.name(), part, cabinetId);
	          if (obj[row.size] === undefined) obj[row.size] = row;
	          else {
	            obj[row.size].quantity++;
	          }
	        });
	      });
	    }));
	    return Object.values(obj);
	  }
	}
	module.exports = UFObj
	
});


RequireJS.addFunction('./app-src/displays/managers/cost.js',
function (require, exports, module) {
	

	
	const CostTree = require('../../cost/cost-tree.js');
	const Assembly = require('../../objects/assembly/assembly.js');
	const du = require('../../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../../public/js/utils/$t.js');
	const DecisionInputTree = require('../../../../../public/js/utils/input/decision/decision.js');
	const Select = require('../../../../../public/js/utils/input/styles/select');
	const Input = require('../../../../../public/js/utils/input/input');
	const RelationInput = require('../../../../../public/js/utils/input/styles/select/relation');
	const Inputs = require('../../input/inputs.js');
	const RadioDisplay = require('../../display-utils/radio-display.js');
	
	class CostManager {
	  constructor(id, name) {
	    const costTree = new CostTree();
	    this.root = () => costTree.root();
	    this.update = () => {
	      const html = CostManager.mainTemplate.render(this);
	      du.find(`#${id}`).innerHTML = html;
	    }
	    this.nodeInputHtml = () => CostManager.nodeInput().payload().html();
	    this.headHtml = (node) =>
	        CostManager.headTemplate.render({node, CostManager: this});
	    this.bodyHtml = (node) =>
	        CostManager.bodyTemplate.render({node, CostManager: this});
	    this.loadPoint = () => console.log('load');
	    this.savePoint = () => console.log('save');
	    this.fromJson = () => {};
	    this.update();
	  }
	}
	
	CostManager.mainTemplate = new $t('managers/cost/main');
	CostManager.headTemplate = new $t('managers/cost/head');
	CostManager.bodyTemplate = new $t('managers/cost/body');
	CostManager.propertySelectTemplate = new $t('managers/cost/property-select');
	CostManager.costInputTree = (costTypes, objId, onUpdate) => {
	  const logicTree = new LogicTree();
	  return logicTree;
	}
	CostManager.nodeInput = () => {
	  const dit = new DecisionInputTree();
	  const typeSelect = new Select({
	    name: 'type',
	    list: CostTree.types,
	    value: CostTree.types[0]
	  });
	  const selectorType = new Select({
	    name: 'selectorType',
	    list: ['Manual', 'Auto'],
	    value: 'Manual'
	  });
	  const propertySelector = new Select({
	    name: 'propertySelector',
	    list: CostTree.propertyList,
	  });
	
	  const accVals = ['select', 'multiselect', 'conditional'];
	  const condtionalPayload = new DecisionInputTree.ValueCondition('type', accVals, [selectorType]);
	  const type = dit.branch('Node', [Inputs('name'), typeSelect]);
	  const selectType = type.conditional('selectorType', condtionalPayload);
	  const payload = [Inputs('formula'), propertySelector, RelationInput.selector];
	  const condtionalPayload2 = new DecisionInputTree.ValueCondition('selectorType', 'Auto', payload);
	  selectType.conditional('formula', condtionalPayload2);
	  return dit;
	}
	new RadioDisplay('cost-tree', 'radio-id');
	
	new CostManager('cost-manager', 'cost');
	
	function abbriviation(group) {
	  return Assembly.classes[group] ? Assembly.classes[group].abbriviation : 'nope';
	}
	const scope = {groups: CostTree.propertyList, abbriviation};
	// du.id('property-select-cnt').innerHTML =
	//       CostManager.propertySelectTemplate.render(scope);
	module.exports = CostManager
	
});


RequireJS.addFunction('./app-src/displays/managers/template.js',
function (require, exports, module) {
	

	const FunctionCache = require('../../../../../public/js/utils/services/function-cache.js');
	
	const Assembly = require('../../objects/assembly/assembly.js');
	const Input = require('../../../../../public/js/utils/input/input.js');
	const Select = require('../../../../../public/js/utils/input/styles/select.js');
	const MeasurementInput = require('../../../../../public/js/utils/input/styles/measurement.js');
	const DecisionInputTree = require('../../../../../public/js/utils/input/decision/decision.js');
	const Lookup = require('../../../../../public/js/utils/object/lookup.js');
	const Inputs = require('../../input/inputs.js');
	const CabinetTemplate = require('../../config/cabinet-template.js');
	const ExpandableList = require('../../../../../public/js/utils/lists/expandable-list.js');
	const $t = require('../../../../../public/js/utils/$t.js');
	const du = require('../../../../../public/js/utils/dom-utils.js');
	const RadioDisplay = require('../../display-utils/radio-display.js');
	const Bind = require('../../../../../public/js/utils/input/bind.js');
	const Joint = require('../../objects/joint/joint.js');
	const StringMathEvaluator = require('../../../../../public/js/utils/string-math-evaluator.js');
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	const ThreeView = require('../three-view.js');
	const Layout2D = require('../../objects/layout.js');
	const Draw2D = require('../../two-d/draw.js');
	const Vertex3D = require('../../three-d/objects/vertex');
	const Snap2d = require('../../two-d/objects/snap');
	const PropertyConfig = require('../../config/property/config.js');
	const cabinetBuildConfig = require('../../../public/json/cabinets.json');
	const Pattern = require('../../division-patterns.js');
	const Handle = require('../../objects/assembly/assemblies/hardware/pull.js');
	const LayouSketch = require('../layout-sketch');
	const CSG = require('../../../public/js/3d-modeling/csg.js');
	const approximate = require('../../../../../public/js/utils/approximate').new(10);
	
	let template;
	let modifyingOpening = false;
	const sectionState = {
	  style: 'Overlay',
	  vertical: false,
	  innerOouter: 'true',
	  xOyOz: 'x',
	  index: 0,
	  count: 0,
	};
	
	const layoutSketch = new LayouSketch('layout-sketch-cnt');
	function updateState(elem) {
	  const opening = ExpandableList.get(elem);
	  sectionState.id = opening.id;
	  const attr = elem.name.replace(/(.*?)-.*/, '$1');
	  if (attr === 'index') sectionState[attr] = Number.parseInt(elem.value);
	  else sectionState[attr] = elem.value;
	}
	
	function updateConfig(elem) {
	  const value = elem.type === 'checkbox' ? elem.checked : elem.value;
	  sectionState[elem.name] = value;
	}
	
	du.on.match('keydown', '#template-divider-count-input', (elem,ev) => ev.preventDefault());
	du.on.match('change', '.border-location-cnt>input', updateState);
	du.on.match('change', '.section-properties>input', updateConfig);
	
	function applyDividers(cabinet) {
	  for (let index = 0; index < cabinet.openings.length; index++) {
	    const divideCount = Number.parseInt(sectionState.count);
	    const opening = cabinet.openings[index];
	    opening.vertical(sectionState.vertical);
	    opening.divide(divideCount);
	    const sectionType = sectionState.sectionType;
	    if (sectionType) {
	      for (let si = 0; si < opening.sections.length; si++) {
	        opening.sections[si].setSection(sectionType);
	      }
	    }
	    const coords = opening.update();
	  }
	}
	
	function applyTestConfiguration(cabinet) {
	  cabinet.width(60*2.54);
	
	  const opening = cabinet.openings[0];
	  opening.divide(2);
	  opening.sectionProperties().pattern('bab').value('a', 30*2.54);
	  const left = opening.sections[0];
	  const center = opening.sections[1];
	  const right = opening.sections[2];
	  const a = 6*2.54
	
	  left.divide(2);
	  left.vertical(false);
	  left.sections[0].setSection("DrawerSection");
	  left.sections[1].setSection("DrawerSection");
	  left.sections[2].setSection("DrawerSection");
	  left.pattern('abb').value('a', a);
	
	  center.divide(1);
	  center.vertical(false);
	  center.sections[1].setSection('DualDoorSection');
	  center.pattern('ab').value('a', a);
	  const centerTop = center.sections[0];
	
	  centerTop.divide(2);
	  centerTop.sections[0].setSection("DoorSection");
	  centerTop.sections[1].setSection("FalseFrontSection");
	  centerTop.sections[2].setSection("DoorSection");
	  centerTop.pattern('ztz').value('t', 15*2.54);
	  centerTop.sections[0].cover().pull().location(Handle.location.LEFT);
	  centerTop.sections[2].cover().pull().location(Handle.location.RIGHT);
	
	  right.divide(2);
	  right.vertical(false);
	  right.sections[0].setSection("DrawerSection");
	  right.sections[1].setSection("DrawerSection");
	  right.sections[2].setSection("DrawerSection");
	  right.pattern('abb').value('a', a);
	}
	
	FunctionCache.disable();
	function getCabinet(elem) {
	  const templateBody = du.find.closest(`.template-body[template-id]`, elem);
	  const template = CabinetTemplate.get(templateBody.getAttribute('template-id'), templateBody);
	  const height = new Measurement(templateBody.children[4].value, true).decimal();
	  const width = new Measurement(templateBody.children[3].value, true).decimal();
	  const thickness = new Measurement(templateBody.children[5].value, true).decimal();
	  const cabinet = template.getCabinet(height, width, thickness);
	  cabinet.propertyConfig().set(sectionState.style);
	
	  if (sectionState.testDividers) applyTestConfiguration(cabinet);
	  else applyDividers(cabinet);
	  layoutSketch.cabinet(cabinet);
	  console.log(`Cabinet Demesions: ${cabinet.width()} !== ${cabinet.eval('c.w')} x ${cabinet.length()} x ${cabinet.thickness()}`)
	  return cabinet;
	}
	
	const toDisplay = (value) =>  new Measurement(value).display();
	const threeView = new ThreeView();
	du.on.match('click', '#template-list-TemplateManager_template-manager', (elem) =>
	  du.move.inFront(elem));
	du.on.match('click', `#${threeView.id()}>.three-view-two-d-cnt>.three-view-canvases-cnt`, (elem) =>
	  du.move.inFront(elem));
	
	const containerClasses = {
	  values: `template-values`,
	  subassemblies: `template-subassemblies`,
	  joints: `template-joints`,
	  dividerJoint: `template-divider-joint`,
	  openings: `template-openings`
	};
	
	function resetHeaderErrors() {
	  const containers = du.find.all('.cabinet-template-input-cnt');
	  containers.forEach((cnt) => {
	    const headers = du.find.downAll('.expand-header', cnt);
	    headers.forEach((h) => du.class.remove(h, 'error'))
	  });
	}
	
	function setHeaderErrors(elem) {
	  const firstHeader = du.find.closest('.expand-header', elem);
	  const secondHeader = du.find.up('.cabinet-template-input-cnt', firstHeader).children[0];
	  du.class.add(firstHeader, 'error');
	  du.class.add(secondHeader, 'error');
	}
	
	function updateCss(elem, isValid, errorMsg) {
	  if (elem) {
	    if (isValid) {
	      du.class.remove(elem, 'error');
	      elem.setAttribute('error-msg', '');
	    } else {
	      du.class.add(elem, 'error');
	      elem.setAttribute('error-msg', errorMsg);
	      setHeaderErrors(elem);
	    }
	  }
	}
	
	const varReg = /^[$_a-zA-Z][$_a-zA-Z0-9\.]*$/;
	const variableNameCheck = (elem) => updateCss(elem, elem.value.match(varReg), `Illegal characters: ${varReg}`);
	const positiveValueCheck = (elem) => updateCss(elem, Number.parseFloat(elem.value) > 0, 'Value must be positive');
	const partCodeCheck = (template) => (elem) => updateCss(elem, template.validPartCode(elem.value), 'Invalid Part Code');
	
	function openingCodeCheck(template, opening, input) {
	  if (opening._Type === 'location') return true;
	  let count = 0;
	  let errorString = '';
	  if (!template.validPartCode(opening.top)) {count++; (errorString += 'top,');}
	  if (!template.validPartCode(opening.bottom)) {count++; (errorString += 'bottom,');}
	  if (!template.validPartCode(opening.left)) {count++; (errorString += 'left,');}
	  if (!template.validPartCode(opening.right)) {count++; (errorString += 'right,');}
	  if (!template.validPartCode(opening.back)) {count++; (errorString += 'back,');}
	  if (count === 0) updateCss(input, true);
	  else {
	    errorString = errorString.substring(0, errorString.length - 1);
	    if (count === 1) updateCss(input, false, `'${errorString}' part code is invalid (CABINET WILL NOT RENDER)`);
	    else updateCss(input, false, `Multiple part codes are invalid: ${errorString} (CABINET WILL NOT RENDER)`);
	  }
	  return count === 0;
	}
	
	function openingsCodeCheck (template, inputs) {
	  const openings = template.openings();
	  let valid = true;
	  for (let index = 0; index < openings.length; index += 1) {
	    const opening = openings[index];
	    const input = inputs[index];
	    valid &&= openingCodeCheck(template, opening, input)
	  }
	  return valid;
	}
	
	function validateEquations(template, cabinet, valueInput, eqnInput, valueIndex, eqnMap) {
	  let errorString = '';
	  let errorCount = 0;
	  let eqnKeys = Object.keys(eqnMap);
	  for (let index = 0; index < eqnKeys.length; index += 1) {
	    const key = eqnKeys[index];
	    const eqn = eqnMap[key];
	    if (index === valueIndex) {
	      const value = template.evalEqn(eqn, cabinet);
	      if (Number.isNaN(value)) {
	        errorString += `${key},`;
	        errorCount++;
	      } else {
	        const convertCheckBox = valueInput.nextElementSibling;
	        if (convertCheckBox && convertCheckBox.getAttribute('name') === 'convert' &&
	              convertCheckBox.checked) {
	          valueInput.value = new Measurement(value).display();
	        } else {
	          valueInput.value = value;
	        }
	      }
	    } else {
	      if (!template.validateEquation(eqn, cabinet)) {
	        errorString += `${key},`;
	        errorCount++;
	      }
	    }
	  }
	  if (errorCount > 0) {
	    du.class.add(eqnInput, 'error');
	    if (eqnKeys.length > 1) {
	      errorString = errorString.substring(0, errorString.length - 1);
	      updateCss(eqnInput, false, `Errors found within the following equations:${errorString}`);
	    } else {
	      updateCss(eqnInput, false, `Errors found within the equation.`)
	    }
	  } else {
	    du.class.remove(eqnInput, 'error');
	    updateCss(eqnInput, true);
	  }
	}
	
	const valueEqnCheck = (template, cabinet) => (eqnInput) => {
	  const valueInput = du.find.closest('[name="value"]', eqnInput);
	  const name = eqnInput.name;
	  const eqn = eqnInput.value;
	  const eqnMap = {};
	  eqnMap[name] = eqn;
	  validateEquations(template, cabinet, valueInput, eqnInput, 0, eqnMap);
	}
	
	const xyzEqnCheck = (template, cabinet) => (xyzInput) => {
	  const valueInput = du.find.closest('[name="value"]', xyzInput);
	  const index = Number.parseInt(du.find.closest('select', xyzInput).value);
	  const subAssem = ExpandableList.get(xyzInput);
	  const part = cabinet.getAssembly(subAssem.code);
	  const eqns = subAssem[xyzInput.name];
	  const eqnMap = {x: eqns[0], y: eqns[1], z: eqns[2]};
	  validateEquations(template, cabinet, valueInput, xyzInput, index, eqnMap);
	}
	
	function updatePartsDataList() {
	  const partMap = threeView.partMap();
	  if (!partMap) return;
	  const partKeys = Object.keys(partMap);
	  let html = '';
	  for (let index = 0; index < partKeys.length; index += 1) {
	    const id = partKeys[index];
	    const partCode = partMap[id].code;
	    const partName = partMap[id].name;
	    html += `<option value='${partCode}'></option>`;
	  }
	
	  const datalist = du.id('part-list');
	  datalist.innerHTML = html;
	}
	
	function vertexToDisplay(vertex) {
	  const x = new Measurement(vertex.x).display();
	  const y = new Measurement(vertex.y).display();
	  const z = new Measurement(vertex.z).display();
	  return `(${x}, ${y}, ${z})`;
	}
	
	function target(io, i) {
	  const targetIndex = i + (io === 'inner' ? 0 : 4);
	  return (index) => targetIndex === index;
	}
	
	function updateOpenLocationDisplay (opening, elem) {
	  const state = sectionState;
	
	  const io = state.innerOouter === 'true' ? 'inner' : 'outer';
	  const i = state.index;
	  const description = `Current formula describes the ${io} boundry ${state.xOyOz} coordinate of vertex ${state.index}.`;
	  du.find.closest('.opening-location-description-cnt', elem).innerText = description;
	
	  const eqnPoint = opening.coordinates && opening.coordinates[io] && opening.coordinates[io][i];
	
	  if (eqnPoint && elem.name !== 'opening-coordinate-value')
	    du.find.closest('[name="opening-coordinate-value"]', elem).value = eqnPoint[state.xOyOz];
	
	  const cabinet = getCabinet(elem);
	  const coords = cabinet.openings[0].update();
	
	
	  const html = openingPointTemplate.render({display: vertexToDisplay, coords, target: target(io, i)});
	  du.find.closest('.opening-location-value-cnt', elem).innerHTML = html;
	}
	
	const openingPointTemplate = new $t('managers/template/openings/points');
	
	function onOpeningLocationChange(elem) {
	  const opening = ExpandableList.get(elem);
	  // const state = opening.state;
	  // let value = elem.value;
	  // if (value === 'true') value = true;
	  // else if (value === 'false') value = false;
	  // const attr = elem.name.replace(/(.*?)-.*/, '$1');
	  // state[attr] = value;
	
	  updateOpenLocationDisplay(opening, elem);
	}
	
	function onOpeningTypeChange(elem) {
	  const opening = ExpandableList.get(elem);
	  if (opening._Type !== elem.value) {
	    const isLocation = elem.checked;
	    const defaultFunc = isLocation ? 'defaultLocationOpening' : 'defaultPartCodeOpening';
	    const def = CabinetTemplate[defaultFunc]();
	    Object.merge(opening, def, true);
	    opening._Type = isLocation ? 'location' : undefined;
	    du.find.closest('.border-location-cnt', elem).hidden = !isLocation;
	    updateOpeningPartCode(du.find.closest('select', elem));
	  }
	}
	
	du.on.match('change', '.border-location-cnt>input,.border-location-cnt>span>input', onOpeningLocationChange);
	du.on.match('change', '.opening-type-selector', onOpeningTypeChange);
	
	function updateOpeningPoints(template, cabinet) {
	  const threeDModel = threeView.threeDModel();
	  if (threeDModel) {
	    threeDModel.removeAllExtraObjects();
	    const openings = cabinet.openings;
	    for (let index = 0; index < openings.length; index++) {
	      const opening = openings[index];
	      const size = modifyingOpening ? 1 : .25;
	      const state = sectionState;
	      const i = state.index;
	      const vertexColor = (io, i) => io !== state.innerOouter ? 'black' :
	            (modifyingOpening && i === state.index ? 'lime' : 'white');
	
	      const vertexSize = (io) => modifyingOpening && io === state.innerOouter ? size*2 : size;
	
	      const coords = opening.update();
	      threeDModel.addVertex(coords.inner[0], vertexSize('true'), vertexColor('true', '0'));
	      threeDModel.addVertex(coords.inner[1], vertexSize('true'), vertexColor('true', '1'));
	      threeDModel.addVertex(coords.inner[2], vertexSize('true'), vertexColor('true', '2'));
	      threeDModel.addVertex(coords.inner[3], vertexSize('true'), vertexColor('true', '3'));
	
	      threeDModel.addVertex(coords.outer[0], vertexSize('false'), vertexColor('false', '0'));
	      threeDModel.addVertex(coords.outer[1], vertexSize('false'), vertexColor('false', '1'));
	      threeDModel.addVertex(coords.outer[2], vertexSize('false'), vertexColor('false', '2'));
	      threeDModel.addVertex(coords.outer[3], vertexSize('false'), vertexColor('false', '3'));
	    }
	  }
	}
	
	const topView = du.id('three-view-top');
	const leftView = du.id('three-view-left');
	const frongView = du.id('three-view-front');
	function validateOpenTemplate (elem) {
	  const templateBody = du.find('.template-body[template-id]');
	  if (!templateBody || du.is.hidden(templateBody)) return;
	  resetHeaderErrors();
	  const template = CabinetTemplate.get(templateBody.getAttribute('template-id'), templateBody);
	
	  const valueNameInputs = du.find.downAll('input[attr="values"][name="name"]', templateBody);
	  valueNameInputs.forEach(variableNameCheck);
	  const subNameInputs = du.find.downAll('input[attr="subassemblies"][name="name"]', templateBody);
	  subNameInputs.forEach(variableNameCheck);
	  const subCodeInputs = du.find.downAll('input[attr="subassemblies"][name="code"]', templateBody);
	  subCodeInputs.forEach(variableNameCheck);
	
	  const positiveInputs = du.find.downAll('input[name="thickness"],input[name="width"],input[name="height"]', templateBody);
	  positiveInputs.forEach(positiveValueCheck);
	
	  const pcc = partCodeCheck(template);
	  const jointMaleInputs = du.find.downAll('input[attr="joints"][name="malePartCode"]', templateBody);
	  jointMaleInputs.forEach(pcc);
	  const jointFemaleInputs = du.find.downAll('input[attr="joints"][name="femalePartCode"]', templateBody);
	  jointFemaleInputs.forEach(pcc);
	
	  const openingCodeInputs = du.find.downAll('input[attr="openings"][name="partCode"]', templateBody);
	  openingsCodeCheck(template, openingCodeInputs);
	
	  try {
	    const cabinet = getCabinet(templateBody);
	
	    const depthInputs = du.find.downAll('[name=depth]', templateBody);
	    depthInputs.forEach(valueEqnCheck(template, cabinet));
	    const valueEqnInputs = du.find.downAll('input[attr="values"][name="eqn"]', templateBody);
	    valueEqnInputs.forEach(valueEqnCheck(template, cabinet));
	    const subDemInputs = du.find.downAll('input[attr="subassemblies"][name="demensions"]', templateBody);
	    subDemInputs.forEach(xyzEqnCheck(template, cabinet));
	    const subCenterInputs = du.find.downAll('input[attr="subassemblies"][name="center"]', templateBody);
	    subCenterInputs.forEach(xyzEqnCheck(template, cabinet));
	    const subRotInputs = du.find.downAll('input[attr="subassemblies"][name="rotation"]', templateBody);
	    subRotInputs.forEach(xyzEqnCheck(template, cabinet));
	    updateOpeningPoints(template, cabinet);
	    threeView.update(cabinet);
	    setTimeout(updatePartsDataList, 500);
	  } catch (e) {
	    console.log(e);
	  }
	
	
	}
	
	function getEqn(select, values) {
	  return values && values[select.value()];
	}
	
	const depthValidation = (measurment) =>
	        measurment.decimal() > 0;
	
	function getJointInputTree(func, joint, dividerJoint) {
	  joint.type ||= 'Butt';
	  const selectType = new Select({
	    name: 'type',
	    list: Object.keys(Joint.types),
	    class: 'template-select',
	    value: joint.type
	  });
	
	  const centerOffsetInput = new Select({
	    name: 'centerAxis',
	    list: ['+x', '+y', '+z', '-x', '-y', '-z'],
	    value: joint.centerAxis
	  });
	  const demensionOffsetInput = new Select({
	    name: 'demensionAxis',
	    list: ['x', 'y', 'z'],
	    value: joint.demensionAxis
	  });
	
	  const depthInput = new Input({
	    name: 'maleOffset',
	    value: joint.maleOffset
	  });
	
	  const dadoInputs = dividerJoint ? [depthInput] : [depthInput, centerOffsetInput, demensionOffsetInput];
	
	  const dit = new DecisionInputTree(undefined, {noSubmission: true});
	  const type = dit.branch('Type', [selectType]);
	  const condtionalPayload = new DecisionInputTree.ValueCondition('type', 'Dado', dadoInputs);
	  type.conditional('dado', condtionalPayload);
	  dit.onChange(func);
	  return dit;
	}
	
	let lastDepth;
	const jointOnChange = (vals, dit) => {
	  const selectId = dit.payload().inputArray[0].id();
	  const joint = ExpandableList.get(du.id(selectId));
	  joint.type = vals.type;
	  lastDepth = vals.maleOffset || lastDepth;
	  joint.maleOffset = lastDepth || undefined;
	  const depthInput = dit.children()[0].payload().inputArray[0];
	  // depthInput.updateDisplay();
	  joint.demensionAxis = vals.demensionAxis || undefined;
	  joint.centerAxis = vals.centerAxis || undefined;
	  console.log(vals);
	}
	
	function getTypeInput(obj) {
	  return new Select({
	    name: 'type',
	    value: obj.type,
	    class: 'template-input',
	    list: Object.keys(Assembly.components),
	    inline: true
	  });
	}
	
	function getXyzSelect(label) {
	  return new Select({
	    label,
	    name: 'xyz',
	    list: {'0': 'X', '1': 'Y', '2':'Z'},
	    inline: true
	  });
	}
	
	function getWhdSelect(label) {
	  return new Select({
	    label,
	    name: 'xyz',
	    list: {'0': 'W', '1': 'H', '2':'D'},
	    inline: true
	  });
	}
	
	function getOpeningLocationSelect() {
	  return new Select({
	    name: 'openingLocation',
	    list: ['top', 'bottom', 'left', 'right', 'back'],
	    inline: true
	  });
	}
	
	function getJoint(obj) {
	  return {obj, jointInput: getJointInputTree(jointOnChange, obj).payload()};
	}
	function getSubassembly(obj) {
	  return {typeInput:  getTypeInput(obj),
	          centerXyzSelect: getXyzSelect('Center'),
	          demensionXyzSelect: getWhdSelect('Demension'),
	          rotationXyzSelect: getXyzSelect('Rotation'),
	          getEqn, obj
	        };
	}
	
	function getOpening(obj) {
	  return {obj, select: getOpeningLocationSelect(), state: sectionState};
	}
	
	const scopes = {};
	function getScope(type, obj) {
	  obj.id = obj.id || String.random();
	  if (scopes[obj.id]) return scopes[obj.id];
	  switch (type) {
	    case 'joints':
	      scopes[obj.id] = getJoint(obj);
	      break;
	    case 'subassemblies':
	      scopes[obj.id] = getSubassembly(obj);
	      break;
	    case 'openings':
	      scopes[obj.id] = getOpening(obj);
	      break;
	    default:
	      scopes[obj.id] = {obj};
	  }
	  return scopes[obj.id];
	}
	
	const getObjects = {
	    subassemblies: () => (      {
	      type: "Panel",
	      center: [0,0,0],
	      demensions: [1,1,1],
	      rotation: [0,0,0],
	      include: 'All'
	    })
	}
	
	function updateTemplateDisplay() {
	  const managerElems = du.find.all('[template-manager]');
	  for (let index = 0; index < managerElems.length; index += 1) {
	    const templateManagerId = managerElems[index].getAttribute('template-manager');
	    const templateManager =TemplateManager.get(templateManagerId);
	    templateManager.update();
	  }
	}
	
	
	function addExpandable(template, type) {
	  const containerClass = containerClasses[type];
	  let parentSelector = `[template-id='${template.id()}']>.${containerClass}`;
	  TemplateManager.headTemplate[type] ||= new $t(`managers/template/${type.toKebab()}/head`);
	  TemplateManager.bodyTemplate[type] = TemplateManager.bodyTemplate[type] === undefined ?
	                    new $t(`managers/template/${type.toKebab()}/body`) : TemplateManager.bodyTemplate[type];
	  let getHeader = (obj) => TemplateManager.headTemplate[type].render(getScope(type, obj));
	  let getBody = TemplateManager.bodyTemplate[type] ? ((obj) => TemplateManager.bodyTemplate[type].render(getScope(type, obj))) : undefined;
	  const expListProps = {
	    idAttribute: 'name',
	    list: template[type](),
	    getObject: getObjects[type],
	    renderBodyOnOpen: false,
	    parentSelector, getHeader, getBody,
	    listElemLable: type.toSentance(),
	  };
	  const expandList = new ExpandableList(expListProps);
	  expandList.afterRemoval(updateTemplateDisplay);
	  return expandList;
	}
	
	class TemplateManager extends Lookup {
	  constructor(id) {
	    super(id);
	    const parentId = `template-list-${this.id()}`;
	    this.parentId = () => parentId;
	    let currentTemplate;
	    const parentSelector = `#${parentId}`;
	    const dividerJointChange = (template) => (vals) => {
	      template.dividerJoint(vals);
	    }
	    const templateShapeInput = (template) => TemplateManager.templateShapeInput(template.shape());
	    const dividerJointInput = (template) =>
	      getJointInputTree(dividerJointChange(template), template.dividerJoint(), true).payload();
	
	    const containerSelector = (template, containerClass) => `[template-id="${template.id()}"]>.${containerClass}`;
	
	    const getHeader = (template) =>
	      TemplateManager.headTemplate.render({template, TemplateManager: this});
	    const getBody = (template) => {
	      currentTemplate = template;
	      setTimeout(() => {
	        updateExpandables(template);
	      }, 100);
	      setTimeout(() => {
	        validateOpenTemplate(du.id(parentId));
	      }, 1000);
	      return TemplateManager.bodyTemplate.render({template, TemplateManager: this,
	        containerClasses, dividerJointInput: dividerJointInput(template), toDisplay,
	        templateShapeInput: templateShapeInput(template)});
	      }
	
	    this.sectionState = sectionState;
	    const expandables = {};
	    function initTemplate(template) {
	      const list = [];
	      expandables[template.id()] = list;
	      return () => {
	        list.push(addExpandable(template, 'values'));
	        list.push(addExpandable(template, 'subassemblies'));
	        list.push(addExpandable(template, 'joints'));
	        list.push(addExpandable(template, 'openings', true));
	      };
	    }
	
	    function updateExpandables(template) {
	      template ||= currentTemplate;
	      if (template === undefined) return;
	      if (!expandables[template.id()]) initTemplate(template)();
	      expandables[template.id()].forEach((e) => e.refresh());
	    }
	    this.updateExpandables = updateExpandables;
	
	    const getObject = (values) => {
	      const cabTemp = new CabinetTemplate(values.name);
	      initTemplate(cabTemp)();
	      return cabTemp;
	    }
	
	    this.active = () => expandList.active();
	    const expListProps = {
	      list: CabinetTemplate.defaultList(),
	      inputTree: TemplateManager.inputTree(),
	      parentSelector, getHeader, getBody, getObject,
	      listElemLable: 'Template',
	      type: 'sidebar'
	    };
	    setTimeout(initTemplate(expListProps.list[0]), 200);
	    const expandList = new ExpandableList(expListProps);
	
	    this.update = () => {
	      expandList.refresh();
	    }
	    this.loadPoint = () => console.log('load');
	    this.savePoint = () => console.log('save');
	    this.fromJson = () => {};
	    const html = TemplateManager.mainTemplate.render(this);
	    du.find(`#${id}`).innerHTML = html;
	  }
	}
	
	const radioDisplay = new RadioDisplay('cabinet-template-input-cnt', 'template-id');
	radioDisplay.afterSwitch(function (header){
	  const coordinateInput = du.find.closest('[name="opening-coordinate-value"]', header);
	  const opening = ExpandableList.get(coordinateInput);
	  if (opening && opening._Type === 'location') {
	    const state = opening.state;
	    const io = state.innerOouter ? 'inner' : 'outer';
	    coordinateInput.value = opening.coordinates[io][state.index][state.xOyOz];
	  }
	
	  console.log(opening);
	});
	
	TemplateManager.inputTree = () => {
	  const dit = new DecisionInputTree();
	  dit.leaf('Template Name', [Inputs('name')]);
	  return dit;
	}
	
	TemplateManager.templateShapeInput = (value) => {
	  return new Select({
	      name: 'templateShape',
	      list: Object.keys(Snap2d.get),
	      class: 'template-shape-input',
	      value: value
	    });
	};
	
	radioDisplay.afterSwitch((elem, detail) => {
	  const newState = detail.targetHeader.innerText === 'Openings';
	  const updateModel = newState !== modifyingOpening;
	  modifyingOpening = newState;
	  updateModel && validateOpenTemplate(detail.targetHeader);
	});
	
	TemplateManager.mainTemplate = new $t('managers/template/main');
	TemplateManager.headTemplate = new $t('managers/template/head');
	TemplateManager.bodyTemplate = new $t('managers/template/body');
	TemplateManager.bodyTemplate.values = false;
	new TemplateManager('template-manager', 'template');
	
	function updateValuesTemplate(elem, template) {
	  const nameInput = du.find.closest('[name="name"]', elem);
	  const name = nameInput.value;
	  const eqn = du.find.closest('[name="eqn"]', elem).value;
	  const valueObj = ExpandableList.get(elem);
	  valueObj.key = name;
	  valueObj.eqn = eqn;
	  return true
	}
	
	function updateSubassembliesTemplate(elem, template) {
	  const nameInput = du.find.closest('[name="name"]', elem);
	  const type = du.find.closest('[name="type"]', elem).value;
	  const name = `${type}.${nameInput.value.toDot()}`;
	  const subAssem = ExpandableList.get(elem);
	  subAssem.name = nameInput.value;
	  if (elem.name === 'name') return;
	  if (elem.name === 'center' || elem.name === 'demensions' || elem.name === 'rotation') {
	    const index = du.find.closest('[name="xyz"]', elem).value;
	    const eqn = elem.value;
	    if (subAssem[elem.name] === undefined) subAssem[elem.name] = [];
	    subAssem[elem.name][index] = eqn;
	  } else if (elem.name !== 'name') {
	    subAssem[elem.name] = elem.value;
	  }
	}
	
	function switchEqn(elem) {
	  const nameInput = du.find.closest('[name="name"]', elem);
	  const type = du.find.closest('[name="type"]', elem).value;
	  const name = `${type}.${nameInput.value.toDot()}`;
	  const subAssem = ExpandableList.get(elem);
	  if (subAssem) {
	    const eqnInput = du.find.closest('input', elem);
	    const index = elem.value;
	    if (subAssem[eqnInput.name] === undefined) subAssem[eqnInput.name] = [];
	    const value = subAssem[eqnInput.name][index];
	    eqnInput.value = value === undefined ? '' : value;
	  }
	}
	
	function updateOpeningsTemplate(elem, template) {
	  const partCode = elem.value;
	  const attr = du.find.closest('select', elem).value;
	  const listElem = ExpandableList.get(elem);
	  listElem[attr] = elem.value;
	  console.log(ExpandableList.get(elem,1).toJson());
	}
	
	function updateViewShape(elem) {
	  const templateId = du.find.up('[template-id]', elem).getAttribute('template-id');
	  const template = CabinetTemplate.get(templateId);
	  template.shape(elem.value);
	}
	
	function updateJointPartCode(elem) {
	  const attr = elem.name;
	  const listElem = ExpandableList.get(elem);
	  listElem[attr] = elem.value;
	}
	
	function updateOpeningPartCode(elem) {
	  const attr = elem.value;
	  const opening = ExpandableList.get(elem);
	  const partCodeInput = du.find.closest('input', elem);
	  partCodeInput.value = opening[attr] || '';
	  updateOpenLocationDisplay(opening, elem);
	}
	
	function updateTemplate(elem, template) {
	  const attr = du.find.closest('[attr]', elem).getAttribute('attr');
	  switch (attr) {
	    case 'values': return updateValuesTemplate(elem, template);
	    case 'subassemblies': return updateSubassembliesTemplate(elem, template);
	    case 'openings': return updateOpeningsTemplate(elem, template);
	
	    default:
	
	  }
	}
	
	function updateInclude(elem) {
	  const subAssem = ExpandableList.get(elem);;
	  subAssem.include = elem.value;
	  console.log(subAssem);
	}
	
	du.on.match('change', '.template-include', updateInclude);
	du.on.match('change', '.opening-part-code-input', updateOpeningsTemplate);
	du.on.match('change', '.template-shape-input', updateViewShape);
	du.on.match('change', '[name="xyz"]', switchEqn);
	du.on.match('change', '[name="openingLocation"]', updateOpeningPartCode);
	du.on.match('change', '.template-input[name="malePartCode"],.template-input[name="femalePartCode"]', updateJointPartCode);
	du.on.match('click', '.copy-template', (elem) => {
	  const templateId = du.find.up('[template-id]', elem).getAttribute('template-id');
	  const template = CabinetTemplate.get(templateId);
	  let jsonStr = JSON.stringify(template.toJson(), null, 2);
	  jsonStr = jsonStr.replace(/.*"id":.*($|,)/g, '');
	  du.copy(jsonStr);
	});
	
	du.on.match('click', '.paste-template', (elem) => {
	  navigator.clipboard.readText()
	  .then(text => {
	    try {
	      const obj = Object.fromJson(JSON.parse(text));
	      if (!(obj instanceof CabinetTemplate)) throw new Error(`Json is of type ${obj.constructor.name}`);
	      const templateId = du.find.up('[template-id]', elem).getAttribute('template-id');
	      const template = CabinetTemplate.get(templateId);
	      template.fromJson(obj.toJson());
	      const templateManagerId = du.find.up('[template-manager]', elem).getAttribute('template-manager');
	      const templateManager =TemplateManager.get(templateManagerId);
	      templateManager.update();
	    } catch (e) {
	      alert('clipboard does not contain a valid CabinetTemplate');
	    }
	  })
	  .catch(err => {
	    console.error('Failed to read clipboard contents: ', err);
	  });
	});
	
	du.on.match('change', '.template-input', function (elem) {
	  const templateId = du.find.up('[template-id]', elem).getAttribute('template-id');
	  template = CabinetTemplate.get(templateId);
	  updateTemplate(elem, template);
	});
	
	du.on.match('change', 'input,select',   () => setTimeout(validateOpenTemplate, 0));
	
	
	module.exports = TemplateManager
	
});


RequireJS.addFunction('./app-src/objects/assembly/assembly.js',
function (require, exports, module) {
	

	
	const StringMathEvaluator = require('../../../../../public/js/utils/string-math-evaluator.js');
	const Position = require('../../position.js');
	const getDefaultSize = require('../../utils.js').getDefaultSize;
	const KeyValue = require('../../../../../public/js/utils/object/key-value.js');
	
	const valueOfunc = (valOfunc) => (typeof valOfunc) === 'function' ? valOfunc() : valOfunc;
	
	class Assembly extends KeyValue {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig, parent) {
	    super({childrenAttribute: 'subassemblies', parentAttribute: 'parentAssembly', object: true});
	
	    const instance = this;
	    let group;
	    const temporaryInitialVals = {parentAssembly: parent, _TEMPORARY: true};
	    const initialVals = {
	      part: true,
	      included: true,
	      centerConfig, demensionConfig, rotationConfig, partCode, partName,
	      propertyId: undefined,
	    }
	    const subAssems = this.subassemblies;
	    Object.getSet(this, initialVals, 'values', 'subassemblies', 'joints');
	    this.subassemblies = subAssems;
	    Object.getSet(this, temporaryInitialVals);
	    this.path = () => `${this.constructor.name}.${partName}`.toDot();
	
	    if ((typeof centerConfig) === 'function') this.centerConfig = centerConfig;
	    else this.centerConfig = centerConfig
	    if ((typeof demensionConfig) === 'function') this.demensionConfig = demensionConfig;
	    else this.demensionConfig = demensionConfig
	    if ((typeof rotationConfig) === 'function') this.rotationConfig = rotationConfig;
	    else this.rotationConfig = rotationConfig
	
	    const parentIncluded = this.included;
	
	    this.included = (value) => {
	        value = parentIncluded(value);
	        if ((typeof value) === 'string') return  group.propertyConfig(value);
	        switch (value) {
	          case true: return true;
	          case false: return false;
	          default: return true;
	        }
	    }
	
	    function getValueSmeFormatter(path) {
	      const split = path.split('.');
	      let attr = split[0];
	      let objIdStr;
	      if (split.length > 2) {
	      }
	      if (split.length > 1) {
	        objIdStr = split[0];
	        attr = split.slice(1).join('.');
	      }
	
	      let obj;
	      if (objIdStr === undefined) {
	        obj = instance;
	      } else {
	        obj = instance.getAssembly(objIdStr);
	      }
	      const returnVal = Assembly.resolveAttr(obj, attr);
	      return returnVal;
	    }
	    const sme = new StringMathEvaluator({Math}, getValueSmeFormatter);
	
	    // KeyValue setup
	    const funcReg = /length|width|thickness/;
	    this.value.addCustomFunction((key, value) => key.match(funcReg) ? this[code](value) : undefined)
	    this.value.evaluators.string = (value) => sme.eval(value, this);
	    this.value.defaultFunction = (key) => this.propertyConfig(this.constructor.name, key);
	
	    this.eval = (eqn) => sme.eval(eqn, this);
	    this.evalObject = (obj) => sme.evalObject(obj, this);
	
	    this.group = (g) => {
	      if (g) group = g;
	      return group;
	    }
	    this.propertyConfig = (one, two) => {
	      const parent = this.parentAssembly();
	      if (parent instanceof Assembly) return parent.propertyConfig(one, two);
	      const group = this.group();
	      if (group) {
	        if (one) return group.propertyConfig(one, two);
	        return group.propertyConfig;
	      }
	    }
	
	    this.getAssembly = (partCode, callingAssem) => {
	      if (callingAssem === this) return undefined;
	      if (this.partCode() === partCode) return this;
	      if (this.subassemblies[partCode]) return this.subassemblies[partCode];
	      if (callingAssem !== undefined) {
	        const children = Object.values(this.subassemblies);
	        for (let index = 0; index < children.length; index += 1) {
	          const assem = children[index].getAssembly(partCode, this);
	          if (assem !== undefined) return assem;
	        }
	      }
	      if (this.parentAssembly() !== undefined && this.parentAssembly() !== callingAssem)
	        return this.parentAssembly().getAssembly(partCode, this);
	      return undefined;
	    }
	    let position = new Position(this, sme);
	    this.position = () => position;
	    this.updatePosition = () => position = new Position(this, sme);
	    this.joints = [];
	    this.values = {};
	    this.rootAssembly = () => {
	      let currAssem = this;
	      while (currAssem.parentAssembly() !== undefined) currAssem = currAssem.parentAssembly();
	      return currAssem;
	    }
	    this.getJoints = (pc) => {
	      const root = this.getRoot();
	      if (root !== this) return root.getJoints(pc || partCode);
	      pc = pc || partCode;
	      const assemList = this.getSubassemblies();
	      let jointList = [].concat(this.joints);
	      assemList.forEach((assem) => jointList = jointList.concat(assem.joints));
	      let joints = {male: [], female: []};
	      jointList.forEach((joint) => {
	        if (joint.malePartCode() === pc) {
	          joints.male.push(joint);
	        } else if (joint.femalePartCode() === pc) {
	          joints.female.push(joint);
	        }
	      });
	      return joints;
	    }
	    function initObj(value) {
	      const obj = {};
	      for (let index = 1; index < arguments.length; index += 1) {
	        obj[arguments[index]] = value;
	      }
	      return obj;
	    }
	
	
	    this.setSubassemblies = (assemblies) => {
	      this.subassemblies = {};
	      assemblies.forEach((assem) => this.subassemblies[assem.partCode()] = assem);
	    };
	
	    this.partsOf = (clazz) => {
	      const parts = this.getRoot().getParts();
	      if (clazz === undefined) return parts;
	      return parts.filter((p) => p instanceof clazz);
	    }
	
	    // TODO: wierd dependency on inherited class.... fix!!!
	    const defaultPartCode = () =>
	      instance.partCode(instance.partCode() || Assembly.partCode(this));
	
	    this.setParentAssembly = (pa) => {
	      this.parentAssembly(pa);
	      defaultPartCode();
	    }
	    this.addSubAssembly = (assembly) => {
	      this.subassemblies[assembly.partCode()] = assembly;
	      // assembly.setParentAssembly(this);
	    }
	
	    this.objId = this.constructor.name;
	
	    this.addJoints = function () {
	      for (let i = 0; i < arguments.length; i += 1) {
	        const joint = arguments[i];
	        this.joints.push(joint);
	        joint.parentAssemblyId(this.id());
	      }
	    }
	
	    this.addSubassemblies = function () {
	      for (let i = 0; i < arguments.length; i += 1) {
	        this.addSubAssembly(arguments[i]);
	      }
	    }
	
	    this.children = () => Object.values(this.subassemblies);
	
	    this.getSubassemblies = () => {
	      let assemblies = [];
	      this.children().forEach((assem) => {
	        assemblies.push(assem);
	        assemblies = assemblies.concat(assem.getSubassemblies());
	      });
	      return assemblies;
	    }
	    this.getParts = () => {
	      return this.getSubassemblies().filter((a) => {
	        if ((typeof a.part) !== 'function') {
	          console.log('party')
	        }
	        return a.part() && a.included()
	      });
	    }
	
	    if (Assembly.idCounters[this.objId] === undefined) {
	      Assembly.idCounters[this.objId] = 0;
	    }
	
	    Assembly.add(this);
	
	    this.width = (value) => position.setDemension('x', value);
	    this.length = (value) => position.setDemension('y', value);
	    this.thickness = (value) => position.setDemension('z', value);
	    defaultPartCode();
	  }
	}
	
	Assembly.list = {};
	Assembly.get = (id) => {
	  const keys = Object.keys(Assembly.list);
	  for (let index = 0; index < keys.length; index += 1) {
	    const assembly = Assembly.list[keys[index]][id];
	    if (assembly !== undefined) return assembly;
	  }
	  return null;
	}
	Assembly.add = (assembly) => {
	  const name = assembly.constructor.name;
	  if (Assembly.list[name] === undefined) Assembly.list[name] = {};
	  Assembly.list[name][assembly.id()] = assembly;
	}
	Assembly.all = () => {
	  const list = [];
	  const keys = Object.keys(Assembly.list);
	  keys.forEach((key) => list.concat(Object.values(Assembly.list[key])));
	  return list;
	}
	
	const positionReg = /^(c|r|d|center|rotation|demension).(x|y|z)$/;
	Assembly.resolveAttr = (assembly, attr) => {
	  if (!(assembly instanceof Assembly)) return undefined;
	  if (attr === 'length' || attr === 'height' || attr === 'h' || attr === 'l') {
	    return assembly.length();
	  } else if (attr === 'w' || attr === 'width') {
	    return assembly.width();
	  } else if (attr === 'depth' || attr === 'thickness' || attr === 'd' || attr === 't') {
	    return assembly.thickness();
	  }
	
	  const positionMatch = attr.match(positionReg);
	  if (positionMatch) {
	    const func = positionMatch[1];
	    const axis = positionMatch[2];
	    if (func === 'r' || func === 'rotation') return assembly.position().rotation(axis);
	    if (func === 'c' || func === 'center') return assembly.position().center(axis);
	    if (func === 'd' || func === 'demension') return assembly.position().demension(axis);
	  }
	  return assembly.value(attr);
	}
	Assembly.fromJson = (assemblyJson) => {
	  const demensionConfig = assemblyJson.demensionConfig;
	  const centerConfig = assemblyJson.centerConfig;
	  const rotationConfig = assemblyJson.rotationConfig;
	  const partCode = assemblyJson.partCode;
	  const partName = assemblyJson.partName;
	  const clazz = Object.class.get(assemblyJson._TYPE);
	  const assembly = new (clazz)(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	  assembly.id(assemblyJson.id);
	  assembly.values = assemblyJson.values;
	  assembly.setParentAssembly(assemblyJson.parent)
	  Object.values(assemblyJson.subassemblies).forEach((json) =>
	    assembly.addSubAssembly(Assembly.class(json._TYPE)
	                              .fromJson(json, assembly)));
	  if (assemblyJson.length) assembly.length(assemblyJson.length);
	  if (assemblyJson.width) assembly.width(assemblyJson.width);
	  if (assemblyJson.thickness) assembly.thickness(assemblyJson.thickness);
	  return assembly;
	}
	
	Assembly.classes = Object.class.object;
	Assembly.new = function (id) {
	  return new (Object.class.get(id))(...Array.from(arguments).slice(1));
	};
	Assembly.class = Object.class.get;
	Assembly.classObj = Object.class.filter;
	
	Assembly.classList = (filterFunc) => Object.values(Assembly.classObj(filterFunc));
	Assembly.classIds = (filterFunc) => Object.keys(Assembly.classObj(filterFunc));
	Assembly.lists = {};
	Assembly.idCounters = {};
	
	Assembly.partCode = (assembly) => {
	  const cabinet = assembly.getAssembly('c');
	  if (cabinet) {
	    const name = assembly.constructor.name;
	    cabinet.partIndex = cabinet.partIndex || 0;
	    return `${assembly.constructor.abbriviation}`;
	  }
	}
	
	module.exports = Assembly
	
});


RequireJS.addFunction('./app-src/objects/assembly/init-assem.js',
function (require, exports, module) {
	
const Assembly = require('./assembly.js');
	new Assembly();
	
	const Cabinet = require('./assemblies/cabinet.js');
	new Cabinet();
	
	const Divider = require('./assemblies/divider.js');
	new Divider();
	
	const DoorCatch = require('./assemblies/door/door-catch.js');
	new DoorCatch();
	
	const Door = require('./assemblies/door/door.js');
	new Door();
	
	const Hinges = require('./assemblies/door/hinges.js');
	new Hinges();
	
	const DrawerBox = require('./assemblies/drawer/drawer-box.js');
	new DrawerBox();
	
	const DrawerFront = require('./assemblies/drawer/drawer-front.js');
	new DrawerFront();
	
	const Guides = require('./assemblies/drawer/guides.js');
	new Guides();
	
	const Frame = require('./assemblies/frame.js');
	new Frame();
	
	const Handle = require('./assemblies/hardware/pull.js');
	new Handle();
	
	const Screw = require('./assemblies/hardware/screw.js');
	new Screw();
	
	const Panel = require('./assemblies/panel.js');
	new Panel();
	
	// const PartitionSection = require('./assemblies/section/partition/sections/divider.js');
	// new PartitionSection();
	//
	// const DividerSection = require('./assemblies/section/partition/partition');
	// new DividerSection();
	//
	// const Section = require('./assemblies/section/section.js');
	// new Section();
	//
	// const DivideSection = require('./assemblies/section/space/sections/divide-section.js');
	// new DivideSection();
	//
	// const OpeningCoverSection = require('./assemblies/section/space/sections/open-cover/open-cover.js');
	// new OpeningCoverSection();
	
	const DoorSection = require('./assemblies/section/sections/door.js');
	new DoorSection();
	
	const DrawerSection = require('./assemblies/section/sections/drawer.js');
	new DrawerSection();
	
	const DualDoorSection = require('./assemblies/section/sections/duel-door.js');
	new DualDoorSection();
	
	const FalseFrontSection = require('./assemblies/section/sections/false-front.js');
	new FalseFrontSection();
	
	// const SpaceSection = require('./assemblies/section/space/space.js');
	// new SpaceSection();
	
	const Cutter = require('./assemblies/cutter.js');
	new Cutter();
	
	Assembly.components = {
	  Door, DrawerBox, DrawerFront, Frame, Panel, Cutter,
	};
	
});


RequireJS.addFunction('./app-src/objects/joint/init.js',
function (require, exports, module) {
	
const Joint = require('./joint');
	
	const Butt = require('./joints/butt.js');
	const Dado = require('./joints/dado.js');
	const Miter = require('./joints/miter.js');
	const Rabbet = require('./joints/rabbet.js');
	
	Joint.types = {
	  Butt, Dado, Miter, Rabbet
	};
	
});


RequireJS.addFunction('./app-src/three-d/objects/polygon.js',
function (require, exports, module) {
	
const Polygon2D = require('../../two-d/objects/polygon.js');
	const Line2D = require('../../two-d/objects/line.js');
	const Line3D = require('./line');
	const Vertex3D = require('./vertex');
	const Vector3D = require('./vector');
	
	const CSG = require('../../../public/js/3d-modeling/csg.js');
	
	class Polygon3D {
	  constructor(initialVerticies) {
	    const lines = [];
	    let map;
	    let normal;
	
	    function calcNormal() {
	        const points = [lines[0].startVertex, lines[1].startVertex, lines[2].startVertex];
	        const vector1 = points[1].minus(points[0]);
	        const vector2 = points[2].minus(points[0]);
	        const normVect = vector1.crossProduct(vector2);
	        return normVect.scale(1 / normVect.magnitude());
	    }
	    this.normal = calcNormal;
	
	    this.translate = (vector) => {
	      const verts = [];
	      for (let index = 0; index < lines.length; index++) {
	        verts.push(lines[index].startVertex.translate(vector, true));
	      }
	      return new Polygon3D(verts);
	    }
	
	    this.perpendicular = (poly) => {
	      return this.normal().perpendicular(poly.normal());
	    }
	    const xyNormal = new Vector3D(0,0,1);
	    const yzNormal = new Vector3D(1,0,0);
	    const xzNormal = new Vector3D(0,1,0);
	    this.inXY = () => this.perpendicular(xyPoly);
	    this.inYZ = () => this.perpendicular(yzPoly);
	    this.inXZ = () => this.perpendicular(xzPoly);
	
	    this.parrelle = (poly) => {
	      if (normal === undefined || poly.normal() === undefined) return false;
	      return normal.parrelle(poly.normal());
	    }
	
	    this.parrelleAt = (distance) => {
	      const normal = this.normal();
	      const scaled = normal.scale(distance);
	      const verticies = this.verticies();
	      for (let index = 0; index < verticies.length; index++) {
	        verticies[index].translate(scaled);
	      }
	      return new Polygon3D(verticies);
	    }
	
	    this.verticies = () => {
	      if (lines.length === 0) return [];
	      const verticies = [];
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        verticies.push(line.startVertex);
	      }
	
	      return JSON.clone(verticies);
	    }
	
	    this.vertex = (index) => lines[Math.mod(index, lines.length)].startVertex.copy();
	
	    this.isClockwise = () => {
	      let sum = 0;
	      for (let index = 0; index < lines.length; index += 1) {
	        const point1 = lines[index].startVertex;
	        const point2 = lines[index].startVertex;
	        sum += (point2.x - point1.x)*(point2.y + point1.y)*(point2.z - point1.z);
	      }
	      return sum > 0;
	    }
	
	    this.lines = () => JSON.clone(lines);
	    this.line = (index) => JSON.clone(lines[Math.mod(index, lines.length)]);
	    this.startLine = () => lines[0];
	    this.endLine = () => lines[lines.length - 1];
	
	    this.lineMap = (force) => {
	      if (!force && map !== undefined) return map;
	      if (lines.length === 0) return {};
	      map = {};
	      let lastEnd;
	      if (!lines[0].startVertex.equals(lines[lines.length - 1].endVertex)) throw new Error('Broken Polygon');
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        if (lastEnd && !line.startVertex.equals(lastEnd)) throw new Error('Broken Polygon');
	        lastEnd = line.endVertex;
	        map[line.toString()] = line;
	      }
	      return map;
	    }
	
	    this.equals = (other) => {
	      if (!(other instanceof Polygon3D)) return false;
	      const verts = this.verticies();
	      const otherVerts = other.verticies();
	      if (verts.length !== otherVerts.length) return false;
	      let otherIndex = undefined;
	      let direction;
	      for (let index = 0; index < verts.length * 2; index += 1) {
	        const vIndex = index % verts.length;
	        if (otherIndex === undefined) {
	          if (index > verts.length) {
	            return false
	          } if(verts[index].equals(otherVerts[0])) {
	            otherIndex = otherVerts.length * 2;
	          }
	        } else if (otherIndex === otherVerts.length * 2) {
	          if (verts[vIndex].equals(otherVerts[1])) direction = 1;
	          else if(verts[vIndex].equals(otherVerts[otherVerts.length - 1])) direction = -1;
	          else return false;
	          otherIndex += direction * 2;
	        } else if (!verts[vIndex].equals(otherVerts[otherIndex % otherVerts.length])) {
	          return false;
	        } else {
	          otherIndex += direction;
	        }
	      }
	      return true;
	    }
	
	    function getLine(line) {
	      const lineMap = this.lineMap();
	      return lineMap[line.toString()] || lineMap[line.toNegitiveString()];
	    }
	
	    this.getLines = (startVertex, endVertex, reverse) => {
	      const inc = reverse ? -1 : 1;
	      const subSection = [];
	      let completed = false;
	      const doubleLen = lines.length * 2;
	      for (let steps = 0; steps < doubleLen; steps += 1) {
	        const index =  (!reverse ? steps : (doubleLen - steps - 1)) % lines.length;
	        const curr = lines[index];
	        if (subSection.length === 0) {
	          if (startVertex.equals(!reverse ? curr.startVertex : curr.endVertex)) {
	            subSection.push(!reverse ? curr : curr.negitive());
	            if (endVertex.equals(reverse ? curr.startVertex : curr.endVertex)) {
	              completed = true;
	              break;
	            }
	          }
	        } else {
	          subSection.push(!reverse ? curr : curr.negitive());
	          if (endVertex.equals(reverse ? curr.startVertex : curr.endVertex)) {
	            completed = true;
	            break;
	          }
	        }
	      }
	      if (completed) return subSection;
	    }
	
	    this.center = () => {
	      const verts = [];
	      for (let index = 0; index < lines.length; index++) {
	        verts.push(lines[index].startVertex);
	      }
	      return Vertex3D.center(verts);
	    }
	
	    this.addVerticies = (list) => {
	      if (list === undefined) return;
	      const verts = [];
	      const endLine = this.endLine();
	      for (let index = 0; index < list.length + 1; index += 1) {
	        if (index < list.length) verts[index] = new Vertex3D(list[index]);
	        if (index === 0 && endLine) endLine.endVertex = verts[0];
	        else if (index > 0) {
	          const startVertex = verts[index - 1];
	          const endVertex = verts[index] || this.startLine().startVertex;
	          const line = new Line3D(startVertex, endVertex);
	          lines.push(line);
	          const prevLine = lines[lines.length - 2];
	          // if (lines.length > 1 && !(normal instanceof Vector3D)) normal = calcNormal(line, prevLine);
	          // else if (lines.length > 2) {
	          //   const equal = normal.equals(calcNormal(line, prevLine));
	          //   if (equal === false) {
	          //     console.log('Trying to add vertex that does not lie in the existing plane');
	          //   }
	          // }
	        }
	      }
	      if (verts.length > 0 && lines.length > 0) {
	        if (endLine) endline.endVertex = verts[0];
	      }
	      this.removeLoops();
	      this.lineMap(true);
	    }
	
	    this.removeLoops = () => {
	      const map = {}
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        const key = line.toString();
	        const negKey = line.toNegitiveString();
	        if (map[key]) {
	          lines.splice(map[key].index, index - map[key].index + 1);
	        } else if (map[negKey]) {
	          lines.splice(map[negKey].index, index - map[negKey].index + 1);
	        } else {
	          map[key] = {line, index};
	        }
	      }
	    }
	
	    this.path = () => {
	      let path = '';
	      this.verticies().forEach((v) => path += `${v.toString()} => `);
	      return path.substring(0, path.length - 4);
	    }
	
	    this.merge = (other) => {
	      // if (!this.normal.equals(other.normal)) return;
	      const sharedMap = [];
	      const inverseMap = [];
	      const notShared = [];
	      const lineMap = this.lineMap();
	      const otherLines = other.lines();
	      let merged;
	      for (let index = 0; index < otherLines.length; index += 1) {
	        const curr = otherLines[index];
	        if (lineMap[curr.toString()] !== undefined) {
	          let thisLines = this.getLines(curr.startVertex, curr.endVertex, true);
	          let otherLines = other.getLines(curr.endVertex, curr.startVertex, false);
	          if (thisLines && otherLines) {
	            if (thisLines[0].startVertex.equals(otherLines[0].startVertex)) {
	              merged = new Polygon3D(Line3D.verticies(thisLines.concat(otherLines.reverse())));
	            } else {
	              merged = new Polygon3D(Line3D.verticies(thisLines.concat(otherLines)));
	            }
	          }
	        }
	        if (lineMap[curr.toNegitiveString()] !== undefined) {
	          let thisLines = this.getLines(curr.endVertex, curr.startVertex, true);
	          let otherLines = other.getLines(curr.startVertex, curr.endVertex, true);
	          if (thisLines[0].startVertex.equals(otherLines[0].startVertex)) {
	            merged = new Polygon3D(Line3D.verticies(thisLines.concat(otherLines.reverse())));
	          } else {
	            merged = new Polygon3D(Line3D.verticies(thisLines.concat(otherLines)));
	          }
	        }
	      }
	
	      if (merged) {
	        // merged.removeLoops();
	        return merged;
	      }
	    }
	
	    this.toString = () => {
	      let startStr = '';
	      let endStr = '';
	      for (let index = 0; index < lines.length; index++) {
	        startStr += ` => ${lines[index].startVertex.toString()}`;
	        endStr += ` => ${lines[Math.mod(index - 1, lines.length)].endVertex.toString()}`;
	      }
	      return `Start Verticies: ${startStr.substring(4)}\nEnd   Verticies: ${endStr.substring(4)}`;
	    }
	    this.addVerticies(initialVerticies);
	  }
	}
	
	Polygon3D.merge = (polygons) => {
	  let currIndex = 0;
	  while (currIndex < polygons.length - 1) {
	    const target = polygons[currIndex];
	    for (let index = currIndex + 1; index < polygons.length; index += 1) {
	      const other = polygons[index];
	      const merged = target.merge(other);
	      if (merged) {
	        polygons[currIndex--] = merged;
	        polygons.splice(index, 1);
	        break;
	      }
	    }
	    currIndex++;
	  }
	}
	
	const xyPoly = new Polygon3D([[1,10,0],[11,2,0],[22,1,0]]);
	const yzPoly = new Polygon3D([[6,0,1],[10,0,27],[2,0,11]]);
	const xzPoly = new Polygon3D([[0,11,13],[0,12,23],[0,22,3]]);
	
	// const include = (axis1, axis2, axis3) => !(Math.abs(axis1) === 1 || Math.abs(axis2) === 1);
	// const include = (axis1, axis2, axis3) => axis3 !== 0 && axis1 === 0 && axis2 === 0;
	const include = (n1, n2) => ((n1[0] * n2[0]) + (n1[1] * n2[1]) + (n1[2] * n2[2])) !== 0;
	Polygon3D.toTwoD = (polygons) => {
	  const map = {xy: [], xz: [], zy: []};
	  for (let index = 0; index < polygons.length; index += 1) {
	    const poly = polygons[index];
	    const norm = poly.normal();
	    const inXY = poly.inXY();//include(norm, [0,0,1]);//include(norm[0], norm[1], norm[2]);
	    const inXZ = poly.inXZ();//include(norm, [0,1,0]);//include(norm[0], norm[2], norm[1]);
	    const inZY = poly.inYZ();//include(norm, [1,0,0]);//include(norm[2], norm[1], norm[0]);
	    const includeXY = inXY;//!inXZ && !inZY;
	    const includeXZ = inXZ;//!inXY && !inZY;
	    const includeZY = inZY;//!inXY && !inXZ;
	    const indexXY = map.xy.length;
	    const indexXZ = map.xz.length;
	    const indexZY = map.zy.length;
	    if (includeXY) map.xy[indexXY] = [];
	    if (includeXZ) map.xz[indexXZ] = [];
	    if (includeZY) map.zy[indexZY] = [];
	    poly.verticies().forEach((vertex) => {
	      if (includeXY) map.xy[indexXY].push({x: vertex.x, y: -1 * vertex.y, layer: vertex.z});
	      if (includeXZ) map.xz[indexXZ].push({x: vertex.x, y: -1 * vertex.z, layer: vertex.y});
	      if (includeZY) map.zy[indexZY].push({x: -1 * vertex.z, y: -1 * vertex.y, layer: vertex.x});
	    });
	    if (includeXY) map.xy[indexXY] = new Polygon2D(map.xy[indexXY]);
	    if (includeXZ) map.xz[indexXZ] = new Polygon2D(map.xz[indexXZ]);
	    if (includeZY) map.zy[indexZY] = new Polygon2D(map.zy[indexZY]);
	  }
	  return map;
	}
	
	Polygon3D.fromVectorObject =
	    (vectorObj, center, height, width) => {
	  const hh = height/2;
	  const hw = width/2;
	  const hV = vectorObj.height;
	  const wV = vectorObj.width;
	  const vector1 = center.translate(hV.scale(hh), true).translate(wV.scale(-hw));
	  const vector2 = center.translate(hV.scale(hh), true).translate(wV.scale(hw));
	  const vector3 = center.translate(hV.scale(-hh), true).translate(wV.scale(hw));
	  const vector4 = center.translate(hV.scale(-hh), true).translate(wV.scale(-hw));
	  return new Polygon3D([vector1, vector2, vector3, vector4]);
	}
	
	Polygon3D.fromLines = (lines) => {
	  const verts = [];
	  for (let index = 0; index < lines.length; index += 1) {
	    if (!lines[index].startVertex.equals(lines[Math.mod(index - 1, lines.length)].endVertex)) throw new Error('Lines must be connected');
	    verts.push(lines[index].startVertex);
	  }
	  return new Polygon3D(verts);
	}
	
	module.exports = Polygon3D;
	
});


RequireJS.addFunction('./app-src/three-d/models/drawer-box.js',
function (require, exports, module) {
	

	const CSG = require('../../../public/js/3d-modeling/csg');
	const Polygon3D = require('../objects/polygon.js');
	const BiPolygon = require('../objects/bi-polygon.js');
	
	function drawerBox(length, width, depth) {
	  const bottomHeight = 7/8;
	  const box = CSG.cube({demensions: [width, length, depth], center: [0,0,0]});
	  box.setColor(1, 0, 0);
	  const inside = CSG.cube({demensions: [width-1.5, length, depth - 1.5], center: [0, bottomHeight, 0]});
	  inside.setColor(0, 0, 1);
	  const bInside = CSG.cube({demensions: [width-1.5, length, depth - 1.5], center: [0, (-length) + (bottomHeight) - 1/4, 0]});
	  bInside.setColor(0, 0, 1);
	
	  return box.subtract(bInside).subtract(inside);
	}
	
	function unionAll(...polygons) {
	  let model = polygons[0].toModel();
	  for (let index = 1; index < polygons.length; index++) {
	    model = model.union(polygons[index].toModel());
	  }
	  return model;
	}
	
	function drawerBox(frontPoly, normal, length) {
	  const sideThickness = (2.54 * 5) / 8
	  const bottomThickness = (2.54 * 3) / 8;
	  const bottomHeight = (7*2.54)/8;
	  const norm = normal;
	
	  // In order (front, (frontMoved), back, left, right, top, bottom) Polygon: verticies are if facing polygon topLeft, topRight, bottomRight, bottomLeft
	  const fP = frontPoly;
	  const fPm = fP.translate(norm.scale(-length));
	  const bP = new Polygon3D([fPm.vertex(1), fPm.vertex(0), fPm.vertex(3), fPm.vertex(2)]);
	  const lP = new Polygon3D([bP.vertex(1), fP.vertex(0), fP.vertex(3), bP.vertex(2)]);
	  const rP = new Polygon3D([fP.vertex(1), bP.vertex(0), bP.vertex(3), fP.vertex(2)]);
	  const tP = new Polygon3D([bP.vertex(1), bP.vertex(0), fP.vertex(1), bP.vertex(0)]);
	  const btmP = new Polygon3D([bP.vertex(2), bP.vertex(3), fP.vertex(2), fP.vertex(3)]);
	
	  const front = BiPolygon.fromPolygon(fP, 0, -sideThickness);
	  const back = BiPolygon.fromPolygon(bP, 0, -sideThickness);
	  const left = BiPolygon.fromPolygon(lP, 0, -sideThickness);
	  const right = BiPolygon.fromPolygon(rP, 0, -sideThickness);
	  const bottom = BiPolygon.fromPolygon(btmP, -bottomHeight, -bottomHeight-bottomThickness);
	  return unionAll(front, back, left, right, bottom);
	}
	module.exports = drawerBox
	
});


RequireJS.addFunction('./app-src/three-d/objects/matrix.js',
function (require, exports, module) {
	
const Approximate = require('../../../../../public/js/utils/approximate.js');
	
	function findRowColumnCount (array) {
	  let rows = array.length;
	  let columns = array[0].length;
	  for (let i = 0; i < array.length; i++) {
	    const row = array[i];
	    columns = row.length > columns ? row.length : columns;
	  }
	  return {rows, columns};
	}
	
	function columnValidator (min, max) {
	  return (target, key, value) => {
	    if (key > max || key < min) {
	      throw new Error('An assignment error was made or you need to resize your matrix');
	    }
	    if ((typeof value) !== 'number') {
	      throw new Error('Matrix must be filled with numbers');
	    }
	    target[key] = value;
	    return true;
	  }
	}
	
	function rowValidator () {
	  return (target, key, value) => {
	    if (Number.isNaN(Number.parseInt(key))) {
	      throw new Error('You do not have access to the numerical attributes of a Matrix object, they are reserved for rows and cannot be modified');
	    }
	    target[key] = value;
	    return true;
	  }
	}
	
	class Matrix extends Array {
	  constructor(values, rows, columns) {
	    super();
	    if (!rows || !columns) {
	      const max = findRowColumnCount(values);
	      if (!rows) rows = max.rows;
	      if (!columns) columns = max.columns;
	    }
	
	    for (let i = 0; i < rows; i +=1) {
	      this[i] = new Proxy([], { set: columnValidator(0, columns) });
	      for (let j = 0; j < columns; j ++) {
	        const value = values && values[i] && values[i][j];
	        this[i][j] = !value ? 0 : value;
	      }
	    }
	
	    new Proxy(this, {set: rowValidator()});
	
	    this.rows = () => rows;
	    this.columns = () => columns;
	
	    this.remove = (rowIndex, columnIndex) => {
	      if ((typeof rowIndex) !== 'number') rowIndex = Number.MAX_SAFE_INTEGER;
	      else rowIndex = Math.mod(rowIndex, rows);
	      if ((typeof columnIndex) !== 'number') columnIndex = Number.MAX_SAFE_INTEGER;
	      else columnIndex = Math.mod(columnIndex, columns);
	
	      const rowLimit = rowIndex > -1 && rowIndex < rows ? rows - 1 : rows;
	      const columnLimit = columnIndex > -1 && columnIndex < columns ? columns - 1 : columns;
	      let matrix = new Matrix(null, rowLimit, columnLimit);
	      for (let i = 0; i < rows; i++) {
	        if (i !== rowIndex) {
	          const rowI = i < rowIndex ? i : i - 1;
	          for (let j = 0; j < columns; j++) {
	            if (j !== columnIndex) {
	              const columnJ = j < columnIndex ? j : j - 1;
	              matrix[rowI][columnJ] = this[i][j];
	            }
	          }
	        }
	      }
	      return matrix;
	    }
	
	    this.replaceRow = (rowIndex, values) => {
	      rowIndex = Math.mod(rowIndex, rows);
	
	      for (let j = 0; j < columns; j++) {
	        this[rowIndex][j] = values[j];
	      }
	    }
	
	    this.replaceColumn = (columnIndex, values) => {
	      columnIndex = Math.mod(columnIndex, rows);
	
	      for (let i = 0; i < rows; i++) {
	        this[i][columnIndex] = values[i];
	      }
	    }
	
	    this.minor = (index) => {
	      return this.remove(0, index);
	    }
	
	    this.determinate = () => {
	      if (rows === 2) return this[0][0] * this[1][1] - this[0][1] * this[1][0];
	
	      let sign = 1;
	      let sum = 0;
	      let colNum = 0;
	      while (colNum < columns) {
	        const minor = this.minor(colNum);
	        const determinate = minor.determinate();
	        sum += this[0][colNum++] * determinate * sign;
	        sign *= -1;
	      }
	      return sum;
	    }
	
	    this.solve = (answer) => {
	      const solution = new Matrix(null, columns, 1);
	      answer ||= new Array(columns).fill(0);
	      const determinate = this.determinate();
	      for (let j = 0; j < columns; j++) {
	        const matrix = this.copy()
	        matrix.replaceColumn(j, answer);
	        const matrixDeterminate = matrix.determinate();
	        solution[j][0] = matrixDeterminate / determinate;
	      }
	      return solution;
	    }
	
	    this.dot = (other) => {
	      if (this.columns() !== other.rows()) throw new Error('this.columns() and other.rows() much match for a dot product');
	      const result = new Matrix(null, this.rows(), other.columns());
	      let ri = 0;
	      let rj = 0;
	      for (let i = 0; i < rows; i++) {
	        for (let oj = 0; oj < other.columns(); oj++) {
	          let value = 0;
	          for (let j = 0; j < columns; j++) {
	            value = value + this[i][j] * other[j][oj];
	          }
	          result[i][oj] = value;
	        }
	      }
	      return result;
	    }
	
	    this.scale = (coef, oddOnly) => {
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < columns; j++) {
	          if (!oddOnly || (i + j) % 2 === 1) {
	            this[i][j] = this[i][j] * coef;
	          }
	        }
	      }
	    }
	
	    this.approximate = (accuracy) => {
	      const approximate = Approximate.new(accuracy);
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < columns; j++) {
	          this[i][j] = approximate(this[i][j]);
	        }
	      }
	    }
	
	    this.transpose = () => {
	      const rows = this.rows();
	      const cols = this.columns();
	      const result = new Matrix(null, cols, rows);
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < cols; j++) {
	          result[j][i] = this[i][j];
	        }
	      }
	      return result;
	    }
	
	    this.diagonal = () => {
	      const rows = this.rows();
	      const cols = this.columns();
	      const result = new Matrix(null, cols, rows);
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < cols; j++) {
	          if (i + j !== rows - 1) {
	            result[rows - i - 1][cols - j - 1] = this[i][j];
	          } else {
	            result[i][j] = this[i][j];
	          }
	        }
	      }
	      return result;
	    }
	
	    this.multiply = (other) => {
	      const result = new Matrix(null, this.rows(), other.columns());
	      for (let i = 0; i < this.rows(); i++) {
	        for (let j = 0; j < this.columns(); j++) {
	          let sum = 0
	          for (let k = 0; k < other.rows(); k++) {
	            sum = sum + this[i][k] * other[k][j]
	            result[i][j] = sum
	          }
	        }
	      }
	      return result;
	    }
	
	    this.inverse = () => {
	      let inverse;
	      if (this.rows() === 2) {
	        inverse = this.diagonal();
	        inverse.scale(-1, true);
	        inverse.scale(1/this.determinate());
	        return inverse;
	      }
	
	      const rows = this.rows();
	      const cols = this.columns();
	      inverse = new Matrix(null, rows, columns);
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < cols; j++) {
	          const minor = this.remove(i, j);
	          const value = minor.determinate();
	          inverse[i][j] = value;
	        }
	      }
	      inverse.scale(-1, true);
	      inverse = inverse.transpose();
	      inverse.scale(1/this.determinate());
	      return inverse;
	    }
	
	    this.toString = () => {
	      let str = '';
	      for (let i = 0; i < rows; i++) {
	        str += '|'
	        for (let j = 0; j < columns; j++) {
	          str += `${this[i][j]}  `;
	        }
	        str = str.substring(0, str.length - 2) + '|\n'
	      }
	      return str.substring(0, str.length - 1);
	    }
	
	    this.equals = (other) => {
	      if (other.rows() !== rows || other.columns() !== columns) return false;
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < columns; j++) {
	          if (other[i][j] !== this[i][j]) return false;
	        }
	      }
	      return true;
	    }
	
	    this.copy = () => new Matrix(this);
	
	  }
	}
	
	Matrix.identity = (rows) => {
	  let identity = new Matrix(null, rows, rows);
	  for (let i = 0; i < rows; i++) {
	    for (let j = 0; j < rows; j++) {
	      if (i === j) identity[i][i] = 1;
	      else identity[i][j] = 0;
	    }
	  }
	  return identity;
	}
	
	Matrix.rotation = function (roll, pitch, yaw) {
	  if (roll instanceof Object) {
	    pitch = Math.toRadians(roll.y);
	    yaw = Math.toRadians(roll.z);
	    roll = Math.toRadians(roll.x);
	  }
	  roll ||= 0;
	  pitch ||= 0;
	  yaw ||= 0;
	  var cosa = Math.cos(yaw);
	  var sina = Math.sin(yaw);
	
	  var cosb = Math.cos(pitch);
	  var sinb = Math.sin(pitch);
	
	  var cosc = -1*Math.cos(roll);
	  var sinc = -1*Math.sin(roll);
	
	  var Axx = cosa*cosb;
	  var Axy = cosa*sinb*sinc - sina*cosc;
	  var Axz = cosa*sinb*cosc + sina*sinc;
	
	  var Ayx = sina*cosb;
	  var Ayy = sina*sinb*sinc + cosa*cosc;
	  var Ayz = sina*sinb*cosc - cosa*sinc;
	
	  var Azx = -sinb;
	  var Azy = cosb*sinc;
	  var Azz = cosb*cosc;
	
	  return new Matrix([
	    [Axx, Axy, Axz],
	    [Ayx, Ayy, Ayz],
	    [Azx, Azy, Azz],
	  ]);
	}
	
	module.exports = Matrix;
	
});


RequireJS.addFunction('./app-src/three-d/models/pull.js',
function (require, exports, module) {
	

	const CSG = require('../../../public/js/3d-modeling/csg');
	const Polygon3D = require('../objects/polygon.js');
	const BiPolygon = require('../objects/bi-polygon.js');
	
	function pull(length, height) {
	  var rspx = length - .75;
	  var h = height-.125;
	  var gerth = .27
	  // var rCyl = CSG.cylinder({start: [rspx, .125, .125-height], end: [rspx, .125, .125], radius: .25})
	  // var lCyl = CSG.cylinder({start: [.75, .125, .125 - height], end: [.75, .125, .125], radius: .25})
	  // var mainCyl = CSG.cylinder({start: [0, .125, .125], end: [length, .125, .125], radius: .25})
	  var rCyl = CSG.cube({demensions: [gerth, gerth, h], center: [rspx/2, 0, h/-2]});
	  var lCyl = CSG.cube({demensions: [gerth, gerth, h], center: [rspx/-2, 0, h/-2]});
	  var mainCyl = CSG.cube({demensions: [length, gerth, gerth], center: [0, 0, 0]});
	
	  return mainCyl.union(lCyl).union(rCyl);
	}
	
	function pull(baseCenter, line, normal, projection, cTOc) {
	  let gerth = .27
	  let length = cTOc + gerth;
	  const midNormOffset = line.midpoint().translate(normal);
	  const lineNormPoly = new Polygon3D([line.startVertex.copy(), line.endVertex.copy(), midNormOffset]);
	  const vecObj = {
	    depth: normal,
	    width: line.vector().unit(),
	    height: lineNormPoly.normal(),
	  };
	
	  let sideProjection = projection - gerth;
	  const centerRL = baseCenter.translate(vecObj.depth.scale(sideProjection/2), true);
	  const centerLeft = centerRL.translate(vecObj.width.scale(cTOc/-2), true);
	  const centerRight = centerRL.translate(vecObj.width.scale(cTOc/2), true);
	  const centerMain = baseCenter.translate(vecObj.depth.scale(projection - gerth/2));
	
	  var lCyl = BiPolygon.fromVectorObject(vecObj, centerLeft, sideProjection, gerth, gerth);
	  var rCyl = BiPolygon.fromVectorObject(vecObj, centerRight, sideProjection, gerth, gerth);
	  var mainCyl = BiPolygon.fromVectorObject(vecObj, centerMain, gerth, gerth, length);
	
	  return mainCyl.toModel().union(lCyl.toModel()).union(rCyl.toModel());
	}
	module.exports = pull
	
});


RequireJS.addFunction('./app-src/three-d/objects/line.js',
function (require, exports, module) {
	
const Vector3D = require('./vector');
	const Vertex3D = require('./vertex');
	const Plane = require('./plane');
	
	class Line3D {
	  constructor(startVertex, endVertex) {
	    if (startVertex === undefined || endVertex === undefined) throw new Error('Lines must have a start and an end point');
	    startVertex = new Vertex3D(startVertex);
	    endVertex = new Vertex3D(endVertex);
	    this.startVertex = startVertex;
	    this.endVertex = endVertex;
	
	    this.clone = () => new Line3D(startVertex.clone(), endVertex.clone());
	
	    this.negitive = () => new Line3D(endVertex, startVertex);
	    this.equals = (other) => startVertex && endVertex && other &&
	        startVertex.equals(other.startVertex) && endVertex.equals(other.endVertex);
	    this.vector = () => {
	      let i = endVertex.x - startVertex.x;
	      let j = endVertex.y - startVertex.y;
	      let k = endVertex.z - startVertex.z;
	      return new Vector3D(i,j,k);
	    };
	
	    this.translate = (vector) => {
	      this.startVertex.translate(vector);
	      this.endVertex.translate(vector);
	    }
	
	    this.planeAt = (rotation) => {
	      const two = new Vertex3D({x: startVertex.x + 1, y: startVertex.y, z: startVertex.z});
	      two.rotate(rotation, startVertex);
	      const three = {x: endVertex.x + 1, y: endVertex.y, z: endVertex.z};
	      thtee.rotate(rotation, endVertex);
	      return new Plane(startVertex.copy(), two, three, endVertex.copy());
	    }
	
	    this.on = (vertex, tolerance) => {
	      tolerance ||= .01;
	    }
	
	    this.equation = () => {
	      const returnValue = {};
	      for (let i = 0; i < 3; i++) {
	        let coord = String.fromCharCode(i + 120);
	        let t = (endVertex[coord] - startVertex[coord]) / 1;
	        if (t !== 0) {
	          let coef = String.fromCharCode(i + 97);
	          returnValue[coef] = 1;
	
	          let offset = ((i + 1) % 3);
	          coord = String.fromCharCode(offset + 120);
	          coef = String.fromCharCode(offset + 97);
	          returnValue[coef] = (endVertex[coord] - startVertex[coord]) / t;
	
	          offset = ((i + 2) % 3);
	          coord = String.fromCharCode(offset + 120);
	          coef = String.fromCharCode(offset + 97);
	          returnValue[coef] = (endVertex[coord] - startVertex[coord]) / t;
	          break;
	        }
	      }
	      if (returnValue.a === undefined) throw new Error('This Line is a point... I think...');
	      return returnValue;
	    }
	
	    this.toString = () => `${new String(this.startVertex)} => ${new String(this.endVertex)}`;
	    this.toNegitiveString = () => `${new String(this.endVertex)} => ${new String(this.startVertex)}`;
	
	    this.midpoint = () => new Vertex3D(
	      (endVertex.x + startVertex.x) / 2,
	      (endVertex.y + startVertex.y) / 2,
	      (endVertex.z + startVertex.z) / 2
	    );
	
	    this.length = () => this.vector().magnitude();
	
	    this.adjustLength = (change, fromStartVertex) => {
	      if ((typeof change) !== 'number' || change === 0) return;
	      const unitVec = this.vector().unit();
	      if (fromStartVertex !== undefined) {
	        if (fromStartVertex === true) {
	          this.endVertex = this.startVertex.translate(unitVec.scale(change), true);
	        } else {
	          this.startVertex = this.endVertex.translate(unitVec.scale(change), true);
	        }
	      } else {
	        const len = this.length();
	        const halfChangeMag = change/2;
	        const halfDistVec = unitVec.scale(halfChangeMag);
	        startVertex.translate(halfDistVec.inverse());
	        endVertex.translate(halfDistVec);
	      }
	    }
	
	    this.pointAtDistance = (distance) => {
	      const point = startVertex.copy();
	      const unitVec = this.vector().unit();
	      point.translate(unitVec.scale(distance));
	      return point;
	    }
	
	    this.rotate = (rotation, center) => {
	      center ||= this.midpoint();
	      startVertex.rotate(rotations, center);
	      endVertex.rotate(rotations, center);
	    }
	
	    this.reverseRotate = (rotation, center) => {
	      center ||= this.midpoint();
	      startVertex.reverseRotate(rotations, center);
	      endVertex.reverseRotate(rotations, center);
	    }
	
	  }
	}
	
	Line3D.verticies = (lines) => {
	  const verts = [];
	  for (let index = 0; index < lines.length; index += 1) {
	    verts.push(lines[index].endVertex);
	  }
	  return verts;
	}
	
	Line3D.adjustVerticies = (vert1, vert2, change) => {
	  const line = new Line3D(vert1, vert2);
	  line.adjustLength(change);
	}
	
	module.exports = Line3D;
	
});


RequireJS.addFunction('./app-src/two-d/objects/snap/init.js',
function (require, exports, module) {
	const Snap2d = require('../snap');
	
	Snap2d.registar(require('./square.js'));
	Snap2d.registar(require('./corner.js'));
	Snap2d.registar(require('./corner-l.js'));
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/has-pull.js',
function (require, exports, module) {
	const Assembly = require('../assembly.js');
	const Handle = require('./hardware/pull.js');
	
	class HasPull extends Assembly {
	  constructor(partCode, partName, getBiPolygon) {
	    super(partCode, partName);
	    const pulls = [];
	    this.pull = (index) => pulls[index || 0];
	    this.addPull = (location) => {
	      pulls.push(new Handle(`${partCode}-dp`, 'Door.Handle', this, location));
	      this.addSubAssembly(pulls[pulls.length - 1]);
	    }
	    this.setPulls = (locations) => {
	      pulls.copy([]);
	      this.subassemblies.deleteAll();
	      locations.forEach((location) => this.addPull(location));
	    }
	    this.biPolygon = () => getBiPolygon();
	
	  }
	}
	
	module.exports = HasPull;
	
});


RequireJS.addFunction('./app-src/objects/joint/joints/dado.js',
function (require, exports, module) {
	
const Joint = require('../joint.js');
	
	class Dado extends Joint {
	  constructor(malePartCode, femalePartCode) {
	    super(malePartCode, femalePartCode);
	
	    this.updatePosition = (position) => {
	      const direction = this.centerAxis()[0] === '-' ? -1 : 1;
	      const centerAxis = this.centerAxis()[1].toLowerCase();
	      const offset = this.parentAssembly().eval(this.maleOffset());
	      const demAxis = this.demensionAxis().toLowerCase();
	      position.demension[demAxis] = position.demension[demAxis] + offset;
	      position.center[centerAxis] = position.center[centerAxis] + (offset/2 * direction);
	    };
	
	  }
	}
	
	Joint.register(Dado);
	module.exports = Dado
	
});


RequireJS.addFunction('./app-src/two-d/objects/snap/corner-l.js',
function (require, exports, module) {
	
const Snap2d = require('../snap');
	const SnapCorner = require('../snap/corner');
	const Square2d = require('../square');
	const Polygon2d = require('../polygon');
	const SnapLocation2d = require('../snap-location');
	const Vertex2d = require('../vertex');
	
	class SnapCornerL extends Snap2d {
	  constructor(parent, tolerance) {
	    const polygon = new Polygon2d();
	    super(parent, polygon, tolerance);
	    polygon.getTextInfo = () => {
	      const fwr = (this.height() - this.dl());
	      const fwl = (this.width() - this.dr());
	      const areaL = this.dl() * fwr;
	      const areaR = this.dr() * fwl;
	      const center = polygon.center();
	      const info = {
	        text: this.parent().name(),
	        center: polygon.center(),
	        maxWidth: this.width(),
	        limit: 4
	      };
	
	      if (areaR > areaL) {
	        // Dont know why radians cause the x and y axis to flip.... its not supposed to, check draw function
	        info.x = this.height()/2 - fwr/2;
	        info.y = this.width()/-2 + this.dr();
	        info.maxWidth = fwr*.75;
	        info.radians = Math.toRadians(-90) + this.radians();
	      } else {
	        info.x = this.width()/2 + -1 * (this.dr() + fwl/2);
	        info.y = this.height()/-2 + 3 * this.dl() / 4;
	        info.maxWidth = fwl;
	        info.radians = Math.toRadians(180) + this.radians();
	      }
	      return info;
	    }
	    if (parent === undefined) return this;
	
	    this.addLocation(SnapCorner.backRight(this));
	    this.addLocation(SnapCorner.frontRight(this));
	    this.addLocation(SnapCornerL.frontCenter(this));
	    this.addLocation(SnapCorner.frontLeft(this));
	    this.addLocation(SnapCorner.backLeft(this));
	
	    this.addLocation(SnapCorner.daginalLeft(this));
	    this.addLocation(SnapCorner.diagonalRight(this));
	    const verticies = this.snapLocations().map((snap) =>
	      snap.vertex());
	    polygon.addVerticies(verticies);
	  }
	}
	
	const f = SnapLocation2d.locationFunction;
	const fromToPoint = SnapLocation2d.fromToPoint;
	const wf = (snapLoc, attrM, props) => f(snapLoc, 'width', attrM, props);
	const hf = (snapLoc, attrM, props) => f(snapLoc, 'height', attrM, props);
	
	SnapCornerL.frontCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontCenter",  new Vertex2d(null),  null);
	  snapLoc.locationFunction(fromToPoint(snapLoc, wf(snapLoc, -.5, {dr: 1}), hf(snapLoc, .5, {dl: -1})));
	  snapLoc.at();
	  return snapLoc;
	}
	
	module.exports = SnapCornerL;
	
});


RequireJS.addFunction('./app-src/objects/joint/joints/butt.js',
function (require, exports, module) {
	

	
	const Joint = require('../joint.js');
	
	class Butt extends Joint {
	  constructor(joinStr) {
	    super(joinStr);
	  }
	}
	
	Joint.register(Butt);
	module.exports = Butt
	
	
	
	
	
});


RequireJS.addFunction('./app-src/two-d/objects/snap/corner.js',
function (require, exports, module) {
	
const Snap2d = require('../snap');
	const Square2d = require('../square');
	const Polygon2d = require('../polygon');
	const SnapLocation2d = require('../snap-location');
	const Vertex2d = require('../vertex');
	const Line2d = require('../line');
	
	class SnapCorner extends Snap2d {
	  constructor(parent, tolerance) {
	    const polygon = new Polygon2d();
	    // super(parent, new Square2d(parent.center), tolerance);
	    super(parent, polygon, tolerance);
	    if (parent === undefined) return this;
	    polygon.getTextInfo = () => {
	      const fwr = (this.height() - this.dl());
	      const fwl = (this.width() - this.dr());
	      const areaL = this.dl() * fwr;
	      const areaR = this.dr() * fwl;
	      const center = polygon.center();
	      const info = {
	        text: this.parent().name(),
	        center: polygon.center(),
	        maxWidth: this.width(),
	        limit: 4
	      };
	
	      if (areaR > areaL) {
	        // Dont know why radians cause the x and y axis to flip.... its not supposed to, check draw function
	        info.x = this.height()/2 - fwr/2;
	        info.y = this.width()/-2 + this.dr();
	        info.maxWidth = fwr*.75;
	        info.radians = Math.toRadians(-90) + this.radians();
	      } else {
	        info.x = this.width()/2 + -1 * (this.dr() + fwl/2);
	        info.y = this.height()/-2 + 3 * this.dl() / 4;
	        info.maxWidth = fwl;
	        info.radians = Math.toRadians(180) + this.radians();
	      }
	      return info;
	    }
	
	    this.addLocation(SnapCorner.backRight(this));
	    this.addLocation(SnapCorner.frontRight(this));
	    this.addLocation(SnapCorner.frontLeft(this));
	    this.addLocation(SnapCorner.backLeft(this));
	
	    this.addLocation(SnapCorner.daginalLeft(this));
	    this.addLocation(SnapCorner.diagonalRight(this));
	    const verticies = this.snapLocations().map((snap) =>
	      snap.vertex());
	    polygon.addVerticies(verticies);
	  }
	}
	
	const f = (snapLoc, attr, attrM, props) => () => {
	  let val = snapLoc.parent()[attr]() * attrM;
	  let keys = Object.keys(props || {});
	  for (let index = 0; index < keys.length; index += 1) {
	    const key = keys[index];
	    val += snapLoc.parent()[key]() * props[key];
	  }
	  return val;
	};
	
	const fromToPoint = SnapLocation2d.fromToPoint;
	const wf = (snapLoc, attrM, props) => f(snapLoc, 'width', attrM, props);
	const hf = (snapLoc, attrM, props) => f(snapLoc, 'height', attrM, props);
	
	SnapCorner.diagonalRight = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "diagonalRight",  new Vertex2d(null),  'daginalLeft');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wf(snapLoc, -.5), hf(snapLoc, .5, {dol: -1})));
	  snapLoc.wallThetaOffset(90);
	  snapLoc.thetaOffset('SnapCorner', null, 180);
	  snapLoc.thetaOffset('SnapCornerL', null, 180);
	  snapLoc.at();
	  return snapLoc;
	}
	
	SnapCorner.daginalLeft = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "daginalLeft",  new Vertex2d(null),  'diagonalRight');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wf(snapLoc, -.5, {dor: 1}), hf(snapLoc, .5)));
	  snapLoc.wallThetaOffset(180);
	  snapLoc.thetaOffset('SnapCorner', null, 180);
	  snapLoc.thetaOffset('SnapCornerL', null, 180);
	  snapLoc.at();
	  return snapLoc;
	}
	
	SnapCorner.backRight = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "backRight",  new Vertex2d(null),  'backLeft');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wf(snapLoc, -.5), hf(snapLoc, -.5)));
	  snapLoc.thetaOffset('SnapCorner', null, -90);
	  snapLoc.thetaOffset('SnapCornerL', null, -90);
	  snapLoc.thetaOffset('SnapSquare', null, 90);
	  snapLoc.at();
	  return snapLoc;
	}
	
	SnapCorner.frontRight = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontRight",  new Vertex2d(null),  'frontLeft');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wf(snapLoc, -.5, {dr: 1}), hf(snapLoc, -.5)));
	  snapLoc.thetaOffset('SnapCorner', null, -90);
	  snapLoc.thetaOffset('SnapCornerL', null, -90);
	  snapLoc.thetaOffset('SnapSquare', null, 90);
	  snapLoc.at();
	  return snapLoc;
	}
	
	SnapCorner.backLeft = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "backLeft",  new Vertex2d(null),  'backRight');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wf(snapLoc, .5), hf(snapLoc, .5)));
	  snapLoc.thetaOffset('SnapCorner', null, 90);
	  snapLoc.thetaOffset('SnapCornerL', null, 90);
	  snapLoc.thetaOffset('SnapSquare', null, 180);
	  snapLoc.at();
	  return snapLoc;
	}
	
	SnapCorner.frontLeft = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontLeft",  new Vertex2d(null),  'frontRight');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wf(snapLoc,.5), hf(snapLoc, .5, {dl: -1})));
	  snapLoc.thetaOffset('SnapCorner', null, 90);
	  snapLoc.thetaOffset('SnapCornerL', null, 90);
	  snapLoc.thetaOffset('SnapSquare', null, 180);
	  snapLoc.at();
	  return snapLoc;
	}
	
	module.exports = SnapCorner;
	
});


RequireJS.addFunction('./app-src/two-d/objects/snap/square.js',
function (require, exports, module) {
	const Snap2d = require('../snap');
	const Square2d = require('../square');
	const Polygon2d = require('../polygon');
	const SnapLocation2d = require('../snap-location');
	const Vertex2d = require('../vertex');
	
	class SnapSquare extends Snap2d {
	  constructor(parent, tolerance) {
	    const polygon = new Polygon2d();
	    polygon.getTextInfo = () => ({
	      text: this.parent().name(),
	      center: this.object().center(),
	      radians: this.radians(),
	      x: 0,
	      y: this.height() / 4,
	      maxWidth: this.width(),
	      limit: 10
	    });
	    // super(parent, new Square2d(parent.center), tolerance);
	    super(parent, polygon, tolerance);
	    if (parent === undefined) return this;
	    this.addLocation(SnapSquare.backCenter(this));
	    this.addLocation(SnapSquare.backRight(this));
	    this.addLocation(SnapSquare.rightCenter(this));
	    this.addLocation(SnapSquare.frontRight(this));
	    this.addLocation(SnapSquare.frontLeft(this));
	    this.addLocation(SnapSquare.leftCenter(this));
	    this.addLocation(SnapSquare.backLeft(this));
	    const verticies = this.snapLocations().map((snap) =>
	      snap.vertex());
	    polygon.addVerticies(verticies);
	  }
	}
	
	const fromToPoint = SnapLocation2d.fromToPoint;
	const wFunc = (snapLoc, multiplier) => SnapLocation2d.locationFunction(snapLoc, 'width', multiplier);
	const hFunc = (snapLoc, multiplier) => SnapLocation2d.locationFunction(snapLoc, 'height', multiplier);
	
	SnapSquare.backCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "backCenter",  new Vertex2d(null),  'backCenter');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wFunc(snapLoc, 0), hFunc(snapLoc, -.5)));
	  snapLoc.wallThetaOffset(0);
	  snapLoc.thetaOffset(null, null, 180);
	  snapLoc.at();
	  return snapLoc;
	}
	SnapSquare.frontCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontCenter",  new Vertex2d(null),  'frontCenter');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wFunc(snapLoc, 0), () => hFunc(snapLoc, .5)));
	  snapLoc.at();
	  return snapLoc;
	}
	SnapSquare.leftCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "leftCenter",  new Vertex2d(null),  'rightCenter');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wFunc(snapLoc, -.5), hFunc(snapLoc, 0)));
	  snapLoc.at();
	  return snapLoc;
	}
	SnapSquare.rightCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "rightCenter",  new Vertex2d(null),  'leftCenter');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wFunc(snapLoc, .5), hFunc(snapLoc, 0)));
	  snapLoc.at();
	  return snapLoc;
	}
	
	SnapSquare.backLeft = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "backLeft",  new Vertex2d(null),  'backRight');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wFunc(snapLoc, -.5), hFunc(snapLoc, -.5)));
	  snapLoc.wallThetaOffset(-90);
	  snapLoc.thetaOffset('SnapCorner', null, 270);
	  snapLoc.thetaOffset('SnapCornerL', null, 270);
	  snapLoc.at();
	  return snapLoc;
	}
	SnapSquare.backRight = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "backRight",  new Vertex2d(null),  'backLeft');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wFunc(snapLoc, .5), hFunc(snapLoc, -.5)));
	  snapLoc.wallThetaOffset(90);
	  snapLoc.thetaOffset('SnapCorner', null, 180);
	  snapLoc.thetaOffset('SnapCornerL', null, 180);
	  snapLoc.at();
	  return snapLoc;
	}
	
	SnapSquare.frontRight = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontRight",  new Vertex2d(null),  'frontLeft');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wFunc(snapLoc, .5), hFunc(snapLoc, .5)));
	  snapLoc.thetaOffset('SnapCorner', null, 180);
	  snapLoc.thetaOffset('SnapCornerL', null, 180);
	  snapLoc.at();
	  return snapLoc;
	}
	SnapSquare.frontLeft = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontLeft",  new Vertex2d(null),  'frontRight');
	  snapLoc.locationFunction(fromToPoint(snapLoc, wFunc(snapLoc, -.5), hFunc(snapLoc, .5)));
	  snapLoc.thetaOffset('SnapCorner', null, 270);
	  snapLoc.thetaOffset('SnapCornerL', null, 270);
	  snapLoc.at();
	  return snapLoc;
	}
	
	module.exports = SnapSquare;
	
});


RequireJS.addFunction('./app-src/objects/joint/joints/miter.js',
function (require, exports, module) {
	

	
	const Joint = require('../joint.js');
	
	class Miter extends Joint {
	  constructor(joinStr) {
	    super(joinStr);
	  }
	}
	
	Joint.register(Miter);
	module.exports = Miter
	
	
	
	
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/cutter.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	
	class Cutter extends Assembly {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig) {
	    super(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	    this.included(false);
	  }
	}
	Cutter.abbriviation = 'cut';
	
	module.exports = Cutter;
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/divider.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	
	class Divider extends Assembly {
	  constructor(partCode, partName, toModel) {
	    super(partCode, partName);
	
	    this.toModel = toModel;
	  }
	}
	Divider.count = 0;
	
	Divider.abbriviation = 'dv';
	
	module.exports = Divider
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/cabinet.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	const cabinetBuildConfig = require('../../../../public/json/cabinets.json');
	const Joint = require('../../joint/joint.js');
	const CabinetOpeningCorrdinates = require('../../../services/cabinet-opening-coordinates.js');
	const SectionProperties = require('./section/section-properties.js');
	const Measurement = require('../../../../../../public/js/utils/measurement.js');
	const PropertyConfig = require('../../../config/property/config.js');
	const Group = require('../../group');
	const Line2d = require('../../../two-d/objects/line');
	const Vertex2d = require('../../../two-d/objects/vertex');
	const Vertex3D = require('../../../three-d/objects/vertex');
	const CSG = require('../../../../public/js/3d-modeling/csg.js');
	
	const OVERLAY = {};
	OVERLAY.FULL = 'Full';
	OVERLAY.HALF = 'Half';
	OVERLAY.INSET = 'Inset';
	
	const CABINET_TYPE = {FRAMED: 'Framed', FRAMELESS: 'Frameless'};
	
	class Cabinet extends Assembly {
	  constructor(partCode, partName) {
	    super(partCode, partName);
	    Object.getSet(this, {_DO_NOT_OVERWRITE: true}, 'length', 'width', 'thickness');
	    Object.getSet(this, 'propertyId', 'name');
	    const instance = this;
	    let toeKickHeight = 4;
	    this.part = false;
	    this.display = false;
	    this.overlay = OVERLAY.HALF;
	    this.openings = [];
	    this.type = CABINET_TYPE.FRAMED;
	    const panels = 0;
	    const framePieces = 0;
	    const addFramePiece = (piece) => framePieces.push(piece);
	    const framePieceCount = () => pieces.length;
	    const addPanel = (panel) => panels.push(panel);
	    const panelCount = () => panels.length;
	
	    const resolveOuterReveal = (panel, location) => {
	      const propConfig = this.propertyConfig();
	      if (propConfig.isInset()) {
	        return new Measurement(-1 * props.Inset.is.value()).value();
	      }
	      const definedValue = panel.railThickness() - panel.value(location);
	      let calculatedValue;
	      if (propConfig.isReveal()) {
	        calculatedValue = panel.railThickness() - propConfig.reveal();
	      } else {
	        calculatedValue = propConfig.overlay();
	      }
	      return calculatedValue < definedValue ? calculatedValue : definedValue;
	    }
	
	    function bordersByIds(borderIds) {
	      const borders = {};
	      const center = borderIds.center;
	      borders.right = instance.getAssembly(borderIds.right);
	      borders.left = instance.getAssembly(borderIds.left);
	      borders.top = instance.getAssembly(borderIds.top);
	      borders.bottom = instance.getAssembly(borderIds.bottom);
	
	      const pb = instance.getAssembly(borderIds.back);
	
	      return () => {
	        const depth = pb.position().center('z') + pb.position().limits('-z');
	
	        const position = {};
	        const propConfig = instance.propertyConfig();
	        if (propConfig.isReveal()) {
	          const revealProps = propConfig.reveal();
	          position.right = borders.right.position().centerAdjust('x', '+z') - revealProps.rvr.value();
	          position.left = borders.left.position().centerAdjust('x', '-z') + revealProps.rvl.value();
	          position.top = borders.top.position().centerAdjust('y', '+z') - revealProps.rvt.value();
	          position.bottom = borders.bottom.position().centerAdjust('y', '-z') + revealProps.rvb.value();
	        } else if (propConfig.isInset()) {
	          const insetValue = propConfig('Inset').is.value();
	          position.right = borders.right.position().centerAdjust('x', '-z') - insetValue;
	          position.left = borders.left.position().centerAdjust('x', '+z') + insetValue;
	          position.top = borders.top.position().centerAdjust('y', '-z') - insetValue;
	          position.bottom = borders.bottom.position().centerAdjust('y', '+z') + insetValue;
	        } else {
	          const ov = propConfig('Overlay').ov.value();
	          position.right = borders.right.position().centerAdjust('x', '-z') + ov;;
	          position.left = borders.left.position().centerAdjust('x', '+z') - ov;
	          position.top = borders.top.position().centerAdjust('y', '-z') + ov;
	          position.bottom = borders.bottom.position().centerAdjust('y', '+z') - ov;
	        }
	
	        position.front = 0;
	        position.back = pb.position().center('z') + pb.position().limits('-z');
	
	        return {borders, position, depth, borderIds, center};
	      }
	    }
	
	    function bordersByEndPoints (borderObj) {
	      const bo = borderObj;
	
	      return () => {
	        const rotation = {x: 0, z: 0, y: instance.eval(borderObj.zRotation)};
	        let evaluated;
	
	        let points;
	        const propConfig = instance.propertyConfig();
	        if (propConfig.isReveal()) {
	          points = instance.evalObject(bo.outer);
	        } else {
	          points = instance.evalObject(bo.inner);
	        }
	
	        const pointArr = [points.top.left, points.top.right, points.bottom.right, points.bottom.left];
	        let center = Vertex3D.center.apply(null, pointArr);
	        // CSG.rotatePointsAroundCenter(rotation, pointArr, center, true);
	
	        const width = new Vertex3D(points.top.left).distance(new Vertex3D(points.top.right));
	        const length = new Vertex3D(points.bottom.left).distance(new Vertex3D(points.top.left));
	
	        //TODO: calculate real value;
	        const depth = 20 * 2.54;
	
	        const position = {};
	        if (propConfig.isReveal()) {
	          const revealProps = propConfig.reveal();
	          position.right = center.x + width/2 - revealProps.rvr.value();
	          position.left = center.x - width/2 + revealProps.rvl.value();
	          position.top = center.y + length/2 - revealProps.rvt.value();
	          position.bottom = center.y - length/2 + revealProps.rvb.value();
	        } else if (propConfig.isInset()) {
	          const insetValue = propConfig('Inset').is.value();
	          position.right = center.x + width/2 - insetValue;
	          position.left = center.x - width/2 + insetValue;
	          position.top = center.y + length/2 - insetValue;
	          position.bottom = center.y - length/2 + insetValue;
	        } else {
	          const ov = propConfig('Overlay').ov.value();
	          position.right = center.x + width/2 + ov;;
	          position.left = center.x - width/2 - ov;
	          position.top = center.y + length/2 + ov;
	          position.bottom = center.y - length/2 - ov;
	        }
	
	        return {position, depth, center, rotation};
	      }
	    }
	
	    this.borders = (borderObj) => {
	      if (borderObj.inner) return bordersByEndPoints(borderObj);
	      return bordersByIds(borderObj);
	    }
	  }
	}
	
	Cabinet.build = (type, group, config) => {
	  group ||= new Group();
	  const cabinet = new Cabinet('c', type);
	  cabinet.group(group);
	  config ||= cabinetBuildConfig[type];
	  config.values.forEach((value) => cabinet.value(value.key, value.eqn));
	
	  config.subassemblies.forEach((subAssemConfig) => {
	    const type = subAssemConfig.type;
	    const name = subAssemConfig.name;
	    const demStr = subAssemConfig.demensions.join(',');
	    const centerConfig = subAssemConfig.center.join(',');
	    const rotationConfig = subAssemConfig.rotation.join(',');
	    const subAssem = Assembly.new(type, subAssemConfig.code, name, centerConfig, demStr, rotationConfig);
	    subAssem.partCode(subAssemConfig.code);
	    cabinet.addSubAssembly(subAssem);
	  });
	
	  config.joints.forEach((relationConfig) => {
	    const type = relationConfig.type;
	    const depth = relationConfig.depth;
	    const demensionToOffset = relationConfig.demensionToOffset;
	    const centerOffset = relationConfig.centerOffset;
	    const joint = Joint.new(type, relationConfig);
	    cabinet.addJoints(joint);
	  });
	
	  config.openings.forEach((config) => {
	    const sectionProperties = new SectionProperties(config);
	    const cabOpenCoords = new CabinetOpeningCorrdinates(cabinet, config, sectionProperties);
	    cabinet.openings.push(cabOpenCoords);
	    cabinet.addSubAssembly(sectionProperties);
	    cabOpenCoords.update();
	  });
	  return cabinet;
	}
	
	Cabinet.fromJson = (assemblyJson, group) => {
	  group ||= new Group();
	  const partCode = assemblyJson.partCode;
	  const partName = assemblyJson.partName;
	  const assembly = new Cabinet(partCode, partName);
	  assembly.name(assemblyJson.name);
	  assembly.length(assemblyJson.length);
	  assembly.width(assemblyJson.width);
	  assembly.group(group);
	  assembly.id(assemblyJson.id);
	  assembly.values = assemblyJson.values;
	  Object.values(assemblyJson.subassemblies).forEach((json) => {
	    const clazz = Assembly.class(json._TYPE);
	    json.parent = assembly;
	    if (clazz !== SectionProperties) {
	      assembly.addSubAssembly(Object.fromJson(json));
	    } else {
	      const sectionProperties = clazz.fromJson(json, assembly);
	      assembly.openings.push(sectionProperties);
	      assembly.addSubAssembly(sectionProperties);
	    }
	  });
	  assembly.thickness(assemblyJson.thickness);
	  const joints = Object.fromJson(assemblyJson.joints);
	  assembly.addJoints.apply(assembly, joints);
	  return assembly;
	}
	Cabinet.abbriviation = 'c';
	
	function getIntersectPoint(line, centerLine, right, dist, gap, noneAdjacent) {
	  if (noneAdjacent) {
	    if (right)
	      return centerLine.endVertex();
	    return centerLine.startVertex();
	  }
	  const parr = line.parrelle(dist);
	  if (line.isParrelle(centerLine)) {
	    if (right)
	      return parr.trimmed(gap/2).startVertex();
	    return parr.trimmed(gap/-2).endVertex();
	  }
	  return centerLine.findIntersection(parr);
	}
	
	// document location /cabinet/html/docs/door-intersect-diagram.html
	function doorIntersect(llp, lcp, rcp, rrp, ld, cd, rd, gap, padOffset) {
	  padOffset ||= 0;
	  const LL = new Line2d(llp, lcp);
	  const CL = new Line2d(lcp, rcp);
	  const RL = new Line2d(rcp, rrp);
	
	  const CLFP = CL.parrelle(cd + padOffset);
	
	  const cxlp = getIntersectPoint(LL, CLFP, false, ld + padOffset, gap, !llp);
	  const cxrp = getIntersectPoint(RL, CLFP, true, rd + padOffset, gap, !rrp);
	
	  const centerFrontTrimmed = new Line2d(cxlp, cxrp).trimmed(gap, true);
	  const centerBackTrimmed = centerFrontTrimmed.parrelle(-1 * cd);
	  const tsp = centerFrontTrimmed.startVertex();
	  const tep = centerFrontTrimmed.endVertex();
	  const clrs = CL.closestPointOnLine(tsp);
	  const crrs = CL.closestPointOnLine(tep);
	
	  const centerRightSide = new Line2d(crrs, tep);
	  const centerLeftSide = new Line2d(clrs, tsp);
	
	  const info = {center: {left: {}, right: {}}, left: {}, right: {}};
	
	
	  info.center.center = Vertex2d.center(tsp, tep, centerBackTrimmed.startVertex(), centerBackTrimmed.endVertex());
	  info.center.length = centerFrontTrimmed.length();
	  info.center.left.reveal = clrs.distance(lcp) * (CL.isOn(clrs) ? 1 : -1);
	  info.center.right.reveal = crrs.distance(rcp) * (CL.isOn(crrs) ? 1 : -1);
	
	  if (rrp){
	    const rrsp = RL.closestPointOnLine(cxrp);
	    const rightSide = new Line2d(rrsp, cxrp);
	    const rightGapTheta = CL.thetaBetween(RL);
	    const rightGapLine = Line2d.startAndTheta(rcp, CL.negitive().radians() + rightGapTheta / 2);
	    info.right.reveal = rrsp.distance(rcp) * (RL.isOn(rrsp) ? 1 : -1);
	    if (rightGapTheta > Math.PI) {
	      info.right.theta = rightGapLine.thetaBetween(rightSide);
	      info.center.right.theta = centerRightSide.thetaBetween(rightGapLine);
	    } else if (info.center.right.reveal < 0) {
	      //For meeting walls or other flat surfaces
	      info.center.right.theta = centerRightSide.thetaBetween(RL);
	    }
	  }
	
	  if (llp) {
	    const lrsp = LL.closestPointOnLine(cxlp);
	    info.left.reveal = lrsp.distance(lcp) * (LL.isOn(lrsp) ? 1 : -1);
	    const leftGapTheta = LL.thetaBetween(CL);
	    if (leftGapTheta > Math.PI) {
	      const leftSide = new Line2d(lrsp, cxlp);
	      const leftGapLine = Line2d.startAndTheta(rcp, CL.radians() - leftGapTheta / 2);
	      info.left.theta = leftSide.thetaBetween(leftGapLine);
	      info.center.left.theta = leftGapLine.thetaBetween(centerLeftSide);
	    } else if (info.center.left.reveal < 0) {
	      //For meeting walls or other flat surfaces
	      info.center.left.theta = LL.thetaBetween(centerRightSide);
	    }
	  }
	
	  return info;
	}
	
	Cabinet.doorIntersect = doorIntersect;
	
	module.exports = Cabinet
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/panel.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	
	class Panel extends Assembly {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig) {
	    super(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	
	    this.railThickness = () => this.thickness();
	    Object.getSet(this, {hasFrame: false});
	  }
	}
	
	Panel.abbriviation = 'pn';
	
	class PanelModel extends Panel {
	  constructor(partCode, partName, toModel) {
	    super(partCode, partName);
	    this.toModel = toModel;
	  }
	}
	
	Panel.Model = PanelModel;
	module.exports = Panel
	
});


RequireJS.addFunction('./app-src/objects/joint/joints/rabbet.js',
function (require, exports, module) {
	

	
	const Joint = require('../joint.js');
	
	class Rabbet extends Joint {
	  constructor(joinStr, defaultDepth, axis, centerOffset) {
	    super(joinStr);
	    this.maleOffset = (assembly) => {
	      return defaultDepth;
	    }
	
	    if (axis === undefined) return;
	
	    this.updatePosition = (position) => {
	      const direction = centerOffset[0] === '-' ? -1 : 1;
	      const centerAxis = centerOffset[1];
	      position.demension[axis] += defaultDepth;
	      position.center[centerAxis] += defaultDepth/2 * direction;
	    };
	  }
	}
	
	Joint.register(Rabbet);
	module.exports = Rabbet
	
	
	
	
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/frame.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	
	class Frame extends Assembly {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig) {
	    super(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	  }
	}
	
	Frame.abbriviation = 'fr';
	
	
	module.exports = Frame
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/hardware/pull.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	const CSG = require('../../../../../public/js/3d-modeling/csg.js');
	const pull = require('../../../../three-d/models/pull.js');
	/*
	    a,b,c
	    d,e,f
	    g,h,i
	*/
	class Handle extends Assembly {
	  constructor(partCode, partName, door, location, index, count) {
	    let instance;
	    location ||= Handle.location.CENTER;
	    function baseCenter() {
	      let center;
	      const edgeOffset = (19 * 2.54) / 16;
	      const toCenter = 3 * 2.54 + instance.centerToCenter() / 2;
	      const front = door.front();
	      const top = front.line(0);
	      // TODO: Maybe... not sure why these are flipped.
	      const left = front.line(-1);
	      const right = front.line(1);
	      const bottom = front.line(2);
	
	      switch (instance.location()) {
	        case Handle.location.TOP_RIGHT:
	          center = top.endVertex;
	          center.translate(top.vector().unit().scale(-edgeOffset));
	          center.translate(right.vector().unit().scale(toCenter));
	          break;
	        case Handle.location.TOP_LEFT:
	          center = top.startVertex;
	          center.translate(top.vector().unit().scale(edgeOffset));
	          center.translate(left.vector().unit().scale(-toCenter));
	          break;
	        case Handle.location.BOTTOM_RIGHT:
	          center = bottom.startVertex;
	          center.translate(bottom.vector().unit().scale(edgeOffset));
	          center.translate(right.vector().unit().scale(-toCenter));
	          break;
	        case Handle.location.BOTTOM_LEFT:
	          center = bottom.endVertex;
	          center.translate(bottom.vector().unit().scale(-edgeOffset));
	          center.translate(left.vector().unit().scale(toCenter));
	          break;
	        case Handle.location.TOP:
	          center = top.midpoint();
	          center.translate(right.vector().unit().scale(edgeOffset));
	          break;
	        case Handle.location.BOTTOM:
	          center = bottom.midpoint();
	          center.translate(right.vector().unit().scale(-edgeOffset));
	          break;
	        case Handle.location.RIGHT:
	          center = right.midpoint();
	          center.translate(top.vector().unit().scale(-edgeOffset));
	          break;
	        case Handle.location.LEFT:
	          center = left.midpoint();
	          center.translate(top.vector().unit().scale(edgeOffset));
	          break;
	        case Handle.location.CENTER:
	          center = front.center();
	          break;
	        break;
	        default:
	          throw new Error('Invalid pull location');
	      }
	      return center;
	    };
	
	    super(`${partCode}-${location.position.toKebab()}`, 'Handle');
	    Object.getSet(this, {location});
	    instance = this;
	    index = index || 0;
	    count = count || 1;
	
	    this.count = (c) => {
	      if (c > 0) {
	        count = c;
	      }
	      return count;
	    }
	
	    function offset(center, distance) {
	      const spacing = distance / count;
	      return center - (distance / 2) + spacing / 2 + spacing * (index);
	    }
	
	    this.toModel = () => {
	      const baseC = baseCenter();
	      const biPolygon = door.biPolygon();
	      const front = biPolygon.front();
	      const rotated =  instance.location().rotate;
	      const line = rotated ? front.line(-1) : front.line(0);
	      const normal = biPolygon.normal();
	      return pull(baseC, line, normal, this.projection(), this.centerToCenter());
	    }
	
	    this.projection = () => 2.54;
	    this.centerToCenter = () => 9.6;
	  }
	}
	Handle.location = {};
	Handle.location.TOP_RIGHT = {rotate: true, position: 'TOP_Right'};
	Handle.location.TOP_LEFT = {rotate: true, position: 'TOP_LEFT'};
	Handle.location.BOTTOM_RIGHT = {rotate: true, position: 'BOTTOM_RIGHT'};
	Handle.location.BOTTOM_LEFT = {rotate: true, position: 'BOTTOM_LEFT'};
	Handle.location.TOP = {multiple: true, position: 'TOP'};
	Handle.location.BOTTOM = {multiple: true, position: 'BOTTOM'};
	Handle.location.RIGHT = {multiple: true, rotate: true, position: 'RIGHT'};
	Handle.location.LEFT = {multiple: true, rotate: true, position: 'LEFT'};
	Handle.location.CENTER = {multiple: true, position: 'CENTER'};
	
	Handle.abbriviation = 'hn';
	
	
	module.exports = Handle
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/section/section-properties.js',
function (require, exports, module) {
	
const Vertex3D = require('../../../../three-d/objects/vertex.js');
	const Polygon3D = require('../../../../three-d/objects/polygon.js');
	const Line3D = require('../../../../three-d/objects/line.js');
	const Plane = require('../../../../three-d/objects/plane.js');
	const BiPolygon = require('../../../../three-d/objects/bi-polygon.js');
	const KeyValue = require('../../../../../../../public/js/utils/object/key-value.js');
	const Notification = require('../../../../../../../public/js/utils/collections/notification.js');
	const Assembly = require('../../assembly.js');
	const CSG = require('../../../../../public/js/3d-modeling/csg.js');
	const DividerSection = require('./partition/divider.js');
	const Pattern = require('../../../../division-patterns.js');
	
	const v = () => new Vertex3D();
	class SectionProperties extends KeyValue{
	  constructor(config, index) {
	    super({childrenAttribute: 'sections', parentAttribute: 'parentAssembly'})
	
	    index ||= 0;
	    this.index = () => index;
	    const coordinates = {inner: [v(),v(),v(),v()], outer: [v(),v(),v(),v()]};
	    let rotation, innerCenter, outerCenter, outerLength, innerLength, outerWidth, innerWidth = null;
	    const temporaryInitialVals = {parent, _TEMPORARY: true};
	    Object.getSet(this, temporaryInitialVals);
	    Object.getSet(this, {divideRight: false}, 'divider', 'parentAssembly', 'cover');
	    const instance = this;
	    let pattern;
	
	    this.partCode = () => {
	      const oreintation = this.vertical() ? 'V' : 'H';
	      if (index === 0) return oreintation;
	      const pPartCode = this.parentAssembly().partCode();
	      return `${pPartCode}${index}${this.sections.length > 1 ? oreintation : ''}`;
	    }
	    this.coordinates = () => JSON.clone(coordinates);
	    this.reverseInner = () => CSG.reverseRotateAll(this.coordinates().inner);
	    this.reverseOuter = () => CSG.reverseRotateAll(this.coordinates().outer);
	    this.part = () => false;
	    this.included = () => false;
	    this.joints = [];
	    this.subassemblies = [];
	    this.vertical = (is) => {
	      const curr = instance.value('vertical', is);
	      if (is !== undefined && curr !== is) removeCachedValues();
	      return curr;
	    }
	    this.isVertical = () => this.sections.length < 2 ? undefined : this.vertical();
	    this.verticalDivisions = () => {
	      const parent = this.parentAssembly();
	      if (parent instanceof SectionProperties) return parent.isVertical();
	      return false;
	    }
	    this.rotation = () => {
	      if (config.rotation === undefined || config._Type === 'part-code') return {x:0,y:0,z:0};
	      if (true || rotation === null) rotation = this.getRoot().evalObject(config.rotation);
	      return JSON.copy(rotation);
	    }
	
	    this.getCabinet = () => {
	      const root = this.getRoot();
	      return root.constructor.name === 'Cabinet' ? root : undefined;
	    }
	
	    this.innerDepth = () => {
	      const cabinet = this.getCabinet();
	      if (cabinet && (config.rotation === undefined || config._Type === 'part-code'))
	        return cabinet.getAssembly(config.back).position().centerAdjust('z', '-z');
	      // TODO: access Variable.
	      return 4*2.54;
	    };
	
	    function offsetCenter(center, left, right, up, down, forward, backward) {
	      center = JSON.copy(center);
	      const offset = {
	        x: (right - left) / 2,
	        y: (up - down) / 2,
	        z: (forward - backward) / 2
	      }
	      const rotated = CSG.rotatePointAroundCenter(instance.rotation(), offset, {x:0,y:0, z:0});
	
	      return {x: center.x + rotated.x, y: center.y + rotated.y, z: center.z + rotated.z};
	    }
	
	    function offsetRotatedPoint(point, x, y, z, rotation) {
	      rotation ||= instance.rotation();
	      point = JSON.copy(point);
	      const originalPosition = CSG.reverseRotate(point, rotation);
	      originalPosition.x += x;
	      originalPosition.y += y;
	      originalPosition.z += z;
	      return CSG.rotate(originalPosition, rotation);
	    }
	    this.offsetRotatedPoint = offsetRotatedPoint;
	    this.transRotate = CSG.transRotate;
	
	    function offsetPoint(point, x, y, z) {
	      const offset = {x,y,z};
	      return CSG.transRotate(point, offset, instance.rotation());
	    }
	    this.offsetPoint = offsetPoint;
	
	    function init () {
	      if (instance.sections.length === 0) {
	        instance.sections.push(new SectionProperties({rotation: config.rotation, back: config.back, flipNormal: config.flipNormal}, 1));
	      }
	    }
	
	    this.init = init;
	    this.dividerCount = () => this.sections.length - 1;
	    this.sectionCount = () => this.sections.length;
	    this.children = () => this.sections;
	    this.getSubassemblies = () => {
	      const assems = Object.values(this.sections);
	      const cover = this.cover()
	      if (cover) assems.concatInPlace(cover.getSubassemblies());
	      if (this.divideRight()) assems.concatInPlace(this.divider().getSubassemblies());
	      for (let index = 0; index < this.sections.length; index++) {
	        assems.concatInPlace(this.sections[index].getSubassemblies());
	      }
	      return assems;
	    }
	
	    this.propertyConfig = () => this.getCabinet().propertyConfig();
	
	    this.getAssembly = (partCode, callingAssem) => {
	      if (callingAssem === this) return undefined;
	      if (this.partCode() === partCode) return this;
	      if (this.subassemblies[partCode]) return this.subassemblies[partCode];
	      if (callingAssem !== undefined) {
	        const children = Object.values(this.subassemblies);
	        for (let index = 0; index < children.length; index += 1) {
	          const assem = children[index].getAssembly(partCode, this);
	          if (assem !== undefined) return assem;
	        }
	      }
	      if (this.parentAssembly() !== undefined && this.parentAssembly() !== callingAssem)
	        return this.parentAssembly().getAssembly(partCode, this);
	      return undefined;
	    }
	
	    function makePlane1ToMeetPlane2(plane1, plane2, rotation) {
	      const rotated1 = CSG.reverseRotate(plane1, rotation);
	      const rotated2 = CSG.reverseRotate(plane2, rotation);
	      const center1 = Vertex3D.center(rotated1);
	      if (approximate.eq(center1.z, 0)) throw new Error('Invalid planeRotation: Rotation reversed should make plane1.z === 0');
	      const keep1 = [];
	      const keep2 = [];
	      const intersections = [];
	      const plane2Line2d = Line2d.combine(new Line2d(rotated2[0], rotated2[1]), new Line2d(rotated2[2], rotated2[3]));
	      const p2l2Midpoint = plane2Line2d.midPoint();
	      const len = plane1.length;
	      let keep = keep1;
	      for (let index = 0; index < plane1.length; index++) {
	        const nextIndex = (index + 1) % len;
	        const prevIndex = (index + 1) % len;
	        const positiveLine = new Line2d(plane1[nextIndex], plane1[index]);
	        const negativeLine = new Line2d(plane1[prevIndex], plane1[index]);
	        const intersection1 = plane2Line2d.findDirectionalIntersection(positiveLine);
	        const intersection2 = plane2Line2d.findDirectionalIntersection(negativeLine);
	        if (intersections.length > 0) keep = keep2;
	        if (!intersection1 && !intersection2) keep.push(plan1[index]);
	        else if (!intersection1) intersections.push(intersection2);
	        else if (!intersection2) intersections.push(intersection1);
	        else {
	          const dist1 = p2l2Midpoint.distance(intersection1);
	          const dist2 = p2l2Midpoint.distance(intersection2);
	          intersections.push(dist1 > dist2 ? intersection1 : intersection2);
	        }
	      }
	      plane1.removeAll();
	      plane1.concat(keep1.concat(intersections).concat(keep2));
	    }
	
	    // function updateDividerCoordinates(section, patVal, dividerOffsetInfo) {
	    //   const pos = section.position();
	    //   const dOffset = dividerOffsetInfo[index];
	    //   const widthOffset = section.maxWidth() / 2;
	    //   const divideCenter = dOffset + patVal + widthOffset;
	    //   pos.depth = instance.innerDepth();
	    //   if (instance.vertical()) {
	    //     pos.center = {y: divideCenter};
	    //     pos.center.x = instance.innerCenter().x;
	    //     pos.length = instance.innerWidth();
	    //   } else {
	    //     pos.center = {x: divideCenter};
	    //     pos.center.y = instance.innerCenter().y;
	    //     pos.length = instance.innerLength();
	    //   }
	    //   pos.center.z = pos.depth / 2
	    //
	    // }
	
	    function updatdSectionPropertiesCoordinates(section, startOuter, startInner, endInner, endOuter, innerOffset) {
	      const coords = {};
	      const fresh = instance.coordinates();
	      const outer = fresh.outer;
	      const inner = fresh.inner;
	      const rotation = instance.rotation();
	      if (!instance.vertical()) {
	        const leftOutLine = new Line3D(outer[3], outer[0]);
	        const leftInnerLine = new Line3D(inner[3], inner[0]);
	        const rightOutLine = new Line3D(outer[2], outer[1]);
	        const rightInnerLine = new Line3D(inner[2], inner[1]);
	        coords.outer = [leftOutLine.pointAtDistance(endOuter),
	                        rightOutLine.pointAtDistance(endOuter),
	                        rightOutLine.pointAtDistance(startOuter),
	                        leftOutLine.pointAtDistance(startOuter)];
	        coords.inner = [leftInnerLine.pointAtDistance(endInner - innerOffset),
	                        rightInnerLine.pointAtDistance(endInner - innerOffset),
	                        rightInnerLine.pointAtDistance(startInner - innerOffset),
	                        leftInnerLine.pointAtDistance(startInner - innerOffset)];
	
	      } else {
	        const topOutLine = new Line3D(outer[0], outer[1]);
	        const topInnerLine = new Line3D(inner[0], inner[1]);
	        const bottomOutLine = new Line3D(outer[3], outer[2]);
	        const bottomInnerLine = new Line3D(inner[3], inner[2]);
	        coords.outer = [topOutLine.pointAtDistance(startOuter),
	                        topOutLine.pointAtDistance(endOuter),
	                        bottomOutLine.pointAtDistance(endOuter),
	                        bottomOutLine.pointAtDistance(startOuter)];
	        coords.inner = [topInnerLine.pointAtDistance(startInner - innerOffset),
	                        topInnerLine.pointAtDistance(endInner - innerOffset),
	                        bottomInnerLine.pointAtDistance(endInner - innerOffset),
	                        bottomInnerLine.pointAtDistance(startInner - innerOffset)];
	      }
	      section.updateCoordinates(coords);
	    }
	
	    this.dividerLayout = () => {
	      init();
	      const dividerOffsetInfo = instance.dividerOffsetInfo();
	      const coverage = instance.coverage(dividerOffsetInfo.startOffset, dividerOffsetInfo.endOffset);
	      return instance.pattern().calc(coverage._TOTAL);
	    }
	
	    function setSectionCoordinates() {
	      const dividerOffsetInfo = instance.dividerOffsetInfo();
	      const coverage = instance.coverage(dividerOffsetInfo.startOffset, dividerOffsetInfo.endOffset);
	
	      if (coverage.length > 1) {
	        const patternInfo = instance.pattern().calc(coverage._TOTAL);
	
	        let offset = 0;
	        const innerOffset = dividerOffsetInfo[0].offset;
	        for (let index = 0; index < instance.sections.length; index++) {
	          const section = instance.sections[index];
	          const patVal = patternInfo.list;
	          const overlayOffset = coverage[index * 2].overlay + coverage[index * 2 + 1].overlay;
	          let startOuter, startInner, endInner, endOuter;
	
	          startOuter = offset;
	          if (index === 0) startInner = startOuter + dividerOffsetInfo[index].offset;
	          else startInner = startOuter + dividerOffsetInfo[index].offset/2;
	
	
	          endInner = startInner + patVal[index] - overlayOffset;
	          if (index === instance.sections.length - 1) endOuter = endInner + dividerOffsetInfo[index + 1].offset;
	          else endOuter = endInner + dividerOffsetInfo[index + 1].offset / 2;
	          if (index < instance.sections.length - 1) section.divideRight(true);
	          updatdSectionPropertiesCoordinates(section, startOuter, startInner, endInner, endOuter, innerOffset);
	          offset = endOuter;
	        }
	      }
	    }
	
	    function perpendicularDistance(point, line) {
	      if (instance.sectionCount() !== 0) {
	        const plane = Plane.fromPointNormal(point, line.vector());
	        const intersection = plane.lineIntersection(line);
	        const distance = line.startVertex.distance(intersection);
	        return distance;
	      }
	      return 0;
	    }
	
	    this.coverage = (startOffset, endOffset) => {
	      const info = [];
	      const propConfig = this.propertyConfig();
	      const isReveal = propConfig.isReveal();
	      const isInset = propConfig.isInset();
	      const vertical = instance.vertical();
	      info._TOTAL = isReveal ?
	              (!vertical ? instance.outerLength() : instance.outerWidth()) :
	              (!vertical ? instance.innerLength() : instance.innerWidth());
	
	      let overlay, reveal, insetValue;
	      if (isReveal) reveal = propConfig.reveal().r.value();
	      else if (propConfig.isInset()) insetValue = propConfig('Inset').is.value();
	      else overlay = propConfig.overlay();
	
	      for (let index = 0; index < this.sections.length * 2; index += 1) {
	        const section = this.sections[Math.ceil((index - 1)/2)];
	        let offset = 0;
	        const divider = section.divider();
	        if (isReveal) {
	          if (index % 2 === 0) {
	            if (index === 0) info._TOTAL -= reveal;
	            else info._TOTAL -= reveal;
	          }
	          if (index === 0) info.push({overlay: startOffset - reveal / 2});
	          if (index === this.sections.length - 1) info.push({overlay: endOffset - reveal / 2});
	          else info.push({overlay: (divider.maxWidth() - reveal)/2});
	        }  else if (isInset) {
	          if (index % 2 === 0) {
	            if (index === this.sections.length * 2 - 2) info._TOTAL -= insetValue * 2;
	            else info._TOTAL -= (divider.maxWidth() + insetValue * 2);
	          }
	          info.push({overlay: -insetValue});
	        } else {
	          if (index % 2 === 0) {
	            if (index === this.sections.length * 2 - 2) info._TOTAL += overlay * 2;
	            else info._TOTAL += overlay * 2 - divider.maxWidth();
	          }
	          info.push({overlay: overlay});
	        }
	      }
	      return info;
	    }
	
	    this.dividerOffsetInfo = () => {
	      let startOffset = 0;
	      let endOffset = 0;
	
	      const coords = this.coordinates();
	      const outer = coords.outer;
	      const inner = coords.inner;
	      if (this.vertical()) {
	         startOffset = perpendicularDistance(outer[0], new Line3D(inner[0], inner[1]));
	         endOffset = perpendicularDistance(outer[1], new Line3D(inner[0], inner[1]));
	       } else {
	         startOffset = perpendicularDistance(outer[0], new Line3D(inner[0], inner[3]));
	         endOffset = perpendicularDistance(outer[3], new Line3D(inner[3], inner[0]));
	       }
	       const info = [{offset: startOffset}];
	       info.startOffset = startOffset;
	       info.endOffset = endOffset;
	
	      let offset = this.isVertical() ? this.outerLength() : this.outerWidth();
	      const propConfig = this.propertyConfig();
	      for (let index = 0; index < this.sections.length; index += 1) {
	        if (index < this.sections.length - 1) {
	          const section = this.sections[index];
	          const divider = section.divider();
	          const offset = divider.maxWidth();
	          info[index + 1] = {offset, divider};
	        } else {
	          info[index + 1] = {offset: endOffset};
	        }
	      }
	      return info;
	    }
	
	    this.divide = (dividerCount) => {
	      init();
	      if (!Number.isNaN(dividerCount) && dividerCount !== this.dividerCount()) {
	        dividerCount = dividerCount > 10 ? 10 : dividerCount;
	        dividerCount = dividerCount < 0 ? 0 : dividerCount;
	        const currDividerCount = this.dividerCount();
	        if (dividerCount < currDividerCount) {
	          const diff = currDividerCount - dividerCount;
	          this.sections.splice(dividerCount + 1);
	          setSectionCoordinates();
	          return true;
	        } else {
	          const diff = dividerCount - currDividerCount;
	          for (let index = currDividerCount; index < dividerCount; index +=1) {
	            const section = new SectionProperties({rotation: config.rotation, back: config.back, flipNormal: config.flipNormal}, index + 2);
	            this.sections.push(section);
	          }
	          if (diff !== 0) setSectionCoordinates();
	          return diff !== 0;
	        }
	      }
	      return false;
	    }
	
	    this.pattern = (patternStr) => {
	      if ((typeof patternStr) === 'string') {
	        const sectionCount = patternStr.length;
	        this.divide(sectionCount - 1);
	        pattern = new Pattern(patternStr);
	      } else {
	        if (!pattern || pattern.str.length !== this.sectionCount())
	          pattern = new Pattern(new Array(this.sectionCount()).fill('a').join(''));
	      }
	      return pattern;
	    }
	
	    this.outerCenter = () => {
	      if (true || outerCenter === null) outerCenter = Vertex3D.center(coordinates.outer);
	      return outerCenter;
	    }
	
	    this.innerCenter = () => {
	      if (true || innerCenter === null) innerCenter = Vertex3D.center(coordinates.inner);
	      return innerCenter;
	    }
	
	    this.outerLength = () => {
	      if (true || outerLength === null)
	        outerLength = coordinates.outer[0].distance(coordinates.outer[3]);
	      return outerLength;
	    }
	
	    this.outerWidth = () => {
	      if (true || outerWidth === null)
	        outerWidth = coordinates.outer[0].distance(coordinates.outer[1]);
	      return outerWidth;
	    }
	
	    this.innerLength = () => {
	      if (true || innerLength === null)
	        innerLength = coordinates.inner[0].distance(coordinates.inner[3]);
	      return innerLength;
	    }
	
	    this.innerWidth = () => {
	      if (true || innerWidth === null)
	        innerWidth = coordinates.inner[0].distance(coordinates.inner[1]);
	      return innerWidth;
	    }
	
	    this.longestRadius = () => {
	      const oc = this.outerCenter();
	      let max = oc.distance(outerCoordinates[0]);
	      for (let index = 1; index < outerCoordinates.length; index++) {
	        const dist = oc.distance(coordinates.outer[index]);
	        if (dist > max) max = dist;
	      }
	      return max;
	    };
	
	    this.coverInfo = () => {
	      const propConfig = this.propertyConfig();
	      let biPolygon, backOffset, frontOffset, offset, coords;
	      const doorThickness = 3 * 2.54/4;
	      const bumperThickness = 3 * 2.54 / 16;
	      if (propConfig.isInset()) {
	        coords = this.coordinates().inner;
	        offset = propConfig('Inset').is.value() * -2;
	        const projection = 3 * 2.54/64;
	        frontOffset = projection;
	        backOffset = projection - doorThickness;
	      } else if (propConfig.isReveal()) {
	        coords = this.coordinates().outer;
	        offset = -propConfig.reveal().r.value();
	        frontOffset = (doorThickness + bumperThickness);
	        backOffset = bumperThickness;
	      } else {
	        coords = this.coordinates().inner;
	        offset = propConfig.overlay();
	        frontOffset = (doorThickness + bumperThickness);
	        backOffset = bumperThickness;
	      }
	
	      frontOffset *= -1;
	      backOffset *= -1;
	      const offsetObj = {x: offset, y: offset};
	      if (!config.flipNormal) {
	        let temp = coords[0];
	        coords[0] = coords[1];
	        coords[1] = temp;
	        temp = coords[2];
	        coords[2] = coords[3];
	        coords[3] = temp;
	      }
	      biPolygon = BiPolygon.fromPolygon(new Polygon3D(coords), frontOffset, backOffset, offsetObj);
	      return {biPolygon, frontOffset, backOffset};
	    }
	
	    this.dividerInfo = (panelThickness) => {
	      const depth = this.innerDepth() * (config.flipNormal ? 1 : -1);
	      const length = this.innerLength();
	      const width = this.innerWidth();
	      const innerCenter = this.innerCenter();
	      const coordinates = this.coordinates();
	      if (!this.verticalDivisions()) {
	        const outer = coordinates.outer;
	        const point1 = outer[0];
	        const point2 = outer[1];
	        let depthVector = new Polygon3D(outer).normal();
	        depthVector = depthVector.scale(depth);
	        const point3 = outer[1].translate(depthVector, true);
	        const point4 = outer[0].translate(depthVector, true);
	        const points = [point1, point2, point3, point4];
	        const offset = panelThickness / (config.flipNormal ? -2 : 2);
	        return BiPolygon.fromPolygon(new Polygon3D(points), offset, -offset, null, config.flipNormal);
	      }
	      const outer = coordinates.outer;
	      const point1 = outer[1];
	      const point2 = outer[2];
	      let depthVector = new Polygon3D(outer).normal();
	      depthVector = depthVector.scale(depth);
	      const point3 = point2.translate(depthVector, true);
	      const point4 = point1.translate(depthVector, true);
	      const points = [point1, point2, point3, point4];
	      const offset = panelThickness / (config.flipNormal ? -2 : 2);
	      return BiPolygon.fromPolygon(new Polygon3D(points), offset, -offset, null, config.flipNormal);
	    }
	
	    const assemToJson = this.toJson;
	    this.toJson = () => {
	      const json = assemToJson.apply(this);
	      json.pattern = this.pattern().toJson();
	      json.subassemblies = this.sections.map((section) => section.toJson());
	      return json;
	    }
	
	    function removeCachedValues() {
	      rotation = innerCenter = outerCenter = innerLength = innerWidth = outerLength = outerWidth = null;
	      setSectionCoordinates();
	    }
	
	    function updateCoordinates(obj, newCoords) {
	      let change = false;
	      for (let i = 0; i < 4; i++) {
	        const v = obj[i];
	        const nv = newCoords[i];
	        if (v.x !== nv.x || v.y !== nv.y || v.z !== nv.z) change = true;
	        v.x = nv.x;
	        v.y = nv.y;
	        v.z = nv.z;
	      }
	      return change
	    }
	
	    this.updateCoordinates = (newCoords) => {
	      let change = updateCoordinates(coordinates.outer, newCoords.outer) | updateCoordinates(coordinates.inner, newCoords.inner);
	      if (change) {
	        removeCachedValues();
	        setSectionCoordinates();
	      }
	    }
	
	    this.setSection = (constructorIdOobject) => {
	      let section;
	      this.cover(SectionProperties.new(constructorIdOobject, this));
	    }
	
	    this.divider(new DividerSection('divider', this));
	    this.value('vertical', true);
	    // this.vertical(true);
	    // coordinates.onAfterChange(setSectionCoordinates);
	  }
	}
	
	const list = [];
	const byId = {};
	const tolerance = .04
	SectionProperties.updateLinks = (sectionProp) => {
	  const id = sectionProp.id();
	  if (byId[id] === undefined) {
	    byId[id] = sectionProp;
	    list.push(sectionProp);
	  }
	  sectionProp.clearDirections();
	  const sectRad = section.longestRadius();
	  const sectionOuterCenter = sectionProp.outerCenter();
	  const centerDist = {};
	  for (let index = 0; index < list.length; index++) {
	    if (!other.rotation().equals(this.rotation()))  {
	      const other = list[index];
	      const otherRad = other.longestRadius();
	      const centerDist = sectionOuterCenter.distance(other.outerCenter());
	      if (centerDist - tolerance < otherRad + sectRad) {
	        const direction = Vertex3D.direction(sectionProp.outerCoordinates(), other.outerCoordinates(), tolerance, true);
	        if (direction) {
	          if (sectionProp[direction]() === undefined || centerDist < centerDistObj[distance]) {
	            sectionProp[direction](other);
	            centerDistObj[distance] = centerDist;
	          }
	        }
	      }
	    }
	  }
	}
	
	SectionProperties.new = function (constructorId) {
	  const section = Assembly.new.apply(null, arguments);
	  return section;
	}
	
	const sections = [];
	SectionProperties.sections = () => [].concat(sections);
	SectionProperties.addSection = (clazz) => list.push(clazz);
	
	module.exports = SectionProperties;
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/drawer/drawer-box.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	const drawerBox = require('../../../../three-d/models/drawer-box.js');
	
	class DrawerBox extends Assembly {
	  constructor(partCode, partName, getFrontPoly, getNormal, getDepth) {
	    super(partCode, partName);
	
	    this.toModel = () => drawerBox(getFrontPoly(), getNormal(), getDepth());
	  }
	}
	
	DrawerBox.abbriviation = 'db';
	
	
	module.exports = DrawerBox
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/door/door-catch.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	
	
	class DoorCatch extends Assembly {
	  constructor() {
	    super();
	  }
	}
	
	module.exports = DoorCatch
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/hardware/screw.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	
	
	class Screw extends Assembly {
	  constructor() {
	    super();
	  }
	}
	
	
	module.exports = Screw
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/door/door.js',
function (require, exports, module) {
	

	
	const HasPull = require('../has-pull.js');
	const Handle = require('../hardware/pull.js');
	
	class Door extends HasPull {
	  constructor(partCode, partName, getBiPolygon) {
	    super(partCode, partName, getBiPolygon);
	
	    this.toModel = () => {
	      const biPolygon = getBiPolygon();
	      if (biPolygon) return biPolygon.toModel();
	      return undefined;
	    }
	
	    this.front = () => {
	      const biPoly = getBiPolygon();
	      if (biPoly === undefined) return;
	      return biPoly.front();
	    }
	    this.back = () => {
	      const biPoly = getBiPolygon();
	      if (biPoly === undefined) return;
	      return biPoly.back();
	    }
	
	    this.addPull(Handle.location.TOP_RIGHT);
	    // this.setPulls([Handle.location.TOP_RIGHT,
	    // Handle.location.TOP_LEFT,
	    // Handle.location.BOTTOM_RIGHT,
	    // Handle.location.BOTTOM_LEFT,
	    // Handle.location.TOP,
	    // Handle.location.BOTTOM,
	    // Handle.location.CENTER,
	    // Handle.location.RIGHT,
	    // Handle.location.LEFT]);
	  }
	}
	
	Door.abbriviation = 'dr';
	
	
	module.exports = Door
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/door/hinges.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	
	
	class Hinge extends Assembly {
	  constructor() {
	    super();
	  }
	}
	
	Hinge.abbriviation = 'hg';
	
	module.exports = Hinge
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/drawer/guides.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	
	
	class Guides extends Assembly {
	  constructor() {
	    super();
	  }
	}
	
	Guides.abbriviation = 'gu';
	
	
	module.exports = Guides
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/drawer/drawer-front.js',
function (require, exports, module) {
	

	
	const HasPull = require('../has-pull.js');
	const Handle = require('../hardware/pull.js');
	
	class DrawerFront extends HasPull {
	  constructor(partCode, partName, getBiPolygon) {
	    super(partCode, partName, getBiPolygon);
	    const instance = this;
	    this.addPull(Handle.location.CENTER);
	
	    this.toModel = () => {
	      const biPolygon = getBiPolygon();
	      if (biPolygon) return biPolygon.toModel();
	      return undefined;
	    }
	
	    this.front = () => {
	      const biPoly = getBiPolygon();
	      if (biPoly === undefined) return;
	      return biPoly.front();
	    }
	    this.back = () => {
	      const biPoly = getBiPolygon();
	      if (biPoly === undefined) return;
	      return biPoly.back();
	    }
	  }
	}
	
	DrawerFront.abbriviation = 'df';
	
	
	module.exports = DrawerFront
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/section/partition/divider.js',
function (require, exports, module) {
	

	
	const Divider = require('../../divider.js');
	const Position = require('../../../../../position.js');
	const PanelModel = require('../../panel.js').Model;
	const Frame = require('../../frame.js');
	const Assembly = require('../../../assembly.js');
	const Joint = require('../../../../joint/joint');
	
	class DividerSection extends Assembly {
	  constructor(partCode, sectionProperties) {
	    super(partCode, 'Divider');
	    if (sectionProperties === undefined) return;
	    const props = sectionProperties;
	    const instance = this;
	    let panel;
	
	    function toModel() {
	      const biPoly = sectionProperties.dividerInfo(3*2.54/4);
	      return biPoly.toModel();
	    }
	
	    this.part = () => false;
	    this.included = () => false;
	
	
	    this.maxWidth = () => 2.54*3/4;
	
	
	    panel = new PanelModel(`${partCode}-p`, 'Divider.Panel', toModel);
	    // const frame = new Frame(`df-${index}`, 'Divider.Frame', frameCenterFunc, frameDemFunc, frameRotFunc);
	    this.addSubAssembly(panel);
	    // this.addSubAssembly(frame);
	  }
	}
	
	DividerSection.abbriviation = 'dvrs';
	
	
	module.exports = DividerSection
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/section/sections/drawer.js',
function (require, exports, module) {
	

	
	const SectionProperties = require('../section-properties.js');
	const PULL_TYPE = require('../../../../../../globals/CONSTANTS.js').PULL_TYPE;
	const DrawerBox = require('../../drawer/drawer-box.js');
	const DrawerFront = require('../../drawer/drawer-front.js');
	const Assembly = require('../../../assembly.js');
	const Polygon3D = require('../../../../../three-d/objects/polygon.js');
	
	class DrawerSection extends Assembly {
	  constructor(sectionProperties) {
	    super();
	    if (sectionProperties === undefined) return;
	    const instance = this;
	    this.part = () => false;
	
	    function getFrontBiPolygon () {
	      return sectionProperties.coverInfo().biPolygon;
	    }
	
	    const front = new DrawerFront('ff', 'DrawerFront', getFrontBiPolygon);
	    this.front = () => door;
	    this.pull = (i) => front.pull(i);
	    this.addSubAssembly(front);
	
	
	
	    function getDrawerDepth() {
	      const depth = sectionProperties.innerDepth();
	      if (depth < 3) return 0;
	      return (Math.floor(((depth - 2.54) / 2.54)/2) * 2) * 2.54;
	    }
	
	    const getNormal = () => front.biPolygon().normal();
	
	    function getFrontPoly() {
	      const innerPoly = new Polygon3D(sectionProperties.coordinates().inner);
	      const coverInfo = sectionProperties.coverInfo();
	      const biPoly = front.biPolygon();
	      const depth = getDrawerDepth(sectionProperties.innerDepth);
	      const offsetVect = biPoly.normal().scale(coverInfo.backOffset);
	      return innerPoly.translate(offsetVect);
	    }
	
	    const drawerBox = new DrawerBox('db', 'Drawer.Box', getFrontPoly, getNormal, getDrawerDepth);
	    this.box = () => drawerBox;
	    this.addSubAssembly(drawerBox);
	  }
	}
	
	DrawerSection.abbriviation = 'dws';
	SectionProperties.addSection(DrawerSection);
	
	
	module.exports = DrawerSection
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/section/sections/duel-door.js',
function (require, exports, module) {
	

	
	const SectionProperties = require('../section-properties.js');
	const Door = require('../../door/door.js');
	const Handle = require('../../hardware/pull.js');
	const Assembly = require('../../../assembly.js');
	const Polygon3D = require('../../../../../three-d/objects/polygon.js');
	const BiPolygon = require('../../../../../three-d/objects/bi-polygon.js');
	
	class DualDoorSection extends Assembly {
	  constructor(sectionProperties) {
	    super('dds', 'Duel.Door.Section');
	    if (sectionProperties === undefined) return;
	    const instance = this;
	
	    this.part = () => false;
	
	    function shrinkPoly(poly, left) {
	      const lines = JSON.clone(poly.lines());
	      const offset = (lines[0].length() - instance.gap()) / 2;
	      if (left) {
	        lines[0].adjustLength(offset, true);
	        lines[1].startVertex = lines[0].endVertex;
	        lines[2].adjustLength(-offset, false);
	        lines[1].endVertex = lines[2].startVertex;
	      } else {
	        lines[0].adjustLength(-offset, false);
	        lines[3].endVertex = lines[0].startVertex;
	        lines[2].adjustLength(offset, true);
	        lines[3].startVertex = lines[2].endVertex;
	      }
	      return Polygon3D.fromLines(lines);
	
	    }
	
	    function getBiPolygon(left) {
	      return () => {
	        const fullPoly = sectionProperties.coverInfo().biPolygon;
	        const front = shrinkPoly(fullPoly.front(), left);
	        const back = shrinkPoly(fullPoly.back(), left);
	        return new BiPolygon(front, back);
	      }
	    }
	
	    const leftDoor = new Door('dl', 'DoorLeft', getBiPolygon(true));
	    this.addSubAssembly(leftDoor);
	    leftDoor.setPulls([Handle.location.TOP_RIGHT]);
	
	    const rightDoor = new Door('dr', 'DoorRight', getBiPolygon(false));
	    this.addSubAssembly(rightDoor);
	    rightDoor.setPulls([Handle.location.TOP_LEFT]);
	
	
	    this.gap = () => 2.54 / 16;
	  }
	}
	
	
	DualDoorSection.abbriviation = 'dds';
	SectionProperties.addSection(DualDoorSection);
	
	
	
	module.exports = DualDoorSection
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/section/sections/false-front.js',
function (require, exports, module) {
	

	
	const SectionProperties = require('../section-properties.js');
	const PULL_TYPE = require('../../../../../../globals/CONSTANTS.js').PULL_TYPE;
	const DrawerFront = require('../../drawer/drawer-front.js');
	const Assembly = require('../../../assembly.js');
	
	class FalseFrontSection extends Assembly {
	  constructor(sectionProperties) {
	    super();
	    if (sectionProperties === undefined) return;
	    this.part = () => false;
	
	    function getBiPolygon () {
	      return sectionProperties.coverInfo().biPolygon;
	    }
	
	    const front = new DrawerFront('ff', 'DrawerFront', getBiPolygon);
	    this.front = () => door;
	    this.pull = (i) => front.pull(i);
	    this.addSubAssembly(front);
	  }
	}
	
	FalseFrontSection.abbriviation = 'ffs';
	SectionProperties.addSection(FalseFrontSection);
	
	
	
	module.exports = FalseFrontSection
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/section/sections/door.js',
function (require, exports, module) {
	

	const SectionProperties = require('../section-properties.js');
	const Door = require('../../door/door.js');
	const Assembly = require('../../../assembly.js');
	
	class DoorSection extends Assembly {
	  constructor(sectionProperties) {
	    super();
	    if (sectionProperties === undefined) return;
	    const instance = this;
	    this.part = () => false;
	
	
	    function getBiPolygon () {
	      return sectionProperties.coverInfo().biPolygon;
	    }
	
	    const door = new Door('d', 'Door', getBiPolygon);
	    this.door = () => door;
	    this.pull = (i) => door.pull(i);
	    this.addSubAssembly(door);
	  }
	}
	
	DoorSection.abbriviation = 'drs';
	SectionProperties.addSection(DoorSection);
	
	module.exports = DoorSection
	
});


RequireJS.addFunction('./app-src/objects/assembly/assemblies/section/space/sections/divide-section.js',
function (require, exports, module) {
	

	
	const SpaceSection = require('../space.js');
	const Pattern = require('../../../../../../division-patterns.js');
	const DividerSection = require('../../partition/sections/divider.js');
	const Section = require('../../section.js');
	const Assembly = require('../../../../assembly.js');
	
	function sectionId(parent, sectionProperties) {
	
	}
	
	let dvs;
	let dsCount = 0;
	class DivideSection extends SpaceSection {
	  constructor(sectionProperties, parent) {
	    const pId = parent && parent.id ? parent.id() : null;
	    const sIndex = (typeof sectionProperties) === 'function' ? sectionProperties().index : null;
	    super(`dvds-${pId}-${sIndex}`, 'divideSection', sectionProperties, parent);
	    // this.important = ['partCode', 'partName', 'borderIds', 'index'];
	    const instance = this;
	    dvs = dvs || this;
	    let pattern;
	    let sectionCount = 1;
	    this.vertical = (is) => instance.value('vertical', is);
	    this.vertical(true);
	    this.sections = [];
	    this.pattern = (patternStr) => {
	      if ((typeof patternStr) === 'string') {
	        sectionCount = patternStr.length;
	        this.divide(sectionCount - 1);
	        pattern = new Pattern(patternStr);
	      } else {
	        if (!pattern || pattern.str.length !== sectionCount)
	          pattern = new Pattern(new Array(sectionCount).fill('a').join(''));
	      }
	      return pattern;
	    }
	    this.dividerCount = () => this.init() && Math.ceil((this.sections.length - 1) / 2);
	    this.isVertical = () => this.sections.length < 2 ? undefined : this.vertical();
	    this.sectionProperties = () => JSON.stringify(sectionProperties);
	    this.init = () => {
	      if (this.sections.length === 0) {
	        this.sections.push(new DivideSection(this.borders(0), this));
	      }
	      return true;
	    }
	
	    // TODO: will break in future should be calling getJoints.. recursive iissue;
	    this.getJoints = () => {
	      let joints = [];
	      this.children().forEach((child) => joints = joints.concat(child.joints));
	      return joints;
	    }
	    this.children = () => this.sections;
	    this.partitions = () => this.sections.filter((e, index) => index % 2 === 1);
	    this.spaces = () => this.sections.filter((e, index) => index % 2 === 0);
	    this.borders = (index) => {
	      return () => {
	        // if (index === 1) {
	        //   console.log('center');
	        // }
	        const props = sectionProperties();
	        const position = {
	          front: props.position.front,
	          back: props.position.back,
	          top: props.position.top,
	          bottom: props.position.bottom,
	          left: props.position.left,
	          right: props.position.right
	        };
	        const rotation = props.rotation;
	
	        let top = props.borders ? props.borders.top : props.position.top;
	        let bottom = props.borders ? props.borders.bottom : props.position.bottom;
	        let left = props.borders ? props.borders.left : props.position.left;
	        let right = props.borders ? props.borders.right : props.position.right;
	        if (this.vertical()) {
	          if (index !== 0) {
	            left = this.sections[index - 1];
	            position.left = undefined;
	          } if (this.sections[index + 1] !== undefined) {
	            right = this.sections[index + 1];
	            position.right = undefined;
	          }
	        } else {
	          if (index !== 0) {
	            top = this.sections[index - 1];
	            position.top = undefined;
	          } if (this.sections[index + 1] !== undefined) {
	            bottom = this.sections[index + 1];
	            position.bottom = undefined;
	          }
	        }
	
	        const depth = props.depth;
	        if (!top || !bottom || !right || !left)
	          throw new Error('Border not defined');
	        return {borders: {top, bottom, right, left}, position, depth, index, rotation};
	      }
	    }
	    this.dividerProps = (index) => {
	      return () => {
	        // if (index === 1) {
	        //   console.log('center');
	        // }
	        const answer = this.dividerLayout().list;
	        let offset = this.dividerOffset(index * 2);
	        for (let i = 0; i < index + 1; i += 1) offset += answer[i];
	        let props = sectionProperties();
	        const innerSize = this.innerSize();
	        let center = this.center();
	        let dividerLength;
	        if (this.vertical()) {
	          const start = props.borders ? props.borders.left.position().centerAdjust('x', '-z') : props.position.left;
	          center.x = start + offset;
	          dividerLength = innerSize.y;
	        } else {
	          const start = props.borders ? props.borders.top.position().centerAdjust('y', '+z') : props.position.top;
	          center.y = start - offset;
	          dividerLength = innerSize.x;
	        }
	        const rotationFunc = () =>  this.vertical() ? {x: 0, y:0, z: 0} : {x: 0, y:0, z: 90};
	
	        const depth = props.depth;
	        const vertical = this.vertical();
	        const borders = props.borders;
	        return {center, dividerLength, rotationFunc, index, depth, vertical, borders};
	      }
	    }
	
	    this.dividerOffset = (limitIndex) => {
	      limitIndex = limitIndex > -1 && limitIndex < this.sections.length ? limitIndex : this.sections.length;
	      let cov = this.coverable();
	      let frOut = this.outerSize();
	      let offset = this.isVertical() ? cov.limits['-x'] - frOut.limits['-x'] : frOut.limits.y - cov.limits.y;
	      for (let index = 0; index < limitIndex + 2; index += 1) {
	        const section = this.sections[index];
	        if (section instanceof DividerSection) {
	          const maxWidth = section.maxWidth();
	          let halfReveal;
	          if (this.propertyConfig().isReveal()) {
	            halfReveal = this.propertyConfig().reveal().r.value() / 2;
	          } else if (this.propertyConfig().isInset()) {
	            const insetValue = this.propertyConfig('Inset').is.value();
	            halfReveal = (section.maxWidth() + insetValue * 2) / 2;
	          } else {
	            halfReveal = (maxWidth - this.propertyConfig().overlay() * 2)/2;
	          }
	          offset += index < limitIndex ? halfReveal*2 : halfReveal;
	        }
	      }
	      return offset;
	    }
	
	    this.dividerReveal = (limitIndex) => {
	      limitIndex = limitIndex > -1 && limitIndex < this.sections.length ? limitIndex : this.sections.length;
	      let offset = 0;
	      for (let index = 0; index < limitIndex; index += 1) {
	        const section = this.sections[index];
	        if (section instanceof DividerSection) {
	          if (this.propertyConfig().isReveal()) {
	            offset += this.propertyConfig().reveal().r.value();
	          }  else if (this.propertyConfig().isInset()) {
	            const insetValue = this.propertyConfig('Inset').is.value();
	            offset += section.maxWidth() + insetValue * 2;
	          } else {
	            offset += section.maxWidth();
	            offset -= this.propertyConfig().overlay() * 2;
	          }
	        }
	      }
	      return offset;
	    }
	
	    this.sectionCount = () => this.dividerCount() + 1;
	    this.dividerLayout = () => {
	      let distance;
	      const coverable = this.coverable();
	      distance = this.vertical() ? coverable.dems.x : coverable.dems.y;
	      distance -= this.dividerReveal();
	      return this.pattern().calc(distance);
	    };
	    this.divide = (dividerCount) => {
	      if (!Number.isNaN(dividerCount)) {
	        dividerCount = dividerCount > 10 ? 10 : dividerCount;
	        dividerCount = dividerCount < 0 ? 0 : dividerCount;
	        const currDividerCount = this.dividerCount();
	        if (dividerCount < currDividerCount) {
	          const diff = currDividerCount - dividerCount;
	          this.sections.splice(dividerCount * 2 + 1);
	          return true;
	        } else {
	          const diff = dividerCount - currDividerCount;
	          for (let index = currDividerCount; index < dividerCount; index +=1) {
	            this.sections.push(new DividerSection(`dv-${this.id()}-${index}`, this.dividerProps(index), instance));
	            const divideIndex = dividerCount + index + 1;
	            this.sections.push(new DivideSection(this.borders(divideIndex), instance));
	          }
	          return diff !== 0;
	        }
	      }
	      return false;
	    }
	    this.setSection = (constructorIdOobject, index) => {
	      let section;
	      index = Number.parseInt(index);
	      if ((typeof constructorIdOobject) === 'string') {
	        if (constructorIdOobject === 'DivideSection') {
	          section = new DivideSection(this.borders(index), instance);
	        } else {
	          section = Section.new(constructorIdOobject, 'dr', this.borders(index), this);
	        }
	      } else {
	        section = constructorIdOobject;
	      }
	      this.sections[index] = section;
	    }
	    this.size = () => {
	      return {width: this.width, height: this.height};
	    }
	    this.sizes = () => {
	      return 'val';
	    }
	    const assemToJson = this.toJson;
	    this.toJson = () => {
	      const json = assemToJson.apply(this);
	      json.pattern = this.pattern().toJson();
	      json.subassemblies = this.sections.map((section) => section.toJson());
	      return json;
	    }
	  }
	}
	
	DivideSection.fromJson = (json) => {
	  const sectionProps = json.parent.borders(json.borderIds || json.index);
	  const assembly = new DivideSection(sectionProps, json.parent);
	  assembly.partCode(json.partCode);
	  assembly.id(json.id)
	  assembly.index(json.index);
	  const subAssems = json.subassemblies;
	  assembly.values = json.values;
	  for (let index = 0; index < subAssems.length / 2; index += 1) {
	    const partIndex = index * 2 + 1;
	    if (partIndex < subAssems.length) {
	      const partJson = subAssems[partIndex];
	      partJson.parent = assembly;
	      const partition = Assembly.class(partJson._TYPE).fromJson(partJson, assembly);
	      assembly.setSection(partition, partIndex);
	    }
	
	    const spaceIndex = index * 2;
	    const spaceJson = subAssems[spaceIndex];
	    spaceJson.index = spaceIndex;
	    spaceJson.parent = assembly;
	    const space = Assembly.class(spaceJson._TYPE).fromJson(spaceJson, assembly);
	    assembly.setSection(space, spaceIndex);
	  }
	  assembly.pattern(json.pattern.str);
	  const pattern = assembly.pattern();
	  const patternIds = Object.keys(json.pattern.values);
	  patternIds.forEach((id) => pattern.value(id, json.pattern.values[id]));
	  return assembly;
	}
	
	DivideSection.abbriviation = 'ds';
	
	
	module.exports = DivideSection
	
});


RequireJS.addFunction('./test/run.js',
function (require, exports, module) {
	

	
	const EPNTS = require('../generated/EPNTS.js');
	const Test = require('../../../public/js/utils/test/test').Test;
	
	if (EPNTS.getEnv() === 'local') {
	  require('./tests/cabinet');
	  require('../../../public/js/utils/test/tests/decision-tree');
	  require('../../../public/js/utils/test/tests/logic-tree');
	  require('./tests/polygon-merge');
	  require('./tests/array-math');
	  require('./tests/plane');
	  require('./tests/line-consolidate');
	}
	
	Test.run();
	
});


RequireJS.addFunction('./test/tests/line-consolidate.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Polygon2d = require('../../app-src/two-d/objects/polygon.js');
	const Line2d = require('../../app-src/two-d/objects/line.js');
	const Line3D = require('../../app-src/three-d/objects/line.js');
	const Vertex2d = require('../../app-src/two-d/objects/vertex.js');
	const approximate = require('../../../../public/js/utils/approximate.js');
	
	const extraLinePoly = new Polygon2d([[0,0],[0,1],[0,2],[0,3],
	                [1,3],[1,4],[0,4],[0,5],[0,6],[1,6],[2,6],[3,6],
	                [3,5],[4,5],[5,4],[6,3],[5,3],[5,2],[6,2],[6,1],
	                [6,0],[5,0],[4,0],[4,-1],[4,-2],[1,0]]);
	
	const consisePoly = new Polygon2d([[0,0],[0,3],[1,3],[1,4],
	                [0,4],[0,6],[3,6],[3,5],[4,5],[6,3],[5,3],[5,2],
	                [6,2],[6,0],[4,0],[4,-2],[1,0]]);
	
	const root2 = Math.sqrt(2);
	
	
	// const A = new Polygon3D([[,],[,],[,],[,]])
	Test.add('Line2d: consolidate',(ts) => {
	  const lines = Polygon2d.lines(extraLinePoly);
	  ts.assertTrue(lines.length === consisePoly.lines().length);
	  ts.success();
	});
	
	
	Test.add('Line2d: perpendicular', (ts) => {
	  let line = new Line2d({x:0,y:0}, {x:1, y:0});
	  let perp = line.perpendicular(1, null, true);
	  let expectedMidpoint = new Vertex2d({x: .5, y: 0});
	  let expectedLine = new Line2d({x: .5, y: .5}, {x: .5, y: -.5});
	  ts.assertTrue(perp.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(-2, null, true);
	  expectedLine = new Line2d({x: .5, y: 1}, {x: .5, y: -1});
	  ts.assertTrue(perp.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(1);
	  expectedLine = new Line2d({x: .5, y: 0}, {x: .5, y: 1});
	  expectedMidpoint = new Vertex2d({x: .5, y: .5});
	  ts.assertTrue(perp.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(-2);
	  expectedLine = new Line2d({x: .5, y: 0}, {x: .5, y: -2});
	  expectedMidpoint = new Vertex2d({x: .5, y: -1});
	  ts.assertTrue(perp.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(-1);
	  expectedLine = new Line2d({x: .5, y: 0}, {x: .5, y: -1});
	  expectedMidpoint = new Vertex2d({x: .5, y: -.5});
	  ts.assertTrue(perp.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(2);
	  expectedLine = new Line2d({x: .5, y: 0}, {x: .5, y: 2});
	  expectedMidpoint = new Vertex2d({x: .5, y: 1});
	  ts.assertTrue(perp.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  line = new Line2d({x:0,y:0}, {x:2, y:2});
	  perp = line.perpendicular(root2);
	  expectedLine = new Line2d({x: 1, y: 1}, {x: 0, y: 2});
	  expectedMidpoint = new Vertex2d({x: .5, y: 1.5});
	  ts.assertTrue(perp.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  line = new Line2d({x:0,y:0}, {x:2, y:2});
	  perp = line.perpendicular(-1 * root2);
	  expectedLine = new Line2d({x: 1, y: 1}, {x: 2, y: 0});
	  expectedMidpoint = new Vertex2d({x: 1.5, y: .5});
	  ts.assertTrue(perp.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  ts.success();
	});
	
	Test.add('Line2d: parrelle', (ts) => {
	  let line = new Line2d({x:0,y:0}, {x:2, y:2});
	  let expectedLine = new Line2d({x: -1, y: 1}, {x: 1, y: 3});
	  let expectedMidpoint = new Vertex2d({x: 0, y: 2});
	  let parrelle = line.parrelle(-1 * root2);
	  ts.assertTrue(parrelle.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  expectedLine = new Line2d({x: 1, y: -1}, {x: 3, y: 1});
	  expectedMidpoint = new Vertex2d({x: 2, y: 0});
	  parrelle = line.parrelle(root2);
	  ts.assertTrue(parrelle.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  line = new Line2d({x:2, y:2}, {x:0,y:0});
	  expectedLine = new Line2d({x: 1, y: 3}, {x: -1, y: 1});
	  expectedMidpoint = new Vertex2d({x: 0, y: 2});
	  parrelle = line.parrelle(root2);
	  ts.assertTrue(parrelle.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  expectedLine = new Line2d({x: 3, y: 1}, {x: 1, y: -1});
	  expectedMidpoint = new Vertex2d({x: 2, y: 0});
	  parrelle = line.parrelle(-1 * root2);
	  ts.assertTrue(parrelle.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  line = new Line2d({x:3,y:1}, {x:8, y:4});
	  expectedMidpoint = new Vertex2d({x: -.5, y: 12.5});
	  expectedLine = new Line2d({x: -3, y: 11}, {x: 2, y: 14});
	  parrelle = line.parrelle(-1 * expectedMidpoint.distance(line.midpoint()));
	  ts.assertTrue(parrelle.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  expectedMidpoint = new Vertex2d({x: 11.5, y: -7.5});
	  expectedLine = new Line2d({x: 9, y: -9}, {x: 14, y: -6});
	  parrelle = line.parrelle(expectedMidpoint.distance(line.midpoint()));
	  ts.assertTrue(parrelle.midpoint().equal(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  ts.success();
	});
	
	Test.add('Line2d: trimmed', (ts) => {
	  let line = new Line2d({x:0,y:0}, {x:0, y:8});
	
	  let trimmed = line.trimmed(.5);
	  let expectedLine = new Line2d({x: 0, y: .5}, {x: 0, y: 8});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(-.5);
	  expectedLine = new Line2d({x: 0, y: 0}, {x: 0, y: 7.5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(.5, true);
	  expectedLine = new Line2d({x: 0, y: .5}, {x: 0, y: 7.5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(-.5, true);
	  expectedLine = new Line2d({x: 0, y: .5}, {x: 0, y: 7.5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  line = new Line2d({x:-4,y:-8}, {x:0, y:-4});
	  trimmed = line.trimmed(root2, true);
	  expectedLine = new Line2d({x: -3, y: -7}, {x: -1, y: -5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(root2);
	  expectedLine = new Line2d({x: -3, y: -7}, {x: 0, y: -4});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(-1 * root2);
	  expectedLine = new Line2d({x: -4, y: -8}, {x: -1, y: -5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  ts.success();
	});
	
	Test.add('Line2d: thetaBetween', (ts) => {
	  let line = new Line2d({x:0,y:0}, {x:0, y:10});
	  let line2 = new Line2d({x:0,y:10}, {x:10, y:20});
	  let line3 = new Line2d({x:10,y:20}, {x:10, y:30})
	
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 135);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line3))), 225);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 225);
	  ts.assertEquals(approximate(Math.toDegrees(line3.thetaBetween(line2))), 135);
	
	  let origin = {x:3, y:22};
	  line = Line2d.startAndTheta(origin, Math.toRadians(16), 10);
	  line2 = Line2d.startAndTheta(origin, Math.toRadians(251), 10);
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 235);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 125);
	
	  line2 = line2.negitive();
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 235);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 125);
	
	  line = line.negitive();
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 235);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 125);
	
	  line2 = line2.negitive();
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 235);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 125);
	
	  ts.success();
	});
	
	// Test.add('Line3D: intersects', (ts) => {
	//   const line1 = new Line3D({x: 10, y: 10, z: 10}, {x: 5, y: 5, z: 5});
	//   const line2 = new Line3D({x: 10, y: 10, z: -10}, {x: 5, y: 5, z: -5});
	//   let intersection = line1.intersects(line2);
	//   ts.assertTrue(intersection.equals({x: 0, y:0, z:0}));
	//   ts.success();
	// });
	
});


RequireJS.addFunction('./test/tests/RelationInput.js',
function (require, exports, module) {
	

	
	const RelationInput = require('../../../../public/js/utils/input/styles/select/relation.js');
	
	
	
	Test.add('RelationInput: Equal',(ts) => {
	  ts.assertEquals(RelationInput.eval('Equal', [1,4,3,5,6,4,8,9], 6), 4);
	  ts.assertEquals(RelationInput.eval('equal', [1,4,3,5,6,4,8,9], 7), undefined);
	  ts.assertEquals(RelationInput.eval('EQual', [1,4,3,5,6,4,8,9], 1), 0);
	  ts.assertEquals(RelationInput.eval('EqUAL', [1,4,3,5,6,4,8,9], 9), 7);
	  ts.assertEquals(RelationInput.eval('EquaL', [1,4,3,5,6,4,8,9], 4), 1);
	  ts.assertEquals(RelationInput.eval('EqUal', [1,4,3,5,6,undefined,8,9], 8), 6);
	  ts.success();
	});
	
	
	Test.add('RelationInput: Less Than',(ts) => {
	  ts.assertEquals(RelationInput.eval('Less ThAn', [1,4,3,5,6,4,8,9], 6), 3);
	  ts.assertEquals(RelationInput.eval('LeSs_Than', [1,4,3,5,6,4,8,9], 1), undefined);
	  ts.assertEquals(RelationInput.eval('LeSS Than', [1,4,3,5,6,4,8,9], 200), 7);
	  ts.assertEquals(RelationInput.eval('less than', [1,4,3,5,6,4,8,9], 9), 6);
	  ts.assertEquals(RelationInput.eval('Less Than', [1,4,3,5,6,4,8,9], -2), undefined);
	  ts.assertEquals(RelationInput.eval('Less Than', [1,4,3,5,6,undefined,8,9], 8), 4);
	  ts.success();
	});
	
	Test.add('RelationInput: Greater Than',(ts) => {
	  ts.assertEquals(RelationInput.eval('Greater ThAn', [1,4,3,5,6,4,8,9], 6), 6);
	  ts.assertEquals(RelationInput.eval('Greater_Than', [1,4,3,5,6,4,8,9], 1), 2);
	  ts.assertEquals(RelationInput.eval('Greater Than', [1,4,3,5,6,4,8,9], 200), undefined);
	  ts.assertEquals(RelationInput.eval('Greater than', [1,4,3,5,6,4,8,9], 9), undefined);
	  ts.assertEquals(RelationInput.eval('Greater Than', [1,4,3,5,6,4,8,9], -2), 0);
	  ts.assertEquals(RelationInput.eval('Greater Than', [1,4,3,5,6,undefined,8,9], 8), 7);
	  ts.success();
	});
	
	Test.add('RelationInput: Less Than Or Equal',(ts) => {
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], 6), 4);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], 2), 0);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], 200), 7);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], 9), 7);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], -2), undefined);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,undefined,8,9], 7.5), 4);
	  ts.success();
	});
	
	Test.add('RelationInput: Greater Than Or Equal',(ts) => {
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], 6), 4);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], 1.01), 2);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], 200), undefined);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], 9), 7);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], -2), 0);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,undefined,8,9], 8), 6);
	  ts.success();
	});
	
});


RequireJS.addFunction('./test/tests/polygon-merge.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Polygon3D = require('../../app-src/three-d/objects/polygon.js');
	
	
	const B = new Polygon3D([[0,1,0],[1,1,0],[1,3,0],[0,3,0]])
	const C = new Polygon3D([[0,4,0],[2,4,0],[2,6,0],[0,6,0]]);
	const A = new Polygon3D([[0,0,0],[0,1,0],[1,1,0],[4,1,0],[4,0,0]]);
	const D = new Polygon3D([[0,6,0],[0,8,0],[3,8,0],[3,7,0],[3,6,0],[2,6,0]]);
	const E = new Polygon3D([[3,8,0],[1,10,0],[0,8,0]]);
	const F = new Polygon3D([[6,7,0],[6,8,0],[6,10,0],[8,10,0],[8,7,0]]);
	const G = new Polygon3D([[4,7,0],[4,6,0],[3,6,0],[3,7,0]]);
	const H = new Polygon3D([[6,4,0],[4,4,0],[2,4,0],[2,6,0],[3,6,0],[4,6,0],[6,6,0]]);
	const I = new Polygon3D([[4,7,0],[4,8,0],[6,8,0],[6,7,0]]);
	const J = new Polygon3D([[4,0,0],[4,1,0],[4,4,0],[6,4,0],[6,0,0]])
	
	const polyAB = new Polygon3D([[1,3,0],[0,3,0],[0,1,0],[0,0,0],[4,0,0],[4,1,0],[1,1,0]]);
	const polyIF = new Polygon3D([[6,10,0],[6,8,0],[4,8,0],[4,7,0],[6,7,0],[8,7,0],[8,10,0]]);
	const polyABCDEGHJ = new Polygon3D([[1,10,0],[3,8,0],[3,7,0],[4,7,0],[4,6,0],[6,6,0],[6,4,0],
	                                          [6,0,0],[4,0,0],[0,0,0],[0,1,0],[0,3,0],[1,3,0],[1,1,0],
	                                          [4,1,0],[4,4,0],[2,4,0],[0,4,0],[0,6,0],[0,8,0]]);
	
	// const A = new Polygon3D(null, [[,],[,],[,],[,]])
	Test.add('Polygon3D merge',(ts) => {
	  // const poly = A.merge(B).merge(J);
	  const AB = A.merge(B);
	  const IF = [F,I];
	  Polygon3D.merge(IF);
	  const ABCDEFGHIJ = [A,B,C,D,E,F,G,H,I,J];
	  ABCDEFGHIJ.shuffle();
	  Polygon3D.merge(ABCDEFGHIJ);
	
	  ts.assertTrue(polyAB.equals(AB), 'merge or equals is malfunctioning');
	  ts.assertTrue(AB.equals(polyAB), 'merge or equals is malfunctioning');
	  ts.assertFalse(polyAB.equals(undefined));
	  ts.assertFalse(polyAB.equals(A));
	  ts.assertTrue(IF[0].equals(polyIF));
	  ts.assertTrue(polyIF.equals(IF[0]));
	  ts.assertTrue(ABCDEFGHIJ.length === 2);
	  ts.assertTrue(polyABCDEGHJ.equals(ABCDEFGHIJ[0]) || polyABCDEGHJ.equals(ABCDEFGHIJ[1]));
	  ts.assertTrue(polyIF.equals(ABCDEFGHIJ[1]) || polyIF.equals(ABCDEFGHIJ[0]))
	  ts.success();
	});
	
});


RequireJS.addFunction('./test/tests/array-math.js',
function (require, exports, module) {
	const Test = require('../../../../public/js/utils/test/test').Test;
	const Matrix = require('../../app-src/three-d/objects/matrix.js');
	const Vertex3D = require('../../app-src/three-d/objects/vertex.js');
	const Vertex2d = require('../../app-src/two-d/objects/vertex.js');
	const Line2d = require('../../app-src/two-d/objects/line.js');
	const approximate = require('../../../../public/js/utils/approximate.js');
	
	const CSG = require('../../public/js/3d-modeling/csg');
	
	
	Test.add('Array: translate',(ts) => {
	  let result = [].translate([1,2,3]);
	  ts.assertTrue(result.equals([1,2,3]));
	  ts.assertFalse(result.equals([1,2,4]));
	  ts.assertFalse(result.equals([1,2,3,4]))
	  ts.assertFalse(result.equals([1,2]))
	
	  result = [3,6,9].translate([1,-2,3]);
	  ts.assertTrue(result.equals([4,4,12]));
	  ts.assertFalse(result.equals([4,2,12]));
	
	  let a = [4,-4,-4];
	  let b = a.translate([5,5,5], true, true);
	  ts.assertTrue(a.equals([4,-4,-4]));
	  ts.assertTrue(b.equals([9,1,1]));
	
	  ts.success();
	});
	
	
	Test.add('Array: inverse',(ts) => {
	  let result = [3,6,9].inverse();
	  ts.assertTrue(result.equals([-3,-6,-9]));
	
	  let a = [4,-4,-4];
	  let b = a.inverse(true);
	  ts.assertTrue(a.equals([4,-4,-4]));
	  ts.assertTrue(b.equals([-4,4,4]));
	
	  a = [1,2,3];
	  b = a.inverse(true);
	  let c = a.translate(b, true);
	  ts.assertTrue(a.equals([1,2,3]));
	  ts.assertTrue(b.equals([-1,-2,-3]));
	  ts.assertTrue(c.equals([0,0,0]));
	
	  ts.success();
	});
	
	
	Test.add('Matrix: multiply',(ts) => {
	  let result = new Matrix([[1,2],[6,7]]).multiply(new Matrix([[5,3],[4,4]]));
	  ts.assertTrue(result.equals(new Matrix([[13,11],[58,46]])));
	
	  let A = new Matrix([[7,7,7],[2,3,4],[6,7,8],[5,5,5]]);
	  let B = new Matrix([[4,0,7],[1,1,1],[7,7,7]]);
	
	  let AB = new Matrix([[84,56,105],[39,31,45],[87,63,105],[60,40,75]]);
	  ts.assertTrue(AB.equals(A.multiply(B)));
	
	  ts.success();
	});
	
	Test.add('Matrix: remove',(ts) => {
	  let matrix = new Matrix([
	    [1,2,3,4],
	    [5,6,7,8],
	    [9,0,2,3],
	    [6,6,6,6]
	  ]);
	  let result = matrix.remove();
	  ts.assertTrue(result.equals(matrix));
	
	  result = matrix.remove(0);
	  ts.assertTrue(result.equals(new Matrix([
	    [5,6,7,8],
	    [9,0,2,3],
	    [6,6,6,6]
	  ])));
	
	  result = matrix.remove(null, 2);
	  ts.assertTrue(result.equals(new Matrix([
	    [1,2,4],
	    [5,6,8],
	    [9,0,3],
	    [6,6,6]
	  ])));
	
	  result = matrix.remove(0,1);
	  ts.assertTrue(result.equals(new Matrix([
	    [5,7,8],
	    [9,2,3],
	    [6,6,6]
	  ])));
	
	  result = matrix.remove(-2, -1);
	  ts.assertTrue(result.equals(new Matrix([
	    [1,2,3],
	    [5,6,7],
	    [6,6,6]
	  ])));
	
	  result = matrix.minor(0);
	  ts.assertTrue(result.equals(new Matrix([
	    [6,7,8],
	    [0,2,3],
	    [6,6,6]
	  ])));
	
	  result = matrix.minor(2);
	  ts.assertTrue(result.equals(new Matrix([
	    [5,6,8],
	    [9,0,3],
	    [6,6,6]
	  ])));
	
	  ts.success();
	});
	
	
	Test.add('Matrix: remove',(ts) => {
	  let matrix = new Matrix([
	    [7,8],
	    [9,3],
	  ]);
	  let result = matrix.determinate();
	  ts.assertTrue(result === -51);
	
	  matrix = new Matrix([
	    [1,2,4],
	    [5,7,8],
	    [0,2,3]
	  ]);
	  let det = matrix.determinate();
	  ts.assertTrue(det === 15);
	
	  matrix = new Matrix([
	    [4,7],
	    [2,6]
	  ]);
	  det = matrix.determinate();
	
	  let inverse = matrix.diagonal();
	  inverse.scale(-1, true);
	  inverse.scale(1/det);
	
	  // matrix = new Matrix([
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  // ]);
	  // result = matrix.determinate();
	  // ts.assertTrue(result === 0);
	
	
	  // matrix = new Matrix([
	  //   [1,1,5,6,3,8,7,6,5,4],
	  //   [1,1,5,6,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,5,1,2,4],
	  //   [1,6,3,8,7,6,5,1,2,4],
	  //   [1,1,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,1,2,4],
	  //   [1,1,5,6,3,8,7,1,2,4],
	  //   [1,1,5,6,3,8,7,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1],
	  //   [1,1,5,8,7,6,5,1,2,4],
	  // ]);
	  // result = matrix.determinate();
	  // ts.assertTrue(result === 0);
	
	  ts.success();
	});
	
	
	Test.add('Matrix: identity',(ts) => {
	  let identity2 = Matrix.identity(2);
	  let identity3 = Matrix.identity(3);
	
	  let matrix = new Matrix([
	    [7,8],
	    [9,3],
	  ]);
	  let inverse = matrix.inverse();
	  let result = matrix.multiply(inverse)
	  result.approximate();
	  ts.assertTrue(result.equals(identity2));
	
	  result = inverse.multiply(matrix);
	  result.approximate();
	  ts.assertTrue(result.equals(identity2));
	
	
	  matrix = new Matrix([
	    [1,2,3],
	    [4,5,6],
	    [7,2,9]
	  ]);
	  inverse = matrix.inverse();
	  result = matrix.multiply(inverse)
	  result.approximate();
	  ts.assertTrue(result.equals(identity3));
	
	  result = inverse.multiply(matrix);
	  result.approximate();
	  ts.assertTrue(result.equals(identity3));
	
	  ts.success();
	});
	
	
	
	Test.add('Matrix: solve',(ts) => {
	  let equations = new Matrix([
	    [3,-5,4],
	    [5,2,1],
	    [2,3,-2],
	  ]);
	  let answer = [5, 0, 3];
	
	  const solution = equations.solve(answer);
	  solution.equals(new Matrix([
	    [2],
	    [-3],
	    [-4]
	  ]));
	
	  ts.success();
	});
	
	const accuracy = 10000000000;
	
	
	function testRotation(ts, center, rotation) {
	  center = new Vertex3D({x: 1, y:0, z:0});
	  let cube = CSG.cube({radius: .0000000000001});
	  cube.center(center);
	  cube.rotate(rotation);
	  let modelCenter = cube.polygons[0].vertices[0].pos;
	
	  let calculatedCenter = CSG.rotate(center, rotation);
	  ts.assertTrue(approximate.eq(modelCenter.x, calculatedCenter.x), `${modelCenter.x} !~= ${calculatedCenter.x}`);
	  ts.assertTrue(approximate.eq(modelCenter.y, calculatedCenter.y), `${modelCenter.y} !~= ${calculatedCenter.y}`);
	  ts.assertTrue(approximate.eq(modelCenter.z, calculatedCenter.z), `${modelCenter.z} !~= ${calculatedCenter.z}`);
	}
	
	function comparePoints(ts, p1, p2) {
	  ts.assertEquals(p1.x, p2.x, null,  accuracy);
	  ts.assertEquals(p1.y , p2.y, null,  accuracy);
	  ts.assertEquals(p1.z, p2.z, null,  accuracy);
	}
	
	Test.add('CSG: rotation',(ts) => {
	
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 90, y: 0, z: 0});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 0, y: 1, z: 0});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 0, y: 0, z: 1});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 1, y: 1, z: 1});
	  testRotation(ts, {x: 1, y:1, z:1}, {x: 27, y: 0, z: 0});
	  testRotation(ts, {x: 1, y:1, z:1}, {x: 0, y: -15, z: 0});
	  testRotation(ts, {x: 1, y:1, z:1}, {x: 0, y: 0, z: 33});
	  testRotation(ts, {x: 1, y:1, z:1}, {x: 90, y: 90, z: 90});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 27, y: 90, z: 0});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 27, y: 0, z: 90});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 27, y: 90, z: 90});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 27, y: -15, z: 33});
	
	  let rotation = {x: 27, y: -15, z: 33};
	  let start = {x: 50, y: -12, z:-4};
	  let point = CSG.rotate(start, rotation);
	  let reversed = CSG.reverseRotate(point, rotation);
	
	  ts.assertEquals(start.x, reversed.x, null, accuracy);
	  ts.assertEquals(start.y, reversed.y, null, accuracy);
	  ts.assertEquals(start.z, reversed.z, null, accuracy);
	
	  point = {x: 0, y:0, z: -3};
	  let offset = {x: 1, y:0, z: 0};
	  rotation = {x: 0, y:90, z: 0};
	
	  let result = CSG.transRotate(point, offset, rotation);
	  ts.assertEquals(result.x, 0, null,  accuracy);
	  ts.assertEquals(result.y , 0, null,  accuracy);
	  ts.assertEquals(result.z, -4, null,  accuracy);
	
	  point = {x: 0, y:0, z: -3};
	  offset = {x: -1, y:0, z: 2};
	  rotation = {x: 0, y:90, z: 0};
	
	  result = CSG.transRotate(point, offset, rotation);
	  ts.assertEquals(result.x, 2, null,  accuracy);
	  ts.assertEquals(result.y , 0, null,  accuracy);
	  ts.assertEquals(result.z, -2, null,  accuracy);
	
	
	  let topLeft = {x: -1, y: 1, z:0};
	  let topRight = {x: 1, y: 1, z:0};
	  let bottomRight = {x: 1, y:-1 , z:0};
	  let bottomLeft = {x: -1, y: -1, z:0};
	
	  offset = {x: -1, y: 0, z: 0}
	  rotation = {x: 0, y:90, z: 0};
	
	  let topLeftAns = {x: -1, y: 1, z:1};
	  let topRightAns = {x: 1, y: 1, z:1};
	  let bottomRightAns = {x: 1, y: -1, z:1};
	  let bottomLeftAns = {x: -1, y: -1, z:1};
	
	  let points = [topLeft, topRight, bottomRight, bottomLeft];
	  CSG.transRotateAll(points, offset, rotation);
	  comparePoints(ts, points[0], topLeftAns);
	  comparePoints(ts, points[1], topRightAns);
	  comparePoints(ts, points[2], bottomRightAns);
	  comparePoints(ts, points[3], bottomLeftAns);
	
	  point = {x: 10, y:20, z: 0};
	  offset = {x: -1, y: -1, z: 1};
	  answer = {x: 9, y: 19, z: 1};
	  result = CSG.transRotate(point, offset, {x:0,y:0,z:0});
	  comparePoints(ts, result, answer);
	  rotation = {x: 6.009, y: 0, z: 0};
	  let rotatedPoint = CSG.rotate(point, rotation);
	  result = CSG.transRotate(rotatedPoint, offset, rotation);
	  result = CSG.reverseRotate(result, rotation);
	  comparePoints(ts, result, answer);
	
	  ts.success();
	});
	
	Test.add('Vertex3D: direction',(ts) => {
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 0, y: 1, z: 0}]), 'up');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 0, y: -1, z: 0}]), 'down');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: -1, y: 0, z: 0}]), 'left');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 1, y: 0, z: 0}]), 'right');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 0, y: 0, z: -1}]), 'forward');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 0, y: 0, z: 1}]), 'backward');
	
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 1, y: 1, z: 0}]), 'right up');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: -1, y: 0, z: -1}]), 'left forward');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 1, y: 1, z: 1}]), 'right up backward');
	
	  ts.success();
	});
	
});


RequireJS.addFunction('./test/tests/plane.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Plane = require('../../app-src/three-d/objects/plane.js');
	const Vertex3D = require('../../app-src/three-d/objects/vertex.js');
	const Vector3D = require('../../app-src/three-d/objects/vector.js');
	const Line3D = require('../../app-src/three-d/objects/line.js');
	const CSG = require('../../public/js/3d-modeling/csg');
	
	const Notification = require('../../../../public/js/utils/collections/notification.js');
	
	
	
	
	Test.add('Plane: makePlane1MeetPlane2',(ts) => {
	
	  let plane1 = [{x: 0, y: 0, z: 0}, {x: 0, y: 3, z: 0}, {x: 2, y: 3, z: 0}, {x: 2, y: 0, z: 0}];
	  let plane2 = [{x: 4, y: 3, z: -1}, {x: 4, y: 0, z: -1}, {x: 4, y: 3, z: 1}, {x: 4, y: 0, z: 1}];
	  let answer = new Plane({x: 0, y: 0, z: 0}, {x: 0, y: 3, z: 0}, {x: 4, y: 3, z: 0}, {x: 4, y: 0, z: 0});
	  let rotation = {x: 0, y: 0, z: 0};
	  let result = Plane.makePlane1MeetPlane2(JSON.copy(plane1), plane2, rotation);
	  ts.assertTrue(answer.equals(result));
	
	  rotation = {x: 0, y: 90, z: 0};
	  let center = Vertex3D.center.apply(null, plane1);
	  let plane3 = CSG.rotatePointsAroundCenter(rotation, JSON.copy(plane1), center);
	  let plane4 = CSG.rotatePointsAroundCenter(rotation, JSON.copy(plane2), center);
	  result = Plane.makePlane1MeetPlane2(JSON.copy(plane3), plane4, rotation);
	  let reverted = CSG.rotatePointsAroundCenter(rotation, JSON.copy(result), center, true);
	  ts.assertTrue(answer.equals(reverted));
	
	  rotation = {x: 111, y: 62, z: 212};
	  center = Vertex3D.center.apply(null, plane1);
	  plane3 = CSG.rotatePointsAroundCenter(rotation, JSON.copy(plane1), center);
	  plane4 = CSG.rotatePointsAroundCenter(rotation, JSON.copy(plane2), center);
	  result = Plane.makePlane1MeetPlane2(JSON.copy(plane3), plane4, rotation);
	  reverted = CSG.rotatePointsAroundCenter(rotation, JSON.copy(result), center, true);
	  ts.assertTrue(answer.equals(reverted));
	
	  ts.success();
	});
	
	
	Test.add('Plane: equation',(ts) => {
	  const p1 = {x: 1, y: -2, z: 1};
	  const p2 = {x: 4, y: -2, z: -2};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  const equation = new Plane(p1, p2, p3).equation();
	  ts.assertEquals(equation.a * 54, 9);
	  ts.assertEquals(equation.b * 54, -18);
	  ts.assertEquals(equation.c * 54, 9);
	  ts.assertEquals(equation.d * 54, 54);
	  ts.success();
	});
	
	Test.add('Plane: XYrotation',(ts) => {
	  const p1 = {x: 1, y: -2, z: 1};
	  const p2 = {x: 4, y: -2, z: -2};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  const equation = new Plane(p1, p2, p3).equation();
	  const plane = new Plane(equation);
	  const rotation = plane.XYrotation();
	  const result = plane.matrixRotation(rotation);
	  ts.success();
	});
	
	Test.add('Plane: findPoints',(ts) => {
	  const p1 = {x: 1, y: -2, z: 4};
	  const p2 = {x: 4, y: -2, z: 4};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  const equation = new Plane(p1, p2, p3).equation();
	  const plane = new Plane(equation);
	
	  const result = plane.findPoints(13);
	  ts.assertEquals(result.length, 13);
	  ts.success();
	});
	
	Test.add('Vector: crossProduct',(ts) => {
	  const vect1 = new Vector3D(3,1,4);
	  const vect2 = new Vector3D(3,2,6);
	  const crossP = vect1.crossProduct(vect2);
	  ts.assertEquals(crossP.i(), -2/7);
	  ts.assertEquals(crossP.j(), -6/7);
	  ts.assertEquals(crossP.k(), 3/7);
	  ts.success();
	});
	
	Test.add('Plane: normal',(ts) => {
	  const p1 = {x: 1, y: 2, z: 4};
	  const p2 = {x: 4, y: 2, z: 4};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  const equation = new Plane(p1, p2, p3).equation();
	  let plane = new Plane(equation);
	
	  let normal = plane.normal();
	
	  plane = new Plane(p1,p2,p3);
	  plane.rotate({x: 90, y:0, z:0});
	  normal = plane.normal();
	
	  plane = new Plane(p1,p2,p3);
	  plane.rotate({x: 0, y:90, z:0});
	  normal = plane.normal();
	
	  ts.success();
	});
	
	Test.add('Plane: lineIntersection',(ts) => {
	  const p1 = {x: 1, y: 2, z: 4};
	  const p2 = {x: 4, y: 2, z: 4};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  let plane = new Plane(p1,p2,p3);
	  let line = new Line3D({x:0,y:0,z:0}, {x:0,y:0,z:2});
	  let intersection = plane.lineIntersection(line);
	  ts.assertTrue(intersection.equals({x: 0, y: 0, z: 4}));
	
	  line = new Line3D({x:0,y:0,z:0}, {x:0,y:1,z:1});
	  intersection = plane.lineIntersection(line);
	  ts.assertTrue(intersection.equals({x: 0, y: 4, z: 4}));
	
	  line = new Line3D({x:-1,y:-1,z:-1}, {x:6,y:-1,z:6});
	  intersection = plane.lineIntersection(line);
	  ts.assertTrue(intersection.equals({x: 4, y: -1, z: 4}));
	
	  line = new Line3D({x:-1,y:-1,z:-1}, {x:1,y:1,z:1});
	  intersection = plane.lineIntersection(line);
	  ts.assertTrue(intersection.equals({x: 4, y: 4, z: 4}));
	
	  ts.success();
	});
	
	Test.add('Plane: bisector',(ts) => {
	  let eqn1 = {a: 2, b: -1, c: 2, d: 3};
	  let eqn2 = {a: 3, b: -2, c: 6, d: 8};
	
	  let plane1 = new Plane(eqn1);
	  let plane2 = new Plane(eqn2);
	  let bisector = Plane.bisector(plane1, plane2);
	  let eqn = bisector.accute.equation();
	  ts.assertEquals(eqn.a, 23);
	  ts.assertEquals(eqn.b, -13);
	  ts.assertEquals(eqn.c, 32);
	  ts.assertEquals(eqn.d, 45);
	
	  eqn = bisector.obtuse.equation();
	  ts.assertEquals(eqn.a, 5);
	  ts.assertEquals(eqn.b, -1);
	  ts.assertEquals(eqn.c, -4);
	  ts.assertEquals(eqn.d, -3);
	
	  plane1 = new Plane({x:3, y: 8, z: 88}, {x:1, y: 12, z: 6}, {x:30, y: -2, z: 4});
	  plane2 = new Plane({x:5, y: 44, z: -16}, {x:-13, y: -20, z: 48}, {x:30, y: -2, z: 3});
	  bisector = Plane.bisector(plane1, plane2);
	
	  ts.assertEquals(plane1.equationEqualToZ(), '(0.038192x + 0.078697y + 1) / 0.002907');
	  ts.assertEquals(plane2.equationEqualToZ(), '(0.031282x + 0.035156y + 1) / 0.043954');
	  ts.assertEquals(bisector.obtuse.equationEqualToZ(), '(-0.000279x + 0.001991y + -0.023131) / -0.00366');
	  ts.assertEquals(bisector.accute.equationEqualToZ(), '(0.005197x + 0.008144y + 0.151916) / 0.004034');
	
	  ts.success();
	});
	
	
	Test.add('Plane: bisector',(ts) => {
	  const xyPlane = Plane.fromPointNormal({x: 12, y: 41, z: 0}, new Vector3D(1, 1, 1));
	  const yzPlane = Plane.fromPointNormal({x: 0, y: 41, z: 1}, new Vector3D(0, 3, -1));
	  const xzPlane = Plane.fromPointNormal({x: 12, y: 0, z: 50}, new Vector3D(5, 0, 13));
	  ts.success();
	});
	
});


RequireJS.addFunction('./test/tests/cabinet.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Cabinet = require('../../app-src/objects/assembly/assemblies/cabinet.js')
	const approximate = require('../../../../public/js/utils/approximate.js').new(100);
	
	
	Test.add('Cabinet: doorIntersect',(ts) => {
	  ts.assertEquals(6, 6);
	  let dx;
	
	  //Parrelle up with no right point
	  let llp = {x:0,y:0};
	  let lcp = {x:0,y:10};
	  let rcp = {x:0,y:20};
	  let rrp = undefined;
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, 1/8);
	  ts.assertEquals(dx.center.length, 9.8125);
	  ts.assertEquals(dx.center.center.x(), .5, null, 1000);
	  ts.assertEquals(dx.center.center.y(), 15 - 1/32, null, 1000);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.center.left.reveal, 1/16);
	  ts.assertEquals(dx.center.right.reveal, 1/8);
	  ts.assertEquals(dx.left.reveal, 1/16);
	
	  //Parrelle down with no leftPoint.
	  llp = undefined;
	  lcp = {x:0,y:20};
	  rcp = {x:0,y:10};
	  rrp = {x:0,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, 1/8);
	  ts.assertEquals(dx.center.length, 9.8125);
	  ts.assertEquals(dx.center.center.x(), -.5, null, 1000);
	  ts.assertEquals(dx.center.center.y(), 15 - 1/32, null, 1000);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.center.left.reveal, 1/8);
	  ts.assertEquals(dx.center.right.reveal, 1/16);
	  ts.assertEquals(dx.right.reveal, 1/16);
	
	  //Parrelle right
	  llp = {x:0,y:0};
	  lcp = {x:10,y:0};
	  rcp = {x:20,y:0};
	  rrp = {x:30,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, 1/8);
	  ts.assertEquals(dx.center.length, 9.875);
	  ts.assertEquals(dx.center.center.x(), 15, null, 1000);
	  ts.assertEquals(dx.center.center.y(), -.5, null, 1000);
	  ts.assertEquals(dx.center.left.reveal, 1/16);
	  ts.assertEquals(dx.center.right.reveal, 1/16);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.left.reveal, 1/16);
	  ts.assertEquals(dx.right.reveal, 1/16);
	
	  //Parrelle left
	  llp = {x:30,y:0};
	  lcp = {x:20,y:0};
	  rcp = {x:10,y:0};
	  rrp = {x:0,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, 1/8);
	  ts.assertEquals(dx.center.length, 9.875);
	  ts.assertEquals(dx.center.center.x(), 15, null, 1000);
	  ts.assertEquals(dx.center.center.y(), .5, null, 1000);
	  ts.assertEquals(dx.center.left.reveal, 1/16);
	  ts.assertEquals(dx.center.right.reveal, 1/16);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.left.reveal, 1/16);
	  ts.assertEquals(dx.right.reveal, 1/16);
	
	  // Inner Horse Shoe
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:10,y:10};
	  rrp = {x:10,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, .125);
	  ts.assertEquals(dx.center.length, 7.75);
	  ts.assertEquals(dx.center.left.reveal, 1.125);
	  ts.assertEquals(dx.center.right.reveal, 1.125);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.left.reveal, 1);
	  ts.assertEquals(dx.right.reveal, 1);
	
	  // Inner Horse Shoe 3/4
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:10,y:10};
	  rrp = {x:10,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 3/4, 3/4, 3/4, .125, 1/4);
	  ts.assertEquals(dx.center.length, 7.75);
	  ts.assertEquals(dx.center.center.x(), 5, null, 1000);
	  ts.assertEquals(dx.center.center.y(), 9.375, null, 1000);
	  ts.assertEquals(dx.center.left.reveal, 1.125);
	  ts.assertEquals(dx.center.right.reveal, 1.125);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.left.reveal, 1);
	  ts.assertEquals(dx.right.reveal, 1);
	
	  // Outer Horse Shoo
	  rrp = {x:0,y:0};
	  rcp = {x:0,y:10};
	  lcp = {x:10,y:10};
	  llp = {x:10,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, .125);
	  ts.assertEquals(dx.center.length, 11.75);
	  ts.assertEquals(dx.center.left.reveal, -.875);
	  ts.assertEquals(dx.center.right.reveal, -.875);
	  ts.assertEquals(approximate(Math.toDegrees(dx.left.theta)), 45);
	  ts.assertEquals(approximate(Math.toDegrees(dx.right.theta)), 45);
	  ts.assertEquals(dx.left.reveal, -1);
	  ts.assertEquals(dx.right.reveal, -1);
	
	  // Zig
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:10,y:20};
	  rrp = {x:10,y:30};
	
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, .125);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(approximate(Math.toDegrees(dx.right.theta)), 22.5);
	
	  // Wall right
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:10,y:20};
	  rrp = {x:30,y:20};
	
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 0, .125);
	  ts.assertEquals(dx.center.left.theta, undefined);
	  ts.assertEquals(approximate(Math.toDegrees(dx.center.right.theta)), 45);
	
	  // Wall left
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:9,y:25};
	  rrp = {x:30,y:20};
	
	  // dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 0, 1, 1, .125);
	  // ts.assertEquals(approximate(Math.toDegrees(dx.center.right.theta)), 17.57);
	  // ts.assertEquals(approximate(Math.toDegrees(dx.center.left.theta)), 59.04);
	
	  ts.success();
	});
	
});


RequireJS.addFunction('./test/tests/cost/category.js',
function (require, exports, module) {
	

	
	const Frame = require('../../../app-src/objects/assembly/assemblies/frame.js');
	const Panel = require('../../../app-src/objects/assembly/assemblies/panel.js');
	const StringMathEvaluator = require('../../../../../public/js/utils/string-math-evaluator.js');
	const Category = require('../../../app-src/cost/types/category.js');
	const Material = require('../../../app-src/cost/types/material.js');
	
	//
	//
	// {
	//   const frame = new Frame('f', 'Frame', '0,0,0', '4, 196\', .75');
	//   const panel = new Panel('p', 'Panel', '0,0,0', '24, 10, .75');
	//   const frame.addSubAssembly(panel);
	//   const props = {};
	//   const smeRound = StringMathEvaluator.round;
	//
	//   let unitCostValue = smeRound(15.37/(8*12));
	//   let costValue = smeRound(unitCostValue * 2 * 196 * 12);
	//   let assembly = frame;
	//   props.linear = {
	//     id: 'frame',
	//     method: 'Linear Feet',
	//     length: '8\'',
	//     cost: '15.37',
	//     formula: '2*l',
	//     unitCostValue, costValue, assembly
	//   };
	//
	//   unitCostValue = smeRound((75.13)/(96*48));
	//   costValue = smeRound(unitCostValue * 24 * 10);
	//   props.square = {
	//     id: 'panel0',
	//     method: 'Square Feet',
	//     length: '96',
	//     width: '48',
	//     cost: 75.13,
	//     unitCostValue, costValue, assembly
	//   };
	//
	//   unitCostValue = smeRound(29.86/(12*6*1));
	//   costValue = smeRound(unitCostValue * 24 * 10 * .75);
	//   props.cubic = {
	//     id: 'metal',
	//     method: 'Cubic Feet',
	//     length: '12',
	//     width: '6',
	//     depth: '1',
	//     cost: 29.86,
	//     unitCostValue, costValue, assembly
	//   };
	//
	//   unitCostValue = smeRound(50.12/10);
	//   costValue = smeRound(unitCostValue * 13);
	//   props.unit = {
	//     id: 'parts',
	//     method: 'Unit',
	//     laborType: 'Instalation',
	//     hourlyRate: '20',
	//     hours: '.66',
	//     cost: '50.12',
	//     count: '10',
	//     unitCostValue, costValue,
	//     assembly: 13
	//   };
	//   const catCost = new Category({id: 'catTest'});
	//
	//   Test.add('CategoryCost: calc',(ts) => {
	//     let totalCost = 0;
	//     function testProps(props) {
	//       const matCost = new Material(props);
	//       catCost.addChild(matCost);
	//       totalCost += matCost.calc(props.assembly);
	//     }
	//     Object.values(props).forEach(testProps);
	//     ts.assertTolerance(totalCost, catCost.calc(), .0001);
	//     ts.success();
	//   });
	// }
	
	exports.Frame = Frame
	exports.Panel = Panel
	exports.StringMathEvaluator = StringMathEvaluator
	exports.Category = Category
	exports.Material = Material
	
});


RequireJS.addFunction('./test/tests/cost/material.js',
function (require, exports, module) {
	

	const Frame = require('./labor.js').Frame;
	const Material = require('./category.js').Material;
	
	
	{
	  const frame = new Frame('f', 'Frame', '0,0,0', '4, 196\', .75');
	  const panel = new Panel('p', 'Panel', '0,0,0', '24, 10, .75');
	  const props = {};
	  const smeRound = StringMathEvaluator.round;
	  const referenceable = true;
	  const group = 'localTest30487';
	
	  let unitCostValue = smeRound(15.37/(8*12));
	  let costValue = smeRound(unitCostValue * 2 * 196 * 12);
	  let assembly = frame;
	  props.linear = {
	    id: 'frame',
	    method: 'Linear Feet',
	    objectId: 'Frame',
	    length: '8\'',
	    cost: '15.37',
	    formula: '2*l',
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound((75.13)/(96*48));
	  costValue = smeRound(unitCostValue * 24 * 10);
	  assembly = panel;
	  props.square = {
	    id: 'panel0',
	    method: 'Square Feet',
	    objectId: 'Panel',
	    length: '96',
	    width: '48',
	    cost: 75.13,
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound(29.86/(12*6*1));
	  costValue = smeRound(unitCostValue * 24 * 10 * .75);
	  props.cubic = {
	    id: 'metal',
	    method: 'Cubic Feet',
	    objectId: 'Panel',
	    length: '12',
	    width: '6',
	    depth: '1',
	    cost: 29.86,
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound(50.12/10);
	  costValue = smeRound(unitCostValue * 13);
	  props.unit = {
	    id: 'parts',
	    method: 'Unit',
	    laborType: 'Instalation',
	    hourlyRate: '20',
	    hours: '.66',
	    cost: '50.12',
	    count: '10',
	    referenceable, unitCostValue, costValue, group,
	    assembly: 13
	  };
	
	  Test.add('MaterialCost: unitCost/calc',(ts) => {
	    const costs = [];
	    function testProps(props) {
	      const labor = new Material(props);
	      costs.push(labor);
	      ts.assertTolerance(labor.unitCost().value, props.unitCostValue, .0001);
	      ts.assertTolerance(labor.calc(props.assembly), props.costValue, .0001);
	    }
	    Object.values(props).forEach(testProps);
	    costs.forEach((cost) => cost.delete());
	    ts.success();
	  });
	}
	
	exports.Frame = Frame
	exports.Material = Material
	
});


RequireJS.addFunction('./test/tests/cost/labor.js',
function (require, exports, module) {
	

	
	const Frame = require('../../../app-src/objects/assembly/assemblies/frame.js');
	const Panel = require('../../../app-src/objects/assembly/assemblies/panel.js');
	const StringMathEvaluator = require('../../../../../public/js/utils/string-math-evaluator.js');
	const Labor = require('../../../app-src/cost/types/material/labor.js');
	const FunctionArgumentTest = require('../../test.js').FunctionArgumentTest;
	
	
	{
	  const frame = new Frame('f', 'Frame', '0,0,0', '4, 196\', .75');
	  const panel = new Panel('p', 'Panel', '0,0,0', '24, 10, .75');
	  const props = {};
	  const smeRound = StringMathEvaluator.round;
	  const referenceable = true;
	  const group = 'localTest30487';
	
	  let unitCostValue = smeRound((35*.017)/(8*12));
	  let costValue = smeRound(unitCostValue * 196 * 12);
	  let assembly = frame;
	  props.linear = {
	    id: 'Sand Frame',
	    method: 'Linear Feet',
	    laborType: 'Sand',
	    objectId: 'Frame',
	    hourlyRate: '35',
	    length: '8\'',
	    hours: '.017',
	    formula: 'l',
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound((35*.08)/(48*48));
	  costValue = smeRound(unitCostValue * 24 * 10);
	  assembly = panel;
	  props.square = {
	    id: 'Sand Panel',
	    method: 'Square Feet',
	    laborType: 'Sand',
	    length: '48',
	    objectId: 'Panel',
	    width: '48',
	    hours: '.08',
	    formula: 'l*w',
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound((35*.06)/(12*6*1));
	  costValue = smeRound(unitCostValue * 24 * 10 * .75);
	  props.cubic = {
	    id: 'Sand Block',
	    method: 'Cubic Feet',
	    laborType: 'Sand',
	    hourlyRate: '35',
	    objectId: 'Panel',
	    length: '12',
	    width: '6',
	    depth: '1',
	    hours: '.06',
	    formula: 'l*w*d',
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound(20*.66);
	  costValue = smeRound(unitCostValue * 13);
	  props.unit = {
	    id: 'instalation',
	    method: 'Unit',
	    laborType: 'Instalation',
	    hourlyRate: '20',
	    hours: '.66',
	    referenceable, unitCostValue, costValue, group,
	    assembly: 13
	  };
	
	  Test.add('LaborCost: unitCost/calc',(ts) => {
	    const costs = [];
	    function testProps(props) {
	      const labor = new Labor(props);
	      costs.push(labor);
	      ts.assertTolerance(labor.unitCost().value, props.unitCostValue, .00001);
	      ts.assertTolerance(labor.calc(props.assembly), props.costValue, .00001);
	    }
	    Object.values(props).forEach(testProps);
	    costs.forEach((cost) => cost.delete());
	    ts.success();
	  });
	
	  // Test.add('LaborCost: argument validation',(ts) => {
	  //   const args = [props.linear];
	  //   const func = function (args) {new (Labor.prototype.constructor)(...arguments);}
	  //   new FunctionArgumentTest(ts, func, args)
	  //       .setIndex(0)
	  //       .add('id', undefined)
	  //       .run();
	  //   ts.success();
	  // });
	}
	
	exports.Frame = Frame
	exports.Panel = Panel
	exports.StringMathEvaluator = StringMathEvaluator
	exports.Labor = Labor
	exports.FunctionArgumentTest = FunctionArgumentTest
	
});


window.onload = () => RequireJS.init('app-src/init.js')
