let fs = () => 'Only works on searver';
let shell = fs;

try {
  fs = require('fs');
  shell = require('shelljs');
} catch(e) {}



function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

class MapScript {
  constructor (absolutePath, script) {
    this.script = script;
    script = MapScript.removeReg(/\/\/.*?\n/g, '', script);
    script = MapScript.removeReg(/`.*?`/g, '', script);
    script = MapScript.removeReg(/([^\\])\/[^\n]{1,}?[^\\]\//g, '$1', script);
    script = MapScript.removeReg(MapScript.reg.block, '', script);
    script = MapScript.removeReg(/\s{2,}/g, ' ', script);

    this.absPath = () => absolutePath;
    this.dir = () => absolutePath.replace(/^(.*\/).*$/, '$1')
    this.existingExports = MapScript.regToNameArr(MapScript.reg.export, script);
    this.requires = MapScript.regToNameArr(MapScript.reg.require, script);
    this.classes = MapScript.regToNameArr(MapScript.reg.class, script);
    this.functions = MapScript.regToNameArr(MapScript.reg.function, script);
    this.consts = MapScript.regToNameArr(MapScript.reg.const, script);

    this.exports = this.existingExports.length > 0 ?
                    this.existingExports : (this.classes.length > 0 ?
                        this.classes : (this.functions.length > 0 ?
                          this.functions : this.consts));

    this.exportStr = () => {
      let exportStr = '';
      if (this.existingExports.length === 0) {
        if (this.exports.length === 1) return `module.exports = ${this.exports[0]}\n`;
        this.exports.forEach((exprt) => (exportStr += `exports.${exprt} = ${exprt}\n`));
      }
      return exportStr;
    }

    this.requireStr = async () => {
      return new Promise(async (resolve) => {
        let requireStr = '';
        if (this.requires.length === 0) {
          const reqReg = MapScript.findRequireReg();
          console.log(reqReg)
          if (reqReg) {
            const referenced = this.script.match(reqReg.all) || [];
            const filesRefd = {};
            filesRefd[this.absPath()] = true;
            for (let i = 0; i < referenced.length; i += 1) {
              const ref = referenced[i];
              const formattedRef = ref.match(reqReg.first)[1];
              const refMap = MapScript.list[formattedRef];
              if (!filesRefd[refMap.absPath()]) {
                filesRefd[refMap.absPath()] = true;
                const moduleExport = refMap.exports.length === 1;
                console.log(this.dir(), '->', refMap.absPath())
                const relitivePath = await MapScript.toRelitivePath(refMap.absPath(), this.dir());
                requireStr += `const ${formattedRef} = require('${relitivePath}')`;
                requireStr += moduleExport ? ';\n' : `.${formattedRef};\n`
              }
            }
          }
        }
        resolve(requireStr);
      });
      return requireStr;
    }

    this.toString = async () => {
      const arrToStr = (name, arr) => `(${arr.length}) ${name}: ${arr}\n`;
      console.log(`File: ${absolutePath}\n` +
             arrToStr('exports', this.exports) +
             arrToStr('requires', this.requires) +
             arrToStr('classes', this.classes) +
             arrToStr('functions', this.functions) +
             arrToStr('consts', this.consts) +
             `requireStr ${await this.requireStr()}\n` +
             `exportStr ${this.exportStr()}\n` +
             `script: \n${script}`);
    }
    this.exports.forEach((name) => MapScript.list[name] = this);
  }
}

MapScript.list = {};
MapScript.findRequireReg = () => {
  let reg = '';
  const names = Object.keys(MapScript.list);
  console.log('nameslen', names.length);
  if (names.length === 0) return null;
  names.forEach((name) => {
    reg += `${name}|`;
  });
  reg = reg.substr(0, reg.length - 1);
  reg = `[^a-z^A-Z^$^_](${reg})[^a-z^A-Z^0-9^$^_]`;
  return {all: new RegExp(reg, 'g'), first: new RegExp(reg)};
}
MapScript.regToNameArr = function (regObj, script) {
  const arr = [];
  const matches = script.match(regObj.all) || [];
  matches.forEach((match) =>
    arr.push(regObj.name.apply(null, match.match(regObj.first))))
  return arr;
}

MapScript.removeReg = function (reg, replace, script) {
  while(script.match(reg)) {
    script = script.replace(reg, replace);
  }
  return script;
}

MapScript.value = {one: (match, one) => one};
MapScript.value.exports = (match, one, two, exportName, realName) => {
  return exportName || realName;
}

MapScript.reg = {};
MapScript.reg.const = {
  all: /const\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)\s{1,}=/g,
  first: /const\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)\s{1,}=/,
  name: MapScript.value.one
}

MapScript.reg.function = {
  all: /function\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)/g,
  first: /function\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)/,
  name: MapScript.value.one
}

MapScript.reg.class = {
  all: /class\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)/g,
  first: /class\s{1,}([a-zA-Z$_][a-zA-Z0-9$_]*)/,
  name: MapScript.value.one
}
MapScript.reg.export = {
  all: /(module.|)exports(.([a-zA-Z$_][a-zA-Z0-9$_]*)|)\s*=\s*([a-zA-Z$_][a-zA-Z0-9$_]*)/g,
  first: /(module.|)exports(.([a-zA-Z$_][a-zA-Z0-9$_]*)|)\s*=\s*([a-zA-Z$_][a-zA-Z0-9$_]*)/,
  name: MapScript.value.exports
}

MapScript.reg.require = {
  all: /require\((.*?)\)/g,
  first: /require\((.*?)\)/,
  name: MapScript.value.one
}

MapScript.reg.block = /\{[^{^}]*\}/g;
MapScript.upFolderRegex = /(\/|^)([^/]{3,}|[^.]|[^.].|.[^.])\/\.\.\//g;


MapScript.simplifyPath = function (path) {
  path = path.replace(/^\.\//, '');
  path = path.replace(/\/.\//, '/');
  path += path.match(/^.*\.(js|json)$/) ? '' : '.js';
  let simplified = path;
  let currSimplify = path;
  while(currSimplify.match(MapScript.upFolderRegex)) {
    currSimplify = currSimplify.replace(MapScript.upFolderRegex, '$1');
    simplified = currSimplify;
  }
  const fChar = simplified[0];
  if (fChar !== '.' && fChar !== '/') simplified = `./${simplified}`;
  return simplified;
}

MapScript.toRelitivePath = async function (path, dir) {
  const cmd = `realpath --relative-to='${dir}' '${path}'`;
  const promise = new Promise((resolve) => {
    function resolver(data) {
      const relPath = MapScript.simplifyPath(`${data.trim()}`);
      resolve(relPath);
    }
    const child = shell.exec(cmd, {async: true});
    child.stdout.on('data', resolver);
  });
  return promise;
}


class RequireJS {
  constructor(projectDir, main) {
    function guessProjectDir () {
      const stackTarget = new Error().stack.split('\n')[4];
      return stackTarget === undefined ? '' : stackTarget
          .replace(/^.*?\(([^(^:]*)\/[^/]{1,}?:.*$/, '$1');
    }

    projectDir = projectDir || guessProjectDir();
    const scripts = {};
    const prefixReg = /^\.\//;
    const trimPrefix = (path) => path.replace(prefixReg, '');

    const nameReg = /^(.*)\/(.*)$/;
    function guessFilePath (wrongPath, currFile) {
      const guesses = [];
      const fileName = wrongPath.replace(nameReg, '$2').toLowerCase();
      Object.keys(scripts).forEach((path) => {
        const name = path.replace(nameReg, '$2').toLowerCase();
        if (name === fileName) {
          guesses.push(determinRelitivePath(currFile, path));
        }
      });
      return guesses;
    }

    function determinRelitivePath(from, to) {
      from = trimPrefix(MapScript.simplifyPath(from))
      from = from.replace(nameReg, '$1');
      from = from.split('/');
      to = trimPrefix(MapScript.simplifyPath(to))
      to = to.split('/');
      let index = 0;
      while (from[index] && from[index] === to[index]) {
        index += 1;
      }
      const backPages = from.length - index;
      const relPathArr = backPages === 0  ? `./${to.slice(to.length - 1)}` :
                          new Array(backPages).fill('..').concat(to.slice(index)).join('/');
      return relPathArr;
    }

    function requireWrapper (absDir, relitivePath, filePath) {
      relitivePath = MapScript.simplifyPath(relitivePath);
      const path = MapScript.simplifyPath(`${absDir}${relitivePath}`);
      if (scripts[path] instanceof Unloaded) {
        scripts[path] = scripts[path].load();
      }
      if (scripts[path] === undefined) console.warn(`Trying to load a none exisant js file
\t'${relitivePath}' from file '${filePath}'
\t\tDid you mean:\n\t\t\t${guessFilePath(relitivePath, filePath).join('\n\t\t\t')}`);
      return scripts[path];
    }

    function requireFunc (absoluteDir, filePath) {
      return (relitivePath) => requireWrapper(absoluteDir, relitivePath, filePath);
    }

    const loadPath = [];
    class Unloaded {
      constructor(path, func) {
        const absoluteDir = MapScript.simplifyPath(path).replace(/(.*\/).*/, '$1');
        const modulee = {exports: {}};
        this.load = () => {
          if (loadPath.indexOf(path) !== -1) throw Error(`Circular Reference: \n\t\t${loadPath.join('\n\t\t')}`);
          loadPath.push(path);
          // console.log('loading: ', path);
          func(requireFunc(absoluteDir, path), modulee.exports, modulee);
          loadPath.splice(loadPath.indexOf(path), 1);
          return modulee.exports;
        };
      }
    }

    function addFunction (path, func) {
      scripts[path] = new Unloaded(path, func);
    }

    let header;
    this.header = () => {
      if (header === undefined) {
        header = fs.readFileSync(__filename, 'utf8');
      }
      return `${header}\n\n\n`;
    }

    this.footer = () => {
      return `window.onload = () => RequireJS.init('${main}')\n`;
    }

    let guess = false;
    this.guess = (g) => guess = (typeof g) === 'boolean' ? g : !guess;

    function resolveBody (script) {
      async function resolver(resolve) {
        try {
          JSON.parse(script);
          resolve(`module.exports = ${script.trim()};`);
        } catch (e) {
          if (guess) {
            const reqStr = await map.requireStr();
            const expStr = map.exportStr();
            resolve(`${reqStr}\n${script}${expStr}\n`);
          } else {
            resolve(script);
          }
        }
      }
      return new Promise(resolver);
    }


    const startTime = new Date().getTime();
    const pathCache = {};
    function encapsulate(absolutePath, script) {
      const map = new MapScript(absolutePath, script);
      async function resolver (resolve) {
        if (pathCache[absolutePath] === undefined) {
          pathCache[absolutePath] = await MapScript.toRelitivePath(absolutePath, projectDir);
        }
        const body = await resolveBody(script);
        const encaps = `RequireJS.addFunction('${pathCache[absolutePath]}',
function (require, exports, module) {
${body.replace(/(^|\n)/g, '\n\t').substr(1)}
});\n\n\n`;
        resolve(encaps);

        if (guess && startTime + 10000 < new Date().getTime()) {
          console.log('writinggggg...')
          fs.writeFile(map.absPath(), body, 'utf8');
        }

      }
      const promise = new Promise(resolver);
      return promise;
    }

    function init(main) {
      requireWrapper ('', main)
    }

    this.init = init;
    this.encapsulate = encapsulate;
    this.addFunction = addFunction;
  }
}


try {
  exports.RequireJS = RequireJS;
} catch (e) {}

RequireJS = new RequireJS();



RequireJS.addFunction('./services/cabinet/globals/CONSTANTS.js',
function (require, exports, module) {
	
const APP_ID = 'cabinet-builder';
	const Draw2d = require('../../../public/js/utils/canvas/two-d/draw.js');
	
	
	const PULL_TYPE = {
	  DRAWER: 'Drawer',
	  DOOR: 'Door'
	};
	
	const debug = {
	  showFlags: false,
	  showNormals: false
	}
	
	Draw2d.debug.showFlags = debug.showFlags;
	Draw2d.debug.showNormals = debug.showNormals;
	
	exports.VIEWER = {height: 600, width: 600}
	exports.APP_ID = APP_ID
	exports.PULL_TYPE = PULL_TYPE
	
});


RequireJS.addFunction('./services/cabinet/public/json/endpoints.json',
function (require, exports, module) {
	module.exports = {
	  "_envs": {
	    "local": "http://localhost:3000/cabinet",
	    "dev": "https://dev.jozsefmorrissey.com/cabinet",
	    "prod": "https://node.jozsefmorrissey.com/cabinet"
	  },
	  "user": {
	    "register": "/register",
	    "resendActivation": "/resend/activation",
	    "activate": "/activate/:email/:secret",
	    "validate": "/validate",
	    "login": "/login",
	    "status": "/status",
	    "resetPasswordRequest": "/reset/password/request",
	    "resetPassword": "/reset/password/:email/:secret"
	  },
	  "cabinet": {
	    "add": "/:id",
	    "list": "/all"
	  },
	  "config": {
	    "get": "/config/get",
	    "save": "/config/save"
	  },
	  "costs": {
	    "save": "/costs/save",
	    "get": "/costs/get"
	  },
	  "configuration": {
	    "save": "/configuration/save",
	    "get": "/configuration/get"
	  },
	  "patterns": {
	    "save": "/patterns/save",
	    "get": "/patterns/get"
	  },
	  "properties": {
	    "save": "/properties/save",
	    "get": "/properties/get"
	  },
	  "templates": {
	    "save": "/templates/save",
	    "get": "/templates/get"
	  },
	  "order": {
	    "add": "/order/:id",
	    "get": "/order/:id",
	    "list": "/list/orders"
	  },
	  "export": {
	    "dxf": "/export/dxf"
	  }
	};
});


RequireJS.addFunction('./services/cabinet/generated/EPNTS.js',
function (require, exports, module) {
	const Endpoints = require('../../../public/js/utils/endpoints.js');
	const json = require('../public/json/endpoints.json');
	module.exports = new Endpoints(json, 'local').getFuncObj();
});


RequireJS.addFunction('./services/cabinet/public/js/3d-modeling/lightgl.js',
function (require, exports, module) {
	/*
	 * lightgl.js
	 * http://github.com/evanw/lightgl.js/
	 *
	 * Copyright 2011 Evan Wallace
	 * Released under the MIT license
	 */
	module.exports = (function() {
	
	// src/shader.js
	// Provides a convenient wrapper for WebGL shaders. A few uniforms and attributes,
	// prefixed with `gl_`, are automatically added to all shader sources to make
	// simple shaders easier to write.
	//
	// Example usage:
	//
	//     var shader = new GL.Shader('\
	//       void main() {\
	//         gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
	//       }\
	//     ', '\
	//       uniform vec4 color;\
	//       void main() {\
	//         gl_FragColor = color;\
	//       }\
	//     ');
	//
	//     shader.uniforms({
	//       color: [1, 0, 0, 1]
	//     }).draw(mesh);
	
	function regexMap(regex, text, callback) {
	  let result;
	  while ((result = regex.exec(text)) != null) {
	    callback(result);
	  }
	}
	
	// Non-standard names beginning with `gl_` must be mangled because they will
	// otherwise cause a compiler error.
	var LIGHTGL_PREFIX = 'LIGHTGL';
	
	// ### new GL.Shader(vertexSource, fragmentSource)
	//
	// Compiles a shader program using the provided vertex and fragment shaders.
	function Shader(vertexSource, fragmentSource) {
	  // Allow passing in the id of an HTML script tag with the source
	  function followScriptTagById(id) {
	    var element = document.getElementById(id);
	    return element ? element.text : id;
	  }
	  vertexSource = followScriptTagById(vertexSource);
	  fragmentSource = followScriptTagById(fragmentSource);
	
	  // Headers are prepended to the sources to provide some automatic functionality.
	  var header = '\
	    uniform mat3 gl_NormalMatrix;\
	    uniform mat4 gl_ModelViewMatrix;\
	    uniform mat4 gl_ProjectionMatrix;\
	    uniform mat4 gl_ModelViewProjectionMatrix;\
	    uniform mat4 gl_ModelViewMatrixInverse;\
	    uniform mat4 gl_ProjectionMatrixInverse;\
	    uniform mat4 gl_ModelViewProjectionMatrixInverse;\
	  ';
	  var vertexHeader = header + '\
	    attribute vec4 gl_Vertex;\
	    attribute vec4 gl_TexCoord;\
	    attribute vec3 gl_Normal;\
	    attribute vec4 gl_Color;\
	    vec4 ftransform() {\
	      return gl_ModelViewProjectionMatrix * gl_Vertex;\
	    }\
	  ';
	  var fragmentHeader = '\
	    precision highp float;\
	  ' + header;
	
	  // Check for the use of built-in matrices that require expensive matrix
	  // multiplications to compute, and record these in `usedMatrices`.
	  var source = vertexSource + fragmentSource;
	  var usedMatrices = {};
	  regexMap(/\b(gl_[^;]*)\b;/g, header, function(groups) {
	    var name = groups[1];
	    if (source.indexOf(name) != -1) {
	      var capitalLetters = name.replace(/[a-z_]/g, '');
	      usedMatrices[capitalLetters] = LIGHTGL_PREFIX + name;
	    }
	  });
	  if (source.indexOf('ftransform') != -1) usedMatrices.MVPM = LIGHTGL_PREFIX + 'gl_ModelViewProjectionMatrix';
	  this.usedMatrices = usedMatrices;
	
	  // The `gl_` prefix must be substituted for something else to avoid compile
	  // errors, since it's a reserved prefix. This prefixes all reserved names with
	  // `_`. The header is inserted after any extensions, since those must come
	  // first.
	  function fix(header, source) {
	    var replaced = {};
	    var match = /^((\s*\/\/.*\n|\s*#extension.*\n)+)[^]*$/.exec(source);
	    source = match ? match[1] + header + source.substr(match[1].length) : header + source;
	    regexMap(/\bgl_\w+\b/g, header, function(result) {
	      if (!(result in replaced)) {
	        source = source.replace(new RegExp('\\b' + result + '\\b', 'g'), LIGHTGL_PREFIX + result);
	        replaced[result] = true;
	      }
	    });
	    return source;
	  }
	  vertexSource = fix(vertexHeader, vertexSource);
	  fragmentSource = fix(fragmentHeader, fragmentSource);
	
	  // Compile and link errors are thrown as strings.
	  function compileSource(type, source) {
	    var shader = gl.createShader(type);
	    gl.shaderSource(shader, source);
	    gl.compileShader(shader);
	    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	      throw new Error('compile error: ' + gl.getShaderInfoLog(shader));
	    }
	    return shader;
	  }
	  this.program = gl.createProgram();
	  gl.attachShader(this.program, compileSource(gl.VERTEX_SHADER, vertexSource));
	  gl.attachShader(this.program, compileSource(gl.FRAGMENT_SHADER, fragmentSource));
	  gl.linkProgram(this.program);
	  if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
	    throw new Error('link error: ' + gl.getProgramInfoLog(this.program));
	  }
	  this.attributes = {};
	  this.uniformLocations = {};
	
	  // Sampler uniforms need to be uploaded using `gl.uniform1i()` instead of `gl.uniform1f()`.
	  // To do this automatically, we detect and remember all uniform samplers in the source code.
	  var isSampler = {};
	  regexMap(/uniform\s+sampler(1D|2D|3D|Cube)\s+(\w+)\s*;/g, vertexSource + fragmentSource, function(groups) {
	    isSampler[groups[2]] = 1;
	  });
	  this.isSampler = isSampler;
	}
	
	function isArray(obj) {
	  var str = Object.prototype.toString.call(obj);
	  return str == '[object Array]' || str == '[object Float32Array]';
	}
	
	function isNumber(obj) {
	  var str = Object.prototype.toString.call(obj);
	  return str == '[object Number]' || str == '[object Boolean]';
	}
	
	var tempMatrix = new Matrix();
	var resultMatrix = new Matrix();
	
	Shader.prototype = {
	  // ### .uniforms(uniforms)
	  //
	  // Set a uniform for each property of `uniforms`. The correct `gl.uniform*()` method is
	  // inferred from the value types and from the stored uniform sampler flags.
	  uniforms: function(uniforms) {
	    gl.useProgram(this.program);
	
	    for (var name in uniforms) {
	      var location = this.uniformLocations[name] || gl.getUniformLocation(this.program, name);
	      if (!location) continue;
	      this.uniformLocations[name] = location;
	      var value = uniforms[name];
	      if (value instanceof Vector) {
	        value = [value.x, value.y, value.z];
	      } else if (value instanceof Matrix) {
	        value = value.m;
	      }
	      if (isArray(value)) {
	        switch (value.length) {
	          case 1: gl.uniform1fv(location, new Float32Array(value)); break;
	          case 2: gl.uniform2fv(location, new Float32Array(value)); break;
	          case 3: gl.uniform3fv(location, new Float32Array(value)); break;
	          case 4: gl.uniform4fv(location, new Float32Array(value)); break;
	          // Matrices are automatically transposed, since WebGL uses column-major
	          // indices instead of row-major indices.
	          case 9: gl.uniformMatrix3fv(location, false, new Float32Array([
	            value[0], value[3], value[6],
	            value[1], value[4], value[7],
	            value[2], value[5], value[8]
	          ])); break;
	          case 16: gl.uniformMatrix4fv(location, false, new Float32Array([
	            value[0], value[4], value[8], value[12],
	            value[1], value[5], value[9], value[13],
	            value[2], value[6], value[10], value[14],
	            value[3], value[7], value[11], value[15]
	          ])); break;
	          default: throw new Error('don\'t know how to load uniform "' + name + '" of length ' + value.length);
	        }
	      } else if (isNumber(value)) {
	        (this.isSampler[name] ? gl.uniform1i : gl.uniform1f).call(gl, location, value);
	      } else {
	        throw new Error('attempted to set uniform "' + name + '" to invalid value ' + value);
	      }
	    }
	
	    return this;
	  },
	
	  // ### .draw(mesh[, mode])
	  //
	  // Sets all uniform matrix attributes, binds all relevant buffers, and draws the
	  // mesh geometry as indexed triangles or indexed lines. Set `mode` to `gl.LINES`
	  // (and either add indices to `lines` or call `computeWireframe()`) to draw the
	  // mesh in wireframe.
	  draw: function(mesh, mode) {
	    this.drawBuffers(mesh.vertexBuffers,
	      mesh.indexBuffers[mode == gl.LINES ? 'lines' : 'triangles'],
	      arguments.length < 2 ? gl.TRIANGLES : mode);
	  },
	
	  // ### .drawBuffers(vertexBuffers, indexBuffer, mode)
	  //
	  // Sets all uniform matrix attributes, binds all relevant buffers, and draws the
	  // indexed mesh geometry. The `vertexBuffers` argument is a map from attribute
	  // names to `Buffer` objects of type `gl.ARRAY_BUFFER`, `indexBuffer` is a `Buffer`
	  // object of type `gl.ELEMENT_ARRAY_BUFFER`, and `mode` is a WebGL primitive mode
	  // like `gl.TRIANGLES` or `gl.LINES`. This method automatically creates and caches
	  // vertex attribute pointers for attributes as needed.
	  drawBuffers: function(vertexBuffers, indexBuffer, mode) {
	    // Only construct up the built-in matrices we need for this shader.
	    var used = this.usedMatrices;
	    var MVM = gl.modelviewMatrix;
	    var PM = gl.projectionMatrix;
	    var MVMI = (used.MVMI || used.NM) ? MVM.inverse() : null;
	    var PMI = (used.PMI) ? PM.inverse() : null;
	    var MVPM = (used.MVPM || used.MVPMI) ? PM.multiply(MVM) : null;
	    var matrices = {};
	    if (used.MVM) matrices[used.MVM] = MVM;
	    if (used.MVMI) matrices[used.MVMI] = MVMI;
	    if (used.PM) matrices[used.PM] = PM;
	    if (used.PMI) matrices[used.PMI] = PMI;
	    if (used.MVPM) matrices[used.MVPM] = MVPM;
	    if (used.MVPMI) matrices[used.MVPMI] = MVPM.inverse();
	    if (used.NM) {
	      var m = MVMI.m;
	      matrices[used.NM] = [m[0], m[4], m[8], m[1], m[5], m[9], m[2], m[6], m[10]];
	    }
	    this.uniforms(matrices);
	
	    // Create and enable attribute pointers as necessary.
	    var length = 0;
	    for (var attribute in vertexBuffers) {
	      var buffer = vertexBuffers[attribute];
	      var location = this.attributes[attribute] ||
	        gl.getAttribLocation(this.program, attribute.replace(/^(gl_.*)$/, LIGHTGL_PREFIX + '$1'));
	      if (location == -1 || !buffer.buffer) continue;
	      this.attributes[attribute] = location;
	      gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
	      gl.enableVertexAttribArray(location);
	      gl.vertexAttribPointer(location, buffer.buffer.spacing, gl.FLOAT, false, 0, 0);
	      length = buffer.buffer.length / buffer.buffer.spacing;
	    }
	
	    // Disable unused attribute pointers.
	    for (var attribute in this.attributes) {
	      if (!(attribute in vertexBuffers)) {
	        gl.disableVertexAttribArray(this.attributes[attribute]);
	      }
	    }
	
	    // Draw the geometry.
	    if (length && (!indexBuffer || indexBuffer.buffer)) {
	      if (indexBuffer) {
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
	        gl.drawElements(mode, indexBuffer.buffer.length, gl.UNSIGNED_SHORT, 0);
	      } else {
	        gl.drawArrays(mode, 0, length);
	      }
	    }
	
	    return this;
	  }
	};
	
	// src/vector.js
	// Provides a simple 3D vector class. Vector operations can be done using member
	// functions, which return new vectors, or static functions, which reuse
	// existing vectors to avoid generating garbage.
	function Vector(x, y, z) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	}
	
	// ### Instance Methods
	// The methods `add()`, `subtract()`, `multiply()`, and `divide()` can all
	// take either a vector or a number as an argument.
	Vector.prototype = {
	  negative: function() {
	    return new Vector(-this.x, -this.y, -this.z);
	  },
	  add: function(v) {
	    if (v instanceof Vector) return new Vector(this.x + v.x, this.y + v.y, this.z + v.z);
	    else return new Vector(this.x + v, this.y + v, this.z + v);
	  },
	  subtract: function(v) {
	    if (v instanceof Vector) return new Vector(this.x - v.x, this.y - v.y, this.z - v.z);
	    else return new Vector(this.x - v, this.y - v, this.z - v);
	  },
	  multiply: function(v) {
	    if (v instanceof Vector) return new Vector(this.x * v.x, this.y * v.y, this.z * v.z);
	    else return new Vector(this.x * v, this.y * v, this.z * v);
	  },
	  divide: function(v) {
	    if (v instanceof Vector) return new Vector(this.x / v.x, this.y / v.y, this.z / v.z);
	    else return new Vector(this.x / v, this.y / v, this.z / v);
	  },
	  equals: function(v) {
	    return this.x == v.x && this.y == v.y && this.z == v.z;
	  },
	  dot: function(v) {
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	  },
	  cross: function(v) {
	    return new Vector(
	      this.y * v.z - this.z * v.y,
	      this.z * v.x - this.x * v.z,
	      this.x * v.y - this.y * v.x
	    );
	  },
	  length: function() {
	    return Math.sqrt(this.dot(this));
	  },
	  unit: function() {
	    return this.divide(this.length());
	  },
	  min: function() {
	    return Math.min(Math.min(this.x, this.y), this.z);
	  },
	  max: function() {
	    return Math.max(Math.max(this.x, this.y), this.z);
	  },
	  toAngles: function() {
	    return {
	      theta: Math.atan2(this.z, this.x),
	      phi: Math.asin(this.y / this.length())
	    };
	  },
	  angleTo: function(a) {
	    return Math.acos(this.dot(a) / (this.length() * a.length()));
	  },
	  toArray: function(n) {
	    return [this.x, this.y, this.z].slice(0, n || 3);
	  },
	  clone: function() {
	    return new Vector(this.x, this.y, this.z);
	  },
	  init: function(x, y, z) {
	    this.x = x; this.y = y; this.z = z;
	    return this;
	  }
	};
	
	// ### Static Methods
	// `Vector.randomDirection()` returns a vector with a length of 1 and a
	// statistically uniform direction. `Vector.lerp()` performs linear
	// interpolation between two vectors.
	Vector.negative = function(a, b) {
	  b.x = -a.x; b.y = -a.y; b.z = -a.z;
	  return b;
	};
	Vector.add = function(a, b, c) {
	  if (b instanceof Vector) { c.x = a.x + b.x; c.y = a.y + b.y; c.z = a.z + b.z; }
	  else { c.x = a.x + b; c.y = a.y + b; c.z = a.z + b; }
	  return c;
	};
	Vector.subtract = function(a, b, c) {
	  if (b instanceof Vector) { c.x = a.x - b.x; c.y = a.y - b.y; c.z = a.z - b.z; }
	  else { c.x = a.x - b; c.y = a.y - b; c.z = a.z - b; }
	  return c;
	};
	Vector.multiply = function(a, b, c) {
	  if (b instanceof Vector) { c.x = a.x * b.x; c.y = a.y * b.y; c.z = a.z * b.z; }
	  else { c.x = a.x * b; c.y = a.y * b; c.z = a.z * b; }
	  return c;
	};
	Vector.divide = function(a, b, c) {
	  if (b instanceof Vector) { c.x = a.x / b.x; c.y = a.y / b.y; c.z = a.z / b.z; }
	  else { c.x = a.x / b; c.y = a.y / b; c.z = a.z / b; }
	  return c;
	};
	Vector.cross = function(a, b, c) {
	  c.x = a.y * b.z - a.z * b.y;
	  c.y = a.z * b.x - a.x * b.z;
	  c.z = a.x * b.y - a.y * b.x;
	  return c;
	};
	Vector.unit = function(a, b) {
	  var length = a.length();
	  b.x = a.x / length;
	  b.y = a.y / length;
	  b.z = a.z / length;
	  return b;
	};
	Vector.fromAngles = function(theta, phi) {
	  return new Vector(Math.cos(theta) * Math.cos(phi), Math.sin(phi), Math.sin(theta) * Math.cos(phi));
	};
	Vector.randomDirection = function() {
	  return Vector.fromAngles(Math.random() * Math.PI * 2, Math.asin(Math.random() * 2 - 1));
	};
	Vector.min = function(a, b) {
	  return new Vector(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z));
	};
	Vector.max = function(a, b) {
	  return new Vector(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z));
	};
	Vector.lerp = function(a, b, fraction) {
	  return b.subtract(a).multiply(fraction).add(a);
	};
	Vector.fromArray = function(a) {
	  return new Vector(a[0], a[1], a[2]);
	};
	Vector.angleBetween = function(a, b) {
	  return a.angleTo(b);
	};
	
	// src/mesh.js
	// Represents indexed triangle geometry with arbitrary additional attributes.
	// You need a shader to draw a mesh; meshes can't draw themselves.
	//
	// A mesh is a collection of `GL.Buffer` objects which are either vertex buffers
	// (holding per-vertex attributes) or index buffers (holding the order in which
	// vertices are rendered). By default, a mesh has a position vertex buffer called
	// `vertices` and a triangle index buffer called `triangles`. New buffers can be
	// added using `addVertexBuffer()` and `addIndexBuffer()`. Two strings are
	// required when adding a new vertex buffer, the name of the data array on the
	// mesh instance and the name of the GLSL attribute in the vertex shader.
	//
	// Example usage:
	//
	//     var mesh = new GL.Mesh({ coords: true, lines: true });
	//
	//     // Default attribute "vertices", available as "gl_Vertex" in
	//     // the vertex shader
	//     mesh.vertices = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]];
	//
	//     // Optional attribute "coords" enabled in constructor,
	//     // available as "gl_TexCoord" in the vertex shader
	//     mesh.coords = [[0, 0], [1, 0], [0, 1], [1, 1]];
	//
	//     // Custom attribute "weights", available as "weight" in the
	//     // vertex shader
	//     mesh.addVertexBuffer('weights', 'weight');
	//     mesh.weights = [1, 0, 0, 1];
	//
	//     // Default index buffer "triangles"
	//     mesh.triangles = [[0, 1, 2], [2, 1, 3]];
	//
	//     // Optional index buffer "lines" enabled in constructor
	//     mesh.lines = [[0, 1], [0, 2], [1, 3], [2, 3]];
	//
	//     // Upload provided data to GPU memory
	//     mesh.compile();
	
	// ### new GL.Indexer()
	//
	// Generates indices into a list of unique objects from a stream of objects
	// that may contain duplicates. This is useful for generating compact indexed
	// meshes from unindexed data.
	function Indexer() {
	  this.unique = [];
	  this.indices = [];
	  this.map = {};
	}
	
	Indexer.prototype = {
	  // ### .add(v)
	  //
	  // Adds the object `obj` to `unique` if it hasn't already been added. Returns
	  // the index of `obj` in `unique`.
	  add: function(obj) {
	    var key = JSON.stringify(obj);
	    if (!(key in this.map)) {
	      this.map[key] = this.unique.length;
	      this.unique.push(obj);
	    }
	    return this.map[key];
	  }
	};
	
	// ### new GL.Buffer(target, type)
	//
	// Provides a simple method of uploading data to a GPU buffer. Example usage:
	//
	//     var vertices = new GL.Buffer(gl.ARRAY_BUFFER, Float32Array);
	//     var indices = new GL.Buffer(gl.ELEMENT_ARRAY_BUFFER, Uint16Array);
	//     vertices.data = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]];
	//     indices.data = [[0, 1, 2], [2, 1, 3]];
	//     vertices.compile();
	//     indices.compile();
	//
	function Buffer(target, type) {
	  this.buffer = null;
	  this.target = target;
	  this.type = type;
	  this.data = [];
	}
	
	Buffer.prototype = {
	  // ### .compile(type)
	  //
	  // Upload the contents of `data` to the GPU in preparation for rendering. The
	  // data must be a list of lists where each inner list has the same length. For
	  // example, each element of data for vertex normals would be a list of length three.
	  // This will remember the data length and element length for later use by shaders.
	  // The type can be either `gl.STATIC_DRAW` or `gl.DYNAMIC_DRAW`, and defaults to
	  // `gl.STATIC_DRAW`.
	  //
	  // This could have used `[].concat.apply([], this.data)` to flatten
	  // the array but Google Chrome has a maximum number of arguments so the
	  // concatenations are chunked to avoid that limit.
	  compile: function(type) {
	    var data = [];
	    for (var i = 0, chunk = 10000; i < this.data.length; i += chunk) {
	      data = Array.prototype.concat.apply(data, this.data.slice(i, i + chunk));
	    }
	    var spacing = this.data.length ? data.length / this.data.length : 0;
	    if (spacing != Math.round(spacing)) throw new Error('buffer elements not of consistent size, average size is ' + spacing);
	    this.buffer = this.buffer || gl.createBuffer();
	    this.buffer.length = data.length;
	    this.buffer.spacing = spacing;
	    gl.bindBuffer(this.target, this.buffer);
	    gl.bufferData(this.target, new this.type(data), type || gl.STATIC_DRAW);
	  }
	};
	
	// ### new GL.Mesh([options])
	//
	// Represents a collection of vertex buffers and index buffers. Each vertex
	// buffer maps to one attribute in GLSL and has a corresponding property set
	// on the Mesh instance. There is one vertex buffer by default: `vertices`,
	// which maps to `gl_Vertex`. The `coords`, `normals`, and `colors` vertex
	// buffers map to `gl_TexCoord`, `gl_Normal`, and `gl_Color` respectively,
	// and can be enabled by setting the corresponding options to true. There are
	// two index buffers, `triangles` and `lines`, which are used for rendering
	// `gl.TRIANGLES` and `gl.LINES`, respectively. Only `triangles` is enabled by
	// default, although `computeWireframe()` will add a normal buffer if it wasn't
	// initially enabled.
	function Mesh(options) {
	  options = options || {};
	  this.vertexBuffers = {};
	  this.indexBuffers = {};
	  this.addVertexBuffer('vertices', 'gl_Vertex');
	  if (options.coords) this.addVertexBuffer('coords', 'gl_TexCoord');
	  if (options.normals) this.addVertexBuffer('normals', 'gl_Normal');
	  if (options.colors) this.addVertexBuffer('colors', 'gl_Color');
	  if (!('triangles' in options) || options.triangles) this.addIndexBuffer('triangles');
	  if (options.lines) this.addIndexBuffer('lines');
	}
	
	Mesh.prototype = {
	  // ### .addVertexBuffer(name, attribute)
	  //
	  // Add a new vertex buffer with a list as a property called `name` on this object
	  // and map it to the attribute called `attribute` in all shaders that draw this mesh.
	  addVertexBuffer: function(name, attribute) {
	    var buffer = this.vertexBuffers[attribute] = new Buffer(gl.ARRAY_BUFFER, Float32Array);
	    buffer.name = name;
	    this[name] = [];
	  },
	
	  // ### .addIndexBuffer(name)
	  //
	  // Add a new index buffer with a list as a property called `name` on this object.
	  addIndexBuffer: function(name) {
	    var buffer = this.indexBuffers[name] = new Buffer(gl.ELEMENT_ARRAY_BUFFER, Uint16Array);
	    this[name] = [];
	  },
	
	  // ### .compile()
	  //
	  // Upload all attached buffers to the GPU in preparation for rendering. This
	  // doesn't need to be called every frame, only needs to be done when the data
	  // changes.
	  compile: function() {
	    for (var attribute in this.vertexBuffers) {
	      var buffer = this.vertexBuffers[attribute];
	      buffer.data = this[buffer.name];
	      buffer.compile();
	    }
	
	    for (var name in this.indexBuffers) {
	      var buffer = this.indexBuffers[name];
	      buffer.data = this[name];
	      buffer.compile();
	    }
	  },
	
	  // ### .transform(matrix)
	  //
	  // Transform all vertices by `matrix` and all normals by the inverse transpose
	  // of `matrix`.
	  transform: function(matrix) {
	    this.vertices = this.vertices.map(function(v) {
	      return matrix.transformPoint(Vector.fromArray(v)).toArray();
	    });
	    if (this.normals) {
	      var invTrans = matrix.inverse().transpose();
	      this.normals = this.normals.map(function(n) {
	        return invTrans.transformVector(Vector.fromArray(n)).unit().toArray();
	      });
	    }
	    this.compile();
	    return this;
	  },
	
	  // ### .computeNormals()
	  //
	  // Computes a new normal for each vertex from the average normal of the
	  // neighboring triangles. This means adjacent triangles must share vertices
	  // for the resulting normals to be smooth.
	  computeNormals: function() {
	    if (!this.normals) this.addVertexBuffer('normals', 'gl_Normal');
	    for (var i = 0; i < this.vertices.length; i++) {
	      this.normals[i] = new Vector();
	    }
	    for (var i = 0; i < this.triangles.length; i++) {
	      var t = this.triangles[i];
	      var a = Vector.fromArray(this.vertices[t[0]]);
	      var b = Vector.fromArray(this.vertices[t[1]]);
	      var c = Vector.fromArray(this.vertices[t[2]]);
	      var normal = b.subtract(a).cross(c.subtract(a)).unit();
	      this.normals[t[0]] = this.normals[t[0]].add(normal);
	      this.normals[t[1]] = this.normals[t[1]].add(normal);
	      this.normals[t[2]] = this.normals[t[2]].add(normal);
	    }
	    for (var i = 0; i < this.vertices.length; i++) {
	      this.normals[i] = this.normals[i].unit().toArray();
	    }
	    this.compile();
	    return this;
	  },
	
	  // ### .computeWireframe()
	  //
	  // Populate the `lines` index buffer from the `triangles` index buffer.
	  computeWireframe: function() {
	    var indexer = new Indexer();
	    for (var i = 0; i < this.triangles.length; i++) {
	      var t = this.triangles[i];
	      for (var j = 0; j < t.length; j++) {
	        var a = t[j], b = t[(j + 1) % t.length];
	        indexer.add([Math.min(a, b), Math.max(a, b)]);
	      }
	    }
	    if (!this.lines) this.addIndexBuffer('lines');
	    this.lines = indexer.unique;
	    this.compile();
	    return this;
	  },
	
	  // ### .getAABB()
	  //
	  // Computes the axis-aligned bounding box, which is an object whose `min` and
	  // `max` properties contain the minimum and maximum coordinates of all vertices.
	  getAABB: function() {
	    var aabb = { min: new Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE) };
	    aabb.max = aabb.min.negative();
	    for (var i = 0; i < this.vertices.length; i++) {
	      var v = Vector.fromArray(this.vertices[i]);
	      aabb.min = Vector.min(aabb.min, v);
	      aabb.max = Vector.max(aabb.max, v);
	    }
	    return aabb;
	  },
	
	  // ### .getBoundingSphere()
	  //
	  // Computes a sphere that contains all vertices (not necessarily the smallest
	  // sphere). The returned object has two properties, `center` and `radius`.
	  getBoundingSphere: function() {
	    var aabb = this.getAABB();
	    var sphere = { center: aabb.min.add(aabb.max).divide(2), radius: 0 };
	    for (var i = 0; i < this.vertices.length; i++) {
	      sphere.radius = Math.max(sphere.radius,
	        Vector.fromArray(this.vertices[i]).subtract(sphere.center).length());
	    }
	    return sphere;
	  }
	};
	
	// ### GL.Mesh.plane([options])
	//
	// Generates a square 2x2 mesh the xy plane centered at the origin. The
	// `options` argument specifies options to pass to the mesh constructor.
	// Additional options include `detailX` and `detailY`, which set the tesselation
	// in x and y, and `detail`, which sets both `detailX` and `detailY` at once.
	// Two triangles are generated by default.
	// Example usage:
	//
	//     var mesh1 = GL.Mesh.plane();
	//     var mesh2 = GL.Mesh.plane({ detail: 5 });
	//     var mesh3 = GL.Mesh.plane({ detailX: 20, detailY: 40 });
	//
	Mesh.plane = function(options) {
	  options = options || {};
	  var mesh = new Mesh(options);
	  detailX = options.detailX || options.detail || 1;
	  detailY = options.detailY || options.detail || 1;
	
	  for (var y = 0; y <= detailY; y++) {
	    var t = y / detailY;
	    for (var x = 0; x <= detailX; x++) {
	      var s = x / detailX;
	      mesh.vertices.push([2 * s - 1, 2 * t - 1, 0]);
	      if (mesh.coords) mesh.coords.push([s, t]);
	      if (mesh.normals) mesh.normals.push([0, 0, 1]);
	      if (x < detailX && y < detailY) {
	        var i = x + y * (detailX + 1);
	        mesh.triangles.push([i, i + 1, i + detailX + 1]);
	        mesh.triangles.push([i + detailX + 1, i + 1, i + detailX + 2]);
	      }
	    }
	  }
	
	  mesh.compile();
	  return mesh;
	};
	
	var cubeData = [
	  [0, 4, 2, 6, -1, 0, 0], // -x
	  [1, 3, 5, 7, +1, 0, 0], // +x
	  [0, 1, 4, 5, 0, -1, 0], // -y
	  [2, 6, 3, 7, 0, +1, 0], // +y
	  [0, 2, 1, 3, 0, 0, -1], // -z
	  [4, 5, 6, 7, 0, 0, +1]  // +z
	];
	
	function pickOctant(i) {
	  return new Vector((i & 1) * 2 - 1, (i & 2) - 1, (i & 4) / 2 - 1);
	}
	
	// ### GL.Mesh.cube([options])
	//
	// Generates a 2x2x2 box centered at the origin. The `options` argument
	// specifies options to pass to the mesh constructor.
	Mesh.cube = function(options) {
	  var mesh = new Mesh(options);
	
	  for (var i = 0; i < cubeData.length; i++) {
	    var data = cubeData[i], v = i * 4;
	    for (var j = 0; j < 4; j++) {
	      var d = data[j];
	      mesh.vertices.push(pickOctant(d).toArray());
	      if (mesh.coords) mesh.coords.push([j & 1, (j & 2) / 2]);
	      if (mesh.normals) mesh.normals.push(data.slice(4, 7));
	    }
	    mesh.triangles.push([v, v + 1, v + 2]);
	    mesh.triangles.push([v + 2, v + 1, v + 3]);
	  }
	
	  mesh.compile();
	  return mesh;
	};
	
	// ### GL.Mesh.sphere([options])
	//
	// Generates a geodesic sphere of radius 1. The `options` argument specifies
	// options to pass to the mesh constructor in addition to the `detail` option,
	// which controls the tesselation level. The detail is `6` by default.
	// Example usage:
	//
	//     var mesh1 = GL.Mesh.sphere();
	//     var mesh2 = GL.Mesh.sphere({ detail: 2 });
	//
	Mesh.sphere = function(options) {
	  function tri(a, b, c) { return flip ? [a, c, b] : [a, b, c]; }
	  function fix(x) { return x + (x - x * x) / 2; }
	  options = options || {};
	  var mesh = new Mesh(options);
	  var indexer = new Indexer();
	  detail = options.detail || 6;
	
	  for (var octant = 0; octant < 8; octant++) {
	    var scale = pickOctant(octant);
	    var flip = scale.x * scale.y * scale.z > 0;
	    var data = [];
	    for (var i = 0; i <= detail; i++) {
	      // Generate a row of vertices on the surface of the sphere
	      // using barycentric coordinates.
	      for (var j = 0; i + j <= detail; j++) {
	        var a = i / detail;
	        var b = j / detail;
	        var c = (detail - i - j) / detail;
	        var vertex = { vertex: new Vector(fix(a), fix(b), fix(c)).unit().multiply(scale).toArray() };
	        if (mesh.coords) vertex.coord = scale.y > 0 ? [1 - a, c] : [c, 1 - a];
	        data.push(indexer.add(vertex));
	      }
	
	      // Generate triangles from this row and the previous row.
	      if (i > 0) {
	        for (var j = 0; i + j <= detail; j++) {
	          var a = (i - 1) * (detail + 1) + ((i - 1) - (i - 1) * (i - 1)) / 2 + j;
	          var b = i * (detail + 1) + (i - i * i) / 2 + j;
	          mesh.triangles.push(tri(data[a], data[a + 1], data[b]));
	          if (i + j < detail) {
	            mesh.triangles.push(tri(data[b], data[a + 1], data[b + 1]));
	          }
	        }
	      }
	    }
	  }
	
	  // Reconstruct the geometry from the indexer.
	  mesh.vertices = indexer.unique.map(function(v) { return v.vertex; });
	  if (mesh.coords) mesh.coords = indexer.unique.map(function(v) { return v.coord; });
	  if (mesh.normals) mesh.normals = mesh.vertices;
	  mesh.compile();
	  return mesh;
	};
	
	// ### GL.Mesh.load(json[, options])
	//
	// Creates a mesh from the JSON generated by the `convert/convert.py` script.
	// Example usage:
	//
	//     var data = {
	//       vertices: [[0, 0, 0], [1, 0, 0], [0, 1, 0]],
	//       triangles: [[0, 1, 2]]
	//     };
	//     var mesh = GL.Mesh.load(data);
	//
	Mesh.load = function(json, options) {
	  options = options || {};
	  if (!('coords' in options)) options.coords = !!json.coords;
	  if (!('normals' in options)) options.normals = !!json.normals;
	  if (!('colors' in options)) options.colors = !!json.colors;
	  if (!('triangles' in options)) options.triangles = !!json.triangles;
	  if (!('lines' in options)) options.lines = !!json.lines;
	  var mesh = new Mesh(options);
	  mesh.vertices = json.vertices;
	  if (mesh.coords) mesh.coords = json.coords;
	  if (mesh.normals) mesh.normals = json.normals;
	  if (mesh.colors) mesh.colors = json.colors;
	  if (mesh.triangles) mesh.triangles = json.triangles;
	  if (mesh.lines) mesh.lines = json.lines;
	  mesh.compile();
	  return mesh;
	};
	
	// src/main.js
	// The internal `gl` variable holds the current WebGL context.
	var gl;
	
	var GL = {
	  // ### Initialization
	  //
	  // `GL.create()` creates a new WebGL context and augments it with more
	  // methods. The alpha channel is disabled by default because it usually causes
	  // unintended transparencies in the canvas.
	  create: function(options) {
	    options = options || {};
	    var canvas = document.createElement('canvas');
	    canvas.width = 800;
	    canvas.height = 600;
	    if (!('alpha' in options)) options.alpha = false;
	    try { gl = canvas.getContext('webgl', options); } catch (e) {}
	    try { gl = gl || canvas.getContext('experimental-webgl', options); } catch (e) {}
	    if (!gl) throw new Error('WebGL not supported');
	    gl.HALF_FLOAT_OES = 0x8D61;
	    addMatrixStack();
	    addImmediateMode();
	    addEventListeners();
	    addOtherMethods();
	    return gl;
	  },
	
	  // `GL.keys` contains a mapping of key codes to booleans indicating whether
	  // that key is currently pressed.
	  keys: {},
	
	  // Export all external classes.
	  Matrix: Matrix,
	  Indexer: Indexer,
	  Buffer: Buffer,
	  Mesh: Mesh,
	  HitTest: HitTest,
	  Raytracer: Raytracer,
	  Shader: Shader,
	  Texture: Texture,
	  Vector: Vector
	};
	
	// ### Matrix stack
	//
	// Implement the OpenGL modelview and projection matrix stacks, along with some
	// other useful GLU matrix functions.
	
	function addMatrixStack() {
	  gl.MODELVIEW = ENUM | 1;
	  gl.PROJECTION = ENUM | 2;
	  var tempMatrix = new Matrix();
	  var resultMatrix = new Matrix();
	  gl.modelviewMatrix = new Matrix();
	  gl.projectionMatrix = new Matrix();
	  var modelviewStack = [];
	  var projectionStack = [];
	  var matrix, stack;
	  gl.matrixMode = function(mode) {
	    switch (mode) {
	      case gl.MODELVIEW:
	        matrix = 'modelviewMatrix';
	        stack = modelviewStack;
	        break;
	      case gl.PROJECTION:
	        matrix = 'projectionMatrix';
	        stack = projectionStack;
	        break;
	      default:
	        throw new Error('invalid matrix mode ' + mode);
	    }
	  };
	  gl.loadIdentity = function() {
	    Matrix.identity(gl[matrix]);
	  };
	  gl.setIdentity = function (m) {
	    gl[matrix] = m;
	  }
	  gl.loadMatrix = function(m) {
	    var from = m.m, to = gl[matrix].m;
	    for (var i = 0; i < 16; i++) {
	      to[i] = from[i];
	    }
	  };
	  gl.multMatrix = function(m) {
	    gl.loadMatrix(Matrix.multiply(gl[matrix], m, resultMatrix));
	  };
	  gl.perspective = function(fov, aspect, near, far) {
	    gl.multMatrix(Matrix.perspective(fov, aspect, near, far, tempMatrix));
	  };
	  gl.frustum = function(l, r, b, t, n, f) {
	    gl.multMatrix(Matrix.frustum(l, r, b, t, n, f, tempMatrix));
	  };
	  gl.ortho = function(l, r, b, t, n, f) {
	    gl.multMatrix(Matrix.ortho(l, r, b, t, n, f, tempMatrix));
	  };
	  gl.scale = function(x, y, z) {
	    gl.multMatrix(Matrix.scale(x, y, z, tempMatrix));
	  };
	  gl.translate = function(x, y, z) {
	    gl.multMatrix(Matrix.translate(x, y, z, tempMatrix));
	  };
	  gl.rotateAroundPoint = function(point, rotations) {
	    gl.multMatrix(Matrix.rotateAroundPoint(point, rotations, tempMatrix));
	  };
	  gl.rotate = function(a, x, y, z) {
	    gl.multMatrix(Matrix.rotate(a, x, y, z, tempMatrix));
	  };
	  gl.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz) {
	    return gl.multMatrix(Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz, tempMatrix));
	  };
	  gl.pushMatrix = function() {
	    stack.push(Array.prototype.slice.call(gl[matrix].m));
	  };
	  gl.popMatrix = function() {
	    var m = stack.pop();
	    gl[matrix].m = hasFloat32Array ? new Float32Array(m) : m;
	  };
	  gl.project = function(objX, objY, objZ, modelview, projection, viewport) {
	    modelview = modelview || gl.modelviewMatrix;
	    projection = projection || gl.projectionMatrix;
	    viewport = viewport || gl.getParameter(gl.VIEWPORT);
	    var point = projection.transformPoint(modelview.transformPoint(new Vector(objX, objY, objZ)));
	    return new Vector(
	      viewport[0] + viewport[2] * (point.x * 0.5 + 0.5),
	      viewport[1] + viewport[3] * (point.y * 0.5 + 0.5),
	      point.z * 0.5 + 0.5
	    );
	  };
	  gl.unProject = function(winX, winY, winZ, modelview, projection, viewport) {
	    modelview = modelview || gl.modelviewMatrix;
	    projection = projection || gl.projectionMatrix;
	    viewport = viewport || gl.getParameter(gl.VIEWPORT);
	    var point = new Vector(
	      (winX - viewport[0]) / viewport[2] * 2 - 1,
	      (winY - viewport[1]) / viewport[3] * 2 - 1,
	      winZ * 2 - 1
	    );
	    return Matrix.inverse(Matrix.multiply(projection, modelview, tempMatrix), resultMatrix).transformPoint(point);
	  };
	  gl.matrixMode(gl.MODELVIEW);
	}
	
	// ### Immediate mode
	//
	// Provide an implementation of OpenGL's deprecated immediate mode. This is
	// depricated for a reason: constantly re-specifying the geometry is a bad
	// idea for performance. You should use a `GL.Mesh` instead, which specifies
	// the geometry once and caches it on the graphics card. Still, nothing
	// beats a quick `gl.begin(gl.POINTS); gl.vertex(1, 2, 3); gl.end();` for
	// debugging. This intentionally doesn't implement fixed-function lighting
	// because it's only meant for quick debugging tasks.
	
	function addImmediateMode() {
	  var immediateMode = {
	    mesh: new Mesh({ coords: true, colors: true, triangles: false }),
	    mode: -1,
	    coord: [0, 0, 0, 0],
	    color: [1, 1, 1, 1],
	    pointSize: 1,
	    shader: new Shader('\
	      uniform float pointSize;\
	      varying vec4 color;\
	      varying vec4 coord;\
	      void main() {\
	        color = gl_Color;\
	        coord = gl_TexCoord;\
	        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
	        gl_PointSize = pointSize;\
	      }\
	    ', '\
	      uniform sampler2D texture;\
	      uniform float pointSize;\
	      uniform bool useTexture;\
	      varying vec4 color;\
	      varying vec4 coord;\
	      void main() {\
	        gl_FragColor = color;\
	        if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\
	      }\
	    ')
	  };
	  gl.pointSize = function(pointSize) {
	    immediateMode.shader.uniforms({ pointSize: pointSize });
	  };
	  gl.begin = function(mode) {
	    if (immediateMode.mode != -1) throw new Error('mismatched gl.begin() and gl.end() calls');
	    immediateMode.mode = mode;
	    immediateMode.mesh.colors = [];
	    immediateMode.mesh.coords = [];
	    immediateMode.mesh.vertices = [];
	  };
	  gl.color = function(r, g, b, a) {
	    immediateMode.color = (arguments.length == 1) ? r.toArray().concat(1) : [r, g, b, a || 1];
	  };
	  gl.texCoord = function(s, t) {
	    immediateMode.coord = (arguments.length == 1) ? s.toArray(2) : [s, t];
	  };
	  gl.vertex = function(x, y, z) {
	    immediateMode.mesh.colors.push(immediateMode.color);
	    immediateMode.mesh.coords.push(immediateMode.coord);
	    immediateMode.mesh.vertices.push(arguments.length == 1 ? x.toArray() : [x, y, z]);
	  };
	  gl.end = function() {
	    if (immediateMode.mode == -1) throw new Error('mismatched gl.begin() and gl.end() calls');
	    immediateMode.mesh.compile();
	    immediateMode.shader.uniforms({
	      useTexture: !!gl.getParameter(gl.TEXTURE_BINDING_2D)
	    }).draw(immediateMode.mesh, immediateMode.mode);
	    immediateMode.mode = -1;
	  };
	}
	
	// ### Improved mouse events
	//
	// This adds event listeners on the `gl.canvas` element that call
	// `gl.onmousedown()`, `gl.onmousemove()`, and `gl.onmouseup()` with an
	// augmented event object. The event object also has the properties `x`, `y`,
	// `deltaX`, `deltaY`, and `dragging`.
	function addEventListeners() {
	  var context = gl, oldX = 0, oldY = 0, buttons = {}, hasOld = false;
	  var has = Object.prototype.hasOwnProperty;
	  function isDragging() {
	    for (var b in buttons) {
	      if (has.call(buttons, b) && buttons[b]) return true;
	    }
	    return false;
	  }
	  function augment(original) {
	    // Make a copy of original, a native `MouseEvent`, so we can overwrite
	    // WebKit's non-standard read-only `x` and `y` properties (which are just
	    // duplicates of `pageX` and `pageY`). We can't just use
	    // `Object.create(original)` because some `MouseEvent` functions must be
	    // called in the context of the original event object.
	    var e = {};
	    for (var name in original) {
	      if (typeof original[name] == 'function') {
	        e[name] = (function(callback) {
	          return function() {
	            callback.apply(original, arguments);
	          };
	        })(original[name]);
	      } else {
	        e[name] = original[name];
	      }
	    }
	    e.original = original;
	    e.x = e.pageX;
	    e.y = e.pageY;
	    for (var obj = gl.canvas; obj; obj = obj.offsetParent) {
	      e.x -= obj.offsetLeft;
	      e.y -= obj.offsetTop;
	    }
	    if (hasOld) {
	      e.deltaX = e.x - oldX;
	      e.deltaY = e.y - oldY;
	    } else {
	      e.deltaX = 0;
	      e.deltaY = 0;
	      hasOld = true;
	    }
	    oldX = e.x;
	    oldY = e.y;
	    e.dragging = isDragging();
	    e.preventDefault = function() {
	      e.original.preventDefault();
	    };
	    e.stopPropagation = function() {
	      e.original.stopPropagation();
	    };
	    return e;
	  }
	  function mousedown(e) {
	    gl = context;
	    if (!isDragging()) {
	      // Expand the event handlers to the document to handle dragging off canvas.
	      on(document, 'mousemove', mousemove);
	      on(document, 'mouseup', mouseup);
	      off(gl.canvas, 'mousemove', mousemove);
	      off(gl.canvas, 'mouseup', mouseup);
	    }
	    buttons[e.which] = true;
	    e = augment(e);
	    if (gl.onmousedown) gl.onmousedown(e);
	    e.preventDefault();
	  }
	  function mousemove(e) {
	    gl = context;
	    e = augment(e);
	    if (gl.onmousemove) gl.onmousemove(e);
	    e.preventDefault();
	  }
	  function mouseup(e) {
	    gl = context;
	    buttons[e.which] = false;
	    if (!isDragging()) {
	      // Shrink the event handlers back to the canvas when dragging ends.
	      off(document, 'mousemove', mousemove);
	      off(document, 'mouseup', mouseup);
	      on(gl.canvas, 'mousemove', mousemove);
	      on(gl.canvas, 'mouseup', mouseup);
	    }
	    e = augment(e);
	    if (gl.onmouseup) gl.onmouseup(e);
	    e.preventDefault();
	  }
	  function reset() {
	    hasOld = false;
	  }
	  function resetAll() {
	    buttons = {};
	    hasOld = false;
	  }
	  on(gl.canvas, 'mousedown', mousedown);
	  on(gl.canvas, 'mousemove', mousemove);
	  on(gl.canvas, 'mouseup', mouseup);
	  on(gl.canvas, 'mouseover', reset);
	  on(gl.canvas, 'mouseout', reset);
	  on(document, 'contextmenu', resetAll);
	}
	
	// ### Automatic keyboard state
	//
	// The current keyboard state is stored in `GL.keys`, a map of integer key
	// codes to booleans indicating whether that key is currently pressed. Certain
	// keys also have named identifiers that can be used directly, such as
	// `GL.keys.SPACE`. Values in `GL.keys` are initially undefined until that
	// key is pressed for the first time. If you need a boolean value, you can
	// cast the value to boolean by applying the not operator twice (as in
	// `!!GL.keys.SPACE`).
	
	function mapKeyCode(code) {
	  var named = {
	    8: 'BACKSPACE',
	    9: 'TAB',
	    13: 'ENTER',
	    16: 'SHIFT',
	    27: 'ESCAPE',
	    32: 'SPACE',
	    37: 'LEFT',
	    38: 'UP',
	    39: 'RIGHT',
	    40: 'DOWN'
	  };
	  return named[code] || (code >= 65 && code <= 90 ? String.fromCharCode(code) : null);
	}
	
	function on(element, name, callback) {
	  element.addEventListener(name, callback);
	}
	
	function off(element, name, callback) {
	  element.removeEventListener(name, callback);
	}
	
	on(document, 'keydown', function(e) {
	  if (!e.altKey && !e.ctrlKey && !e.metaKey) {
	    var key = mapKeyCode(e.keyCode);
	    if (key) GL.keys[key] = true;
	    GL.keys[e.keyCode] = true;
	  }
	});
	
	on(document, 'keyup', function(e) {
	  if (!e.altKey && !e.ctrlKey && !e.metaKey) {
	    var key = mapKeyCode(e.keyCode);
	    if (key) GL.keys[key] = false;
	    GL.keys[e.keyCode] = false;
	  }
	});
	
	function addOtherMethods() {
	  // ### Multiple contexts
	  //
	  // When using multiple contexts in one web page, `gl.makeCurrent()` must be
	  // called before issuing commands to a different context.
	  (function(context) {
	    gl.makeCurrent = function() {
	      gl = context;
	    };
	  })(gl);
	
	  // ### Animation
	  //
	  // Call `gl.animate()` to provide an animation loop that repeatedly calls
	  // `gl.onupdate()` and `gl.ondraw()`.
	  gl.animate = function() {
	    var post =
	      window.requestAnimationFrame ||
	      window.mozRequestAnimationFrame ||
	      window.webkitRequestAnimationFrame ||
	      function(callback) { setTimeout(callback, 1000 / 60); };
	    var time = new Date().getTime();
	    var context = gl;
	    function update() {
	      gl = context;
	      var now = new Date().getTime();
	      if (gl.onupdate) gl.onupdate((now - time) / 1000);
	      if (gl.ondraw) gl.ondraw();
	      post(update);
	      time = now;
	    }
	    update();
	  };
	
	  // ### Fullscreen
	  //
	  // Provide an easy way to get a fullscreen app running, including an
	  // automatic 3D perspective projection matrix by default. This should be
	  // called once.
	  //
	  // Just fullscreen, no automatic camera:
	  //
	  //     gl.fullscreen({ camera: false });
	  //
	  // Adjusting field of view, near plane distance, and far plane distance:
	  //
	  //     gl.fullscreen({ fov: 45, near: 0.1, far: 1000 });
	  //
	  // Adding padding from the edge of the window:
	  //
	  //     gl.fullscreen({ paddingLeft: 250, paddingBottom: 60 });
	  //
	  gl.fullscreen = function(options) {
	    options = options || {};
	    var top = options.paddingTop || 0;
	    var left = options.paddingLeft || 0;
	    var right = options.paddingRight || 0;
	    var bottom = options.paddingBottom || 0;
	    if (!document.body) {
	      throw new Error('document.body doesn\'t exist yet (call gl.fullscreen() from ' +
	        'window.onload() or from inside the <body> tag)');
	    }
	    document.body.appendChild(gl.canvas);
	    document.body.style.overflow = 'hidden';
	    gl.canvas.style.position = 'absolute';
	    gl.canvas.style.left = left + 'px';
	    gl.canvas.style.top = top + 'px';
	    function resize() {
	      gl.canvas.width = window.innerWidth - left - right;
	      gl.canvas.height = window.innerHeight - top - bottom;
	      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	      if (options.camera || !('camera' in options)) {
	        gl.matrixMode(gl.PROJECTION);
	        gl.loadIdentity();
	        gl.perspective(options.fov || 45, gl.canvas.width / gl.canvas.height,
	          options.near || 0.1, options.far || 1000);
	        gl.matrixMode(gl.MODELVIEW);
	      }
	      if (gl.ondraw) gl.ondraw();
	    }
	    on(window, 'resize', resize);
	    resize();
	  };
	}
	
	// A value to bitwise-or with new enums to make them distinguishable from the
	// standard WebGL enums.
	var ENUM = 0x12340000;
	
	// src/2d-projection.js
	
	// src/raytracer.js
	// Provides a convenient raytracing interface.
	
	// ### new GL.HitTest([t, hit, normal])
	//
	// This is the object used to return hit test results. If there are no
	// arguments, the constructed argument represents a hit infinitely far
	// away.
	function HitTest(t, hit, normal) {
	  this.t = arguments.length ? t : Number.MAX_VALUE;
	  this.hit = hit;
	  this.normal = normal;
	}
	
	// ### .mergeWith(other)
	//
	// Changes this object to be the closer of the two hit test results.
	HitTest.prototype = {
	  mergeWith: function(other) {
	    if (other.t > 0 && other.t < this.t) {
	      this.t = other.t;
	      this.hit = other.hit;
	      this.normal = other.normal;
	    }
	  }
	};
	
	// ### new GL.Raytracer()
	//
	// This will read the current modelview matrix, projection matrix, and viewport,
	// reconstruct the eye position, and store enough information to later generate
	// per-pixel rays using `getRayForPixel()`.
	//
	// Example usage:
	//
	//     var tracer = new GL.Raytracer();
	//     var ray = tracer.getRayForPixel(
	//       gl.canvas.width / 2,
	//       gl.canvas.height / 2);
	//     var result = GL.Raytracer.hitTestSphere(
	//       tracer.eye, ray, new GL.Vector(0, 0, 0), 1);
	function Raytracer() {
	  var v = gl.getParameter(gl.VIEWPORT);
	  var m = gl.modelviewMatrix.m;
	
	  var axisX = new Vector(m[0], m[4], m[8]);
	  var axisY = new Vector(m[1], m[5], m[9]);
	  var axisZ = new Vector(m[2], m[6], m[10]);
	  var offset = new Vector(m[3], m[7], m[11]);
	  this.eye = new Vector(-offset.dot(axisX), -offset.dot(axisY), -offset.dot(axisZ));
	
	  var minX = v[0], maxX = minX + v[2];
	  var minY = v[1], maxY = minY + v[3];
	  this.ray00 = gl.unProject(minX, minY, 1).subtract(this.eye);
	  this.ray10 = gl.unProject(maxX, minY, 1).subtract(this.eye);
	  this.ray01 = gl.unProject(minX, maxY, 1).subtract(this.eye);
	  this.ray11 = gl.unProject(maxX, maxY, 1).subtract(this.eye);
	  this.viewport = v;
	}
	
	Raytracer.prototype = {
	  // ### .getRayForPixel(x, y)
	  //
	  // Returns the ray originating from the camera and traveling through the pixel `x, y`.
	  getRayForPixel: function(x, y) {
	    x = (x - this.viewport[0]) / this.viewport[2];
	    y = 1 - (y - this.viewport[1]) / this.viewport[3];
	    var ray0 = Vector.lerp(this.ray00, this.ray10, x);
	    var ray1 = Vector.lerp(this.ray01, this.ray11, x);
	    return Vector.lerp(ray0, ray1, y).unit();
	  }
	};
	
	// ### GL.Raytracer.hitTestBox(origin, ray, min, max)
	//
	// Traces the ray starting from `origin` along `ray` against the axis-aligned box
	// whose coordinates extend from `min` to `max`. Returns a `HitTest` with the
	// information or `null` for no intersection.
	//
	// This implementation uses the [slab intersection method](http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm).
	Raytracer.hitTestBox = function(origin, ray, min, max) {
	  var tMin = min.subtract(origin).divide(ray);
	  var tMax = max.subtract(origin).divide(ray);
	  var t1 = Vector.min(tMin, tMax);
	  var t2 = Vector.max(tMin, tMax);
	  var tNear = t1.max();
	  var tFar = t2.min();
	
	  if (tNear > 0 && tNear < tFar) {
	    var epsilon = 1.0e-6, hit = origin.add(ray.multiply(tNear));
	    min = min.add(epsilon);
	    max = max.subtract(epsilon);
	    return new HitTest(tNear, hit, new Vector(
	      (hit.x > max.x) - (hit.x < min.x),
	      (hit.y > max.y) - (hit.y < min.y),
	      (hit.z > max.z) - (hit.z < min.z)
	    ));
	  }
	
	  return null;
	};
	
	// ### GL.Raytracer.hitTestSphere(origin, ray, center, radius)
	//
	// Traces the ray starting from `origin` along `ray` against the sphere defined
	// by `center` and `radius`. Returns a `HitTest` with the information or `null`
	// for no intersection.
	Raytracer.hitTestSphere = function(origin, ray, center, radius) {
	  var offset = origin.subtract(center);
	  var a = ray.dot(ray);
	  var b = 2 * ray.dot(offset);
	  var c = offset.dot(offset) - radius * radius;
	  var discriminant = b * b - 4 * a * c;
	
	  if (discriminant > 0) {
	    var t = (-b - Math.sqrt(discriminant)) / (2 * a), hit = origin.add(ray.multiply(t));
	    return new HitTest(t, hit, hit.subtract(center).divide(radius));
	  }
	
	  return null;
	};
	
	// ### GL.Raytracer.hitTestTriangle(origin, ray, a, b, c)
	//
	// Traces the ray starting from `origin` along `ray` against the triangle defined
	// by the points `a`, `b`, and `c`. Returns a `HitTest` with the information or
	// `null` for no intersection.
	Raytracer.hitTestTriangle = function(origin, ray, a, b, c) {
	  var ab = b.subtract(a);
	  var ac = c.subtract(a);
	  var normal = ab.cross(ac).unit();
	  var t = normal.dot(a.subtract(origin)) / normal.dot(ray);
	
	  if (t > 0) {
	    var hit = origin.add(ray.multiply(t));
	    var toHit = hit.subtract(a);
	    var dot00 = ac.dot(ac);
	    var dot01 = ac.dot(ab);
	    var dot02 = ac.dot(toHit);
	    var dot11 = ab.dot(ab);
	    var dot12 = ab.dot(toHit);
	    var divide = dot00 * dot11 - dot01 * dot01;
	    var u = (dot11 * dot02 - dot01 * dot12) / divide;
	    var v = (dot00 * dot12 - dot01 * dot02) / divide;
	    if (u >= 0 && v >= 0 && u + v <= 1) return new HitTest(t, hit, normal);
	  }
	
	  return null;
	};
	
	// src/texture.js
	// Provides a simple wrapper around WebGL textures that supports render-to-texture.
	
	// ### new GL.Texture(width, height[, options])
	//
	// The arguments `width` and `height` give the size of the texture in texels.
	// WebGL texture dimensions must be powers of two unless `filter` is set to
	// either `gl.NEAREST` or `gl.LINEAR` and `wrap` is set to `gl.CLAMP_TO_EDGE`
	// (which they are by default).
	//
	// Texture parameters can be passed in via the `options` argument.
	// Example usage:
	//
	//     var t = new GL.Texture(256, 256, {
	//       // Defaults to gl.LINEAR, set both at once with "filter"
	//       magFilter: gl.NEAREST,
	//       minFilter: gl.LINEAR,
	//
	//       // Defaults to gl.CLAMP_TO_EDGE, set both at once with "wrap"
	//       wrapS: gl.REPEAT,
	//       wrapT: gl.REPEAT,
	//
	//       format: gl.RGB, // Defaults to gl.RGBA
	//       type: gl.FLOAT // Defaults to gl.UNSIGNED_BYTE
	//     });
	function Texture(width, height, options) {
	  options = options || {};
	  this.id = gl.createTexture();
	  this.width = width;
	  this.height = height;
	  this.format = options.format || gl.RGBA;
	  this.type = options.type || gl.UNSIGNED_BYTE;
	  var magFilter = options.filter || options.magFilter || gl.LINEAR;
	  var minFilter = options.filter || options.minFilter || gl.LINEAR;
	  if (this.type === gl.FLOAT) {
	    if (!Texture.canUseFloatingPointTextures()) {
	      throw new Error('OES_texture_float is required but not supported');
	    }
	    if ((minFilter !== gl.NEAREST || magFilter !== gl.NEAREST) &&
	        !Texture.canUseFloatingPointLinearFiltering()) {
	      throw new Error('OES_texture_float_linear is required but not supported');
	    }
	  } else if (this.type === gl.HALF_FLOAT_OES) {
	    if (!Texture.canUseHalfFloatingPointTextures()) {
	      throw new Error('OES_texture_half_float is required but not supported');
	    }
	    if ((minFilter !== gl.NEAREST || magFilter !== gl.NEAREST) &&
	        !Texture.canUseHalfFloatingPointLinearFiltering()) {
	      throw new Error('OES_texture_half_float_linear is required but not supported');
	    }
	  }
	  gl.bindTexture(gl.TEXTURE_2D, this.id);
	  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.wrap || options.wrapS || gl.CLAMP_TO_EDGE);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.wrap || options.wrapT || gl.CLAMP_TO_EDGE);
	  gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, options.data || null);
	}
	
	var framebuffer;
	var renderbuffer;
	var checkerboardCanvas;
	
	Texture.prototype = {
	  // ### .bind([unit])
	  //
	  // Bind this texture to the given texture unit (0-7, defaults to 0).
	  bind: function(unit) {
	    gl.activeTexture(gl.TEXTURE0 + (unit || 0));
	    gl.bindTexture(gl.TEXTURE_2D, this.id);
	  },
	
	  // ### .unbind([unit])
	  //
	  // Clear the given texture unit (0-7, defaults to 0).
	  unbind: function(unit) {
	    gl.activeTexture(gl.TEXTURE0 + (unit || 0));
	    gl.bindTexture(gl.TEXTURE_2D, null);
	  },
	
	  // ### .canDrawTo()
	  //
	  // Check if rendering to this texture is supported. It may not be supported
	  // for floating-point textures on some configurations.
	  canDrawTo: function() {
	    framebuffer = framebuffer || gl.createFramebuffer();
	    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
	    var result = gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE;
	    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    return result;
	  },
	
	  // ### .drawTo(callback)
	  //
	  // Render all draw calls in `callback` to this texture. This method sets up
	  // a framebuffer with this texture as the color attachment and a renderbuffer
	  // as the depth attachment. It also temporarily changes the viewport to the
	  // size of the texture.
	  //
	  // Example usage:
	  //
	  //     texture.drawTo(function() {
	  //       gl.clearColor(1, 0, 0, 1);
	  //       gl.clear(gl.COLOR_BUFFER_BIT);
	  //     });
	  drawTo: function(callback) {
	    var v = gl.getParameter(gl.VIEWPORT);
	    framebuffer = framebuffer || gl.createFramebuffer();
	    renderbuffer = renderbuffer || gl.createRenderbuffer();
	    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
	    if (this.width != renderbuffer.width || this.height != renderbuffer.height) {
	      renderbuffer.width = this.width;
	      renderbuffer.height = this.height;
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
	    }
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
	    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
	    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
	      throw new Error('Rendering to this texture is not supported (incomplete framebuffer)');
	    }
	    gl.viewport(0, 0, this.width, this.height);
	
	    callback();
	
	    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	    gl.viewport(v[0], v[1], v[2], v[3]);
	  },
	
	  // ### .swapWith(other)
	  //
	  // Switch this texture with `other`, useful for the ping-pong rendering
	  // technique used in multi-stage rendering.
	  swapWith: function(other) {
	    var temp;
	    temp = other.id; other.id = this.id; this.id = temp;
	    temp = other.width; other.width = this.width; this.width = temp;
	    temp = other.height; other.height = this.height; this.height = temp;
	  }
	};
	
	// ### GL.Texture.fromImage(image[, options])
	//
	// Return a new image created from `image`, an `<img>` tag.
	Texture.fromImage = function(image, options) {
	  options = options || {};
	  var texture = new Texture(image.width, image.height, options);
	  try {
	    gl.texImage2D(gl.TEXTURE_2D, 0, texture.format, texture.format, texture.type, image);
	  } catch (e) {
	    if (location.protocol == 'file:') {
	      throw new Error('image not loaded for security reasons (serve this page over "http://" instead)');
	    } else {
	      throw new Error('image not loaded for security reasons (image must originate from the same ' +
	        'domain as this page or use Cross-Origin Resource Sharing)');
	    }
	  }
	  if (options.minFilter && options.minFilter != gl.NEAREST && options.minFilter != gl.LINEAR) {
	    gl.generateMipmap(gl.TEXTURE_2D);
	  }
	  return texture;
	};
	
	// ### GL.Texture.fromURL(url[, options])
	//
	// Returns a checkerboard texture that will switch to the correct texture when
	// it loads.
	Texture.fromURL = function(url, options) {
	  checkerboardCanvas = checkerboardCanvas || (function() {
	    var c = document.createElement('canvas').getContext('2d');
	    c.canvas.width = c.canvas.height = 128;
	    for (var y = 0; y < c.canvas.height; y += 16) {
	      for (var x = 0; x < c.canvas.width; x += 16) {
	        c.fillStyle = (x ^ y) & 16 ? '#FFF' : '#DDD';
	        c.fillRect(x, y, 16, 16);
	      }
	    }
	    return c.canvas;
	  })();
	  var texture = Texture.fromImage(checkerboardCanvas, options);
	  var image = new Image();
	  var context = gl;
	  image.onload = function() {
	    context.makeCurrent();
	    Texture.fromImage(image, options).swapWith(texture);
	  };
	  image.src = url;
	  return texture;
	};
	
	// ### GL.Texture.canUseFloatingPointTextures()
	//
	// Returns false if `gl.FLOAT` is not supported as a texture type. This is the
	// `OES_texture_float` extension.
	Texture.canUseFloatingPointTextures = function() {
	  return !!gl.getExtension('OES_texture_float');
	};
	
	// ### GL.Texture.canUseFloatingPointLinearFiltering()
	//
	// Returns false if `gl.LINEAR` is not supported as a texture filter mode for
	// textures of type `gl.FLOAT`. This is the `OES_texture_float_linear`
	// extension.
	Texture.canUseFloatingPointLinearFiltering = function() {
	  return !!gl.getExtension('OES_texture_float_linear');
	};
	
	// ### GL.Texture.canUseFloatingPointTextures()
	//
	// Returns false if `gl.HALF_FLOAT_OES` is not supported as a texture type.
	// This is the `OES_texture_half_float` extension.
	Texture.canUseHalfFloatingPointTextures = function() {
	  return !!gl.getExtension('OES_texture_half_float');
	};
	
	// ### GL.Texture.canUseFloatingPointLinearFiltering()
	//
	// Returns false if `gl.LINEAR` is not supported as a texture filter mode for
	// textures of type `gl.HALF_FLOAT_OES`. This is the
	// `OES_texture_half_float_linear` extension.
	Texture.canUseHalfFloatingPointLinearFiltering = function() {
	  return !!gl.getExtension('OES_texture_half_float_linear');
	};
	
	// src/matrix.js
	// Represents a 4x4 matrix stored in row-major order that uses Float32Arrays
	// when available. Matrix operations can either be done using convenient
	// methods that return a new matrix for the result or optimized methods
	// that store the result in an existing matrix to avoid generating garbage.
	
	var hasFloat32Array = (typeof Float32Array != 'undefined');
	
	// ### new GL.Matrix([elements])
	//
	// This constructor takes 16 arguments in row-major order, which can be passed
	// individually, as a list, or even as four lists, one for each row. If the
	// arguments are omitted then the identity matrix is constructed instead.
	function Matrix() {
	  var m = Array.prototype.concat.apply([], arguments);
	  if (!m.length) {
	    m = [
	      1, 0, 0, 0,
	      0, 1, 0, 0,
	      0, 0, 1, 0,
	      0, 0, 0, 1
	    ];
	  }
	  this.m = hasFloat32Array ? new Float32Array(m) : m;
	}
	
	Matrix.prototype = {
	  // ### .inverse()
	  //
	  // Returns the matrix that when multiplied with this matrix results in the
	  // identity matrix.
	  inverse: function() {
	    return Matrix.inverse(this, new Matrix());
	  },
	
	  // ### .transpose()
	  //
	  // Returns this matrix, exchanging columns for rows.
	  transpose: function() {
	    return Matrix.transpose(this, new Matrix());
	  },
	
	  // ### .multiply(matrix)
	  //
	  // Returns the concatenation of the transforms for this matrix and `matrix`.
	  // This emulates the OpenGL function `glMultMatrix()`.
	  multiply: function(matrix) {
	    return Matrix.multiply(this, matrix, new Matrix());
	  },
	
	  // ### .transformPoint(point)
	  //
	  // Transforms the vector as a point with a w coordinate of 1. This
	  // means translations will have an effect, for example.
	  transformPoint: function(v) {
	    var m = this.m;
	    return new Vector(
	      m[0] * v.x + m[1] * v.y + m[2] * v.z + m[3],
	      m[4] * v.x + m[5] * v.y + m[6] * v.z + m[7],
	      m[8] * v.x + m[9] * v.y + m[10] * v.z + m[11]
	    ).divide(m[12] * v.x + m[13] * v.y + m[14] * v.z + m[15]);
	  },
	
	  // ### .transformPoint(vector)
	  //
	  // Transforms the vector as a vector with a w coordinate of 0. This
	  // means translations will have no effect, for example.
	  transformVector: function(v) {
	    var m = this.m;
	    return new Vector(
	      m[0] * v.x + m[1] * v.y + m[2] * v.z,
	      m[4] * v.x + m[5] * v.y + m[6] * v.z,
	      m[8] * v.x + m[9] * v.y + m[10] * v.z
	    );
	  }
	};
	
	// ### GL.Matrix.inverse(matrix[, result])
	//
	// Returns the matrix that when multiplied with `matrix` results in the
	// identity matrix. You can optionally pass an existing matrix in `result`
	// to avoid allocating a new matrix. This implementation is from the Mesa
	// OpenGL function `__gluInvertMatrixd()` found in `project.c`.
	Matrix.inverse = function(matrix, result) {
	  result = result || new Matrix();
	  var m = matrix.m, r = result.m;
	
	  r[0] = m[5]*m[10]*m[15] - m[5]*m[14]*m[11] - m[6]*m[9]*m[15] + m[6]*m[13]*m[11] + m[7]*m[9]*m[14] - m[7]*m[13]*m[10];
	  r[1] = -m[1]*m[10]*m[15] + m[1]*m[14]*m[11] + m[2]*m[9]*m[15] - m[2]*m[13]*m[11] - m[3]*m[9]*m[14] + m[3]*m[13]*m[10];
	  r[2] = m[1]*m[6]*m[15] - m[1]*m[14]*m[7] - m[2]*m[5]*m[15] + m[2]*m[13]*m[7] + m[3]*m[5]*m[14] - m[3]*m[13]*m[6];
	  r[3] = -m[1]*m[6]*m[11] + m[1]*m[10]*m[7] + m[2]*m[5]*m[11] - m[2]*m[9]*m[7] - m[3]*m[5]*m[10] + m[3]*m[9]*m[6];
	
	  r[4] = -m[4]*m[10]*m[15] + m[4]*m[14]*m[11] + m[6]*m[8]*m[15] - m[6]*m[12]*m[11] - m[7]*m[8]*m[14] + m[7]*m[12]*m[10];
	  r[5] = m[0]*m[10]*m[15] - m[0]*m[14]*m[11] - m[2]*m[8]*m[15] + m[2]*m[12]*m[11] + m[3]*m[8]*m[14] - m[3]*m[12]*m[10];
	  r[6] = -m[0]*m[6]*m[15] + m[0]*m[14]*m[7] + m[2]*m[4]*m[15] - m[2]*m[12]*m[7] - m[3]*m[4]*m[14] + m[3]*m[12]*m[6];
	  r[7] = m[0]*m[6]*m[11] - m[0]*m[10]*m[7] - m[2]*m[4]*m[11] + m[2]*m[8]*m[7] + m[3]*m[4]*m[10] - m[3]*m[8]*m[6];
	
	  r[8] = m[4]*m[9]*m[15] - m[4]*m[13]*m[11] - m[5]*m[8]*m[15] + m[5]*m[12]*m[11] + m[7]*m[8]*m[13] - m[7]*m[12]*m[9];
	  r[9] = -m[0]*m[9]*m[15] + m[0]*m[13]*m[11] + m[1]*m[8]*m[15] - m[1]*m[12]*m[11] - m[3]*m[8]*m[13] + m[3]*m[12]*m[9];
	  r[10] = m[0]*m[5]*m[15] - m[0]*m[13]*m[7] - m[1]*m[4]*m[15] + m[1]*m[12]*m[7] + m[3]*m[4]*m[13] - m[3]*m[12]*m[5];
	  r[11] = -m[0]*m[5]*m[11] + m[0]*m[9]*m[7] + m[1]*m[4]*m[11] - m[1]*m[8]*m[7] - m[3]*m[4]*m[9] + m[3]*m[8]*m[5];
	
	  r[12] = -m[4]*m[9]*m[14] + m[4]*m[13]*m[10] + m[5]*m[8]*m[14] - m[5]*m[12]*m[10] - m[6]*m[8]*m[13] + m[6]*m[12]*m[9];
	  r[13] = m[0]*m[9]*m[14] - m[0]*m[13]*m[10] - m[1]*m[8]*m[14] + m[1]*m[12]*m[10] + m[2]*m[8]*m[13] - m[2]*m[12]*m[9];
	  r[14] = -m[0]*m[5]*m[14] + m[0]*m[13]*m[6] + m[1]*m[4]*m[14] - m[1]*m[12]*m[6] - m[2]*m[4]*m[13] + m[2]*m[12]*m[5];
	  r[15] = m[0]*m[5]*m[10] - m[0]*m[9]*m[6] - m[1]*m[4]*m[10] + m[1]*m[8]*m[6] + m[2]*m[4]*m[9] - m[2]*m[8]*m[5];
	
	  var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
	  for (var i = 0; i < 16; i++) r[i] /= det;
	  return result;
	};
	
	// ### GL.Matrix.transpose(matrix[, result])
	//
	// Returns `matrix`, exchanging columns for rows. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix.
	Matrix.transpose = function(matrix, result) {
	  result = result || new Matrix();
	  var m = matrix.m, r = result.m;
	  r[0] = m[0]; r[1] = m[4]; r[2] = m[8]; r[3] = m[12];
	  r[4] = m[1]; r[5] = m[5]; r[6] = m[9]; r[7] = m[13];
	  r[8] = m[2]; r[9] = m[6]; r[10] = m[10]; r[11] = m[14];
	  r[12] = m[3]; r[13] = m[7]; r[14] = m[11]; r[15] = m[15];
	  return result;
	};
	
	// ### GL.Matrix.multiply(left, right[, result])
	//
	// Returns the concatenation of the transforms for `left` and `right`. You can
	// optionally pass an existing matrix in `result` to avoid allocating a new
	// matrix. This emulates the OpenGL function `glMultMatrix()`.
	Matrix.multiply = function(left, right, result) {
	  result = result || new Matrix();
	  var a = left.m, b = right.m, r = result.m;
	
	  r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
	  r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
	  r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
	  r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];
	
	  r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
	  r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
	  r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
	  r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];
	
	  r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
	  r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
	  r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
	  r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];
	
	  r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
	  r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
	  r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
	  r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
	
	  return result;
	};
	
	// ### GL.Matrix.identity([result])
	//
	// Returns an identity matrix. You can optionally pass an existing matrix in
	// `result` to avoid allocating a new matrix. This emulates the OpenGL function
	// `glLoadIdentity()`.
	Matrix.identity = function(result) {
	  result = result || new Matrix();
	  var m = result.m;
	  m[0] = m[5] = m[10] = m[15] = 1;
	  m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
	  return result;
	};
	
	// ### GL.Matrix.perspective(fov, aspect, near, far[, result])
	//
	// Returns a perspective transform matrix, which makes far away objects appear
	// smaller than nearby objects. The `aspect` argument should be the width
	// divided by the height of your viewport and `fov` is the top-to-bottom angle
	// of the field of view in degrees. You can optionally pass an existing matrix
	// in `result` to avoid allocating a new matrix. This emulates the OpenGL
	// function `gluPerspective()`.
	Matrix.perspective = function(fov, aspect, near, far, result) {
	  var y = Math.tan(fov * Math.PI / 360) * near;
	  var x = y * aspect;
	  return Matrix.frustum(-x, x, -y, y, near, far, result);
	};
	
	// ### GL.Matrix.frustum(left, right, bottom, top, near, far[, result])
	//
	// Sets up a viewing frustum, which is shaped like a truncated pyramid with the
	// camera where the point of the pyramid would be. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix. This emulates
	// the OpenGL function `glFrustum()`.
	Matrix.frustum = function(l, r, b, t, n, f, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  m[0] = 2 * n / (r - l);
	  m[1] = 0;
	  m[2] = (r + l) / (r - l);
	  m[3] = 0;
	
	  m[4] = 0;
	  m[5] = 2 * n / (t - b);
	  m[6] = (t + b) / (t - b);
	  m[7] = 0;
	
	  m[8] = 0;
	  m[9] = 0;
	  m[10] = -(f + n) / (f - n);
	  m[11] = -2 * f * n / (f - n);
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = -1;
	  m[15] = 0;
	
	  return result;
	};
	
	// ### GL.Matrix.ortho(left, right, bottom, top, near, far[, result])
	//
	// Returns an orthographic projection, in which objects are the same size no
	// matter how far away or nearby they are. You can optionally pass an existing
	// matrix in `result` to avoid allocating a new matrix. This emulates the OpenGL
	// function `glOrtho()`.
	Matrix.ortho = function(l, r, b, t, n, f, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  m[0] = 2 / (r - l);
	  m[1] = 0;
	  m[2] = 0;
	  m[3] = -(r + l) / (r - l);
	
	  m[4] = 0;
	  m[5] = 2 / (t - b);
	  m[6] = 0;
	  m[7] = -(t + b) / (t - b);
	
	  m[8] = 0;
	  m[9] = 0;
	  m[10] = -2 / (f - n);
	  m[11] = -(f + n) / (f - n);
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	// ### GL.Matrix.scale(x, y, z[, result])
	//
	// This emulates the OpenGL function `glScale()`. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix.
	Matrix.scale = function(x, y, z, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  m[0] = x;
	  m[1] = 0;
	  m[2] = 0;
	  m[3] = 0;
	
	  m[4] = 0;
	  m[5] = y;
	  m[6] = 0;
	  m[7] = 0;
	
	  m[8] = 0;
	  m[9] = 0;
	  m[10] = z;
	  m[11] = 0;
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	// ### GL.Matrix.translate(x, y, z[, result])
	//
	// This emulates the OpenGL function `glTranslate()`. You can optionally pass
	// an existing matrix in `result` to avoid allocating a new matrix.
	Matrix.translate = function(x, y, z, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  m[0] = 1;
	  m[1] = 0;
	  m[2] = 0;
	  m[3] = x;
	
	  m[4] = 0;
	  m[5] = 1;
	  m[6] = 0;
	  m[7] = y;
	
	  m[8] = 0;
	  m[9] = 0;
	  m[10] = 1;
	  m[11] = z;
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	Matrix.relitiveDirection = function(x,y,z,matrix) {
	  const m = matrix.m;
	  let v = [
	    m[0] * x + m[1] * y + m[2] * z,
	    m[4] * x + m[5] * y + m[6] * z,
	    m[8] * x + m[9] * y + m[10] * z
	  ];
	
	  return v;
	}
	
	function rotationMatrix(rotation) {
	  let result = new Matrix();
	  var m = result.m;
	
	  const yaw = rotation[0];
	  const pitch = rotation[1];
	  const roll = rotation[2];
	  const ca = Math.cos(yaw);
	  const sa = Math.sin(yaw);
	  const cb = Math.cos(pitch);
	  const sb = Math.sin(pitch);
	  const cc = Math.cos(roll);
	  const sc = Math.sin(roll);
	
	  result.m = [ca*cb, ca*sb*sc-sa*cc, ca*sb*cc+sa*sc, 0,
	              sa*cb, sa*sb*sc+ca*cc, sa*sb*cc-ca*sc, 0,
	              -sb,          cb*sc,          cb*cc, 0,
	                0,              0,              0, 1];
	
	  return result;
	}
	
	Matrix.rotationMatrix = rotationMatrix;
	
	Matrix.rotateAroundPoint = function(point, rotation, result) {
	  if (!rotation || (!rotation[0] && !rotation[1] && !rotation[2])) {
	    return Matrix.identity(result);
	  }
	  result = result || new Matrix();
	
	  const rm = rotationMatrix(rotation).m;
	  const x = point.x;
	  const y = point.y;
	  const z = point.z;
	
	  // I was about to fix this, but after thinking about it. If anyone ever reads this,
	  // I want to be remembered not for the tens, probably hundreds, of thousands of
	  // lines I have written. I wish to be remembered as the autistic obsesive person
	  // who managed to fill his mind soo full, the alphabet fell out.
	  //          Jozsef Morrissey
	  let a,b,c,e,
	      f,g,h,i,
	      j,k,l,m,
	      n,o,p,q;
	
	
	  a = rm[0]; b = rm[1]; c = rm[2];  e = rm[3];
	  f = rm[4]; g = rm[5]; h = rm[6];  i = rm[7];
	  j = rm[8]; k = rm[9]; l = rm[10]; m = rm[11];
	  n = rm[12]; o = rm[13]; p = rm[14]; q = rm[15];
	
	  result.m[0] = a+x*n;
	  result.m[1] = b+x*o;
	  result.m[2] = c+x*p;
	  result.m[3] = -x*(a+x*n)-y*(b+x*o)-z*(c+x*p)+x*q;
	
	  result.m[4] = f+y*n;
	  result.m[5] = g+y*o;
	  result.m[6] = h+y*p;
	  result.m[7] = -x*(f+y*n)-y*(g+y*o)-z*(h+y*p)+y*q;
	
	  result.m[8]  = j+z*n;
	  result.m[9]  = k+z*o;
	  result.m[10] = l+z*p;
	  result.m[11] = -x*(j+z*n)-y*(k+z*o)-z*(l+z*p)+z*q;
	
	  result.m[12] = n;
	  result.m[13] = o;
	  result.m[14] = p;
	  result.m[15] = -x*n-y*o-z*p+q;
	
	  return result;
	};
	
	const multiply = (matrix, point) => {
	
	}
	const result = Matrix.rotateAroundPoint({x: 0, y:0, z: 0}, [2, 5, 3]);
	
	
	
	// const zOnly = new Matrix();
	// zOnly.m[0] = zOnly.m[5] = 0;
	// const zRotation = new Matrix();
	
	// zRotation.m[0] = zRotation.m[5] = 0;
	
	// ### GL.Matrix.rotate(a, x, y, z[, result])
	//
	// Returns a matrix that rotates by `a` degrees around the vector `x, y, z`.
	// You can optionally pass an existing matrix in `result` to avoid allocating
	// a new matrix. This emulates the OpenGL function `glRotate()`.
	Matrix.rotate = function(a, x, y, z, result) {
	  if (!a || (!x && !y && !z)) {
	    return Matrix.identity(result);
	  }
	
	  result = result || new Matrix();
	  var m = result.m;
	
	  var d = Math.sqrt(x*x + y*y + z*z);
	  a *= Math.PI / 180; x /= d; y /= d; z /= d;
	  var c = Math.cos(a), s = Math.sin(a), t = 1 - c;
	
	  m[0] = x * x * t + c;
	  m[1] = x * y * t - z * s;
	  m[2] = x * z * t + y * s;
	  m[3] = 0;
	
	  m[4] = y * x * t + z * s;
	  m[5] = y * y * t + c;
	  m[6] = y * z * t - x * s;
	  m[7] = 0;
	
	  m[8] = z * x * t - y * s;
	  m[9] = z * y * t + x * s;
	  m[10] = z * z * t + c;
	  m[11] = 0;
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	// ### GL.Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz[, result])
	//
	// Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking
	// toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.
	// You can optionally pass an existing matrix in `result` to avoid allocating
	// a new matrix. This emulates the OpenGL function `gluLookAt()`.
	Matrix.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz, result) {
	  result = result || new Matrix();
	  var m = result.m;
	
	  var e = new Vector(ex, ey, ez);
	  var c = new Vector(cx, cy, cz);
	  var u = new Vector(ux, uy, uz);
	  var f = e.subtract(c).unit();
	  var s = u.cross(f).unit();
	  var t = f.cross(s).unit();
	
	  m[0] = s.x;
	  m[1] = s.y;
	  m[2] = s.z;
	  m[3] = -s.dot(e);
	
	  m[4] = t.x;
	  m[5] = t.y;
	  m[6] = t.z;
	  m[7] = -t.dot(e);
	
	  m[8] = f.x;
	  m[9] = f.y;
	  m[10] = f.z;
	  m[11] = -f.dot(e);
	
	  m[12] = 0;
	  m[13] = 0;
	  m[14] = 0;
	  m[15] = 1;
	
	  return result;
	};
	
	return GL;
	})();
	
});


RequireJS.addFunction('./services/cabinet/public/js/3d-modeling/csg.js',
function (require, exports, module) {
	

	const GL = require('./lightgl.js');
	
	// Constructive Solid Geometry (CSG) is a modeling technique that uses Boolean
	// operations like union and intersection to combine 3D solids. This library
	// implements CSG operations on meshes elegantly and concisely using BSP trees,
	// and is meant to serve as an easily understandable implementation of the
	// algorithm. All edge cases involving overlapping coplanar polygons in both
	// solids are correctly handled.
	//
	// Example usage:
	//
	//     var cube = CSG.cube();
	//     var sphere = CSG.sphere({ radius: 1.3 });
	//     var polygons = cube.subtract(sphere).toPolygons();
	//
	// ## Implementation Details
	//
	// All CSG operations are implemented in terms of two functions, `clipTo()` and
	// `invert()`, which remove parts of a BSP tree inside another BSP tree and swap
	// solid and empty space, respectively. To find the union of `a` and `b`, we
	// want to remove everything in `a` inside `b` and everything in `b` inside `a`,
	// then combine polygons from `a` and `b` into one solid:
	//
	//     a.clipTo(b);
	//     b.clipTo(a);
	//     a.build(b.allPolygons());
	//
	// The only tricky part is handling overlapping coplanar polygons in both trees.
	// The code above keeps both copies, but we need to keep them in one tree and
	// remove them in the other tree. To remove them from `b` we can clip the
	// inverse of `b` against `a`. The code for union now looks like this:
	//
	//     a.clipTo(b);
	//     b.clipTo(a);
	//     b.invert();
	//     b.clipTo(a);
	//     b.invert();
	//     a.build(b.allPolygons());
	//
	// Subtraction and intersection naturally follow from set operations. If
	// union is `A | B`, subtraction is `A - B = ~(~A | B)` and intersection is
	// `A & B = ~(~A | ~B)` where `~` is the complement operator.
	//
	// ## License
	//
	// Copyright (c) 2011 Evan Wallace (http://madebyevan.com/), under the MIT license.
	
	// # class CSG
	
	// Holds a binary space partition tree representing a 3D solid. Two solids can
	// be combined using the `union()`, `subtract()`, and `intersect()` methods.
	
	CSG = function() {
	  this.polygons = [];
	};
	
	// Construct a CSG solid from a list of `CSG.Polygon` instances.
	CSG.fromPolygons = function(polygons) {
	  var csg = new CSG();
	  csg.polygons = polygons;
	  return csg;
	};
	
	CSG.toString = function () {
	  const list = [];
	  this.polygons.forEach((polygon) => {
	    const obj = {vertices: []};
	    polygon.vertices.forEach((vertex) =>
	        obj.vertices.push({x: vertex.pos.x, y: vertex.pos.y, z: vertex.pos.z}));
	    list.push(obj);
	  });
	  return JSON.stringify(list, null, 2);
	}
	
	CSG.prototype = {
	  clone: function() {
	    var csg = new CSG();
	    //csg.normals = this.normals;
	    csg.polygons = this.polygons.map(function(p) { return p.clone(); });
	    return csg;
	  },
	
	  toPolygons: function() {
	    return this.polygons;
	  },
	
	  // Return a new CSG solid representing space in either this solid or in the
	  // solid `csg`. Neither this solid nor the solid `csg` are modified.
	  //
	  //     A.union(B)
	  //
	  //     +-------+            +-------+
	  //     |       |            |       |
	  //     |   A   |            |       |
	  //     |    +--+----+   =   |       +----+
	  //     +----+--+    |       +----+       |
	  //          |   B   |            |       |
	  //          |       |            |       |
	  //          +-------+            +-------+
	  //
	  union: function(csg) {
	    var a = new CSG.Node(this.clone().polygons);
	    var b = new CSG.Node(csg.clone().polygons);
	    a.clipTo(b);
	    b.clipTo(a);
	    b.invert();
	    b.clipTo(a);
	    b.invert();
	    a.build(b.allPolygons());
	    return CSG.fromPolygons(a.allPolygons());
	  },
	
	  // Return a new CSG solid representing space in this solid but not in the
	  // solid `csg`. Neither this solid nor the solid `csg` are modified.
	  //
	  //     A.subtract(B)
	  //
	  //     +-------+            +-------+
	  //     |       |            |       |
	  //     |   A   |            |       |
	  //     |    +--+----+   =   |    +--+
	  //     +----+--+    |       +----+
	  //          |   B   |
	  //          |       |
	  //          +-------+
	  //
	  subtract: function(csg) {
	    var a = new CSG.Node(this.clone().polygons);
	    var b = new CSG.Node(csg.clone().polygons);
	    a.invert();
	    a.clipTo(b);
	    b.clipTo(a);
	    b.invert();
	    b.clipTo(a);
	    b.invert();
	    a.build(b.allPolygons());
	    a.invert();
	    return CSG.fromPolygons(a.allPolygons());
	  },
	
	  // Return a new CSG solid representing space both this solid and in the
	  // solid `csg`. Neither this solid nor the solid `csg` are modified.
	  //
	  //     A.intersect(B)
	  //
	  //     +-------+
	  //     |       |
	  //     |   A   |
	  //     |    +--+----+   =   +--+
	  //     +----+--+    |       +--+
	  //          |   B   |
	  //          |       |
	  //          +-------+
	  //
	  intersect: function(csg) {
	    var a = new CSG.Node(this.clone().polygons);
	    var b = new CSG.Node(csg.clone().polygons);
	    a.invert();
	    b.clipTo(a);
	    b.invert();
	    a.clipTo(b);
	    b.clipTo(a);
	    a.build(b.allPolygons());
	    a.invert();
	    return CSG.fromPolygons(a.allPolygons());
	  },
	
	  // Return a new CSG solid with solid and empty space switched. This solid is
	  // not modified.
	  inverse: function() {
	    var csg = this.clone();
	    csg.polygons.map(function(p) { p.flip(); });
	    return csg;
	  },
	  endpoints: function () {
	    const endpoints = {};
	    const endpoint = (attr, value) => {
	      const max = endpoints[attr];
	      endpoints[attr] = max === undefined || max < value ? value : max;
	      const minAttr = `-${attr}`;
	      const min = endpoints[minAttr];
	      endpoints[minAttr] = min === undefined || min > value ? value : min;
	    }
	    this.polygons.forEach((poly) => poly.forEachVertex((vertex) => {
	      endpoint('x', vertex.pos.x);
	      endpoint('y', vertex.pos.y);
	      endpoint('z', vertex.pos.z);
	    }));
	    return endpoints;
	  },
	  distCenter: function () {
	    const endpoints = this.endpoints();
	    const x = ((endpoints.x + endpoints['-x']) / 2);
	    const y = ((endpoints.y + endpoints['-y']) / 2);
	    const z = ((endpoints.z + endpoints['-z']) / 2);
	    return {x,y,z};
	  },
	
	  rotate: function (rotations) {
	    if (Array.isArray(rotations)) {
	      for (let i = 0; i < rotations.length; i++) this.rotate(rotations[i])
	      return;
	    }
	    this.polygons.forEach((poly) => poly.forEachVertex((vertex) => {
	      let newPos = vertex.pos;
	      newPos = ArbitraryRotate(newPos, rotations.x, {x: 1, y:0, z:0});
	      newPos = ArbitraryRotate(newPos, rotations.y, {x: 0, y:1, z:0});
	      newPos = ArbitraryRotate(newPos, rotations.z, {x: 0, y:0, z:1});
	      return new CSG.Vertex(newPos, vertex.normal);
	    }));
	  },
	  reverseRotate: function (rotation) {
	    rotation = {x: rotation.x * -1, y: rotation.y * -1, z: rotation.z * -1};
	    this.polygons.forEach((poly) => poly.forEachVertex((vertex) => {
	      let newPos = vertex.pos;
	      newPos = ArbitraryRotate(newPos, rotation.z, {x: 0, y:0, z:1});
	      newPos = ArbitraryRotate(newPos, rotation.y, {x: 0, y:1, z:0});
	      newPos = ArbitraryRotate(newPos, rotation.x, {x: 1, y:0, z:0});
	      return new CSG.Vertex(newPos, vertex.normal);
	    }));
	  },
	
	  translate: function (offset) {
	    this.polygons.forEach((poly) => poly.forEachVertex((vertex) => {
	      vertex.pos.x += offset.x;
	      vertex.pos.y += offset.y;
	      vertex.pos.z += offset.z;
	    }));
	  },
	
	  center: function (newCenter) {
	    const center = this.distCenter();
	    const offset = {
	      x: newCenter.x - center.x,
	      y: newCenter.y - center.y,
	      z: newCenter.z - center.z
	    }
	    this.translate(offset);
	  }
	};
	
	// Construct an axis-aligned solid cuboid. Optional parameters are `center` and
	// `radius`, which default to `[0, 0, 0]` and `[1, 1, 1]`. The radius can be
	// specified using a single number or a list of three numbers, one for each axis.
	//
	// Example code:
	//
	//     var cube = CSG.cube({
	//       center: [0, 0, 0],
	//       radius: 1
	//     });
	//
	// x1 = (x0  xc)cos()  (y0  yc)sin() + xc(Equation 3)
	// y1 = (x0  xc)sin() + (y0  yc)cos() + yc(Equation 4)
	CSG.cube = function(options) {
	  options = options || {};
	  var c = new CSG.Vector(options.center || [0, 0, 0]);
	  var r = !options.radius ? [1, 1, 1] : options.radius.length ?
	           options.radius : [options.radius, options.radius, options.radius];
	  if (options.demensions) {
	    r = [options.demensions[0]/2, options.demensions[1]/2, options.demensions[2]/2];
	  }
	  return CSG.fromPolygons([
	    [[0, 4, 6, 2], [-1, 0, 0]],
	    [[1, 3, 7, 5], [+1, 0, 0]],
	    [[0, 1, 5, 4], [0, -1, 0]],
	    [[2, 6, 7, 3], [0, +1, 0]],
	    [[0, 2, 3, 1], [0, 0, -1]],
	    [[4, 5, 7, 6], [0, 0, +1]]
	  ].map(function(info) {
	    return new CSG.Polygon(info[0].map(function(i) {
	      var pos = new CSG.Vector(
	        c.x + r[0] * (2 * !!(i & 1) - 1),
	        c.y + r[1] * (2 * !!(i & 2) - 1),
	        c.z + r[2] * (2 * !!(i & 4) - 1)
	      );
	      return new CSG.Vertex(pos, new CSG.Vector(info[1]));
	    }));
	  }));
	};
	
	// Construct a solid sphere. Optional parameters are `center`, `radius`,
	// `slices`, and `stacks`, which default to `[0, 0, 0]`, `1`, `16`, and `8`.
	// The `slices` and `stacks` parameters control the tessellation along the
	// longitude and latitude directions.
	//
	// Example usage:
	//
	//     var sphere = CSG.sphere({
	//       center: [0, 0, 0],
	//       radius: 1,
	//       slices: 16,
	//       stacks: 8
	//     });
	CSG.sphere = function(options) {
	  options = options || {};
	  var c = new CSG.Vector(options.center || [0, 0, 0]);
	  var r = options.radius || 1;
	  var slices = options.slices || 16;
	  var stacks = options.stacks || 8;
	  var polygons = [], vertices;
	  function vertex(theta, phi) {
	    theta *= Math.PI * 2;
	    phi *= Math.PI;
	    var dir = new CSG.Vector(
	      Math.cos(theta) * Math.sin(phi),
	      Math.cos(phi),
	      Math.sin(theta) * Math.sin(phi)
	    );
	    vertices.push(new CSG.Vertex(c.plus(dir.times(r)), dir));
	  }
	  for (var i = 0; i < slices; i++) {
	    for (var j = 0; j < stacks; j++) {
	      vertices = [];
	      vertex(i / slices, j / stacks);
	      if (j > 0) vertex((i + 1) / slices, j / stacks);
	      if (j < stacks - 1) vertex((i + 1) / slices, (j + 1) / stacks);
	      vertex(i / slices, (j + 1) / stacks);
	      polygons.push(new CSG.Polygon(vertices));
	    }
	  }
	  return CSG.fromPolygons(polygons);
	};
	
	// Construct a solid cylinder. Optional parameters are `start`, `end`,
	// `radius`, and `slices`, which default to `[0, -1, 0]`, `[0, 1, 0]`, `1`, and
	// `16`. The `slices` parameter controls the tessellation.
	//
	// Example usage:
	//
	//     var cylinder = CSG.cylinder({
	//       start: [0, -1, 0],
	//       end: [0, 1, 0],
	//       radius: 1,
	//       slices: 16
	//     });
	CSG.cylinder = function(options) {
	  options = options || {};
	  var s = new CSG.Vector(options.start || [0, -1, 0]);
	  var e = new CSG.Vector(options.end || [0, 1, 0]);
	  var ray = e.minus(s);
	  var r = options.radius || 1;
	  var slices = options.slices || 16;
	  var axisZ = ray.unit(), isY = (Math.abs(axisZ.y) > 0.5);
	  var axisX = new CSG.Vector(isY, !isY, 0).cross(axisZ).unit();
	  var axisY = axisX.cross(axisZ).unit();
	  var start = new CSG.Vertex(s, axisZ.negated());
	  var end = new CSG.Vertex(e, axisZ.unit());
	  var polygons = [];
	  function point(stack, slice, normalBlend) {
	    var angle = slice * Math.PI * 2;
	    var out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));
	    var pos = s.plus(ray.times(stack)).plus(out.times(r));
	    var normal = out.times(1 - Math.abs(normalBlend)).plus(axisZ.times(normalBlend));
	    return new CSG.Vertex(pos, normal);
	  }
	  for (var i = 0; i < slices; i++) {
	    var t0 = i / slices, t1 = (i + 1) / slices;
	    polygons.push(new CSG.Polygon([start, point(0, t0, -1), point(0, t1, -1)]));
	    polygons.push(new CSG.Polygon([point(0, t1, 0), point(0, t0, 0), point(1, t0, 0), point(1, t1, 0)]));
	    polygons.push(new CSG.Polygon([end, point(1, t1, 1), point(1, t0, 1)]));
	  }
	  return CSG.fromPolygons(polygons);
	};
	
	function axis(vector, origin, color) {
	  origin ||= [0,0,0];
	  const end = [vector[0]+origin[0],vector[1]+origin[1],vector[2]+origin[2]]
	  const ax = CSG.cylinder({start: origin, end})
	  ax.setColor(color);
	  return ax;
	}
	
	CSG.axis =  function (size, origin) {
	  size ||= 100;
	  origin ||= [0,0,0];
	  const center = CSG.sphere({center: origin, radius: size/50})
	  const xAxis = axis([size,0,0], origin, [255,0,0]);
	  const yAxis = axis([0,size,0], origin, [0,128,0]);
	  const zAxis = axis([0,0,size], origin, [0,0,255]);
	  return center.union(xAxis.union(yAxis).union(zAxis));
	}
	
	// # class Vector
	
	// Represents a 3D vector.
	//
	// Example usage:
	//
	//     new CSG.Vector(1, 2, 3);
	//     new CSG.Vector([1, 2, 3]);
	//     new CSG.Vector({ x: 1, y: 2, z: 3 });
	
	CSG.Vector = function(x, y, z) {
	  if (arguments.length == 3) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	  } else if ('x' in x) {
	    this.x = x.x;
	    this.y = x.y;
	    this.z = x.z;
	  } else {
	    this.x = x[0];
	    this.y = x[1];
	    this.z = x[2];
	  }
	};
	
	CSG.Vector.prototype = {
	  clone: function() {
	    return new CSG.Vector(this.x, this.y, this.z);
	  },
	
	  negated: function() {
	    return new CSG.Vector(-this.x, -this.y, -this.z);
	  },
	
	  plus: function(a) {
	    return new CSG.Vector(this.x + a.x, this.y + a.y, this.z + a.z);
	  },
	
	  minus: function(a) {
	    return new CSG.Vector(this.x - a.x, this.y - a.y, this.z - a.z);
	  },
	
	  times: function(a) {
	    return new CSG.Vector(this.x * a, this.y * a, this.z * a);
	  },
	
	  dividedBy: function(a) {
	    return new CSG.Vector(this.x / a, this.y / a, this.z / a);
	  },
	
	  dot: function(a) {
	    return this.x * a.x + this.y * a.y + this.z * a.z;
	  },
	
	  lerp: function(a, t) {
	    return this.plus(a.minus(this).times(t));
	  },
	
	  length: function() {
	    return Math.sqrt(this.dot(this));
	  },
	
	  unit: function() {
	    return this.dividedBy(this.length());
	  },
	
	  cross: function(a) {
	    return new CSG.Vector(
	      this.y * a.z - this.z * a.y,
	      this.z * a.x - this.x * a.z,
	      this.x * a.y - this.y * a.x
	    );
	  }
	};
	
	// # class Vertex
	
	// Represents a vertex of a polygon. Use your own vertex class instead of this
	// one to provide additional features like texture coordinates and vertex
	// colors. Custom vertex classes need to provide a `pos` property and `clone()`,
	// `flip()`, and `interpolate()` methods that behave analogous to the ones
	// defined by `CSG.Vertex`. This class provides `normal` so convenience
	// functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`
	// is not used anywhere else.
	
	CSG.Vertex = function(pos, normal) {
	  this.pos = new CSG.Vector(pos);
	  this.normal = new CSG.Vector(normal);
	};
	
	CSG.Vertex.prototype = {
	  clone: function() {
	    return new CSG.Vertex(this.pos.clone(), this.normal.clone());
	  },
	  toString: function () {
	    return `(${this.pos.x},${this.pos.y},${this.pos.z})`
	  },
	
	  // Invert all orientation-specific data (e.g. vertex normal). Called when the
	  // orientation of a polygon is flipped.
	  flip: function() {
	    this.normal = this.normal.negated();
	  },
	
	  // Create a new vertex between this vertex and `other` by linearly
	  // interpolating all properties using a parameter of `t`. Subclasses should
	  // override this to interpolate additional properties.
	  interpolate: function(other, t) {
	    return new CSG.Vertex(
	      this.pos.lerp(other.pos, t),
	      this.normal.lerp(other.normal, t)
	    );
	  }
	};
	
	// # class Plane
	
	// Represents a plane in 3D space.
	
	CSG.Plane = function(normal, w) {
	  this.normal = normal;
	  this.w = w;
	};
	
	// `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a
	// point is on the plane.
	CSG.Plane.EPSILON = 1e-5;//1e-3;
	
	CSG.Plane.fromPoints = function(a, b, c) {
	  var n = b.minus(a).cross(c.minus(a)).unit();
	  return new CSG.Plane(n, n.dot(a));
	};
	
	CSG.Plane.prototype = {
	  clone: function() {
	    return new CSG.Plane(this.normal.clone(), this.w);
	  },
	
	  flip: function() {
	    this.normal = this.normal.negated();
	    this.w = -this.w;
	  },
	
	  // Split `polygon` by this plane if needed, then put the polygon or polygon
	  // fragments in the appropriate lists. Coplanar polygons go into either
	  // `coplanarFront` or `coplanarBack` depending on their orientation with
	  // respect to this plane. Polygons in front or in back of this plane go into
	  // either `front` or `back`.
	  splitPolygon: function(polygon, coplanarFront, coplanarBack, front, back) {
	    var COPLANAR = 0;
	    var FRONT = 1;
	    var BACK = 2;
	    var SPANNING = 3;
	
	    // Classify each point as well as the entire polygon into one of the above
	    // four classes.
	    var polygonType = 0;
	    var types = [];
	    for (var i = 0; i < polygon.vertices.length; i++) {
	      var t = this.normal.dot(polygon.vertices[i].pos) - this.w;
	      var type = (t < -CSG.Plane.EPSILON) ? BACK : (t > CSG.Plane.EPSILON) ? FRONT : COPLANAR;
	      polygonType |= type;
	      types.push(type);
	    }
	
	    // Put the polygon in the correct list, splitting it when necessary.
	    switch (polygonType) {
	      case COPLANAR:
	        (this.normal.dot(polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);
	        break;
	      case FRONT:
	        front.push(polygon);
	        break;
	      case BACK:
	        back.push(polygon);
	        break;
	      case SPANNING:
	        var f = [], b = [];
	        for (var i = 0; i < polygon.vertices.length; i++) {
	          var j = (i + 1) % polygon.vertices.length;
	          var ti = types[i], tj = types[j];
	          var vi = polygon.vertices[i], vj = polygon.vertices[j];
	          if (ti != BACK) f.push(vi);
	          if (ti != FRONT) b.push(ti != BACK ? vi.clone() : vi);
	          if ((ti | tj) == SPANNING) {
	            var t = (this.w - this.normal.dot(vi.pos)) / this.normal.dot(vj.pos.minus(vi.pos));
	            var v = vi.interpolate(vj, t);
	            f.push(v);
	            b.push(v.clone());
	          }
	        }
	        if (f.length >= 3) front.push(new CSG.Polygon(f, polygon.shared));
	        if (b.length >= 3) back.push(new CSG.Polygon(b, polygon.shared));
	        break;
	    }
	  }
	};
	
	// # class Polygon
	
	// Represents a convex polygon. The vertices used to initialize a polygon must
	// be coplanar and form a convex loop. They do not have to be `CSG.Vertex`
	// instances but they must behave similarly (duck typing can be used for
	// customization).
	//
	// Each convex polygon has a `shared` property, which is shared between all
	// polygons that are clones of each other or were split from the same polygon.
	// This can be used to define per-polygon properties (such as surface color).
	
	CSG.Polygon = function(vertices, shared) {
	  this.vertices = vertices;
	  this.shared = shared;
	  this.plane = CSG.Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
	};
	
	CSG.Polygon.prototype = {
	  clone: function() {
	    var vertices = this.vertices.map(function(v) { return v.clone(); });
	    return new CSG.Polygon(vertices, this.shared);
	  },
	
	  flip: function() {
	    this.vertices.reverse().map(function(v) { v.flip(); });
	    this.plane.flip();
	  },
	  forEachVertex: function (func) {
	    for (let vIndex = 0; vIndex < this.vertices.length; vIndex += 1) {
	      const vertex = this.vertices[vIndex];
	      const newVertex = func(vertex);
	      this.vertices[vIndex] = newVertex instanceof CSG.Vertex ? newVertex : vertex;
	    }
	  }
	};
	
	// # class Node
	
	// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons
	// by picking a polygon to split along. That polygon (and all other coplanar
	// polygons) are added directly to that node and the other polygons are added to
	// the front and/or back subtrees. This is not a leafy BSP tree since there is
	// no distinction between internal and leaf nodes.
	
	CSG.Node = function(polygons) {
	  this.plane = null;
	  this.front = null;
	  this.back = null;
	  this.polygons = [];
	  if (polygons) this.build(polygons);
	};
	
	CSG.Node.prototype = {
	  clone: function() {
	    var node = new CSG.Node();
	    node.plane = this.plane && this.plane.clone();
	    node.front = this.front && this.front.clone();
	    node.back = this.back && this.back.clone();
	    node.polygons = this.polygons.map(function(p) { return p.clone(); });
	    return node;
	  },
	
	  // Convert solid space to empty space and empty space to solid space.
	  invert: function() {
	    for (var i = 0; i < this.polygons.length; i++) {
	      this.polygons[i].flip();
	    }
	    this.plane.flip();
	    if (this.front) this.front.invert();
	    if (this.back) this.back.invert();
	    var temp = this.front;
	    this.front = this.back;
	    this.back = temp;
	  },
	
	  // Recursively remove all polygons in `polygons` that are inside this BSP
	  // tree.
	  clipPolygons: function(polygons) {
	    if (!this.plane) return polygons.slice();
	    var front = [], back = [];
	    for (var i = 0; i < polygons.length; i++) {
	      this.plane.splitPolygon(polygons[i], front, back, front, back);
	    }
	    if (this.front) front = this.front.clipPolygons(front);
	    if (this.back) back = this.back.clipPolygons(back);
	    else back = [];
	    return front.concat(back);
	  },
	
	  // Remove all polygons in this BSP tree that are inside the other BSP tree
	  // `bsp`.
	  clipTo: function(bsp) {
	    this.polygons = bsp.clipPolygons(this.polygons);
	    if (this.front) this.front.clipTo(bsp);
	    if (this.back) this.back.clipTo(bsp);
	  },
	
	  // Return a list of all polygons in this BSP tree.
	  allPolygons: function() {
	    var polygons = this.polygons.slice();
	    if (this.front) polygons = polygons.concat(this.front.allPolygons());
	    if (this.back) polygons = polygons.concat(this.back.allPolygons());
	    return polygons;
	  },
	
	  // Build a BSP tree out of `polygons`. When called on an existing tree, the
	  // new polygons are filtered down to the bottom of the tree and become new
	  // nodes there. Each set of polygons is partitioned using the first polygon
	  // (no heuristic is used to pick a good split).
	  build: function(polygons) {
	    if (!polygons.length) return;
	    if (!this.plane) this.plane = polygons[0].plane.clone();
	    var front = [], back = [];
	    for (var i = 0; i < polygons.length; i++) {
	      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
	    }
	    if (front.length) {
	      if (!this.front) this.front = new CSG.Node();
	      this.front.build(front);
	    }
	    if (back.length) {
	      if (!this.back) this.back = new CSG.Node();
	      this.back.build(back);
	    }
	  }
	};
	
	/*
	   Rotate a point p by angle theta around an arbitrary axis r
	   Return the rotated point.
	   Positive angles are anticlockwise looking down the axis
	   towards the origin.
	   Assume right hand coordinate system.
	*/
	function ArbitraryRotate(point, degreestheta, radius)
	{
	  theta = degreestheta * Math.PI/180;
	  let p = point;
	  let r = radius;
	   let q = {x: 0.0, y: 0.0, z: 0.0};
	   let costheta,sintheta;
	
	   const Normalise = (obj, attr) => obj[attr] *= obj[attr] > 0 ? 1 : -1;
	   Normalise(r, 'x',);
	   Normalise(r, 'y',);
	   Normalise(r, 'z',);
	
	   costheta = Math.cos(theta);
	   sintheta = Math.sin(theta);
	
	   q.x += (costheta + (1 - costheta) * r.x * r.x) * p.x;
	   q.x += ((1 - costheta) * r.x * r.y - r.z * sintheta) * p.y;
	   q.x += ((1 - costheta) * r.x * r.z + r.y * sintheta) * p.z;
	
	   q.y += ((1 - costheta) * r.x * r.y + r.z * sintheta) * p.x;
	   q.y += (costheta + (1 - costheta) * r.y * r.y) * p.y;
	   q.y += ((1 - costheta) * r.y * r.z - r.x * sintheta) * p.z;
	
	   q.z += ((1 - costheta) * r.x * r.z - r.y * sintheta) * p.x;
	   q.z += ((1 - costheta) * r.y * r.z + r.x * sintheta) * p.y;
	   q.z += (costheta + (1 - costheta) * r.z * r.z) * p.z;
	
	   return(q);
	}
	
	function rotate (point, rotation) {
	  let newPos = point;
	  newPos = ArbitraryRotate(newPos, rotation.x, {x: 1, y:0, z:0});
	  newPos = ArbitraryRotate(newPos, rotation.y, {x: 0, y:1, z:0});
	  newPos = ArbitraryRotate(newPos, rotation.z, {x: 0, y:0, z:1});
	  return newPos;
	}
	
	function reverseRotate (point, rotation) {
	  rotation = {x: rotation.x * -1, y: rotation.y * -1, z: rotation.z * -1};
	  let newPos = point;
	  newPos = ArbitraryRotate(newPos, rotation.z, {x: 0, y:0, z:1});
	  newPos = ArbitraryRotate(newPos, rotation.y, {x: 0, y:1, z:0});
	  newPos = ArbitraryRotate(newPos, rotation.x, {x: 1, y:0, z:0});
	  return newPos;
	}
	
	function transRotate (point, offset, rotation) {
	  let newPos = rotate (offset, rotation);
	  newPos.x += point.x;
	  newPos.y += point.y;
	  newPos.z += point.z;
	  return newPos;
	}
	
	function transRotateAll (points, offset, rotation) {
	  for (let index = 0; index < points.length; index++) {
	    points[index] = transRotate(points[index], offset, rotation);
	  }
	}
	
	function rotateAll (points, rotation) {
	  const ret = [];
	  for (let index = 0; index < points.length; index++) {
	    ret[index] = rotate(points[index], rotation);
	  }
	  return ret;
	}
	
	function reverseRotateAll (points, rotation) {
	  const ret = [];
	  for (let index = 0; index < points.length; index++) {
	    ret[index] = reverseRotate(points[index], rotation);
	  }
	  return ret;
	}
	
	function rotatePointAroundCenter(rotation, point, center, reverse) {
	  center ||= {x:0, y:0, z:0};
	  point.x -=  center.x;
	  point.y -= center.y;
	  point.z -= center.z;
	  const rotated = reverse ? reverseRotate(point, rotation) : rotate(point, rotation);
	  point.x =  center.x + rotated.x;
	  point.y = center.y + rotated.y;
	  point.z = center.z + rotated.z;
	  return point;
	}
	
	function rotatePointsAroundCenter(rotation, points, center, reverse) {
	  for (let index = 0; index < points.length; index++) {
	    rotatePointAroundCenter(rotation, points[index], center, reverse);
	  }
	  return points;
	}
	
	CSG.ArbitraryRotate = ArbitraryRotate;
	CSG.rotatePointsAroundCenter = rotatePointsAroundCenter;
	CSG.rotatePointAroundCenter = rotatePointAroundCenter;
	CSG.transRotate = transRotate;
	CSG.rotateAll = rotateAll;
	CSG.transRotateAll = transRotateAll;
	CSG.reverseRotateAll = reverseRotateAll;
	CSG.rotate = rotate;
	CSG.reverseRotate = reverseRotate;
	module.exports = CSG;
	
});


RequireJS.addFunction('./services/cabinet/public/js/3d-modeling/export-dxf.js',
function (require, exports, module) {
	

	
	const Company = require('../../../app-src/objects/company.js');
	
	
	/*
	AutoCAD DXF Content
	
	These are the common headers, classes, tables, blocks, and objects required for AC2017 DXF files.
	
	## License
	
	Copyright (c) 2018 Z3 Development https://github.com/z3dev
	
	All code released under MIT license
	*/
	
	// Important Variables
	//   ANGDIR = 0 : counter clockwise angles
	//   INSUNITS = 4 : millimeters
	//
	const dxfHeaders = function () {
	  const content = `  0
	SECTION
	  2
	HEADER
	  9
	$ACADVER
	  1
	AC1027
	  9
	$ACADMAINTVER
	 70
	8
	  9
	$DWGCODEPAGE
	  3
	ANSI_1252
	  9
	$LASTSAVEDBY
	  1
	unknown
	  9
	$REQUIREDVERSIONS
	160
	0
	  9
	$INSBASE
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$EXTMIN
	 10
	1e+20
	 20
	1e+20
	 30
	1e+20
	  9
	$EXTMAX
	 10
	-1e+20
	 20
	-1e+20
	 30
	-1e+20
	  9
	$LIMMIN
	 10
	0.0
	 20
	0.0
	  9
	$LIMMAX
	 10
	12.0
	 20
	9.0
	  9
	$ORTHOMODE
	 70
	0
	  9
	$REGENMODE
	 70
	1
	  9
	$FILLMODE
	 70
	1
	  9
	$QTEXTMODE
	 70
	0
	  9
	$MIRRTEXT
	 70
	0
	  9
	$LTSCALE
	 40
	1.0
	  9
	$ATTMODE
	 70
	1
	  9
	$TEXTSIZE
	 40
	0.2
	  9
	$TRACEWID
	 40
	0.05
	  9
	$TEXTSTYLE
	  7
	Notes
	  9
	$CLAYER
	  8
	0
	  9
	$CELTYPE
	  6
	ByLayer
	  9
	$CECOLOR
	 62
	256
	  9
	$CELTSCALE
	 40
	1.0
	  9
	$DISPSILH
	 70
	0
	  9
	$DIMSCALE
	 40
	1.0
	  9
	$DIMASZ
	 40
	3.0
	  9
	$DIMEXO
	 40
	1.5
	  9
	$DIMDLI
	 40
	6.0
	  9
	$DIMRND
	 40
	0.0
	  9
	$DIMDLE
	 40
	0.0
	  9
	$DIMEXE
	 40
	3.0
	  9
	$DIMTP
	 40
	0.0
	  9
	$DIMTM
	 40
	0.0
	  9
	$DIMTXT
	 40
	3.0
	  9
	$DIMCEN
	 40
	3.0
	  9
	$DIMTSZ
	 40
	0.0
	  9
	$DIMTOL
	 70
	0
	  9
	$DIMLIM
	 70
	0
	  9
	$DIMTIH
	 70
	0
	  9
	$DIMTOH
	 70
	0
	  9
	$DIMSE1
	 70
	0
	  9
	$DIMSE2
	 70
	0
	  9
	$DIMTAD
	 70
	1
	  9
	$DIMZIN
	 70
	3
	  9
	$DIMBLK
	  1
	
	  9
	$DIMASO
	 70
	1
	  9
	$DIMSHO
	 70
	1
	  9
	$DIMPOST
	  1
	
	  9
	$DIMAPOST
	  1
	
	  9
	$DIMALT
	 70
	0
	  9
	$DIMALTD
	 70
	2
	  9
	$DIMALTF
	 40
	25.4
	  9
	$DIMLFAC
	 40
	1.0
	  9
	$DIMTOFL
	 70
	0
	  9
	$DIMTVP
	 40
	0.0
	  9
	$DIMTIX
	 70
	0
	  9
	$DIMSOXD
	 70
	0
	  9
	$DIMSAH
	 70
	0
	  9
	$DIMBLK1
	  1
	
	  9
	$DIMBLK2
	  1
	
	  9
	$DIMSTYLE
	  2
	Civil-Metric
	  9
	$DIMCLRD
	 70
	0
	  9
	$DIMCLRE
	 70
	0
	  9
	$DIMCLRT
	 70
	0
	  9
	$DIMTFAC
	 40
	1.0
	  9
	$DIMGAP
	 40
	2.0
	  9
	$DIMJUST
	 70
	0
	  9
	$DIMSD1
	 70
	0
	  9
	$DIMSD2
	 70
	0
	  9
	$DIMTOLJ
	 70
	1
	  9
	$DIMTZIN
	 70
	0
	  9
	$DIMALTZ
	 70
	0
	  9
	$DIMALTTZ
	 70
	0
	  9
	$DIMUPT
	 70
	0
	  9
	$DIMDEC
	 70
	2
	  9
	$DIMTDEC
	 70
	2
	  9
	$DIMALTU
	 70
	2
	  9
	$DIMALTTD
	 70
	2
	  9
	$DIMTXSTY
	  7
	Standard
	  9
	$DIMAUNIT
	 70
	0
	  9
	$DIMADEC
	 70
	2
	  9
	$DIMALTRND
	 40
	0.0
	  9
	$DIMAZIN
	 70
	2
	  9
	$DIMDSEP
	 70
	46
	  9
	$DIMATFIT
	 70
	3
	  9
	$DIMFRAC
	 70
	1
	  9
	$DIMLDRBLK
	  1
	
	  9
	$DIMLUNIT
	 70
	2
	  9
	$DIMLWD
	 70
	-2
	  9
	$DIMLWE
	 70
	-2
	  9
	$DIMTMOVE
	 70
	0
	  9
	$DIMFXL
	 40
	1.0
	  9
	$DIMFXLON
	 70
	0
	  9
	$DIMJOGANG
	 40
	0.785398163397
	  9
	$DIMTFILL
	 70
	0
	  9
	$DIMTFILLCLR
	 70
	0
	  9
	$DIMARCSYM
	 70
	0
	  9
	$DIMLTYPE
	  6
	
	  9
	$DIMLTEX1
	  6
	
	  9
	$DIMLTEX2
	  6
	
	  9
	$DIMTXTDIRECTION
	 70
	0
	  9
	$LUNITS
	 70
	2
	  9
	$LUPREC
	 70
	4
	  9
	$SKETCHINC
	 40
	0.1
	  9
	$FILLETRAD
	 40
	0.0
	  9
	$AUNITS
	 70
	4
	  9
	$AUPREC
	 70
	5
	  9
	$MENU
	  1
	.
	  9
	$ELEVATION
	 40
	0.0
	  9
	$PELEVATION
	 40
	0.0
	  9
	$THICKNESS
	 40
	0.0
	  9
	$LIMCHECK
	 70
	0
	  9
	$CHAMFERA
	 40
	0.0
	  9
	$CHAMFERB
	 40
	0.0
	  9
	$CHAMFERC
	 40
	0.0
	  9
	$CHAMFERD
	 40
	0.0
	  9
	$SKPOLY
	 70
	0
	  9
	$TDCREATE
	 40
	2457986.69756
	  9
	$TDUCREATE
	 40
	2455631.2632
	  9
	$TDUPDATE
	 40
	2457986.69756
	  9
	$TDUUPDATE
	 40
	2456436.43179
	  9
	$TDINDWG
	 40
	0.0003490741
	  9
	$TDUSRTIMER
	 40
	0.0003487153
	  9
	$USRTIMER
	 70
	1
	  9
	$ANGBASE
	 50
	0.0
	  9
	$ANGDIR
	 70
	0
	  9
	$PDMODE
	 70
	0
	  9
	$PDSIZE
	 40
	0.0
	  9
	$PLINEWID
	 40
	0.0
	  9
	$SPLFRAME
	 70
	0
	  9
	$SPLINETYPE
	 70
	6
	  9
	$SPLINESEGS
	 70
	8
	  9
	$HANDSEED
	  5
	5C7
	  9
	$SURFTAB1
	 70
	6
	  9
	$SURFTAB2
	 70
	6
	  9
	$SURFTYPE
	 70
	6
	  9
	$SURFU
	 70
	6
	  9
	$SURFV
	 70
	6
	  9
	$UCSBASE
	  2
	
	  9
	$UCSNAME
	  2
	
	  9
	$UCSORG
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSXDIR
	 10
	1.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSYDIR
	 10
	0.0
	 20
	1.0
	 30
	0.0
	  9
	$UCSORTHOREF
	  2
	
	  9
	$UCSORTHOVIEW
	 70
	0
	  9
	$UCSORGTOP
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGBOTTOM
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGLEFT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGRIGHT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGFRONT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$UCSORGBACK
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSBASE
	  2
	
	  9
	$PUCSNAME
	  2
	
	  9
	$PUCSORG
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSXDIR
	 10
	1.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSYDIR
	 10
	0.0
	 20
	1.0
	 30
	0.0
	  9
	$PUCSORTHOREF
	  2
	
	  9
	$PUCSORTHOVIEW
	 70
	0
	  9
	$PUCSORGTOP
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGBOTTOM
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGLEFT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGRIGHT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGFRONT
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PUCSORGBACK
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$USERI1
	 70
	0
	  9
	$USERI2
	 70
	0
	  9
	$USERI3
	 70
	0
	  9
	$USERI4
	 70
	0
	  9
	$USERI5
	 70
	0
	  9
	$USERR1
	 40
	0.0
	  9
	$USERR2
	 40
	0.0
	  9
	$USERR3
	 40
	0.0
	  9
	$USERR4
	 40
	0.0
	  9
	$USERR5
	 40
	0.0
	  9
	$WORLDVIEW
	 70
	1
	  9
	$SHADEDGE
	 70
	3
	  9
	$SHADEDIF
	 70
	70
	  9
	$TILEMODE
	 70
	1
	  9
	$MAXACTVP
	 70
	64
	  9
	$PINSBASE
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  9
	$PLIMCHECK
	 70
	0
	  9
	$PEXTMIN
	 10
	0.628866766397
	 20
	0.799999952316
	 30
	0.0
	  9
	$PEXTMAX
	 10
	9.02886638493
	 20
	7.19999957085
	 30
	0.0
	  9
	$PLIMMIN
	 10
	-0.700541819174
	 20
	-0.228100386192
	  9
	$PLIMMAX
	 10
	10.2994579405
	 20
	8.27189937351
	  9
	$UNITMODE
	 70
	0
	  9
	$VISRETAIN
	 70
	1
	  9
	$PLINEGEN
	 70
	0
	  9
	$PSLTSCALE
	 70
	1
	  9
	$TREEDEPTH
	 70
	3020
	  9
	$CMLSTYLE
	  2
	Standard
	  9
	$CMLJUST
	 70
	0
	  9
	$CMLSCALE
	 40
	1.0
	  9
	$PROXYGRAPHICS
	 70
	1
	  9
	$MEASUREMENT
	 70
	1
	  9
	$CELWEIGHT
	370
	-1
	  9
	$ENDCAPS
	280
	0
	  9
	$JOINSTYLE
	280
	0
	  9
	$LWDISPLAY
	290
	0
	  9
	$INSUNITS
	 70
	4
	  9
	$HYPERLINKBASE
	  1
	
	  9
	$STYLESHEET
	  1
	
	  9
	$XEDIT
	290
	1
	  9
	$CEPSNTYPE
	380
	0
	  9
	$PSTYLEMODE
	290
	1
	  9
	$FINGERPRINTGUID
	  2
	{39DB1BDD-BC6C-46D3-A333-DFCC0DC4782D}
	  9
	$VERSIONGUID
	  2
	{69EEBB2D-7039-498F-9366-3F994E4A07E7}
	  9
	$EXTNAMES
	290
	1
	  9
	$PSVPSCALE
	 40
	0.0
	  9
	$OLESTARTUP
	290
	0
	  9
	$SORTENTS
	280
	127
	  9
	$INDEXCTL
	280
	0
	  9
	$HIDETEXT
	280
	1
	  9
	$XCLIPFRAME
	280
	0
	  9
	$HALOGAP
	280
	0
	  9
	$OBSCOLOR
	 70
	257
	  9
	$OBSLTYPE
	280
	0
	  9
	$INTERSECTIONDISPLAY
	280
	0
	  9
	$INTERSECTIONCOLOR
	 70
	257
	  9
	$DIMASSOC
	280
	2
	  9
	$PROJECTNAME
	  1
	
	  9
	$CAMERADISPLAY
	290
	0
	  9
	$LENSLENGTH
	 40
	50.0
	  9
	$CAMERAHEIGHT
	 40
	0.0
	  9
	$STEPSPERSEC
	 40
	2.0
	  9
	$STEPSIZE
	 40
	6.0
	  9
	$3DDWFPREC
	 40
	2.0
	  9
	$PSOLWIDTH
	 40
	0.25
	  9
	$PSOLHEIGHT
	 40
	4.0
	  9
	$LOFTANG1
	 40
	1.57079632679
	  9
	$LOFTANG2
	 40
	1.57079632679
	  9
	$LOFTMAG1
	 40
	0.0
	  9
	$LOFTMAG2
	 40
	0.0
	  9
	$LOFTPARAM
	 70
	7
	  9
	$LOFTNORMALS
	280
	1
	  9
	$LATITUDE
	 40
	37.795
	  9
	$LONGITUDE
	 40
	-122.394
	  9
	$NORTHDIRECTION
	 40
	0.0
	  9
	$TIMEZONE
	 70
	-8000
	  9
	$LIGHTGLYPHDISPLAY
	280
	1
	  9
	$TILEMODELIGHTSYNCH
	280
	1
	  9
	$CMATERIAL
	347
	96
	  9
	$SOLIDHIST
	280
	1
	  9
	$SHOWHIST
	280
	1
	  9
	$DWFFRAME
	280
	2
	  9
	$DGNFRAME
	280
	0
	  9
	$REALWORLDSCALE
	290
	1
	  9
	$INTERFERECOLOR
	 62
	1
	  9
	$INTERFEREOBJVS
	345
	A3
	  9
	$INTERFEREVPVS
	346
	A0
	  9
	$CSHADOW
	280
	0
	  9
	$SHADOWPLANELOCATION
	 40
	0.0
	  0
	ENDSEC`
	  return content
	}
	
	const dxfClasses = function () {
	  const content = `  0
	SECTION
	  2
	CLASSES
	  0
	CLASS
	  1
	ACDBDICTIONARYWDFLT
	  2
	AcDbDictionaryWithDefault
	  3
	ObjectDBX Classes
	 90
	0
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	DICTIONARYVAR
	  2
	AcDbDictionaryVar
	  3
	ObjectDBX Classes
	 90
	0
	 91
	15
	280
	0
	281
	0
	  0
	CLASS
	  1
	TABLESTYLE
	  2
	AcDbTableStyle
	  3
	ObjectDBX Classes
	 90
	4095
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	MATERIAL
	  2
	AcDbMaterial
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	3
	280
	0
	281
	0
	  0
	CLASS
	  1
	VISUALSTYLE
	  2
	AcDbVisualStyle
	  3
	ObjectDBX Classes
	 90
	4095
	 91
	26
	280
	0
	281
	0
	  0
	CLASS
	  1
	SCALE
	  2
	AcDbScale
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	17
	280
	0
	281
	0
	  0
	CLASS
	  1
	MLEADERSTYLE
	  2
	AcDbMLeaderStyle
	  3
	ACDB_MLEADERSTYLE_CLASS
	 90
	4095
	 91
	3
	280
	0
	281
	0
	  0
	CLASS
	  1
	CELLSTYLEMAP
	  2
	AcDbCellStyleMap
	  3
	ObjectDBX Classes
	 90
	1152
	 91
	2
	280
	0
	281
	0
	  0
	CLASS
	  1
	EXACXREFPANELOBJECT
	  2
	ExAcXREFPanelObject
	  3
	EXAC_ESW
	 90
	1025
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	NPOCOLLECTION
	  2
	AcDbImpNonPersistentObjectsCollection
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	LAYER_INDEX
	  2
	AcDbLayerIndex
	  3
	ObjectDBX Classes
	 90
	0
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	SPATIAL_INDEX
	  2
	AcDbSpatialIndex
	  3
	ObjectDBX Classes
	 90
	0
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	IDBUFFER
	  2
	AcDbIdBuffer
	  3
	ObjectDBX Classes
	 90
	0
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	DIMASSOC
	  2
	AcDbDimAssoc
	  3
	"AcDbDimAssoc|Product Desc:     AcDim ARX App For Dimension|Company:          Autodesk, Inc.|WEB Address:      www.autodesk.com"
	 90
	0
	 91
	0
	280
	0
	281
	0
	  0
	CLASS
	  1
	ACDBSECTIONVIEWSTYLE
	  2
	AcDbSectionViewStyle
	  3
	ObjectDBX Classes
	 90
	1025
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	ACDBDETAILVIEWSTYLE
	  2
	AcDbDetailViewStyle
	  3
	ObjectDBX Classes
	 90
	1025
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	IMAGEDEF
	  2
	AcDbRasterImageDef
	  3
	ISM
	 90
	0
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	RASTERVARIABLES
	  2
	AcDbRasterVariables
	  3
	ISM
	 90
	0
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	IMAGEDEF_REACTOR
	  2
	AcDbRasterImageDefReactor
	  3
	ISM
	 90
	1
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	IMAGE
	  2
	AcDbRasterImage
	  3
	ISM
	 90
	2175
	 91
	1
	280
	0
	281
	1
	  0
	CLASS
	  1
	PDFDEFINITION
	  2
	AcDbPdfDefinition
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	1
	280
	0
	281
	0
	  0
	CLASS
	  1
	PDFUNDERLAY
	  2
	AcDbPdfReference
	  3
	ObjectDBX Classes
	 90
	4095
	 91
	1
	280
	0
	281
	1
	  0
	CLASS
	  1
	DWFDEFINITION
	  2
	AcDbDwfDefinition
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	2
	280
	0
	281
	0
	  0
	CLASS
	  1
	DWFUNDERLAY
	  2
	AcDbDwfReference
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	1
	280
	0
	281
	1
	  0
	CLASS
	  1
	DGNDEFINITION
	  2
	AcDbDgnDefinition
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	2
	280
	0
	281
	0
	  0
	CLASS
	  1
	DGNUNDERLAY
	  2
	AcDbDgnReference
	  3
	ObjectDBX Classes
	 90
	1153
	 91
	1
	280
	0
	281
	1
	  0
	ENDSEC`
	  return content
	}
	
	const dxfTables = function () {
	  const content = `  0
	SECTION
	  2
	TABLES
	  0
	TABLE
	  2
	VPORT
	  5
	8
	330
	0
	100
	AcDbSymbolTable
	 70
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	LTYPE
	  5
	5F
	330
	0
	100
	AcDbSymbolTable
	 70
	7
	  0
	LTYPE
	  5
	14
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	ByBlock
	 70
	0
	  3
	
	 72
	65
	 73
	0
	 40
	0.0
	  0
	LTYPE
	  5
	15
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	ByLayer
	 70
	0
	  3
	
	 72
	65
	 73
	0
	 40
	0.0
	  0
	LTYPE
	  5
	16
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	Continuous
	 70
	0
	  3
	Solid line
	 72
	65
	 73
	0
	 40
	0.0
	  0
	LTYPE
	  5
	1B1
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	CENTER
	 70
	0
	  3
	Center ____ _ ____ _ ____ _ ____ _ ____ _ ____
	 72
	65
	 73
	4
	 40
	2.0
	 49
	1.25
	 74
	0
	 49
	-0.25
	 74
	0
	 49
	0.25
	 74
	0
	 49
	-0.25
	 74
	0
	  0
	LTYPE
	  5
	1B2
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	DASHED
	 70
	0
	  3
	Dashed __ __ __ __ __ __ __ __ __ __ __ __ __ _
	 72
	65
	 73
	2
	 40
	0.75
	 49
	0.5
	 74
	0
	 49
	-0.25
	 74
	0
	  0
	LTYPE
	  5
	1B3
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	PHANTOM
	 70
	0
	  3
	Phantom ______  __  __  ______  __  __  ______
	 72
	65
	 73
	6
	 40
	2.5
	 49
	1.25
	 74
	0
	 49
	-0.25
	 74
	0
	 49
	0.25
	 74
	0
	 49
	-0.25
	 74
	0
	 49
	0.25
	 74
	0
	 49
	-0.25
	 74
	0
	  0
	LTYPE
	  5
	39E
	330
	5F
	100
	AcDbSymbolTableRecord
	100
	AcDbLinetypeTableRecord
	  2
	HIDDEN
	 70
	0
	  3
	Hidden __ __ __ __ __ __ __ __ __ __ __ __ __ __
	 72
	65
	 73
	2
	 40
	9.525
	 49
	6.35
	 74
	0
	 49
	-3.175
	 74
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	LAYER
	  5
	2
	330
	0
	100
	AcDbSymbolTable
	 70
	3
	  0
	LAYER
	  5
	10
	330
	2
	100
	AcDbSymbolTableRecord
	100
	AcDbLayerTableRecord
	  2
	0
	 70
	0
	  6
	Continuous
	370
	-3
	390
	F
	347
	98
	348
	0
	  0
	LAYER
	  5
	1B4
	330
	2
	100
	AcDbSymbolTableRecord
	100
	AcDbLayerTableRecord
	  2
	View Port
	 70
	0
	  6
	Continuous
	290
	0
	370
	-3
	390
	F
	347
	98
	348
	0
	  0
	LAYER
	  5
	21D
	330
	2
	100
	AcDbSymbolTableRecord
	100
	AcDbLayerTableRecord
	  2
	Defpoints
	 70
	0
	  6
	Continuous
	290
	0
	370
	-3
	390
	F
	347
	98
	348
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	STYLE
	  5
	3
	330
	0
	100
	AcDbSymbolTable
	 70
	3
	  0
	STYLE
	  5
	11
	330
	3
	100
	AcDbSymbolTableRecord
	100
	AcDbTextStyleTableRecord
	  2
	Standard
	 70
	0
	 40
	0.0
	 41
	1.0
	 50
	0.0
	 71
	0
	 42
	0.2
	  3
	arial.ttf
	  4
	
	  0
	STYLE
	  5
	DC
	330
	3
	100
	AcDbSymbolTableRecord
	100
	AcDbTextStyleTableRecord
	  2
	Annotative
	 70
	0
	 40
	0.0
	 41
	1.0
	 50
	0.0
	 71
	0
	 42
	0.2
	  3
	arial.ttf
	  4
	
	  0
	STYLE
	  5
	178
	330
	3
	100
	AcDbSymbolTableRecord
	100
	AcDbTextStyleTableRecord
	  2
	Notes
	 70
	0
	 40
	3.0
	 41
	1.0
	 50
	0.0
	 71
	0
	 42
	0.2
	  3
	arial.ttf
	  4
	
	  0
	ENDTAB
	  0
	TABLE
	  2
	VIEW
	  5
	6
	330
	0
	100
	AcDbSymbolTable
	 70
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	UCS
	  5
	7
	330
	0
	100
	AcDbSymbolTable
	 70
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	APPID
	  5
	9
	330
	0
	100
	AcDbSymbolTable
	 70
	12
	  0
	APPID
	  5
	12
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD
	 70
	0
	  0
	APPID
	  5
	DD
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	AcadAnnoPO
	 70
	0
	  0
	APPID
	  5
	DE
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	AcadAnnotative
	 70
	0
	  0
	APPID
	  5
	DF
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_DSTYLE_DIMJAG
	 70
	0
	  0
	APPID
	  5
	E0
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_DSTYLE_DIMTALN
	 70
	0
	  0
	APPID
	  5
	107
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_MLEADERVER
	 70
	0
	  0
	APPID
	  5
	1B5
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	AcAecLayerStandard
	 70
	0
	  0
	APPID
	  5
	1BA
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_EXEMPT_FROM_CAD_STANDARDS
	 70
	0
	  0
	APPID
	  5
	237
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_DSTYLE_DIMBREAK
	 70
	0
	  0
	APPID
	  5
	28E
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_PSEXT
	 70
	0
	  0
	APPID
	  5
	4B0
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	ACAD_NAV_VCDISPLAY
	 70
	0
	  0
	APPID
	  5
	4E3
	330
	9
	100
	AcDbSymbolTableRecord
	100
	AcDbRegAppTableRecord
	  2
	HATCHBACKGROUNDCOLOR
	 70
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	DIMSTYLE
	  5
	A
	330
	0
	100
	AcDbSymbolTable
	 70
	3
	100
	AcDbDimStyleTable
	 71
	3
	340
	242
	340
	27
	340
	E1
	  0
	DIMSTYLE
	105
	27
	330
	A
	100
	AcDbSymbolTableRecord
	100
	AcDbDimStyleTableRecord
	  2
	Standard
	 70
	0
	 41
	3.0
	 42
	2.0
	 43
	9.0
	 44
	5.0
	140
	3.0
	141
	2.0
	147
	2.0
	340
	11
	1001
	ACAD_DSTYLE_DIMJAG
	1070
	388
	1040
	38.0
	1001
	ACAD_DSTYLE_DIMBREAK
	1070
	391
	1040
	90.0
	1001
	ACAD_DSTYLE_DIMTALN
	1070
	392
	1070
	0
	  0
	DIMSTYLE
	105
	E1
	330
	A
	100
	AcDbSymbolTableRecord
	100
	AcDbDimStyleTableRecord
	  2
	Annotative
	 70
	0
	 40
	0.0
	 41
	3.0
	 42
	2.5
	 43
	10.0
	 44
	5.0
	140
	3.0
	141
	2.0
	147
	2.0
	340
	11
	1001
	AcadAnnotative
	1000
	AnnotativeData
	1002
	{
	1070
	1
	1070
	1
	1002
	}
	1001
	ACAD_DSTYLE_DIMJAG
	1070
	388
	1040
	38.0
	1001
	ACAD_DSTYLE_DIMBREAK
	1070
	391
	1040
	90.0
	1001
	ACAD_DSTYLE_DIMTALN
	1070
	392
	1070
	0
	  0
	DIMSTYLE
	105
	242
	330
	A
	100
	AcDbSymbolTableRecord
	100
	AcDbDimStyleTableRecord
	  2
	Civil-Metric
	 70
	0
	 41
	3.0
	 42
	1.5
	 43
	6.0
	 44
	3.0
	 73
	0
	 74
	0
	 77
	1
	 78
	3
	 79
	2
	140
	3.0
	141
	3.0
	147
	2.0
	179
	2
	271
	2
	272
	2
	276
	1
	340
	11
	1001
	ACAD_DSTYLE_DIMBREAK
	1070
	391
	1040
	3.0
	1001
	ACAD_DSTYLE_DIMJAG
	1070
	388
	1040
	38.0
	1001
	ACAD_DSTYLE_DIMTALN
	1070
	392
	1070
	0
	  0
	ENDTAB
	  0
	TABLE
	  2
	BLOCK_RECORD
	  5
	1
	330
	0
	100
	AcDbSymbolTable
	 70
	4
	  0
	BLOCK_RECORD
	  5
	1F
	330
	1
	100
	AcDbSymbolTableRecord
	100
	AcDbBlockTableRecord
	  2
	*Model_Space
	340
	530
	 70
	0
	280
	1
	281
	0
	  0
	BLOCK_RECORD
	  5
	58
	330
	1
	100
	AcDbSymbolTableRecord
	100
	AcDbBlockTableRecord
	  2
	*Paper_Space
	340
	531
	 70
	0
	280
	1
	281
	0
	  0
	BLOCK_RECORD
	  5
	238
	330
	1
	100
	AcDbSymbolTableRecord
	100
	AcDbBlockTableRecord
	  2
	_ArchTick
	340
	0
	 70
	0
	280
	1
	281
	0
	  0
	BLOCK_RECORD
	  5
	23C
	330
	1
	100
	AcDbSymbolTableRecord
	100
	AcDbBlockTableRecord
	  2
	_Open30
	340
	0
	 70
	0
	280
	1
	281
	0
	  0
	ENDTAB
	  0
	ENDSEC`
	  return content
	}
	
	const dxfBlocks = function () {
	  const content = `  0
	SECTION
	  2
	BLOCKS
	  0
	BLOCK
	  5
	23A
	330
	238
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockBegin
	  2
	_ArchTick
	 70
	0
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  3
	_ArchTick
	  1
	
	  0
	ENDBLK
	  5
	23B
	330
	238
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockEnd
	  0
	BLOCK
	  5
	20
	330
	1F
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockBegin
	  2
	*Model_Space
	 70
	0
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  3
	*Model_Space
	  1
	
	  0
	ENDBLK
	  5
	21
	330
	1F
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockEnd
	  0
	BLOCK
	  5
	5A
	330
	58
	100
	AcDbEntity
	 67
	1
	  8
	0
	100
	AcDbBlockBegin
	  2
	*Paper_Space
	 70
	0
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  3
	*Paper_Space
	  1
	
	  0
	ENDBLK
	  5
	5B
	330
	58
	100
	AcDbEntity
	 67
	1
	  8
	0
	100
	AcDbBlockEnd
	  0
	BLOCK
	  5
	240
	330
	23C
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockBegin
	  2
	_Open30
	 70
	0
	 10
	0.0
	 20
	0.0
	 30
	0.0
	  3
	_Open30
	  1
	
	  0
	ENDBLK
	  5
	241
	330
	23C
	100
	AcDbEntity
	  8
	0
	100
	AcDbBlockEnd
	  0
	ENDSEC`
	  return content
	}
	
	const dxfObjects = function () {
	  const content = `  0
	SECTION
	  2
	OBJECTS
	  0
	DICTIONARY
	  5
	C
	330
	0
	100
	AcDbDictionary
	281
	1
	  3
	ACAD_COLOR
	350
	524
	  3
	ACAD_GROUP
	350
	525
	  3
	ACAD_LAYOUT
	350
	526
	  3
	ACAD_MATERIAL
	350
	527
	  3
	ACAD_MLEADERSTYLE
	350
	528
	  3
	ACAD_MLINESTYLE
	350
	529
	  3
	ACAD_PLOTSETTINGS
	350
	52A
	  3
	ACAD_PLOTSTYLENAME
	350
	52C
	  3
	ACAD_SCALELIST
	350
	52D
	  3
	ACAD_TABLESTYLE
	350
	52E
	  3
	ACAD_VISUALSTYLE
	350
	52F
	  0
	DICTIONARY
	  5
	524
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	525
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	526
	330
	C
	100
	AcDbDictionary
	281
	1
	  3
	Model
	350
	530
	  3
	Layout1
	350
	531
	  0
	DICTIONARY
	  5
	527
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	528
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	529
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	52A
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	ACDBPLACEHOLDER
	  5
	52B
	330
	52C
	  0
	ACDBDICTIONARYWDFLT
	  5
	52C
	330
	C
	100
	AcDbDictionary
	281
	1
	  3
	Normal
	350
	52B
	100
	AcDbDictionaryWithDefault
	340
	52B
	  0
	DICTIONARY
	  5
	52D
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	52E
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	DICTIONARY
	  5
	52F
	330
	C
	100
	AcDbDictionary
	281
	1
	  0
	LAYOUT
	  5
	530
	330
	526
	100
	AcDbPlotSettings
	  1
	
	  2
	DWFx ePlot (XPS Compatible).pc3
	  4
	ANSI_A_(8.50_x_11.00_Inches)
	  6
	
	 40
	5.8
	 41
	17.8
	 42
	5.8
	 43
	17.8
	 44
	215.9
	 45
	279.4
	 46
	0.0
	 47
	0.0
	 48
	0.0
	 49
	0.0
	140
	0.0
	141
	0.0
	142
	1.0
	143
	14.53
	 70
	11952
	 72
	0
	 73
	1
	 74
	0
	  7
	
	 75
	0
	147
	0.069
	148
	114.98
	149
	300.29
	100
	AcDbLayout
	  1
	Model
	 70
	1
	 71
	0
	 10
	0.0
	 20
	0.0
	 11
	12.0
	 21
	9.0
	 12
	0.0
	 22
	0.0
	 32
	0.0
	 14
	0.0
	 24
	0.0
	 34
	0.0
	 15
	0.0
	 25
	0.0
	 35
	0.0
	146
	0.0
	 13
	0.0
	 23
	0.0
	 33
	0.0
	 16
	1.0
	 26
	0.0
	 36
	0.0
	 17
	0.0
	 27
	1.0
	 37
	0.0
	 76
	0
	330
	1F
	  0
	LAYOUT
	  5
	531
	330
	526
	100
	AcDbPlotSettings
	  1
	
	  2
	DWFx ePlot (XPS Compatible).pc3
	  4
	ANSI_A_(8.50_x_11.00_Inches)
	  6
	
	 40
	5.8
	 41
	17.8
	 42
	5.8
	 43
	17.8
	 44
	215.9
	 45
	279.4
	 46
	0.0
	 47
	0.0
	 48
	0.0
	 49
	0.0
	140
	0.0
	141
	0.0
	142
	1.0
	143
	1.0
	 70
	688
	 72
	0
	 73
	1
	 74
	5
	  7
	acad.ctb
	 75
	16
	147
	1.0
	148
	0.0
	149
	0.0
	100
	AcDbLayout
	  1
	Layout1
	 70
	1
	 71
	1
	 10
	-0.7
	 20
	-0.23
	 11
	10.3
	 21
	8.27
	 12
	0.0
	 22
	0.0
	 32
	0.0
	 14
	0.63
	 24
	0.8
	 34
	0.0
	 15
	9.0
	 25
	7.2
	 35
	0.0
	146
	0.0
	 13
	0.0
	 23
	0.0
	 33
	0.0
	 16
	1.0
	 26
	0.0
	 36
	0.0
	 17
	0.0
	 27
	1.0
	 37
	0.0
	 76
	0
	330
	58
	  0
	ENDSEC`
	  return content
	}
	
	const dxfEntities = (objects, options) => {
	  const entityContents = objects.map((object, i) => {
	    return PolygonsTo3DFaces(object, options)
	  });
	
	  let section = `  0
	SECTION
	  2
	ENTITIES
	`
	  entityContents.forEach((content) => {
	    if (content) {
	      section += content
	    }
	  })
	  section += `  0
	ENDSEC`
	  return section
	}
	
	
	const serialize = (options, ...objects) => {
	  const defaults = {
	    geom3To: '3dface', // or polyline
	    pathTo: 'lwpolyline',
	    statusCallback: null,
	    colorIndex: 0
	  }
	  options = Object.assign({}, defaults, options)
	
	  options.entityId = 0 // sequence id for entities created
	
	  if (objects.length === 0) throw new Error('only JSCAD geometries can be serialized to DXF')
	
	  const dxfContent = `999
	Created by JSCAD
	${dxfHeaders(options)}
	${dxfClasses(options)}
	${dxfTables(options)}
	${dxfBlocks(options)}
	${dxfEntities(objects, options)}
	${dxfObjects(options)}
	  0
	EOF
	`
	  return [dxfContent]
	}
	
	let polygonToTriangles = (polygon) => {
	  const length = polygon.vertices.length - 2
	  if (length < 1) return []
	
	  const pivot = polygon.vertices[0]
	  const triangles = []
	  for (let i = 0; i < length; i++) {
	    triangles.push([pivot, polygon.vertices[i + 1], polygon.vertices[i + 2]])
	  }
	  return triangles
	}
	
	let triangleTo3DFaces = (triangle, options, color) => {
	  const corner10 = triangle[0].pos;
	  const corner11 = triangle[1].pos;
	  const corner12 = triangle[2].pos;
	  const corner13 = triangle[2].pos;
	  const str = `  0
	3DFACE
	  5
	MyPart
	  100
	AcDbEntity
	  8
	0
	  62
	${color}
	  100
	AcDbFace
	  70
	0
	  10
	${corner10.x}
	  20
	${corner10.y}
	  30
	${corner10.z}
	  11
	${corner11.x}
	  21
	${corner11.y}
	  31
	${corner11.z}
	  12
	${corner12.x}
	  22
	${corner12.y}
	  32
	${corner12.z}
	  13
	${corner13.x}
	  23
	${corner13.y}
	  33
	${corner13.z}
	`
	  return str
	}
	
	let PolygonsTo3DFaces = (csg, options) => {
	  let str = ''
	  const polygons = csg.polygons
	  // const objectColor = getColorNumber(object, options)
	  polygons.forEach((polygon, i) => {
	    const polyColor = 0;//polygon.color ? getColorNumber(polygon, options) : objectColor
	    const triangles = polygonToTriangles(polygon)
	    triangles.forEach((triangle, i) => {
	      str += triangleTo3DFaces(triangle, options, polyColor)
	    })
	  })
	  return [str]
	}
	exports.dxfHeaders = dxfHeaders
	exports.dxfClasses = dxfClasses
	exports.dxfTables = dxfTables
	exports.dxfBlocks = dxfBlocks
	exports.dxfObjects = dxfObjects
	exports.dxfEntities = dxfEntities
	exports.serialize = serialize
	
	
	
	
	
});


RequireJS.addFunction('./services/cabinet/public/js/3d-modeling/viewer.js',
function (require, exports, module) {
	

	
	const du = require('../../../../../public/js/utils/dom-utils.js');
	const CSG = require('./csg.js');
	const GL = require('./lightgl.js');
	
	// Set the color of all polygons in this solid
	CSG.prototype.setColor = function(r, g, b) {
	  this.toPolygons().map(function(polygon) {
	    if (Array.isArray(r)) {
	      g = r[1];
	      b = r[2];
	      r = r[0];
	    }
	    polygon.shared = [r/255, g/255, b/255];
	  });
	};
	
	// Convert from CSG solid to GL.Mesh object
	CSG.prototype.toMesh = function() {
	  var mesh = new GL.Mesh({ normals: true, colors: true });
	  var indexer = new GL.Indexer();
	  this.toPolygons().map(function(polygon) {
	    var indices = polygon.vertices.map(function(vertex) {
	      vertex.color = polygon.shared || [1, 1, 1];
	      return indexer.add(vertex);
	    });
	    for (var i = 2; i < indices.length; i++) {
	      mesh.triangles.push([indices[0], indices[i - 1], indices[i]]);
	    }
	  });
	  mesh.vertices = indexer.unique.map(function(v) { return [v.pos.x, v.pos.y, v.pos.z]; });
	  mesh.normals = indexer.unique.map(function(v) { return [v.normal.x, v.normal.y, v.normal.z]; });
	  mesh.colors = indexer.unique.map(function(v) { return v.color; });
	  mesh.computeWireframe();
	  return mesh;
	};
	
	var angleX = 0;
	var angleY = 0;
	var angleZ = 0;
	var viewers = [];
	
	// Set to true so lines don't use the depth buffer
	Viewer.lineOverlay = false;
	
	// A viewer is a WebGL canvas that lets the user view a mesh. The user can
	// tumble it around by dragging the mouse.
	function Viewer(csg, width, height, depth) {
	  const originalDepth = depth;
	  viewers.push(this);
	  this.setDepth = (d) => depth = d;
	  let x = 0;
	  let y = 0;
	
	  let lastZoom;
	  let zoomCount = 0;
	  const zoom = (out) => {
	    let direction = (out === true ? 1 : -1);
	    let zoomOffset = 2;
	    let newTime = new Date().getTime();
	    if (lastZoom > newTime - 50) {
	      zoomCount++;
	      zoomOffset *= zoomCount;
	      zoomOffset = zoomOffset > 20 ? 20 : zoomOffset;
	    }
	    lastZoom = newTime;
	    depth += zoomOffset * direction;
	  };
	  this.zoom = zoom;
	  const pan = (leftRight, upDown) => {
	    x += leftRight;
	    y += upDown * -1;
	  }
	
	  // Get a new WebGL canvas
	  var gl = GL.create();
	  this.gl = gl;
	  this.mesh = csg.toMesh();
	  this.canvas = () => gl.canvas;
	
	  // Set up the viewport
	  gl.canvas.width = width;
	  gl.canvas.height = height;
	  gl.viewport(0, 0, width, height);
	  gl.matrixMode(gl.PROJECTION);
	  gl.loadIdentity();
	  gl.perspective(100, width / height, 10, 1000);
	  gl.rotate(0, 0, 1, 0);
	  gl.translate(0, 0, -200);
	  gl.matrixMode(gl.MODELVIEW);
	
	  // Set up WebGL state
	  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	  gl.clearColor(0.93, 0.93, 0.93, 1);
	  gl.enable(gl.DEPTH_TEST);
	  gl.enable(gl.CULL_FACE);
	  gl.polygonOffset(1, 1);
	
	  // Black shader for wireframe
	  this.blackShader = new GL.Shader('\
	    void main() {\
	      gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
	    }\
	  ', '\
	    void main() {\
	      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);\
	    }\
	  ');
	
	  // Shader with diffuse and specular lighting
	  this.changeLightingShaderDirection = (x,y,z) => this.lightingShader = new GL.Shader(`
	    varying vec3 color;
	    varying vec3 normal;
	    varying vec3 light;
	    void main() {
	      const vec3 lightDir = vec3(${x}, ${y}, ${z}) / 3.741657386773941;
	      light = (gl_ModelViewMatrix * vec4(lightDir, 0.005)).xyz;
	      color = gl_Color.rgb;
	      normal = gl_NormalMatrix * gl_Normal;
	      gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
	    }
	  `, `
	    varying vec3 color;
	    varying vec3 normal;
	    varying vec3 light;
	    void main() {
	      vec3 n = normalize(normal);
	      float diffuse = max(0.0, dot(light, n));
	      float specular = pow(max(0.0, -reflect(light, n).z), 32.0) * sqrt(diffuse);
	      gl_FragColor = vec4(mix(color * (0.3 + 0.7 * diffuse), vec3(1.0), specular), 1.0);
	    }`);
	
	  this.changeLightingShaderDirection(0, 0, 0);
	  // this.changeLightingShaderDirection(3, 2, 3);
	
	  let origCenter = {x:0, y:0};
	  let pointClicked = {x: 0, y: 0, z: 0};
	  function setPointClicked(e) {
	    const canvasPos = e.target.getBoundingClientRect();
	    const clickPos = {x: e.x - canvasPos.x, y: e.y - canvasPos.y};
	    const canvasCenter = {x: e.target.width/2, y: e.target.height/2};
	    const canvasOffset = {x: clickPos.x - canvasCenter.x, y: clickPos.y - canvasCenter.y};
	    const twoDLoc = {x: origCenter.x + canvasOffset.x, y: origCenter.y + canvasOffset.y};
	    const centerOffset = GL.Matrix.relitiveDirection(twoDLoc.x, twoDLoc.y,0,gl.modelviewMatrix)
	    pointClicked = {x: centerOffset[0], y: centerOffset[1], z: centerOffset[2]};
	    console.log(pointClicked);
	  }
	
	  let rotationUnit;
	  let rotationOffset = [0,0,0];
	  let panOffset;
	  let panUnit;
	
	  let rotationVector = new CSG.Vector(25, 12,11.5);
	  let point = {x: 0, y: 12, z: 11.5};
	  // let rotationVector = new CSG.Vector(25, 12,11.5);
	  function rotateEvent(e) {
	    if (!rotationUnit) {
	      rotationUnit = {};
	      rotationUnit.y = GL.Matrix.relitiveDirection(1, 0,0,gl.modelviewMatrix);
	      rotationUnit.x = GL.Matrix.relitiveDirection(0, 1,0,gl.modelviewMatrix);
	      console.log(rotationUnit);
	    }
	    if (rotationUnit) {
	      const speed = 40;
	      if (e.deltaY) {
	        const dir = e.deltaY < 0 ? -speed : speed;
	        rotationOffset[0] += rotationUnit.y[0]/dir;
	        rotationOffset[1] += rotationUnit.y[1]/dir;
	        rotationOffset[2] += rotationUnit.y[2]/dir;
	      }
	      if (e.deltaX) {
	        const dir = e.deltaX < 0 ? speed : -speed;
	        rotationOffset[0] += rotationUnit.x[0]/dir;
	        rotationOffset[1] += rotationUnit.x[1]/dir;
	        rotationOffset[2] += rotationUnit.x[2]/dir;
	      }
	    }
	    // angleY += e.deltaX * 2;
	    // angleX += e.deltaY * 2;
	    // angleX = Math.max(-90, Math.min(90, angleX));
	  }
	
	  gl.onmousemove = function(e) {
	    if (e.dragging) {
	      if (shiftHeld) panEvent(e);
	      else rotateEvent(e);
	      gl.ondraw();
	    }
	  };
	
	  function zoomEvent(e) {
	    const st = document.documentElement.scrollTop;
	    if (e.deltaY < 0) {
	      zoom(true);
	    } else {
	      zoom();
	    }
	  }
	
	  function panEvent(e) {
	    const st = document.documentElement.scrollTop;
	    pan(-e.deltaX, e.deltaY)
	  }
	
	  let lastScrollTop = 0;
	  gl.canvas.onwheel = function (e) {
	    zoomEvent(e);
	    gl.ondraw();
	  }
	  disableScroll(gl.canvas);
	
	  let shiftHeld = false;
	  window.onkeydown = (e) => {
	    shiftHeld = e.key === "Shift" ? true : false;
	  }
	  window.onkeyup = (e) => {
	    shiftHeld = !shiftHeld || e.key === "Shift" ? false : true;
	  }
	
	  let clickHeld = false;
	  window.onclick = (e) => {
	    clickHeld = !clickHeld;
	    if (!clickHeld) {
	      rotationUnit = null;
	      panUnit = null;
	    }
	  }
	
	  window.onmousedown = setPointClicked;
	
	  function viewFrom(point, rotation) {
	      gl.makeCurrent();
	
	      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	      // const relDir1 = GL.Matrix.relitiveDirection(point.x, point.y, point.z, gl.modelviewMatrix);
	      gl.loadIdentity();
	
	      gl.rotate(rotation.x, 1, 0, 0);
	      gl.rotate(rotation.y, 0, 1, 0);
	      gl.rotate(rotation.z, 0, 0, 1);
	
	      // gl.translate(0, 0, -20);
	      // const relDir = GL.Matrix.relitiveDirection(point.x, point.y, point.z, gl.modelviewMatrix);
	      // gl.translate(relDir[0], relDir[1], relDir[2]);
	
	      if (!Viewer.lineOverlay) gl.enable(gl.POLYGON_OFFSET_FILL);
	      that.lightingShader.draw(that.mesh, gl.TRIANGLES);
	      if (!Viewer.lineOverlay) gl.disable(gl.POLYGON_OFFSET_FILL);
	
	      if (Viewer.lineOverlay) gl.disable(gl.DEPTH_TEST);
	      gl.enable(gl.BLEND);
	      // that.blackShader.draw(that.mesh, gl.LINES);
	      gl.disable(gl.BLEND);
	      if (Viewer.lineOverlay) gl.enable(gl.DEPTH_TEST);
	  }
	  this.viewFrom = viewFrom;
	
	  function applyZoom() {
	    // const depthArr = GL.Matrix.relitiveDirection(0,0,depth,gl.modelviewMatrix);
	    const transArr = GL.Matrix.relitiveDirection(x,-y,depth,gl.modelviewMatrix);
	    gl.translate(-transArr[0], -transArr[1], transArr[2])
	  }
	
	  var that = this;
	  gl.ondraw = function() {
	    gl.makeCurrent();
	
	    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	    // gl.loadIdentity();
	    applyZoom();
	    gl.rotateAroundPoint(pointClicked, rotationOffset);
	
	    // gl.rotate(angleX, rotationVector.x, rotationVector.y, rotationVector.z);
	    // gl.rotate(angleY, rotationVector.x, rotationVector.y, rotationVector.z);
	    // gl.rotate(rotationOffset[2], 0, 0, -1);
	    x = y = angleX = angleY = rotationOffset[0] = rotationOffset[1] = rotationOffset[2] = depth = 0;
	
	    if (!Viewer.lineOverlay) gl.enable(gl.POLYGON_OFFSET_FILL);
	    that.lightingShader.draw(that.mesh, gl.TRIANGLES);
	    if (!Viewer.lineOverlay) gl.disable(gl.POLYGON_OFFSET_FILL);
	
	    if (Viewer.lineOverlay) gl.disable(gl.DEPTH_TEST);
	    gl.enable(gl.BLEND);
	    // that.blackShader.draw(that.mesh, gl.LINES);
	    gl.disable(gl.BLEND);
	    if (Viewer.lineOverlay) gl.enable(gl.DEPTH_TEST);
	  };
	
	  gl.ondraw();
	
	  // gl.canvas.width = '100vw';
	  // gl.canvas.height = '100vh';
	}
	
	var nextID = 0;
	function addViewer(viewer, id) {
	  du.find(id).appendChild(viewer.gl.canvas);
	}
	
	
	
	
	// left: 37, up: 38, right: 39, down: 40,
	// spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36
	var keys = {37: 1, 38: 1, 39: 1, 40: 1};
	
	function preventDefault(e) {
	  e.preventDefault();
	}
	
	function preventDefaultForScrollKeys(e) {
	  if (keys[e.keyCode]) {
	    preventDefault(e);
	    return false;
	  }
	}
	
	// modern Chrome requires { passive: false } when adding event
	var supportsPassive = false;
	try {
	  window.addEventListener("test", null, Object.defineProperty({}, 'passive', {
	    get: function () { supportsPassive = true; }
	  }));
	} catch(e) {}
	
	var wheelOpt = supportsPassive ? { passive: false } : false;
	var wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel';
	
	// call this to Disable
	function disableScroll(element) {
	  element.addEventListener('DOMMouseScroll', preventDefault, false); // older FF
	  element.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop
	  element.addEventListener('touchmove', preventDefault, wheelOpt); // mobile
	  element.addEventListener('keydown', preventDefaultForScrollKeys, false);
	}
	
	// call this to Enable
	function enableScroll(element) {
	  element.removeEventListener('DOMMouseScroll', preventDefault, false);
	  element.removeEventListener(wheelEvent, preventDefault, wheelOpt);
	  element.removeEventListener('touchmove', preventDefault, wheelOpt);
	  element.removeEventListener('keydown', preventDefaultForScrollKeys, false);
	}
	
	exports.Viewer = Viewer
	exports.addViewer = addViewer
	exports.preventDefault = preventDefault
	exports.preventDefaultForScrollKeys = preventDefaultForScrollKeys
	exports.disableScroll = disableScroll
	exports.enableScroll = enableScroll
	
});


RequireJS.addFunction('./public/js/utils/auto-save.js',
function (require, exports, module) {
	
const du = require('dom-utils');
	
	class AutoSave {
	  constructor(cntId, contentFunc, suggestedName) {
	    if ((typeof contentFunc) !== 'function') throw new Error('Must give a content function or else whats the point?');
	    if (!cntId || (typeof cntId) !== 'string') throw new Error('A container Id is required to activate the autoSave function');
	    let cabinetConfig, propertyConfig, costConfig;
	    let workingDir, ordersDir;
	    let orderDirectories = {};
	    let activeOrderDir, activeVersion;
	    let activeVersionId = 'original';
	    let counter = 0;
	    let autoSaveOn = null;
	    const instance = this;
	
	    const getElem = (selector) => () => du.find.down(selector, du.id(cntId));
	    const getStatusElem = getElem('.status');
	    const getAutoSaveBtn = getElem('button');
	    const activeOrderName = () => activeOrderDir ? activeOrderDir.name : suggestedName;
	
	    const cookieId = () => `last-active-order-${cntId}`;
	    const cookieValue = () => `${activeOrderName()},${activeVersionId}`;
	    const setCookie = () => du.cookie.set(cookieId(), cookieValue());
	    const getCookie = () => du.cookie.get(cookieId());
	
	    this.save = async function () {
	      if (activeVersion) {
	        counter++;
	        getStatusElem().innerHTML = 'Saving...'
	        const writable = await activeVersion.createWritable();
	        await writable.write({type: 'write', data: contentFunc()});
	        await writable.close();
	        getStatusElem.innerHTML = '';
	      }
	    }
	
	    const decoder = new TextDecoder();
	    async function read() {
	      activeVersion = await activeOrderDir.getFileHandle(activeVersionId, {create: true});
	      const file = await activeVersion.getFile();
	      const stream = file.stream()
	      const reader = stream.getReader();
	      const fileSize = file.size;
	      const buffer = new DataView(new ArrayBuffer(fileSize));
	      const gibberish = await reader.read(buffer);
	      const text = decoder.decode(gibberish.value);
	      return text;
	    }
	
	    this.open = async function () {
	      let orderName = getCookie();
	      if (orderDirectories[orderName] === undefined)
	        orderName = Object.keys(orderDirectories)[0];
	      let orderDir = orderDirectories[orderName];
	      if (!orderDir) {
	        orderDir = await ordersDir.getDirectoryHandle(activeOrderName(), {create: true});
	      }
	      activeOrderDir = orderDir;
	      const contents = await read();
	
	      setCookie();
	      return activeVersion;
	    }
	
	    function autoSave() {
	      console.log('auto start:', autoSaveOn);
	      if (autoSaveOn) {
	        console.log('auto:', autoSaveOn);
	        setTimeout(autoSave, 10000);
	        instance.save();
	      }
	    }
	
	    async function init() {
	      workingDir = await window.showDirectoryPicker();
	      let perms = await workingDir.queryPermission()
	      ordersDir = await workingDir.getDirectoryHandle('orders', {create: true});
	      cabinetConfig = await workingDir.getFileHandle('cabinet.json', { create: true });
	      propertyConfig = await workingDir.getFileHandle('property.json', { create: true });
	      costConfig = await workingDir.getFileHandle('cost.json', { create: true });
	      const values = await ordersDir.values();
	      let next;
	      do {
	        next = await values.next();
	        if (next.value && next.value.kind === 'directory') {
	          orderDirectories[next.value.name] = next.value;
	        }
	      } while(!next.done);
	      instance.open();
	      autoSaveOn = true;
	      autoSave();
	    }
	
	    du.on.match('click', `#${cntId}>button`, (elem) =>{
	      if (autoSaveOn === null) return init();
	      if (autoSaveOn) {
	        autoSaveOn = false;
	        elem.innerHTML = 'Autosave off';
	      } else {
	        autoSaveOn = true;
	        elem.innerHTML = 'Autosave on!';
	        autoSave();
	      }
	    });
	  }
	}
	
	module.exports = AutoSave;
	
});


RequireJS.addFunction('./public/js/utils/expression-definition.js',
function (require, exports, module) {
	

	
	
	let idCount = 0;
	class ExprDef {
	  constructor(name, options, notify, stages, alwaysPossible) {
	    this.id = idCount++;
	    let id = this.id;
	    let string;
	    let modified = '';
	    let start;
	    let end;
	    alwaysPossible = alwaysPossible ? alwaysPossible : [];
	    stages = stages ? stages : {};
	    let currStage = stages;
	
	    function getRoutes(prefix, stage) {
	      let routes = [];
	      let keys = Object.keys(stage);
	      for (let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        if (key !== '_meta') {
	          let newPrefix;
	          if (prefix) {
	            newPrefix = `${prefix}.${key}`;
	          } else {
	            newPrefix = key;
	          }
	          const deepRoutes = getRoutes(newPrefix, stage[key]);
	          if (deepRoutes.length > 0) {
	            routes = routes.concat(deepRoutes);
	          }
	          if (stage[key]._meta && stage[key]._meta.end) {
	            routes.push(newPrefix + '.end');
	          }
	          if (stage[key]._meta && stage[key]._meta.repeat) {
	            routes.push(newPrefix + '.repeat');
	          }
	        }
	      }
	      return routes;
	    }
	
	    this.always = function () {
	      for (let index = 0; index < arguments.length; index += 1) {
	        alwaysPossible.push(arguments[index]);
	      }
	    };
	    this.getAlways = function (exprDef) {return alwaysPossible;};
	
	    this.allRoutes = function () {
	      return getRoutes(null, stages);
	    }
	
	    function getNotice (exprDef) {
	      let isInAlways = false;
	      alwaysPossible.map(function (value) {if (value.getName() === exprDef.getName()) isInAlways = true;});
	      if (isInAlways) return;
	      if (!exprDef.closed()) {
	        if (currStage[exprDef.getName()] === undefined) {
	          throw new Error(`Invalid Stage Transition ${currStage._meta.expr.getName()} -> ${exprDef.getName()}\n${currStage._meta.expr.allRoutes()}`)
	        }
	        currStage = currStage[exprDef.getName()];
	      }
	    }
	    this.getNotice = getNotice;
	
	    function getName () {return name;};
	    this.getName = getName;
	    this.onClose = function (start, end) {
	      return function (str, start, end) {
	        if (notify) notify(this);
	        options.onClose(str, start, end);
	      }
	    }
	
	    function setMeta(targetNodes, attr, value) {
	      return function () {
	        for (let lIndex = 0; lIndex < targetNodes.length; lIndex += 1) {
	          targetNodes[lIndex]._meta[attr] = value;
	        }
	      }
	    }
	
	    function then (targetNodes) {
	      return function () {
	        const createdNodes = [];
	        for (let lIndex = 0; lIndex < targetNodes.length; lIndex += 1) {
	          const targetNode = targetNodes[lIndex];
	          for (let index = 0; index < arguments.length; index += 1) {
	            const exprDef = arguments[index];
	            if (!exprDef instanceof ExprDef) {
	              throw new Error(`Argument is not an instanceof ExprDef`);
	            }
	            const nextExpr = exprDef.clone(getNotice);
	            if (targetNode[nextExpr.getName()] === undefined) {
	              targetNode[nextExpr.getName()] = {
	                _meta: {
	                  expr: nextExpr
	                }
	              };
	            }
	            createdNodes.push(targetNode[nextExpr.getName()]);
	          }
	        }
	        return {
	          then: then(createdNodes),
	          repeat: setMeta(createdNodes, 'repeat', true),
	          end: setMeta(createdNodes, 'end', true),
	        };
	      }
	    }
	
	    this.if = function () {return then([stages]).apply(this, arguments);}
	
	    function isEscaped(str, index) {
	      if (options.escape === undefined) {
	        return false;
	      }
	      let count = -1;
	      let firstIndex, secondIndex;
	      do {
	        count += 1;
	        firstIndex = index - (options.escape.length * (count + 1));
	        secondIndex = options.escape.length;
	      } while (str.substr(firstIndex, secondIndex) === options.escape);
	      return count % 2 == 0;
	    }
	
	    function foundCall(onFind, sub) {
	      if ((typeof notify) === 'function') {
	        notify(this);
	      }
	      if ((typeof onFind) === 'function') {
	        return onFind(sub);
	      } else {
	        return sub;
	      }
	    }
	
	    this.find = function (str, index) {
	      let startedThisCall = false;
	      let needle = options.closing;
	      let starting = false;
	      if (start === undefined) {
	        needle = options.opening;
	        starting = true;
	      }
	      const sub = str.substr(index);
	      let needleLength;
	      if (needle instanceof RegExp) {
	        const match = sub.match(needle);
	        if (match && match.index === 0) {
	          needleLength = match[0].length;
	        }
	      } else if ((typeof needle) === 'string') {
	        if (sub.indexOf(needle) === 0 && !isEscaped(str, index))
	          needleLength = needle.length;
	      } else if (needle === undefined || needle === null) {
	        needleLength = 0;
	      } else {
	        throw new Error('Opening or closing type not supported. Needs to be a RegExp or a string');
	      }
	      needleLength += options.tailOffset ? options.tailOffset : 0;
	      let changes = '';
	      if (start === undefined && starting && (needleLength || needle === null)) {
	        string = str;
	        start = index;
	        startedThisCall = true;
	        if (needle === null) {
	          if ((typeof notify) === 'function') {
	            notify(this);
	          }          return {index, changes}
	        } else {
	          changes += foundCall.apply(this, [options.onOpen, str.substr(start, needleLength)]);
	        }
	      }
	      if ((!startedThisCall && needleLength) ||
	            (startedThisCall && options.closing === undefined) ||
	            (!startedThisCall && options.closing === null)) {
	        if (str !== string) {
	          throw new Error ('Trying to apply an expression to two different strings.');
	        }
	        end = index + needleLength;
	        if (options.closing === null) {
	          return {index, changes}
	        }
	        if (!startedThisCall) {
	          changes += foundCall.apply(this, [options.onClose, str.substr(end - needleLength, needleLength)]);
	        }
	        return { index: end, changes };
	      }
	
	      return start !== undefined ? { index: start + needleLength, changes } :
	                      { index: -1, changes };
	    }
	
	    this.clone = function (notify) {
	      return new ExprDef(name, options, notify, stages, alwaysPossible);
	    };
	    this.name = this.getName();
	    this.canEnd = function () {return (currStage._meta && currStage._meta.end) || options.closing === null};
	    this.endDefined = function () {return options.closing !== undefined && options.closing !== null};
	    this.location = function () {return {start, end, length: end - start}};
	    this.closed = function () {return end !== undefined;}
	    this.open = function () {return start !== undefined;}
	    this.next =  function () {
	      const expressions = [];
	      if (currStage._meta && currStage._meta.repeat) {
	        currStage = stages;
	      }
	      Object.values(currStage).map(
	        function (val) {if (val._meta) expressions.push(val._meta.expr);}
	      )
	      return alwaysPossible.concat(expressions);
	    };
	  }
	}
	
	function parse(exprDef, str) {
	  exprDef = exprDef.clone();
	  let index = 0;
	  let modified = '';
	  const breakDown = [];
	  const stack = [];
	
	  function topOfStack() {
	    return stack[stack.length - 1];
	  }
	
	  function closeCheck(exprDef) {
	    if (exprDef && (exprDef.canEnd() || exprDef.endDefined())) {
	      let result = exprDef.find(str, index);
	      if (result.index) {
	        modified += result.changes;
	        return result.index;
	      }
	    }
	  }
	
	  function checkArray(exprDef, array) {
	    if (exprDef.endDefined()) {
	      let nextIndex = closeCheck(exprDef);
	      if (nextIndex) return nextIndex;
	    }
	    for (let aIndex = 0; aIndex < array.length; aIndex += 1) {
	      const childExprDef = array[aIndex].clone(exprDef.getNotice);
	      const result = childExprDef.find(str, index);
	      if (result.index !== -1) {
	        modified += result.changes;
	        if (childExprDef.closed()) {
	          breakDown.push(childExprDef);
	        } else {
	          stack.push(childExprDef);
	        }
	        return result.index;
	      }
	    }
	    if (exprDef.canEnd()) {
	      nextIndex = closeCheck(exprDef);
	      if (nextIndex) return nextIndex;
	    }
	    throw new Error(`Invalid string @ index ${index}\n'${str.substr(0, index)}' ??? '${str.substr(index)}'`);
	  }
	
	  function open(exprDef, index) {
	    const always = exprDef.getAlways();
	    while (!exprDef.open()) {
	      let result = exprDef.find(str, index);
	      modified += result.changes;
	      if(result.index === -1) {
	        let newIndex = checkArray(exprDef, always);
	        index = newIndex;
	      } else {
	        if (exprDef.closed()) {
	          breakDown.push(exprDef);
	        } else {
	          stack.push(exprDef);
	        }
	        index = result.index;
	      }
	    }
	    return index;
	  }
	
	  let loopCount = 0;
	  index = open(exprDef, index);
	  progress = [-3, -2, -1];
	  while (topOfStack() !== undefined) {
	    const tos = topOfStack();
	    if (progress[0] === index) {
	      throw new Error(`ExprDef stopped making progress`);
	    }
	    let stackIds = '';
	    let options = '';
	    stack.map(function (value) {stackIds+=value.getName() + ','});
	    tos.next().map(function (value) {options+=value.getName() + ','})
	    index = checkArray(tos, tos.next());
	    if (tos.closed()) {
	      stack.pop();
	    }
	    loopCount++;
	  }
	  // if (index < str.length) {
	  //   throw new Error("String not fully read");
	  // }
	  return modified;
	}
	
	
	ExprDef.parse = parse;
	
	module.exports = ExprDef;
	
	
	
	
	
});


RequireJS.addFunction('./public/js/utils/utils.js',
function (require, exports, module) {
	Math.PI12 = Math.PI/2;
	Math.PI32 = 3*Math.PI/2;
	Math.PI2 = 2*Math.PI;
	
	Math.PI14 = Math.PI/4;
	Math.PI34 = 3*Math.PI/4;
	Math.PI54 = 5*Math.PI/4;
	Math.PI74 = 7*Math.PI/4;
	
	
	
	function safeStdLibAddition() {
	  const addition = [];
	  function verify() {
	    additions.forEach((a) => {
	      if ((a.static && a.lib[a.field] !== a.func) ||
	      (!a.static && a.lib.prototype[a.field] !== a.func))
	        throw new Error(`Functionality was overwritten -` +
	                          `\n\tLibrary: ${a.lib}` +
	                          `\n\tStatic: ${a.static}` +
	                          `\n\tField: ${a.field}`)
	    });
	    delete additions;
	  }
	  function safeAdd (lib, field, func, static) {
	    if (!static && lib.prototype[field] === undefined)
	      lib.prototype[field] = func;
	    else if (lib[field] === undefined)
	      lib[field] = func;
	    else
	      console.error(`Attempting to overwrite functionality -` +
	                        `\n\tLibrary: ${lib}` +
	                        `\n\tStatic: ${static}` +
	                        `\n\tField: ${field}`);
	    addition.push({lib, field, func, static})
	  }
	  safeAdd(Function, 'safeStdLibAddition', safeAdd);
	}
	safeStdLibAddition();
	
	Function.safeStdLibAddition(Object, 'map',   function (obj, func) {
	  if ((typeof func) !== 'function') return console.warn('Object.map requires a function argument');
	  const keys = Object.keys(obj);
	  const map = {};
	  for (let index = 0; index < keys.length; index++) {
	    const key = keys[index];
	    const value = obj[key];
	    map[key] = func(value, key);
	  }
	  return map;
	}, true);
	
	function processValue(value) {
	  let retVal;
	  if ((typeof value) === 'object' && value !== null) {
	    if ((typeof value.toJson) === 'function') {
	      retVal = value.toJson();
	    } else if ((typeof value.toJSON) === 'function') {
	      retVal = value.toJSON();
	    } else if (Array.isArray(value)){
	      const arr = [];
	      value.forEach((val) => {
	        if ((typeof val.toJson) === 'function') {
	          arr.push(val.toJson());
	        } else if ((typeof val.toJSON) === 'function') {
	          arr.push(val.toJSON());
	        } else {
	          arr.push(val);
	        }
	      });
	      retVal = arr;
	    } else {
	      const keys = Object.keys(value);
	      const obj = {};
	      for (let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        obj[key] = processValue(value[key]);
	      }
	      retVal = obj;
	    }
	  } else {
	    retVal = value;
	  }
	  return retVal;
	}
	
	Function.safeStdLibAddition(String, 'random',  function (len) {
	    len = len || 7;
	    let str = '';
	    while (str.length < len) str += Math.random().toString(36).substr(2);
	    return str.substr(0, len);
	}, true);
	
	const decimalRegStr = "((-|)(([0-9]{1,}\\.[0-9]{1,})|[0-9]{1,}(\\.|)|(\\.)[0-9]{1,}))";
	const decimalReg = new RegExp(`^${decimalRegStr}$`);
	Function.safeStdLibAddition(String, 'isNumber', function (len) {
	  return this.trim().match(decimalReg) !== null;
	});
	
	Function.safeStdLibAddition(String, 'number',  function (str) {
	  str = new String(str);
	  const match = str.match(/([0-9]).([0-9]{1,})e\+([0-9]{2,})/);
	  if (match) {
	    const zeros = Number.parseInt(match[3]) - match[2].length;
	    str = match[1] + match[2] + new Array(zeros).fill('0').join('');
	  }
	  return new String(str)
	      .split('').reverse().join(',')
	      .replace(/([0-9]),([0-9]),([0-9]),/g, '$1$2$3,')
	      .replace(/,([0-9]{1,2}),/g, ',$1')
	      .replace(/,([0-9]{1,2}),/g, ',$1')
	      .split('').reverse().join('')
	}, true);
	
	
	Function.safeStdLibAddition(Math, 'mod',  function (val, mod) {
	  while (val < 0) val += mod;
	  return val % mod;
	}, true);
	
	Function.safeStdLibAddition(Number, 'NaNfinity',  function (...vals) {
	  for (let index = 0; index < vals.length; index++) {
	    let val = vals[index];
	    if(Number.isNaN(val) || !Number.isFinite(val)) return true;
	  }
	  return false;
	}, true);
	
	function stringHash() {
	  let hashString = this;
	  let hash = 0;
	  for (let i = 0; i < hashString.length; i += 1) {
	    const character = hashString.charCodeAt(i);
	    hash = ((hash << 5) - hash) + character;
	    hash &= hash; // Convert to 32bit integer
	  }
	  return hash;
	}
	
	Function.safeStdLibAddition(String, 'hash',  stringHash, false);
	
	const LEFT = 1;
	const RIGHT = 0;
	Function.safeStdLibAddition(String, 'obscure',  function (count) {
	    const direction = count < 0 ? LEFT : RIGHT;
	    const test = (index) => direction === LEFT ? index > this.length + count - 1 : index < count;
	    let str = '';
	    for (let index = 0; index < this.length; index += 1) {
	      if (test(index)) {
	        str += '*';
	      } else {
	        str += this[index];
	      }
	    }
	    return str;
	});
	
	const singleCharReg = /([a-zA-Z]{1,})[^a-z^A-Z]{1,}([a-zA-Z])[^a-z^A-Z]{1,}([a-zA-Z]{1,})/;
	const specialCharReg = /([a-zA-Z])[^a-z^A-Z^0-9]{1,}([a-zA-Z])/g;
	const charNumberReg = /([a-zA-Z])([0-9])/
	function singleCharReplace(whoCares, one, two, three) {
	  const oneLastChar = one[one.length - 1];
	  const twoLower = oneLastChar !== oneLastChar.toLowerCase();
	  const twoStr = twoLower ? two.toLowerCase() : two.toUpperCase();
	  const threeStr = twoLower ? `${three[0].toUpperCase()}${three.substr(1)}` :
	                                `${three[0].toLowerCase()}${three.substr(1)}`;
	  return `${one}${twoStr}${threeStr}`;
	}
	function camelReplace(whoCares, one, two) {return `${one}${two.toUpperCase ? two.toUpperCase() : two}`;}
	function toCamel() {
	  let string = `${this.substr(0,1).toLowerCase()}${this.substr(1)}`.replace(charNumberReg, camelReplace);
	  while (string.match(singleCharReg)) string = string.replace(singleCharReg, singleCharReplace);
	  return string.replace(specialCharReg, camelReplace);
	}
	Function.safeStdLibAddition(String, 'toCamel',  toCamel);
	
	const multipleUpperReg = /([A-Z]{2,})([a-z])/g;
	const caseChangeReg = /([a-z])([A-Z])/g;
	function pascalReplace(whoCares, one, two) {return `${one.toLowerCase()}_${two.toUpperCase ? two.toUpperCase() : two}`;}
	function toPascal() {
	  let string = this;
	  return string.replace(multipleUpperReg, pascalReplace)
	                .replace(caseChangeReg, pascalReplace)
	                .replace(charNumberReg, pascalReplace)
	                .replace(specialCharReg, pascalReplace);
	}
	Function.safeStdLibAddition(String, 'toPascal',  toPascal);
	
	function toKebab() {
	  return this.toPascal().toLowerCase().replace(/_/g, '-');
	}
	Function.safeStdLibAddition(String, 'toKebab',  toKebab);
	
	Function.safeStdLibAddition(String, 'toSnake',  function () {return this.toKebab().replace(/-/g, '_')});
	Function.safeStdLibAddition(String, 'toDot',  function () {return this.toKebab().replace(/-/g, '.')});
	Function.safeStdLibAddition(String, 'toScreamingDot',  function () {return this.toKebab().replace(/-/g, '.')});
	Function.safeStdLibAddition(String, 'toScreamingSnake',  function () {return this.toSnakeCase().toUpperCase()});
	Function.safeStdLibAddition(String, 'toScreamingKebab',  function () {return this.toKebab().toUpperCase()});
	Function.safeStdLibAddition(String, 'toSentance',  function () {return this.toPascal().replace(/_/g, ' ')});
	
	Function.safeStdLibAddition(Function, 'orVal',  function (funcOrVal, ...args) {
	  return (typeof funcOrVal) === 'function' ? funcOrVal(...args) : funcOrVal;
	}, true);
	
	const classLookup = {};
	const attrMap = {};
	const identifierAttr = '_TYPE';
	const immutableAttr = '_IMMUTABLE';
	const temporaryAttr = '_TEMPORARY';
	const doNotOverwriteAttr = '_DO_NOT_OVERWRITE';
	
	const clazz = {};
	clazz.object = () => JSON.clone(classLookup);
	clazz.register = (clazz) => classLookup[clazz.name] = clazz;
	clazz.get = (name) => classLookup[name];
	clazz.filter = (filterFunc) => {
	  const classes = clazz.object();
	  if ((typeof filterFunc) !== 'function') return classes;
	  const classIds = Object.keys(classes);
	  const obj = {};
	  for (let index = 0; index < classIds.length; index += 1) {
	    const id = classIds[index];
	    if (filterFunc(classes[id])) obj[id] = classes[id];
	  }
	  return obj;
	}
	
	function objEq(obj1, obj2) {
	  if (!(obj1 instanceof Object)) return false;
	  if (!(obj2 instanceof Object)) return false;
	  const obj1Keys = Object.keys(obj1);
	  const obj2Keys = Object.keys(obj2);
	  if (obj1Keys.length !== obj2Keys.length) return false;
	  obj1Keys.sort();
	  obj2Keys.sort();
	  for (let index = 0; index < obj1Keys.length; index += 1) {
	    const obj1Key = obj1Keys[index];
	    const obj2Key = obj2Keys[index];
	    if (obj1Key !== obj2Key) return false;
	    const obj1Val = obj1[obj1Key];
	    const obj2Val = obj2[obj2Key];
	    if (obj1Val instanceof Object) {
	      if (!obj1Val.equals(obj2)) return false;
	    } else if (obj1[obj1Key] !== obj2[obj2Key]) return false;
	  }
	  return true;
	}
	
	Function.safeStdLibAddition(Object, 'merge', (target, object, soft) => {
	  if (!(target instanceof Object)) return;
	  if (!(object instanceof Object)) return;
	  const objKeys = Object.keys(object);
	  for (let index = 0; index < objKeys.length; index++) {
	    const key = objKeys[index];
	    if (!soft || target[key] === undefined) {
	      target[key] = object[key];
	    }
	  }
	}, true);
	
	Function.safeStdLibAddition(Object, 'forAllRecursive', (object, func) => {
	  if (!(object instanceof Object)) return;
	  if ((typeof func) !== 'function') return;
	  const target = Array.isArray(object) ? [] :{};
	  const objKeys = Object.keys(object);
	  for (let index = 0; index < objKeys.length; index++) {
	    const key = objKeys[index];
	    if (object[key] instanceof Object) {
	      target[key] = Object.forAllRecursive(object[key], func);
	    } else target[key] = func(object[key], key, object);
	  }
	  return target;
	}, true);
	
	Function.safeStdLibAddition(Object, 'class', clazz, true);
	Function.safeStdLibAddition(Object, 'equals', objEq, true);
	
	
	Function.safeStdLibAddition(Math, 'toDegrees', function (rads) {
	  return Math.round(1000 * Math.mod(rads * 180/Math.PI, 360)) / 1000;
	}, true);
	
	Function.safeStdLibAddition(Object, 'forEachConditional', function (obj, func, conditionFunc, modifyObject) {
	  if (!modifyObject) obj = JSON.clone(obj);
	  conditionFunc = (typeof conditionFunc) === 'function' ? conditionFunc : () => true;
	  const keys = Object.keys(obj);
	  for (let index = 0; index < keys.length; index++) {
	    const key = keys[index];
	    const value = obj[key];
	    if (conditionFunc(value)) func(value, key, obj);
	    if (value instanceof Object) Object.forEachConditional(value, func, conditionFunc, true);
	  }
	  return obj;
	}, true);
	
	Function.safeStdLibAddition(Math, 'toRadians', function (angle, accuracy) {
	  return (angle*Math.PI/180)%(2*Math.PI);
	}, true);
	
	Function.safeStdLibAddition(Math, 'midpoint', function (s, e) {
	  if (e < s) {
	    let t = s;
	    s = e;
	    e = t;
	  }
	  return s + (e - s)/2;
	}, true);
	
	// Ripped off of: https://stackoverflow.com/a/2450976
	Function.safeStdLibAddition(Array, 'shuffle', function() {
	  let currentIndex = this.length,  randomIndex;
	  while (currentIndex != 0) {
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex--;
	    [this[currentIndex], this[randomIndex]] = [
	      this[randomIndex], this[currentIndex]];
	  }
	
	  return this;
	});
	
	Function.safeStdLibAddition(Array, 'count', function(func) {
	  let count = 0;
	  for (let index = 0; index < this.length; index++) {
	    const retVal = func(this[index]);
	    count += (typeof retVal) === 'number' ? retVal : (retVal ? 1 : 0);
	  }
	  return count;
	});
	
	
	const primes = [3,5,7,11,17,19,23,29];
	const firstNotInList = (targetList, ignoreList) => {
	  for (let index = 0; index < targetList.length; index++) {
	    if (ignoreList.indexOf(targetList[index]) === -1) return {item: targetList[index], index};
	  }
	  return null;
	}
	Function.safeStdLibAddition(Array, 'systematicSuffle', function (numberOfSuffles, doNotShufflePrimes) {
	  // const ps = primes;
	  const ps = [];
	  ps.copy(primes);
	  // if (!doNotShufflePrimes) ps.systematicSuffle(numberOfSuffles, true);
	  const map = {};
	  let primeCount = 0;
	  let loops = 0;
	  const lastSeven = [];
	  for (let index = 0; index < numberOfSuffles; index++) {
	    let prime = ps[primeCount % ps.length];
	    if (lastSeven.indexOf(prime) !== -1) {
	      const info = firstNotInList(ps, lastSeven);
	      prime = info.item;
	      primeCount = info.index;
	    }
	    lastSeven[index % 7] = prime;
	    primeCount += prime + (prime * (ps[(primeCount + loops++) % ps.length])) % ps.length;
	    let shuffleIndex = 0;
	    while (shuffleIndex < this.length) {
	      const firstPart = this.slice(0, shuffleIndex)
	      const secondPart = this.slice(shuffleIndex, (shuffleIndex = shuffleIndex + prime));
	      const thirdPart = this.slice(shuffleIndex)
	      this.copy(secondPart.concat(firstPart.concat(thirdPart)));
	      // if (primeCount < shuffleIndex) this.reverse();
	    }
	    // console.log(this.join());
	    map[this.join().hash()] = true;
	  }
	  return Object.keys(map).length;
	});
	
	
	Function.safeStdLibAddition(Array, 'reorder', function () {
	  let count = 2;
	  let currentIndex = this.length,  randomIndex;
	  while (currentIndex != 0) {
	    randomIndex = (currentIndex * count++) % currentIndex;
	    currentIndex--;
	    [this[currentIndex], this[randomIndex]] = [
	      this[randomIndex], this[currentIndex]];
	  }
	});
	
	Function.safeStdLibAddition(Array, 'toJson', function (arr) {
	    const json = [];
	    arr.forEach((elem) => json.push(processValue(elem)));
	    return json;
	}, true);
	
	Function.safeStdLibAddition(Array, 'equalIndexOf', function (elem, startIndex, endIndex) {
	    startIndex =  startIndex > -1 ? startIndex : 0;
	    endIndex = endIndex < this.length ? endIndex : this.length;
	    for (let index = startIndex; index < endIndex; index += 1) {
	      if (elem && (typeof elem.equals) === 'function' && elem.equals(this[index])) {
	        return index;
	      } else if (elem === this[index]) {
	        return index;
	      }
	    }
	    return -1;
	});
	
	Function.safeStdLibAddition(Array, 'equals', function (other, startIndex, endIndex) {
	    startIndex =  startIndex > -1 ? startIndex : 0;
	    endIndex = endIndex < this.length ? endIndex : this.length;
	    if (endIndex < other.length) return false;
	    let equal = true;
	    for (let index = startIndex; equal && index < endIndex; index += 1) {
	      const elem = this[index];
	      if (elem && (typeof elem.equals) === 'function') {
	        if (!elem.equals(other[index])) {
	          return index;
	        }
	      } else if (elem !== other[index]) {
	        equal = false;
	      }
	    }
	    return equal;
	});
	
	Function.safeStdLibAddition(Array, 'removeAll', function (arr) {
	  for (let index = 0; index < arr.length; index += 1) {
	    this.remove(arr[index]);
	  }
	});
	
	Function.safeStdLibAddition(Array, 'condition', function (initalValue, conditionFunc) {
	  const valueFuncDefined = (typeof valueFunc) === 'function';
	  for (let index = 0; index < this.length; index += 1) {
	    const elem = this[index];
	    initalValue = conditionFunc(initalValue, elem);
	  }
	  return initalValue;
	});
	
	Function.safeStdLibAddition(Array, 'max', function (max, func) {
	  const funcDefined = (typeof func) === 'function';
	  const initalValue = max || max === 0 ? {elem: max, value: funcDefined ? func(max) : max} : undefined;
	  return this.condition(initalValue, (max, elem) => {
	    let value = funcDefined ? func(elem, index) : elem;
	    if (!(max instanceof Object) || value > max.value) return {value, elem};
	    return max
	  }).elem;
	});
	
	Function.safeStdLibAddition(Array, 'min', function (min, func) {
	  const funcDefined = (typeof func) === 'function';
	  const initalValue = min || min === 0 ? {elem: min, value: funcDefined ? func(min) : min} : undefined;
	  return this.condition(initalValue, (min, elem) => {
	    let value = funcDefined ? func(elem, index) : elem;
	    if (!(min instanceof Object) || value < min.value) return {value, elem};
	    return min
	  }).elem;
	});
	
	Function.safeStdLibAddition(Array, 'print', function (min, func) {
	  const maxLength = new String(this.length).length;
	  for (let index = 0; index < this.length; index++) {
	    const elem = this[index];
	    const length = new String(index).length;
	    const position = new Array(maxLength - length).fill(' ').join('') + index + ':';
	    console.log(position, elem && elem.toString ? elem.toString() : elem);
	  }
	});
	
	Function.safeStdLibAddition(Array, 'exists', function (array, obj) {
	  if (!Array.isArray(array)) return false;
	  for (let index = 0; index < array.length; index += 1) {
	    if (array[index] === obj) return true;
	  }
	  return false;
	}, true);
	
	Function.safeStdLibAddition(Array, 'remove', function (elem) {
	    for (let index = 0; index < this.length; index += 1) {
	      if (elem && (typeof elem.equals) === 'function' && elem.equals(this[index])) {
	        this.splice(index--, 1);
	      } else if (elem === this[index]) {
	        this.splice(index--, 1);
	      }
	    }
	});
	
	Function.safeStdLibAddition(Array, 'compare', function (original, neww, modify) {
	    const comparison = {both: [], removed: [], added: []};
	    const arr = original.concat(neww);
	    const visited = {new: {}, original: {}};
	    arr.forEach((elem) => {
	      const origIndex = original.equalIndexOf(elem);
	      const newIndex = neww.equalIndexOf(elem);
	      if (!visited.new[newIndex] && !visited.original[origIndex]) {
	        if (newIndex !== -1) visited.new[newIndex] = true;
	        if (origIndex !== -1) visited.original[origIndex] = true;
	        if (origIndex !== -1 && newIndex !== -1) comparison.both.push(elem);
	        else if (newIndex !== -1) comparison.added.push(elem);
	        else comparison.removed.push({elem, index: origIndex});
	      }
	    });
	
	    if (modify) {
	      if (comparison.removed.length > 0) {
	        let removed = 0;
	        comparison.removed.forEach((info) => original.splice(info.index - removed++, 1));
	        comparison.removed = comparison.removed.map((info) => info.elem);
	      }
	      if (comparison.added.length > 0) {
	        original.concatInPlace(neww);
	      }
	    }
	    return comparison.removed.length > 0 || comparison.added.length > 0 ? comparison : false;
	}, true);
	
	Function.safeStdLibAddition(Array, 'concatInPlace', function (arr, checkForDuplicats) {
	  if (arr === this) return;
	  for (let index = 0; index < arr.length; index += 1) {
	    if (checkForDuplicats && this.indexOf(arr[index]) !== -1) {
	      console.error('duplicate');
	    } else {
	      this[this.length] = arr[index];
	    }
	  }
	});
	
	function sortByAttr(attr) {
	  function sort(obj1, obj2) {
	    const val1 = Object.pathValue(obj1, attr);
	    const val2 = Object.pathValue(obj2, attr);
	    if (val2 === val1) {
	      return 0;
	    }
	    return val1 > val2 ? 1 : -1;
	  }
	  return sort;
	}
	
	const nativeSort = Array.sort;
	Function.safeStdLibAddition(Array, 'sortByAttr', function(stringOfunc) {
	  if ((typeof stringOfunc) === 'string')
	    return this.sort.apply(this, [sortByAttr(stringOfunc)]);
	  return this.sort.apply(this, arguments);
	});
	
	Function.safeStdLibAddition(Array, 'copy', function (arr) {
	  this.length = 0;
	  // const keys = Object.keys(this);
	  // for (let index = 0; index < keys.length; index += 1) delete this[keys[index]];
	  const newKeys = Object.keys(arr);
	  for (let index = 0; index < newKeys.length; index += 1) {
	    const key = newKeys[index];
	    this[key] = arr[key];
	  }
	  return this;
	});
	
	Function.safeStdLibAddition(Object, 'fromJson', function (rootJson) {
	  function interpretValue(value) {
	    if (value instanceof Object) {
	      const classname = value[identifierAttr];
	      const attrs = attrMap[classname] ? Object.keys(attrMap[classname]) :
	                    Object.keys(value).filter((attr) => !attr.match(/^_[A-Z]*[A-Z_]*$/));
	      if (Array.isArray(value)) {
	        const realArray = [];
	        for (let index = 0; index < value.length; index += 1) {
	          realArray[index] = Object.fromJson(value[index]);
	        }
	        return realArray;
	      } else if (classname && classLookup[classname]) {
	        if (classLookup[classname].fromJson) {
	          return classLookup[classname].fromJson(value);
	        } else {
	          const classObj = new (classLookup[classname])(value);
	          for (let index = 0; index < attrs.length; index += 1) {
	            const attr = attrs[index];
	            if ((typeof classObj[attr]) === 'function')
	            classObj[attr](interpretValue(value[attr]));
	            else
	            classObj[attr] = interpretValue(value[attr]);
	          };
	          return classObj;
	        }
	      } else {
	        if (classname) {
	          console.warn(`fromJson for class ${classname} not registered`)
	        }
	        const realObj = {}
	        for (let index = 0; index < attrs.length; index += 1) {
	          const attr = attrs[index];
	          realObj[attr] = interpretValue(value[attr]);
	        };
	        return realObj
	      }
	    }
	    return value;
	  }
	
	  if (!(rootJson instanceof Object)) return rootJson;
	  return interpretValue(rootJson);
	}, true);
	
	Function.safeStdLibAddition(Object, 'getSet',   function (obj, initialVals, ...attrs) {
	  const cxtrName = obj.constructor.name;
	  if (classLookup[cxtrName] === undefined) {
	    classLookup[cxtrName] = obj.constructor;
	  } else if (classLookup[cxtrName] !== obj.constructor) {
	    console.warn(`Object.fromJson will not work for the following class due to name conflict\n\taffected class: ${obj.constructor}\n\taready registered: ${classLookup[cxtrName]}`);
	  }
	  if (initialVals === undefined) return;
	  if (!(obj instanceof Object)) throw new Error('arg0 must be an instace of an Object');
	  let values = {};
	  let temporary = false;
	  let immutable = false;
	  let doNotOverwrite = false;
	  if ((typeof initialVals) === 'object') {
	    values = initialVals;
	    immutable = values[immutableAttr] === true;
	    temporary = values[temporaryAttr] === true;
	    doNotOverwrite = values[doNotOverwriteAttr] === true;
	    if (immutable) {
	      attrs = Object.keys(values);
	    } else {
	      attrs = Object.keys(values).concat(attrs);
	    }
	  } else {
	    attrs = [initialVals].concat(attrs);
	  }
	  if (attrMap[cxtrName] === undefined) attrMap[cxtrName] = [];
	  attrs.forEach((attr) => {
	    if (!attr.match(/^_[A-Z]*[A-Z_]*$/))
	      attrMap[cxtrName][attr] = true;
	  });
	
	  for (let index = 0; !doNotOverwrite && index < attrs.length; index += 1) {
	    const attr = attrs[index];
	    if (attr !== immutableAttr) {
	      if (immutable) obj[attr] = () => values[attr];
	      else {
	        obj[attr] = (value) => {
	          if (value === undefined) {
	            const noDefaults = (typeof obj.defaultGetterValue) !== 'function';
	            if (values[attr] !== undefined || noDefaults)
	            return values[attr];
	            return obj.defaultGetterValue(attr);
	          }
	          return values[attr] = value;
	        }
	      }
	    }
	  }
	  if (!temporary) {
	    const origToJson = obj.toJson;
	    obj.toJson = (members, exclusive) => {
	      try {
	        const restrictions = Array.isArray(members) && members.length;
	        const json = (typeof origToJson === 'function') ? origToJson() : {};
	        json[identifierAttr] = obj.constructor.name;
	        for (let index = 0; index < attrs.length; index += 1) {
	          const attr = attrs[index];
	          const inclusiveAndValid = restrictions && !exclusive && members.indexOf(attr) !== -1;
	          const exclusiveAndValid = restrictions && exclusive && members.indexOf(attr) === -1;
	          if (attr !== immutableAttr && (!restrictions || inclusiveAndValid || exclusiveAndValid)) {
	            // if (obj.constructor.name === 'SnapLocation2D')
	            //   console.log('foundit!');
	            const value = (typeof obj[attr]) === 'function' ? obj[attr]() : obj[attr];
	            json[attr] = processValue(value);
	          }
	        }
	        return json;
	      } catch(e) {
	        console.warn(e.message);
	        return e.message;
	      }
	    }
	  }
	  obj.fromJson = (json) => {
	    for (let index = 0; index < attrs.length; index += 1) {
	      const attr = attrs[index];
	      if (attr !== immutableAttr) {
	        if ((typeof obj[attr]) === 'function') {
	          if(Array.isArray(obj[attr]())){
	            obj[attr]().copy(Object.fromJson(json[attr]));
	          } else {
	            obj[attr](Object.fromJson(json[attr]));
	          }
	        }
	        else
	          obj[attr] = Object.fromJson(json[attr]);
	      }
	    };
	    return obj;
	  }
	  if (obj.constructor.DO_NOT_CLONE) {
	    obj.clone = () => obj;
	  } else {
	    obj.clone = () => {
	      const clone = new obj.constructor(obj.toJson());
	      clone.fromJson(obj.toJson());
	      return clone;
	    }
	  }
	  return attrs;
	}, true);
	Object.getSet.format = 'Object.getSet(obj, {initialValues:optional}, attributes...)'
	
	Function.safeStdLibAddition(Object, 'set',   function (obj, otherObj) {
	  if (otherObj === undefined) return;
	  if ((typeof otherObj) !== 'object') {
	    throw new Error('Requires one argument of type object or undefined for meaningless call');
	  }
	  const keys = Object.keys(otherObj);
	  keys.forEach((key) => obj[key] = otherObj[key]);
	}, true);
	
	Function.safeStdLibAddition(Array, 'set',   function (array, values, start, end) {
	  if (start!== undefined && end !== undefined && start > end) {
	    const temp = start;
	    start = end;
	    end = temp;
	  }
	  start = start || 0;
	  end = end || values.length;
	  for (let index = start; index < end; index += 1)
	    array[index] = values[index];
	  return array;
	}, true);
	
	const checked = {};
	
	// Swiped from https://stackoverflow.com/a/43197340
	function isClass(obj) {
	  const isCtorClass = obj.constructor
	      && obj.constructor.toString().substring(0, 5) === 'class'
	  if(obj.prototype === undefined) {
	    return isCtorClass
	  }
	  const isPrototypeCtorClass = obj.prototype.constructor
	    && obj.prototype.constructor.toString
	    && obj.prototype.constructor.toString().substring(0, 5) === 'class'
	  return isCtorClass || isPrototypeCtorClass
	}
	
	Function.safeStdLibAddition(JSON, 'clone',   function  (obj) {
	  if ((typeof obj) != 'object') return obj;
	  const keys = Object.keys(obj);
	  if (!checked[obj.constructor.name]) {
	    // console.log('constructor: ' + obj.constructor.name);
	    checked[obj.constructor.name] = true;
	  }
	
	  const clone = ((typeof obj.clone) === 'function') ? obj.clone() :
	                  Array.isArray(obj) ? [] : {};
	  for(let index = 0; index < keys.length; index += 1) {
	    const key = keys[index];
	    const member = obj[key];
	    if (member && (member.DO_NOT_CLONE || member.constructor.DO_NOT_CLONE)) {
	      clone[key] = member;
	    } else if ((typeof member) !== 'function') {
	      if ((typeof member) === 'object') {
	        if ((typeof member.clone) === 'function') {
	          clone[key] = member.clone();
	        } else {
	          clone[key] = JSON.clone(member);
	        }
	      } else {
	        clone[key] = member;
	      }
	    }
	    else if (isClass(member)) {
	      clone[key] = member;
	    }
	  }
	  return clone;
	}, true);
	
	Function.safeStdLibAddition(JSON, 'copy',   function  (obj) {
	  if (!(obj instanceof Object)) return obj;
	  return JSON.parse(JSON.stringify(obj));
	}, true);
	
	const defaultInterval = 1000;
	const lastTimeStamps = {};
	function intervalFunction() {
	  const caller = intervalFunction.caller;
	  let interval = arguments[0];
	  if (!Number.isFinite(interval) || interval > 60000) interval = defaultInterval;
	  else {
	    arguments = Array.from(arguments)
	    arguments.splice(0,1);
	  }
	  const lastTime = lastTimeStamps[caller];
	  const thisTime = new Date().getTime();
	  if (lastTime === undefined || lastTime + interval < thisTime) this(...arguments);
	  lastTimeStamps[caller] = thisTime;
	}
	Function.safeStdLibAddition(Function, 'subtle',   intervalFunction);
	
	Function.safeStdLibAddition(String, 'parseSeperator',   function (seperator, isRegex) {
	  if (isRegex !== true) {
	    seperator = seperator.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&');
	  }
	  var keyValues = this.match(new RegExp('.*?=.*?(' + seperator + '|$)', 'g'));
	  var json = {};
	  for (let index = 0; keyValues && index < keyValues.length; index += 1) {
	    var split = keyValues[index].match(new RegExp('\\s*(.*?)\\s*=\\s*(.*?)\\s*(' + seperator + '|$)'));
	    if (split) {
	      json[split[1]] = split[2];
	    }
	  }
	  return json;
	});
	
	const colors = [
	  'indianred', 'gray', 'fuchsia', 'lime', 'black', 'lightsalmon', 'red',
	  'maroon', 'yellow', 'olive', 'lightcoral', 'green', 'aqua', 'white',
	  'teal', 'darksalmon', 'blue', 'navy', 'salmon', 'silver', 'purple'
	];
	let colorIndex = 0;
	Function.safeStdLibAddition(String, 'nextColor', () => colors[index++ % colors.length], true);
	
	Function.safeStdLibAddition(Object, 'pathValue', function (obj, path, value) {
	  const attrs = path.split('.');
	  const lastIndex = attrs.length - 1;
	  let currObj = obj;
	  for (let index = 0; index < lastIndex; index += 1) {
	    let attr = attrs[index];
	    if (currObj[attr] === undefined) currObj[attr] = {};
	    currObj = (typeof currObj[attr]) === 'function' ? currObj[attr]() : currObj[attr];
	  }
	
	  const lastAttr = attrs[lastIndex];
	  if ((typeof currObj[lastAttr]) === 'function') {
	    return currObj[lastAttr](value);
	  } else if (value !== undefined) {
	    currObj[lastAttr] = value;
	  }
	  return currObj[lastAttr];
	}, true);
	
	
	/////////////////////////////////// Matrix Equations //////////////////////////
	
	Function.safeStdLibAddition(Array, 'translate', function (vector, doNotModify, quiet) {
	  let point = this;
	  let single = false;
	  if (doNotModify === true) point = Array.from(point);
	  const vecLen = vector.length;
	  if (point.length !== vecLen && !quiet) console.warn('vector.length !== point.length but we\' do it anyway (arg3(quiet) = true to silence)');
	  for (let i = 0; i < vecLen; i += 1) {
	    if (point[i] === undefined) point[i] = 0;
	    point[i] += vector[i];
	  }
	  return point;
	});
	
	Function.safeStdLibAddition(Array, 'inverse', function (doNotModify) {
	  const arr = doNotModify === true ? Array.from(this) : this;
	  for (let index = 0; index < arr.length; index += 1) {
	    arr[index] *= -1;
	  }
	  return arr;
	});
	
	Function.safeStdLibAddition(Array, 'remap', function (func) {
	  for (let index = 0; index < this.length; index += 1) {
	    this[index] = func(this[index], index);
	  }
	});
	
	Function.safeStdLibAddition(Array, 'swap', function (i, j, doNotModify) {
	  const arr = doNotModify === true ? Array.from(this) : this;
	  const temp = arr[i];
	  arr[i] = arr[j];
	  arr[j] = temp;
	});
	
	Function.safeStdLibAddition(Array, 'scale', function (valueOfuncOarray, doNotModify) {
	  const arr = doNotModify === true ? Array.from(this) : this;
	  let func;
	  switch (typeof valueOfuncOarray) {
	    case 'function': func = (val, index) => val * valueOfuncOarray(val, index); break;
	    case 'object': func = (val, index) => val * valueOfuncOarray[index]; break;
	    default: func = (val, index) => val * valueOfuncOarray;
	  }
	  arr.remap(func);
	  return arr;
	});
	
	Function.safeStdLibAddition(Array, 'add', function (valueOfuncOarray, doNotModify) {
	  const arr = doNotModify === true ? Array.from(this) : this;
	  let func;
	  switch (typeof valueOfuncOarray) {
	    case 'function': func = (val, index) => val + valueOfuncOarray(val, index); break;
	    case 'object': func = (val, index) => val + valueOfuncOarray[index]; break;
	    default: func = (val, index) => val + valueOfuncOarray;
	  }
	  arr.remap(func);
	  return arr;
	});
	
	const MSI = Number.MAX_SAFE_INTEGER;
	const msi = Number.MIN_SAFE_INTEGER;
	Function.safeStdLibAddition(Math, 'minMax', function (items, targetAttrs) {
	  let min,max, total;
	  if (!targetAttrs) {
	    max = msi;
	    min = MSI;
	    total = 0;
	  }
	  const maxMinObject = {};
	  for (let index = 0; index < items.length; index++) {
	    const item = items[index];
	    if (max !== undefined) {
	      if (max < item) max = item;
	      if (min > item) min = item;
	      total += item;
	    } else {
	      const attrs = Array.isArray(targetAttrs) ? targetAttrs : Object.keys(targetAttrs);
	      for (let tIndex = 0; tIndex < attrs.length; tIndex++) {
	        const attr = attrs[tIndex];
	        const value = Object.pathValue(item, attr);
	        const key = targetAttrs[attr] === undefined ? attr : targetAttrs[attr];
	        if (!maxMinObject[key]) maxMinObject[key] = {max: msi, min: MSI, total: 0};
	        if (maxMinObject[key].max < value) maxMinObject[key].max = value;
	        if (maxMinObject[key].min > value) maxMinObject[key].min = value;
	        maxMinObject[key].total += value;
	      }
	    }
	  }
	  if (max !== undefined) return {max, min, total};
	  return maxMinObject;
	}, true);
	
	Function.safeStdLibAddition(Math, 'midrange', function (items, targetAttrs) {
	  const maxMin = Math.minMax(items, targetAttrs);
	  if (!targetAttrs) {
	    return (maxMin.max + maxMin.min)/2;
	  }
	  const midRangeObject = {};
	  const attrs = Array.isArray(targetAttrs) ? targetAttrs : Object.keys(targetAttrs);
	  for (let tIndex = 0; tIndex < attrs.length; tIndex++) {
	    const attr = attrs[tIndex];
	    const key = targetAttrs[attr] === undefined ? attr : targetAttrs[attr];
	    midRangeObject[key] = (maxMin[key].max + maxMin[key].min)/2;
	  }
	  return midRangeObject;
	}, true);
	
	Function.safeStdLibAddition(Math, 'mean', function (items, targetAttrs) {
	  const maxMin = Math.minMax(items, targetAttrs);
	  if (!targetAttrs) {
	    return maxMin.total / items.length;
	  }
	  const meanObject = {};
	  const attrs = Array.isArray(targetAttrs) ? targetAttrs : Object.keys(targetAttrs);
	  for (let tIndex = 0; tIndex < attrs.length; tIndex++) {
	    const attr = attrs[tIndex];
	    const key = targetAttrs[attr] === undefined ? attr : targetAttrs[attr];
	    meanObject[key] = maxMin[key].total/items.length;
	  }
	  return meanObject;
	}, true);
	
});


RequireJS.addFunction('./public/js/utils/tolerance.js',
function (require, exports, module) {
	
const DEFAULT_TOLERANCE = .0001;
	
	function round(val) {
	  return Math.round(1000000000000 * val)/1000000000000
	}
	
	function decimalLimit(value, limit) {
	  return (new String(value)).replace(/([0-9]{1,})(.[0-9]{1,}|)/, '$2').length > limit;
	}
	
	function rangeStr(lower, upper) {
	  return `${round(lower)} => ${round(upper)}`;
	}
	
	function boundsFunc(attr, attributeMap, tolerance) {
	  const singleValue = attr === undefined;
	  return (elem) => {
	    const tol = singleValue ? tolerance : attributeMap[attr];
	    const value = singleValue ? elem : Object.pathValue(elem, attr);
	    let lower, upper, center;
	    if (Number.NaNfinity(value)) return {lower: value, upper: value, id: rangeStr(value, value)};
	    else {
	      const mod = value % tol;
	      const center = mod > tol/2 ? value + (tol - mod) : value - mod;
	      lower = round(center - tol);
	      upper = round(center + tol);
	      if (lower>upper) {const temp = lower; lower = upper; upper = temp;}
	      const prevId = rangeStr(lower - tol, center);
	      const id = rangeStr(lower, upper);
	      const nextId = rangeStr(center, upper + tol);
	      if (decimalLimit(lower, 10) || decimalLimit(upper, 10))
	        console.warn.subtle(`Bounding limits may be incorrect: ${id}`);
	      return {lower, upper, prevId, id, nextId};
	    }
	  }
	}
	
	function withinBounds(attr, attributeMap, tolerance) {
	  const singleValue = attr === undefined;
	  return (value1, value2) => {
	    if (value1 === value2) return true;
	    const tol = singleValue ? tolerance : attributeMap[attr];
	    return Math.abs(value1 - value2) < tol;
	  }
	}
	
	class Tolerance {
	  constructor(attributeMap, tolerance) {
	    attributeMap ||= {};
	    let within, bounds;
	    const attrs = Object.keys(attributeMap);
	    const singleValue = attrs.length === 0;
	    this.bounds = {};
	    if (!singleValue)
	      this.attributes = () => attrs;
	    else {
	      tolerance ||= DEFAULT_TOLERANCE;
	      bounds = boundsFunc();
	      within = withinBounds(undefined, undefined, tolerance);
	    }
	
	    this.finalAttr = () => attrs[attrs.length - 1];
	
	    this.details = (elem) => {
	      if (singleValue) return bounds(elem);
	      let details = {};
	      for (let index = 0; index < attrs.length; index++) {
	        details[attrs[index]] = this.bounds[attrs[index]](elem);
	      }
	      return details;
	    }
	
	    this.boundries = (elem) => {
	      if (singleValue) return bounds(elem).id;
	      let boundries = '';
	      for (let index = 0; index < attrs.length; index++) {
	        boundries += this.bounds[attrs[index]](elem).id + '\n';
	      }
	      return boundries.substr(0,boundries.length - 1);
	    }
	
	    for (let index = 0; index < attrs.length; index++) {
	      const attr = attrs[index];
	      this.bounds[attr] = boundsFunc(attr, attributeMap);
	      this.bounds[attr].within = withinBounds(attr, attributeMap);
	    }
	
	    this.within = (elem1, elem2) => {
	      if (singleValue) return within(elem1, elem2);
	      let isWithin = true;
	      for (let index = 0; index < attrs.length; index++) {
	        const attr = attrs[index];
	        const value1 = Object.pathValue(elem1, attr);
	        const value2 = Object.pathValue(elem2, attr);
	        isWithin &&= this.bounds[attr].within(value1, value2);
	        if (!isWithin) return false;
	      }
	      return isWithin;
	    }
	  }
	}
	
	Tolerance.within = (tol) => new Tolerance({'value': tol}).bounds.value.within;
	
	module.exports = Tolerance;
	
});


RequireJS.addFunction('./public/js/utils/tolerance-map.js',
function (require, exports, module) {
	
const Tolerance = require('tolerance');
	
	function sortByAttr(attr) {
	  function sort(obj1, obj2) {
	    if (obj2[attr] === obj1[attr]) {
	      return 0;
	    }
	    return obj2[attr]() < obj1[attr]() ? 1 : -1;
	  }
	  return sort;
	}
	
	class ToleranceMap {
	  constructor(attributeMap, toleranceMap) {
	    const map = toleranceMap || {};
	    const tolerance = new Tolerance(attributeMap);
	    const finalAttrSort = sortByAttr(tolerance.finalAttr());
	
	    this.clone = () => {
	      const tMap = new ToleranceMap(attributeMap);
	      this.forEach(value => tMap.add(value));
	      return tMap;
	    }
	    function forEachSet(func, node, attrs, attrIndex) {
	      if ((typeof func) !== 'function') throw new Error('Arg1 must be of type function');
	      if (Array.isArray(node)) {
	        func(node);
	        return;
	      }
	      if (attrs && !node) return;
	      attrs ||= tolerance.attributes();
	      node ||= map;
	      attrIndex ||= 0;
	      const keys = Object.keys(node);
	      for (let index = 0; index < keys.length; index++) {
	        forEachSet(func, node[keys[index]], attrs, attrIndex + 1);
	      }
	    }
	
	    function matches(elem, node, attrs, list, attrIndex) {
	      if (Array.isArray(node)) {
	        list.concatInPlace(node);
	        return;
	      }
	      if (attrs && !node) return;
	      list ||= [];
	      attrs ||= tolerance.attributes();
	      node ||= map;
	      attrIndex ||= 0;
	      const attr = attrs[attrIndex];
	      const bounds = tolerance.bounds[attr](elem);
	      const id = bounds.id;
	      matches(elem, node[bounds.nextId], attrs, list, attrIndex + 1);
	      matches(elem, node[bounds.id], attrs, list, attrIndex + 1);
	      matches(elem, node[bounds.prevId], attrs, list, attrIndex + 1);
	
	      if (attrIndex === 0) {
	        const matchList = list.filter((other) => tolerance.within(elem, other));
	        matchList.sort(finalAttrSort);
	        return matchList;
	      }
	    }
	
	    function getSet(elem) {
	      let curr = map;
	      let attrs = tolerance.attributes();
	      for (let index = 0; index < attrs.length; index += 1) {
	        const attr = attrs[index];
	        const bounds = tolerance.bounds[attr](elem);
	        const id = bounds.id;
	        if (curr[id] === undefined) {
	          if (index < attrs.length -1) curr[id] = {};
	          else curr[id] = [];
	        }
	        curr = curr[id];
	      }
	
	      return curr;
	    }
	
	    this.forEachSet = forEachSet;
	    this.maxSet = () => {
	      const maxSet = [];
	      forEachSet((set) => maxSet.push(set[0]));
	      maxSet.sort(finalAttrSort);
	      maxSet.reverse();
	      return maxSet;
	    }
	    this.minSet = () => {
	      const minSet = [];
	      forEachSet((set) => minSet.push(set[set.length - 1]));
	      minSet.sort(finalAttrSort);
	      return minSet;
	    }
	    this.forEach = (func, detailed) => {
	      if (!(typeof func) === 'function') return;
	      forEachSet(set => set.forEach((value) => {
	        const details = detailed ? undefined : tolerance.details(value);
	        func(value, details);
	      }));
	    };
	
	    this.values = () => {
	      const values = [];
	      forEachSet(set => values.concatInPlace(set));
	      return values;
	    }
	    this.tolerance = () => tolerance;
	
	    this.matches = (elem) => matches(elem);
	
	    this.add = (elem) => {
	      let matchArr = getSet(elem);
	      matchArr.push(elem);
	      matchArr.sort(finalAttrSort);
	    }
	
	    this.remove = (elem) => {
	      const matchArr = getSet(elem);
	      if (matchArr) {
	        const index = matchArr.indexOf(elem);
	        if (index !== -1) matchArr.splice(index, 1);
	      }
	    }
	
	    this.filter = (elem, filter) => {
	      const matchArr = matches(elem);
	      const filtered = filter(Array.from(matchArr), elem);
	      const returnedArr = new Array(matchArr.length);
	      for (let index = 0; index < filtered.length; index++) {
	        const filElem = filtered[index];
	        const origIndex = matchArr.indexOf(filElem);
	        if (origIndex !== -1) returnedArr[origIndex] = filElem;
	        else this.add(filElem);
	      }
	      let rmElemIndex = 0;
	      while(-1 !== (rmElemIndex = returnedArr.indexOf(undefined, rmElemIndex))) {
	        this.remove(matchArr[rmElemIndex]);
	      }
	    }
	
	    this.addAll = (list) => {
	      for (let index = 0; index < list.length; index++) {
	        const elem = list[index];
	        let matchArr = getSet(elem);
	        matchArr.push(elem);
	      }
	      matchArr.sort(finalAttrSort);
	    }
	
	    this.map = () => map;
	  }
	}
	
	module.exports = ToleranceMap;
	
});


RequireJS.addFunction('./public/js/utils/$t.js',
function (require, exports, module) {
	

	
	
	
	const CustomEvent = require('./custom-event');
	const ExprDef = require('./expression-definition');
	
	class $t {
		constructor(template, id, selector) {
			if (selector) {
				const afterRenderEvent = new CustomEvent('afterRender');
				const beforeRenderEvent = new CustomEvent('beforeRender');
			}
	
			function varReg(prefix, suffix) {
			  const vReg = '([a-zA-Z_\\$][a-zA-Z0-9_\\$]*)';
			  prefix = prefix ? prefix : '';
			  suffix = suffix ? suffix : '';
			  return new RegExp(`${prefix}${vReg}${suffix}`)
			};
	
			function replace(needleRegEx, replaceStr, exceptions) {
			  return function (sub) {
			    if (!exceptions || exceptions.indexOf(sub) === -1) {
			      return sub.replace(needleRegEx, replaceStr)
			    } else {
			      return sub;
			    }
			  }
			}
	
			const signProps = {opening: /([-+\!])/};
			const relationalProps = {opening: /((\<|\>|\<\=|\>\=|\|\||\||&&|&))/};
			const ternaryProps = {opening: /\?/};
			const keyWordProps = {opening: /(new|null|undefined|typeof|NaN|true|false)[^a-z^A-Z]/, tailOffset: -1};
			const ignoreProps = {opening: /new \$t\('.*?'\).render\(.*?, '(.*?)', get\)/};
			const commaProps = {opening: /,/};
			const colonProps = {opening: /:/};
			const multiplierProps = {opening: /(===|[-+=*\/](=|))/};
			const stringProps = {opening: /('|"|`)(\1|.*?([^\\]((\\\\)*?|[^\\])(\1)))/};
			const spaceProps = {opening: /\s{1}/};
			const numberProps = {opening: /([0-9]*((\.)[0-9]{1,})|[0-9]{1,})/};
			const objectProps = {opening: '{', closing: '}'};
			const objectLabelProps = {opening: varReg(null, '\\:')};
			const groupProps = {opening: /\(/, closing: /\)/};
			const expressionProps = {opening: null, closing: null};
			const attrProps = {opening: varReg('(\\.', '){1,}')};
	
			// const funcProps = {
			//   opening: varReg(null, '\\('),
			//   onOpen: replace(varReg(null, '\\('), 'get("$1")('),
			//   closing: /\)/
			// };
			const arrayProps = {
			  opening: varReg(null, '\\['),
			  onOpen: replace(varReg(null, '\\['), 'get("$1")['),
			  closing: /\]/
			};
			const funcRefProps = {
				opening: /\[|\(/,
				closing: /\]|\)/
			};
			const memberRefProps = {
				opening: varReg('\\.', ''),
			};
			const variableProps = {
			  opening: varReg(),
			  onOpen: replace(varReg(), 'get("$1")'),
			};
			const objectShorthandProps = {
			  opening: varReg(),
			  onOpen: replace(varReg(), '$1: get("$1")'),
			};
	
	
			const expression = new ExprDef('expression', expressionProps);
			const ternary = new ExprDef('ternary', ternaryProps);
			const relational = new ExprDef('relational', relationalProps);
			const comma = new ExprDef('comma', commaProps);
			const colon = new ExprDef('colon', colonProps);
			const attr = new ExprDef('attr', attrProps);
			// const func = new ExprDef('func', funcProps);
			const funcRef = new ExprDef('funcRef', funcRefProps);
			const memberRef = new ExprDef('memberRef', memberRefProps);
			const string = new ExprDef('string', stringProps);
			const space = new ExprDef('space', spaceProps);
			const keyWord = new ExprDef('keyWord', keyWordProps);
			const group = new ExprDef('group', groupProps);
			const object = new ExprDef('object', objectProps);
			const array = new ExprDef('array', arrayProps);
			const number = new ExprDef('number', numberProps);
			const multiplier = new ExprDef('multiplier', multiplierProps);
			const sign = new ExprDef('sign', signProps);
			const ignore = new ExprDef('ignore', ignoreProps);
			const variable = new ExprDef('variable', variableProps);
			const objectLabel = new ExprDef('objectLabel', objectLabelProps);
			const objectShorthand = new ExprDef('objectShorthand', objectShorthandProps);
	
			expression.always(space, ignore, keyWord);
			expression.if(string, number, group, array, variable, funcRef, memberRef)
			      .then(multiplier, sign, relational, group)
			      .repeat();
			expression.if(string, group, array, variable, funcRef, memberRef)
						.then(attr)
			      .then(multiplier, sign, relational, expression, funcRef, memberRef)
						.repeat();
			expression.if(string, group, array, variable, funcRef, memberRef)
						.then(attr)
						.end();
	
			funcRef.if(expression).then(comma).repeat();
			funcRef.if(expression).end();
			memberRef.if(expression).then(comma).repeat();
			memberRef.if(expression).end();
	
			expression.if(sign)
			      .then(expression)
			      .then(multiplier, sign, relational, group)
			      .repeat();
			expression.if(string, number, group, array, variable)
			      .then(ternary)
			      .then(expression)
			      .then(colon)
			      .then(expression)
			      .end();
			expression.if(ternary)
			      .then(expression)
			      .then(colon)
			      .then(expression)
			      .end();
			expression.if(object, string, number, group, array, variable)
			      .end();
			expression.if(sign)
			      .then(number)
			      .end();
	
			object.always(space, ignore, keyWord);
			object.if(objectLabel).then(expression).then(comma).repeat();
			object.if(objectShorthand).then(comma).repeat();
			object.if(objectLabel).then(expression).end();
			object.if(objectShorthand).end();
	
			group.always(space, ignore, keyWord);
			group.if(expression).then(comma).repeat();
			group.if(expression).end();
	
			array.always(space, ignore, keyWord);
			array.if(expression).then(comma).repeat();
			array.if(expression).end();
	
			function getter(scope, parentScope) {
				parentScope = parentScope || function () {return undefined};
				function get(name) {
					if (name === 'scope') return scope;
					const split = new String(name).split('.');
					let currObj = scope;
					for (let index = 0; currObj != undefined && index < split.length; index += 1) {
						currObj = currObj[split[index]];
					}
					if (currObj !== undefined) return currObj;
					const parentScopeVal = parentScope(name);
					if (parentScopeVal !== undefined) return parentScopeVal;
	        else {
	          const globalVal = $t.global(name);
	          return globalVal === undefined ? '' : globalVal;
	        }
				}
				return get;
			}
	
			function defaultArray(elemName, get) {
				let resp = '';
				for (let index = 0; index < get('scope').length; index += 1) {
					if (elemName) {
						const obj = {};
	          obj.$index = index;
						obj[elemName] = get(index);
						resp += new $t(template).render(obj, undefined, get);
					} else {
						resp += new $t(template).render(get(index), undefined, get);
					}
				}
				return `${resp}`;
			}
	
			function arrayExp(varName, get) {
				varName = varName.trim();
				const array = get('scope');
				let built = '';
				for (let index = 0; index < array.length; index += 1) {
					const obj = {};
					obj[varName] = array[index];
					obj.$index = index;
					built += new $t(template).render(obj, undefined, get);
				}
				return built;
			}
	
			function itOverObject(varNames, get) {
				const match = varNames.match($t.objectNameReg);
				const keyName = match[1];
				const valueName = match[2];
				const obj = get('scope');
				const keys = Object.keys(obj);
				const isArray = Array.isArray(obj);
				let built = '';
				for (let index = 0; index < keys.length; index += 1) {
					const key = keys[index];
					if (!isArray || key.match(/^[0-9]{1,}$/)) {
						const childScope = {};
						childScope[keyName] = key;
						childScope[valueName] = obj[key];
						childScope.$index = index;
						built += new $t(template).render(childScope, undefined, get);
					}
				}
	      return built;
			}
	
			function rangeExp(elemName, rangeItExpr, get) {
				const match = rangeItExpr.match($t.rangeItExpReg);
				let startIndex = match[1].match(/^[0-9]{1,}$/) ?
							match[1] : get(match[1]);
				let endIndex = match[2].match(/^[0-9]*$/) ?
							match[2] : get(match[2]);
				if (((typeof startIndex) !== 'string' &&
								(typeof	startIndex) !== 'number') ||
									(typeof endIndex) !== 'string' &&
									(typeof endIndex) !== 'number') {
										throw Error(`Invalid range '${itExp}' evaluates to '${startIndex}..${endIndex}'`);
				}
	
				try {
					startIndex = Number.parseInt(startIndex);
				} catch (e) {
					throw Error(`Invalid range '${itExp}' evaluates to '${startIndex}..${endIndex}'`);
				}
				try {
					endIndex = Number.parseInt(endIndex);
				} catch (e) {
					throw Error(`Invalid range '${itExp}' evaluates to '${startIndex}..${endIndex}'`);
				}
	
				let index = startIndex;
				let built = '';
				while (true) {
					let increment = 1;
					if (startIndex > endIndex) {
						if (index <= endIndex) {
							break;
						}
						increment = -1;
					} else if (index >= endIndex) {
						break;
					}
					const obj = {$index: index};
					obj[elemName] = index;
					built += new $t(template).render(obj, undefined, get);
					index += increment;
				}
				return built;
			}
	
			function evaluate(get) {
				if ($t.functions[id]) {
					try {
						return $t.functions[id](get, $t);
					} catch (e) {
					  console.error(e);
					}
				} else {
					return eval($t.templates[id])
				}
			}
	
			function type(scope, expression) {
				if ((typeof scope) === 'string' && scope.match($t.rangeAttemptExpReg)) {
					if (scope.match($t.rangeItExpReg)) {
						return 'rangeExp'
					}
					return 'rangeExpFormatError';
				} else if (Array.isArray(scope)) {
					if (expression === undefined) {
						return 'defaultArray';
					} else if (expression.match($t.nameScopeExpReg)) {
						return 'nameArrayExp';
					}
				}
	
				if ((typeof scope) === 'object') {
					if (expression === undefined) {
						return 'defaultObject';
					} else if (expression.match($t.objectNameReg)){
						return 'itOverObject';
					} else if (expression.match($t.arrayNameReg)){
						return 'arrayExp';
					} else {
						return 'invalidObject';
					}
				} else {
					return 'defaultObject';
				}
			}
	
			// TODO: itExp is not longer an iteration expression. fix!!!!
			function render(scope, itExp, parentScope) {
	      if (scope === undefined) return '';
				let rendered = '';
				const get = getter(scope, parentScope);
				switch (type(scope, itExp)) {
					case 'rangeExp':
						rendered = rangeExp(itExp, scope, get);
						break;
					case 'rangeExpFormatError':
						throw new Error(`Invalid range itteration expression "${scope}"`);
					case 'defaultArray':
						rendered = defaultArray(itExp, get);
						break;
					case 'nameArrayExp':
						rendered = defaultArray(itExp, get);
						break;
					case 'arrayExp':
						rendered = arrayExp(itExp, get);
						break;
					case 'invalidArray':
						throw new Error(`Invalid iterative expression for an array "${itExp}"`);
					case 'defaultObject':
						rendered = evaluate(get);
						break;
					case 'itOverObject':
						rendered = itOverObject(itExp, get);
						break;
					case 'invalidObject':
						throw new Error(`Invalid iterative expression for an object "${itExp}"`);
					default:
						throw new Error(`Programming error defined type '${type()}' not implmented in switch`);
				}
	
	      if (selector) {
	        const elem = document.querySelector(selector);
	        if (elem !== null) {
	          beforeRenderEvent.trigger();
	          elem.innerHTML = rendered;
	          afterRenderEvent.trigger();
	        }
	      }
				return rendered;
			}
	
	
	//---------------------  Compile Functions ---------------//
	
			function stringHash(string) {
				let hashString = string;
				let hash = 0;
				for (let i = 0; i < hashString.length; i += 1) {
					const character = hashString.charCodeAt(i);
					hash = ((hash << 5) - hash) + character;
					hash &= hash; // Convert to 32bit integer
				}
				return hash;
			}
	
			function isolateBlocks(template) {
				let inBlock = false;
				let openBracketCount = 0;
				let block = '';
				let blocks = [];
				let str = template;
				for (let index = 0; index < str.length; index += 1) {
					if (inBlock) {
						block += str[index];
					}
					if (!inBlock && index > 0 &&
						str[index] == '{' && str[index - 1] == '{') {
						inBlock = true;
					} else if (inBlock && str[index] == '{') {
						openBracketCount++;
					} else if (openBracketCount > 0 && str[index] == '}') {
						openBracketCount--;
					} else if (str[index + 1] == '}' && str[index] == '}' ) {
						inBlock = false;
						blocks.push(`${block.substr(0, block.length - 1)}`);
						block = '';
					}
				}
				return blocks;
			}
	
			function compile() {
				const blocks = isolateBlocks(template);
				let str = template;
				for (let index = 0; index < blocks.length; index += 1) {
					const block = blocks[index];
					const parced = ExprDef.parse(expression, block);
					str = str.replace(`{{${block}}}`, `\` + $t.clean(${parced}) + \``);
				}
				return `\`${str}\``;
			}
	
	
					const repeatReg = /<([a-zA-Z-]*):t( ([^>]* |))repeat=("|')(([^>^\4]*?)\s{1,}in\s{1,}([^>^\4]*?))\4([^>]*>((?!(<\1:t[^>]*>|<\/\1:t>)).)*<\/)\1:t>/;
					function formatRepeat(string) {
						// tagname:1 prefix:2 quote:4 exlpression:5 suffix:6
						// string = string.replace(/<([^\s^:^-^>]*)/g, '<$1-ce');
						let match;
						while (match = string.match(repeatReg)) {
							let tagContents = match[2] + match[8];
	            let tagName = match[1];
	            let varNames = match[6];
	            let realScope = match[7];
							let template = `<${tagName}${tagContents}${tagName}>`.replace(/\\'/g, '\\\\\\\'').replace(/([^\\])'/g, '$1\\\'').replace(/''/g, '\'\\\'');
							let templateName = tagContents.replace(/.*\$t-id=('|")([\.a-zA-Z-_\/]*?)(\1).*/, '$2');
							let scope = 'scope';
							template = templateName !== tagContents ? templateName : template;
							const t = eval(`new $t(\`${template}\`)`);
	            let resolvedScope = "get('scope')";;
	            try {
	              // console.log('tagName', tagName);
	              // console.log('varNames', varNames);
	              // console.log('realScope', realScope);
	              // console.log('tagContents', tagContents);
								if (realScope.match(/[0-9]{1,}\.\.[0-9]{1,}/)){
	                resolvedScope = `'${realScope}'`;
	              } else {
	                resolvedScope = ExprDef.parse(expression, realScope);
	              }
	            } catch (e) {}
	            string = string.replace(match[0], `{{ new $t('${t.id()}').render(${resolvedScope}, '${varNames}', get)}}`);
						}
						return string;
					}
	
			if (id) {
				$t.templates[id] = undefined;
				$t.functions[id] = undefined;
			}
	
			template = template.replace(/\s{1,}/g, ' ');
			id = $t.functions[template] ? template : id || stringHash(template);
			if (!$t.functions[id]) {
				if (!$t.templates[id]) {
					template = template.replace(/\s{2,}|\n/g, ' ');
					template = formatRepeat(template);
					$t.templates[id] = compile();
				}
			}
			this.compiled = function () { return $t.templates[id];}
			this.render = render;
	    this.afterRender = (func) => afterRenderEvent.on(func);
	    this.beforeRender = (func) => beforeRenderEvent.on(func);
			this.type = type;
			this.isolateBlocks = isolateBlocks;
	    this.id = () => id;
		}
	}
	
	$t.templates = {};//{"-1554135584": '<h1>{{greeting}}</h1>'};
	$t.functions = {};
	$t.loadFunctions = (functions) => {
		Object.keys(functions).forEach((name) => {
			$t.functions[name] = functions[name];
		});
	
	}
	$t.isTemplate = (id) => $t.functions[id] !== undefined;
	$t.arrayNameReg = /^\s*([a-zA-Z][a-z0-9A-Z]*)\s*$/;
	$t.objectNameReg = /^\s*([a-zA-Z][a-z0-9A-Z]*)\s*,\s*([a-zA-Z][a-z0-9A-Z]*)\s*$/;
	$t.rangeAttemptExpReg = /^\s*(.*\.\..*)\s*$/;
	$t.rangeItExpReg = /^\s*([a-z0-9A-Z]*)\s*\.\.\s*([a-z0-9A-Z]*)\s*$/;
	$t.nameScopeExpReg = /^\s*([a-zA-Z][a-z0-9A-Z]*)\s*$/;
	$t.quoteStr = function (str) {
			str = str.replace(/\\`/g, '\\\\\\`')
			str = str.replace(/([^\\])`/g, '$1\\\`')
			return `\`${str.replace(/``/g, '`\\`')}\``;
		}
	$t.formatName = function (string) {
	    function toCamel(whoCares, one, two) {return `${one}${two.toUpperCase()}`;}
	    return string.replace(/([a-z])[^a-z^A-Z]{1,}([a-zA-Z])/g, toCamel);
	}
	$t.dumpTemplates = function (debug) {
		let templateFunctions = '';
		let tempNames = Object.keys($t.templates);
		for (let index = 0; index < tempNames.length; index += 1) {
			const tempName = tempNames[index];
			if (tempName) {
				let template = $t.templates[tempName];
	      if (debug === true) {
	        const endTagReg = /( \+) /g;
	        template = template.replace(endTagReg, '$1\n\t\t');
	      }
				templateFunctions += `\nexports['${tempName}'] = (get, $t) => \n\t\t${template}\n`;
			}
		}
		return templateFunctions;
	}
	
	$t.clean = (val) => val === undefined ? '' : val;
	
	function createGlobalsInterface() {
	  const GLOBALS = {};
	  const isMotifiable = (name) => GLOBALS[name] === undefined ||
	        GLOBALS[name].imutable !== 'true';
	  $t.global = function (name, value, imutable) {
	    if (value === undefined) return GLOBALS[name] ? GLOBALS[name].value : undefined;
	    if (isMotifiable(name)) GLOBALS[name] = {value, imutable};
	  }
	  $t.rmGlobal = function(name) {
	    if (isMotifiable(name)) delete GLOBALS[name];
	  }
	}
	createGlobalsInterface();
	
	module.exports = $t;
	
});


RequireJS.addFunction('./public/js/utils/approximate.js',
function (require, exports, module) {
	

	
	let defaultAccuracy;
	
	class Approximate {
	  constructor(accuracy) {
	    if ((typeof accuracy) !== 'number' || accuracy === defaultAccuracy) return Approximate.default;
	
	    function approximate(value) {
	      return Math.round(value * accuracy) / accuracy;
	    }
	
	    function approximateFunc(test) {
	      return function () {
	        if (arguments.length === 2) return test(approximate(arguments[0]), approximate(arguments[1]));
	        for (let index = 1; index < arguments.length; index++) {
	          if (!test(approximate(arguments[index - 1]), approximate(arguments[index]))) return false;
	        }
	        return true;
	      }
	    }
	    const af = approximateFunc;
	    approximate.eq = af((one, two) => one === two);
	    approximate.neq = af((one, two) => one !== two);
	    approximate.gt = af((one, two) => one > two);
	    approximate.lt = af((one, two) => one < two);
	    approximate.gteq = af((one, two) => one >= two);
	    approximate.lteq = af((one, two) => one <= two);
	    approximate.eqAbs = af((one, two) => Math.abs(one) === Math.abs(two));
	    approximate.neqAbs = af((one, two) => Math.abs(one) !== Math.abs(two));
	    approximate.abs = (value) => Math.abs(approximate(value));
	    approximate.object = (obj) => {
	      const approx = {};
	      return Object.forAllRecursive(obj,
	            (value) => (typeof value) === 'number' ? approximate(value) : value);
	    }
	    approximate.sameSign = af((value1, value2) => (value1 === 0 && value2 === 0) ||
	                                                      (value2 > 0 && value1 > 0) ||
	                                                      (value2 < 0 && value1 < 0));
	    return approximate;
	  }
	}
	
	
	Approximate.setDefault = (accuracy) => {
	  if ((typeof accuracy) !== 'number') throw new Error('Must enter a number for accuracy: hint must be a power of 10');
	  Approximate.default = new Approximate(accuracy);
	  defaultAccuracy = accuracy;
	  Approximate.default.new = (acc) => new Approximate(acc);
	  Approximate.default.setDefault = Approximate.default;
	}
	
	Approximate.setDefault(1000000);
	
	module.exports  = Approximate.default;
	
});


RequireJS.addFunction('./public/js/utils/request.js',
function (require, exports, module) {
	

	Request = {
	    onStateChange: function (success, failure, id) {
	      return function () {
	        if (this.readyState === 4) {
	          if (this.status == 200) {
	            try {
	              resp = JSON.parse(this.responseText);
	            } catch (e){
	              resp = this.responseText;
	            }
	            if (success) {
	              success(resp, this);
	            }
	          } else if (failure) {
	            const errorMsgMatch = this.responseText.match(Request.errorMsgReg);
	            if (errorMsgMatch) {
	              this.errorMsg = errorMsgMatch[1].trim();
	            }
	            const errorCodeMatch = this.responseText.match(Request.errorCodeReg);
	            if (errorCodeMatch) {
	              this.errorCode = errorCodeMatch[1];
	
	            }
	            failure(this);
	          }
	          var resp = this.responseText;
	        }
	      }
	    },
	
	    id: function (url, method) {
	      return `request.${method}.${url.replace(/\./g, ',')}`;
	    },
	
	    get: function (url, success, failure) {
	      const xhr = new Request.xmlhr();
	      xhr.open("GET", url, true);
	      const id = Request.id(url, 'GET');
	      xhr.setRequestHeader('Content-Type', 'text/pdf');
	      xhr.setRequestHeader('Access-Control-Allow-Origin', '*');
	      Request.setGlobalHeaders(xhr);
	      if (success === undefined && failure === undefined) return xhr;
	      xhr.onreadystatechange =  Request.onStateChange(success, failure, id);
	      xhr.send();
	      return xhr;
	    },
	
	    hasBody: function (method) {
	      return function (url, body, success, failure) {
	        const xhr = new Request.xmlhr();
	        xhr.open(method, url, true);
	        const id = Request.id(url, method);
	        xhr.setRequestHeader('Content-Type', 'application/json');
	        Request.setGlobalHeaders(xhr);
	        if (success === undefined && failure === undefined) return xhr;
	        xhr.onreadystatechange =  Request.onStateChange(success, failure, id);
	        xhr.send(JSON.stringify(body));
	        return xhr;
	      }
	    },
	
	    post: function () {return Request.hasBody('POST')(...arguments)},
	    delete: function () {return Request.hasBody('DELETE')(...arguments)},
	    options: function () {return Request.hasBody('OPTIONS')(...arguments)},
	    head: function () {return Request.hasBody('HEAD')(...arguments)},
	    put: function () {return Request.hasBody('PUT')(...arguments)},
	    connect: function () {return Request.hasBody('CONNECT')(...arguments)},
	}
	
	Request.errorCodeReg = /Error Code:([a-zA-Z0-9]*)/;
	Request.errorMsgReg = /[a-zA-Z0-9]*?:([a-zA-Z0-9 ]*)/;
	const globalHeaders = {};
	Request.globalHeader = (header, funcOval) => {
	  globalHeaders[header] = funcOval;
	}
	Request.setGlobalHeaders = (xhr) => {
	  const headers = Object.keys(globalHeaders);
	  headers.forEach((header) => {
	    const value = (typeof globalHeaders[header]) === 'function' ? globalHeaders[header]() : globalHeaders[header];
	    xhr.setRequestHeader(header, value, xhr);
	  });
	}
	try {
	  Request.xmlhr = XMLHttpRequest;
	} catch (e) {
	  Request.xmlhr = require('xmlhttprequest').XMLHttpRequest;
	}
	
	try {
	  module.exports = Request;
	} catch (e) {}
	
});


RequireJS.addFunction('./public/js/utils/parse-arguments.js',
function (require, exports, module) {
	const trueReg = /^true$/;
	const falseReg = /^false$/;
	const numberReg = /^[0-9]{1,}$/;
	const arrayReg = /^(.*[,].*(,|)){1,}$/;
	
	function getValue(str) {
	  if (str === '') return undefined;
	  if (str.match(trueReg)) return true;
	  if (str.match(falseReg)) return false;
	  if (str.match(numberReg)) return Number.parseInt(str);
	  if (str.match(arrayReg)) {
	    const arr = [];
	    const elems = str.split(',');
	    for (let index = 0; index < elems.length; index += 1) {
	      arr.push(getValue(elems[index]));
	    }
	    return arr;
	  }
	  return str;
	}
	
	const valueRegex = /[A-Z.a-z]{1,}=.*$/;
	function argParser() {
	  for (let index = 2; index < process.argv.length; index += 1) {
	    const arg = process.argv[index];
	    if (arg.match(valueRegex)) {
	      const varName = arg.split('=', 1)[0];
	      const valueStr = arg.substr(varName.length + 1);
	      global[varName] = getValue(valueStr.trim());
	    }
	  }
	}
	
	global.__basedir = __dirname;
	argParser();
	
});


RequireJS.addFunction('./public/js/utils/measurement.js',
function (require, exports, module) {
	
  try {
	    Lookup = require('./object/lookup');
	    StringMathEvaluator = require('./string-math-evaluator');
	  } catch(e) {}
	
	
	function regexToObject (str, reg) {
	  const match = str.match(reg);
	  if (match === null) return null;
	  const returnVal = {};
	  for (let index = 2; index < arguments.length; index += 1) {
	    const attr = arguments[index];
	    if (attr) returnVal[attr] = match[index - 1];
	  }
	  return returnVal;
	}
	
	let units = [
	  'Metric',
	  'Imperial (US)'
	]
	let unit = units[1];
	
	
	class Measurement extends Lookup {
	  constructor(value, notMetric) {
	    super();
	    if ((typeof value) === 'string') {
	      value += ' '; // Hacky fix for regularExpression
	    }
	
	    const determineUnit = () => {
	      if ((typeof notMetric === 'string')) {
	        const index = units.indexOf(notMetric);
	        if (index !== -1) return units[index];
	      } else if ((typeof notMetric) === 'boolean') {
	        if (notMetric === true) return unit;
	      }
	      return units[0];
	    }
	
	    let decimal = 0;
	    let nan = value === null || value === undefined;
	    this.isNaN = () => nan;
	
	    const parseFraction = (str) => {
	      const regObj = regexToObject(str, Measurement.regex, null, 'integer', null, 'numerator', 'denominator');
	      regObj.integer = Number.parseInt(regObj.integer) || 0;
	      regObj.numerator = Number.parseInt(regObj.numerator) || 0;
	      regObj.denominator = Number.parseInt(regObj.denominator) || 0;
	      if(regObj.denominator === 0) {
	        regObj.numerator = 0;
	        regObj.denominator = 1;
	      }
	      regObj.decimal = regObj.integer + (regObj.numerator / regObj.denominator);
	      return regObj;
	    };
	
	    function reduce(numerator, denominator) {
	      let reduced = true;
	      while (reduced) {
	        reduced = false;
	        for (let index = 0; index < Measurement.primes.length; index += 1) {
	          const prime = Measurement.primes[index];
	          if (prime >= denominator) break;
	          if (numerator % prime === 0 && denominator % prime === 0) {
	            numerator = numerator / prime;
	            denominator = denominator / prime;
	            reduced = true;
	            break;
	          }
	        }
	      }
	      if (numerator === 0) {
	        return '';
	      }
	      return ` ${numerator}/${denominator}`;
	    }
	
	    //TODO: This could easily be more efficient.... bigger fish.
	    function fractionEquivalent(decimalValue, accuracy) {
	      accuracy = accuracy || '1/32'
	      const fracObj = parseFraction(accuracy);
	      const denominator = fracObj.denominator;
	      if (fracObj.decimal === 0 || fracObj.integer > 0 || denominator > 1000) {
	        throw new Error('Please enter a fraction with a denominator between (0, 1000]')
	      }
	      let sign = decimalValue > 0 ? 1 : -1;
	      let remainder = Math.abs(decimalValue);
	      let currRemainder = remainder;
	      let value = 0;
	      let numerator = 0;
	      while (currRemainder > 0) {
	        numerator += fracObj.numerator;
	        currRemainder -= fracObj.decimal;
	      }
	      const diff1 = Math.abs(decimalValue) - ((numerator - fracObj.numerator) / denominator);
	      const diff2 = (numerator / denominator) - Math.abs(decimalValue);
	      numerator -= diff1 < diff2 ? fracObj.numerator : 0;
	      const integer = sign * Math.floor(numerator / denominator);
	      numerator = numerator % denominator;
	      return {integer, numerator, denominator};
	    }
	
	    this.fraction = (accuracy, standardDecimal) => {
	      standardDecimal = standardDecimal || decimal;
	      if (nan) return NaN;
	      const obj = fractionEquivalent(standardDecimal, accuracy);
	      if (obj.integer === 0 && obj.numerator === 0) return '0';
	      const integer = obj.integer !== 0 ? obj.integer : '';
	      return `${integer}${reduce(obj.numerator, obj.denominator)}`;
	    }
	    this.standardUS = (accuracy) => this.fraction(accuracy, convertMetricToUs(decimal));
	
	    this.display = (accuracy) => {
	      switch (unit) {
	        case units[0]: return new String(this.decimal(10));
	        case units[1]: return this.standardUS(accuracy);
	        default:
	            return this.standardUS(accuracy);
	      }
	    }
	
	    this.value = (accuracy) => this.decimal(accuracy);
	
	    this.decimal = (accuracy) => {
	      if (nan) return NaN;
	      accuracy = accuracy % 10 ? accuracy : 10000;
	      return Math.round(decimal * accuracy) / accuracy;
	    }
	
	    function getDecimalEquivalant(string) {
	      string = string.trim();
	      if (string.match(Measurement.decimalReg)) {
	        return Number.parseFloat(string);
	      } else if (string.match(StringMathEvaluator.fractionOrMixedNumberReg)) {
	        return parseFraction(string).decimal
	      }
	      nan = true;
	      return NaN;
	    }
	
	    const convertMetricToUs = (standardDecimal) =>  standardDecimal / 2.54;
	    const convertUsToMetric = (standardDecimal) => value = standardDecimal * 2.54;
	
	    function standardize(ambiguousDecimal) {
	      switch (determineUnit()) {
	        case units[0]:
	          return ambiguousDecimal;
	        case units[1]:
	          return convertUsToMetric(ambiguousDecimal);
	        default:
	          throw new Error('This should not happen, Measurement.unit should be the gate keeper that prevents invalid units from being set');
	      }
	    }
	
	    if ((typeof value) === 'number') {
	      decimal = standardize(value);
	    } else if ((typeof value) === 'string') {
	      try {
	        const ambiguousDecimal = getDecimalEquivalant(value);
	        decimal = standardize(ambiguousDecimal);
	      } catch (e) {
	        nan = true;
	      }
	    } else {
	      nan = true;
	    }
	  }
	}
	
	Measurement.unit = (newUnit) => {
	  for (index = 0; index < units.length; index += 1) {
	    if (newUnit === units[index]) unit = newUnit;
	  }
	  return unit
	};
	Measurement.units = () => JSON.parse(JSON.stringify(units));
	Measurement.regex = /^\s*(([0-9]*)\s{1,}|)(([0-9]{1,})\s*\/([0-9]{1,})\s*|)$/;
	Measurement.primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
	Measurement.rangeRegex = /^\s*(\(|\[)(.*),(.*)(\)|\])\s*/;
	Measurement.decimalReg = /(^(-|)[0-9]*(\.|$|^)[0-9]*)$/;
	
	
	Measurement.validation = function (range) {
	  const obj = regexToObject(range, Measurement.rangeRegex, 'minBound', 'min', 'max', 'maxBound');
	  let min = obj.min.trim() !== '' ?
	        new Measurement(obj.min).decimal() : Number.MIN_SAFE_INTEGER;
	  let max = obj.max.trim() !== '' ?
	        new Measurement(obj.max).decimal() : Number.MAX_SAFE_INTEGER;
	  const minCheck = obj.minBound === '(' ? ((val) => val > min) : ((val) => val >= min);
	  const maxCheck = obj.maxBound === ')' ? ((val) => val < max) : ((val) => val <= max);
	  return function (value) {
	    const decimal = new Measurement(value).decimal();
	    if (decimal === NaN) return false;
	    return minCheck(decimal) && maxCheck(decimal);
	  }
	}
	
	Measurement.decimal = (value) => {
	  return new Measurement(value, true).decimal();
	}
	
	Measurement.round = (value, percision) => {
	  if (percision)
	  return new Measurement(value).decimal(percision);
	  return Math.round(value * 10000000) / 10000000;
	}
	
	try {
	  module.exports = Measurement;
	} catch (e) {/* TODO: Consider Removing */}
	
});


RequireJS.addFunction('./public/js/utils/logic-tree.js',
function (require, exports, module) {
	

	const DecisionTree = require('./decision-tree');
	const DataSync = require('./data-sync');
	const Lookup = require('./object/lookup');
	
	const INTERNAL_FUNCTION_PASSWORD = String.random();
	const DEFAULT_GROUP = 'LogicTree';
	
	function getNode(nodeOwrapper) {
	  if (nodeOwrapper.constructor.name === 'DecisionNode') return nodeOwrapper;
	  return nodeOwrapper.node;
	}
	
	class LogicWrapper extends Lookup {
	  constructor(node) {
	    super(node ? node.nodeId() : undefined);
	    this.node = node;
	    this.nodeId = () => LogicWrapper.decode(this.id()).id;
	  }
	}
	
	class LogicType {
	  constructor(wrapperOrJson) {
	    Object.getSet(this, 'nodeId', 'optional', 'value', 'default');
	    this.wrapper = wrapperOrJson instanceof LogicWrapper ?
	                      wrapperOrJson :
	                      LogicWrapper.get(wrapperOrJson.nodeId);
	    if (this.wrapper === undefined) {
	      console.log('here');
	    }
	    this.nodeId(this.wrapper.node.nodeId());
	    let optional = false;
	    this.optional = (val) => {
	      if (val === true || val === false) {
	        optional = val;
	      }
	      return optional;
	    }
	    this.selectionMade = () => true;
	  }
	}
	
	class SelectLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    const json = wrapper;
	    wrapper = this.wrapper;
	    let value, def;
	    const instance = this;
	    this.madeSelection = () => validate(value, true) || validate(def, true);
	    function validate(val, silent) {
	      if (instance.optional() && val === null) return true;
	      const valid = (instance.optional() && val === null) ||
	                    (val !== null && wrapper.node.validState(val));
	      if (!silent && !valid)
	        throw SelectLogic.error;
	      return valid;
	    }
	    this.value = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        value = val;
	        wrapper.valueUpdate(value, wrapper);
	      }
	      return value === undefined ? (def === undefined ? null : def) : value;
	    }
	    this.selectionMade = () => value !== undefined;
	    this.options = () => {
	      return wrapper.node.stateNames();
	    }
	    this.default = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        def = val;
	        wrapper.defaultUpdate(value, wrapper);
	      }
	      return def;
	    }
	    this.selector = () => this.value();
	   }
	}
	
	SelectLogic.error = new Error('Invalid selection: use wrapper.options() to get valid list.')
	
	class MultiselectLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    wrapper = this.wrapper;
	    let value, def;
	    const instance = this;
	    this.madeSelection = () => validate(value, true) || validate(def, true);
	    function validate(val, silent) {
	      if (val === null) return instance.optional();
	      if (val === undefined) return false;
	      const stateNames = Object.keys(val);
	      if (instance.optional() && stateNames.length === 0) return true;
	      let valid = stateNames.length > 0;
	      stateNames.forEach((name) => valid = valid && wrapper.node.validState(name));
	      if (!silent && !valid) throw MultiselectLogic.error;
	      return valid;
	    }
	    this.value = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        value = val;
	        wrapper.valueUpdate(value);
	      }
	      let retVal = value === undefined ? def : value;
	      return retVal === null ? null : JSON.clone(retVal);
	    }
	    this.selectionMade = () => value !== undefined;
	    this.options = () => {
	      const options = {};
	      const stateNames = wrapper.node.stateNames();
	      stateNames.forEach((name) => options[name] = def[name] === undefined ? false : def[name]);
	      return options;
	    }
	    this.default = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        def = val;
	        wrapper.defaultUpdate(value);
	      }
	      return def;
	    }
	    this.selector = () => {
	      const obj = this.value();
	      if (obj === null || obj === undefined) return null;
	      const keys = Object.keys(obj);
	      let selector = '';
	      keys.forEach((key) => selector += obj[key] ? `|${key}` : '');
	      selector = selector.length === 0 ? null : new RegExp(`^${selector.substring(1)}$`);
	      return selector;
	    }
	  }
	}
	MultiselectLogic.error = new Error('Invalid multiselection: use wrapper.options() to get valid list.')
	
	
	class ConditionalLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    wrapper = this.wrapper;
	    let value, def;
	    validate(wrapper.node.payload());
	    def = wrapper.node.payload();
	    function validate(val, password) {
	      if ((typeof val.condition) !== 'function')
	        throw ConditionalLogic.error;
	    }
	    this.value = (val) => {
	      if (val !== undefined) {
	        validate(val);
	        value = val;
	        wrapper.valueUpdate(value);
	      }
	      return value || def;
	    }
	    this.options = () => undefined;
	    this.default = (val, password) => {
	      if (val !== undefined) {
	        validate(val);
	        def = val;
	        wrapper.defaultUpdate(value);
	      }
	      return def;
	    }
	    this.selector = () => () =>
	      this.value().condition(wrapper.root());
	  }
	}
	ConditionalLogic.error = new Error('Invalid condition: must be a function that returns true or false based off of node input');
	
	class BranchLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    this.value = () => undefined;
	    this.options = () => undefined;
	    this.default = () => undefined;
	    this.selector = () => /.*/;
	  }
	}
	
	class LeafLogic extends LogicType {
	  constructor(wrapper) {
	    super(wrapper);
	    this.value = () =>undefined;
	    this.options = () => undefined;
	    this.default = () => undefined;
	    this.selector = () => undefined;
	  }
	}
	
	LogicType.types = {SelectLogic, MultiselectLogic, ConditionalLogic, BranchLogic, LeafLogic};
	class LogicTree {
	  constructor(formatPayload) {
	    Object.getSet(this);
	    const tree = this;
	    let root;
	    let choices = {};
	    const wrapperMap = {};
	
	    function getTypeObjByNodeId(nodeId) {
	      return choices[get(nodeId).name];
	    }
	    let dataSync = new DataSync('nodeId', getTypeObjByNodeId);
	    dataSync.addConnection('value');
	    dataSync.addConnection('default');
	
	    function isOptional(node) {
	      return !(choices[node.name] === undefined || !choices[node.name].optional());
	    }
	
	    function isSelector(node) {
	      return node.payload().LOGIC_TYPE.match(/Select|Multiselect/);
	    }
	
	    function mustSelect(node) {
	      return !isOptional(node)  && node.payload().LOGIC_TYPE.match(/Select|Multiselect/);
	    }
	
	    function structure() { return root.node.toString(null, 'LOGIC_TYPE') }
	
	    function setChoice(name, val) {
	      choices[name].value(val);
	    }
	
	    function setDefault(name, val) {
	      choices[name].default(val);
	    }
	
	    function getByName(name) {
	      if (root.node === undefined) return undefined;
	      const node = root.node.getByName(name);
	      return node === undefined ? undefined : wrapNode(node);
	    }
	
	    function addChildrenFunc(wrapper, options) {
	      return (name) => {
	        const targetWrapper = getByName(name);
	        if (targetWrapper === undefined) throw new Error(`Invalid name: ${name}`);
	        const states = targetWrapper.node.states();
	        states.forEach((state) => wrapNode(wrapper.node.then(state)));
	        return wrapper;
	      }
	    }
	
	    function choicesToSelectors() {
	      const keys = Object.keys(choices);
	      const selectors = {};
	      keys.forEach((key) => selectors[key] = choices[key].selector());
	      return selectors;
	    }
	
	    function reachableTree(node) {
	      return (node || root.node).subtree(choicesToSelectors());
	    }
	
	    function leaves() {
	      const wrappers = [];
	      reachableTree().leaves().forEach((node) => wrappers.push(wrapNode(node)));
	      return wrappers;
	    }
	
	    function pathsToString() {
	      let paths = '=>';
	      forPath((wrapper, data) => {
	        if (data === undefined) paths = paths.substring(0, paths.length - 2) + "\n";
	        paths += `${wrapper.name}=>`;
	        return true;
	      });
	      paths = paths.substring(0, paths.length - 2)
	      return paths;
	    }
	
	    function forPath(func, reverse) {
	      const lvs = reachableTree().leaves();
	      let data = [];
	      let dIndex = 0;
	      lvs.forEach((leave) => {
	        const path = [];
	        let curr = leave;
	        while (curr !== undefined) {
	          path.push(curr);
	          curr = curr.back()
	        }
	        if (reverse === true) {
	          for (let index = 0; index < path.length; index += 1) {
	            data[dIndex] = func(wrapNode(path[index]), data[dIndex]);
	          }
	        } else {
	          for (let index = path.length - 1; index >= 0; index -= 1) {
	            data[dIndex] = func(wrapNode(path[index]), data[dIndex]);
	          }
	        }
	        dIndex++;
	      });
	      return data;
	    }
	
	    function forAll(func, node) {
	      (node || root.node).forEach((n) => {
	        func(wrapNode(n));
	      });
	    }
	
	    function forEach(func, node) {
	      reachableTree(node).forEach((n) => {
	        func(wrapNode(n));
	      });
	    }
	
	    function reachable(nameOwrapper) {
	      const wrapper = nameOwrapper instanceof LogicWrapper ?
	                        nameOwrapper : getByName(nameOwrapper);
	      return wrapper.node.conditionsSatisfied(choicesToSelectors(), wrapper.node);
	    }
	
	    function isComplete() {
	      const subtree = reachableTree();
	      let complete = true;
	      subtree.forEach((node) => {
	        if (node.states().length === 0 && node.payload().LOGIC_TYPE !== 'Leaf' &&
	              !selectionMade(node)) {
	          complete = false;
	        }
	      });
	      return complete;
	    }
	
	    function selectionMade(node, selectors) {
	      selectors = selectors || choicesToSelectors();
	      if (mustSelect(node)) {
	        const wrapper = wrapNode(node);
	        if (getTypeObj(wrapper) === undefined) {
	          throw new Error ('This should not happen. node wrapper was not made correctly.');
	        }
	        return getTypeObj(wrapper).madeSelection();
	      }
	      return true;
	    }
	
	    function getByPath(...args) {
	      return wrapNode(root.node.getNodeByPath(...args))
	    }
	    this.getByPath = getByPath;
	
	    function decisions(wrapper) {
	      return () =>{
	        const decisions = [];
	        const addedNodeIds = [];
	        const selectors = choicesToSelectors();
	        wrapper.node.forEach((node) => {
	          if (isSelector(node)) {
	            let terminatedPath = false;
	            let current = node;
	            while (current = current.back()){
	              if (addedNodeIds.indexOf(current.nodeId()) !== -1)
	                terminatedPath = true;
	            }
	            if (!terminatedPath) {
	              if (node.conditionsSatisfied(selectors, node)) {
	                if (selectionMade(node, selectors)) {
	                  decisions.push(wrapNode(node));
	                } else {
	                  decisions.push(wrapNode(node));
	                  addedNodeIds.push(node.nodeId());
	                }
	              }
	            }
	          }
	        });
	        return decisions;
	      }
	    }
	
	    function toJson(wrapper) {
	      return function () {
	        wrapper = wrapper || root;
	        const json = {_choices: {}, _TYPE: tree.constructor.name};
	        const keys = Object.keys(choices);
	        const ids = wrapper.node.map((node) => node.nodeId());
	        keys.forEach((key) => {
	          if (ids.indexOf(choices[key].nodeId()) !== -1) {
	            json._choices[key] = choices[key].toJson();
	            const valEqDefault = choices[key].default() === choices[key].value();
	            const selectionNotMade = !choices[key].selectionMade();
	            if(selectionNotMade || valEqDefault) json._choices[key].value = undefined;
	          }
	        });
	        json._tree = wrapper.node.toJson();
	        json._connectionList = dataSync.toJson(wrapper.node.nodes());
	        return json;
	      }
	    }
	
	    function children(wrapper) {
	      return () => {
	        const children = [];
	        wrapper.node.forEachChild((child) => children.push(wrapNode(child)));
	        return children;
	      }
	    }
	
	    function addStaticMethods(wrapper) {
	      wrapper.structure = structure;
	      wrapper.choicesToSelectors = choicesToSelectors;
	      wrapper.setChoice = setChoice;
	      wrapper.children = children(wrapper);
	      wrapper.getByPath = getByPath;
	      wrapper.setDefault = setDefault;
	      wrapper.attachTree = attachTree(wrapper);
	      wrapper.toJson = toJson(wrapper);
	      wrapper.root = () => root;
	      wrapper.isComplete = isComplete;
	      wrapper.reachable = (wrap) => reachable(wrap || wrapper);
	      wrapper.decisions = decisions(wrapper);
	      wrapper.forPath = forPath;
	      wrapper.forEach = forEach;
	      wrapper.forAll = forAll;
	      wrapper.pathsToString = pathsToString;
	      wrapper.leaves = leaves;
	      wrapper.toString = () =>
	          wrapper.node.subtree(choicesToSelectors()).toString(null, 'LOGIC_TYPE');
	    }
	
	    function getTypeObj(wrapper) {
	      return choices[wrapper.name];
	    }
	
	    function addHelperMetrhods (wrapper) {
	      const node = wrapper.node;
	      const type = node.payload().LOGIC_TYPE;
	      const name = node.name;
	      if (choices[name] === undefined) {
	        choices[name] = new (LogicType.types[`${type}Logic`])(wrapper);
	      }
	      const typeObj = choices[name];
	      wrapper.name = name;
	      wrapper.getTypeObj = () => getTypeObj(wrapper);
	      wrapper.value = typeObj.value;
	      wrapper.payload = () => node.payload();
	      wrapper.options = typeObj.options;
	      wrapper.optional = typeObj.optional;
	      wrapper.default = typeObj.default;
	      wrapper.selector = typeObj.selector;
	      wrapper.addChildren = addChildrenFunc(wrapper);
	      wrapper.valueSync = (w) => dataSync.valueSync(typeObj, w.getTypeObj());
	      wrapper.defaultSync = (w) => dataSync.defaultSync(typeObj, w.getTypeObj());
	      wrapper.valueUpdate = (value) => dataSync.valueUpdate(value, typeObj);
	      wrapper.defaultUpdate = (value) => dataSync.defaultUpdate(value, typeObj);
	    }
	
	    function attachTree(wrapper) {
	      return (tree) => {
	        const json = tree.toJson();
	        return incorrperateJsonNodes(json, wrapper.node);
	      }
	    }
	
	    function addTypeFunction(type, wrapper) {
	      wrapper[type.toLowerCase()] = (name, payload) => {
	        payload = typeof formatPayload === 'function' ?
	                          formatPayload(name, payload || {}, wrapper) : payload || {};
	        payload.LOGIC_TYPE = type;
	        let newWrapper;
	        if (root === undefined) {
	          root = wrapper;
	          root.node = new DecisionTree(name, payload);
	          root.payload = root.node.payload;
	          newWrapper = root;
	        } else if (getByName(name)) {
	          newWrapper = wrapNode(wrapper.node.then(name));
	        } else {
	          wrapper.node.addState(name, payload);
	          newWrapper = wrapNode(wrapper.node.then(name));
	        }
	        return newWrapper;
	      }
	    }
	
	    function getNode(nodeOrwrapperOrId) {
	      switch (nodeOrwrapperOrId.constructor.name) {
	        case 'DecisionNode':
	          return nodeOrwrapperOrId;
	        case 'LogicWrapper':
	          return nodeOrwrapperOrId.node;
	        default:
	          const node = DecisionTree.DecisionNode.get(nodeOrwrapperOrId);
	          if (node) return node;
	          return nodeOrwrapperOrId;
	      }
	    }
	
	    function get(nodeOidOwrapper) {
	      if (nodeOidOwrapper === undefined) return undefined;
	      const node = getNode(nodeOidOwrapper);
	      if (node instanceof DecisionTree.DecisionNode) {
	        return wrapperMap[node.nodeId()];
	      } else {
	        return wrapperMap[node];
	      }
	    }
	
	    const set = (wrapper) =>
	        wrapperMap[wrapper.node.nodeId()] = wrapper;
	    this.get = get;
	
	    function wrapNode(node) {
	      let wrapper = get(node);
	      if (wrapper) return wrapper;
	      wrapper = new LogicWrapper(node);
	      if (node === undefined) {
	        wrapper.toString = () =>
	          root !== undefined ? root.toString() : 'Empty Tree';
	      }
	      if (node === undefined || node.payload().LOGIC_TYPE !== 'Leaf') {
	        addTypeFunction('Select', wrapper);
	        addTypeFunction('Multiselect', wrapper);
	        addTypeFunction('Conditional', wrapper);
	        addTypeFunction('Leaf', wrapper);
	        addTypeFunction('Branch', wrapper);
	      }
	      addStaticMethods(wrapper);
	      if (node && node.payload().LOGIC_TYPE !== undefined) {
	        addHelperMetrhods(wrapper);
	        set(wrapper);
	      }
	      return wrapper;
	    }
	
	    function updateChoices(jsonChoices) {
	      const keys = Object.keys(jsonChoices);
	      keys.forEach((key) =>
	          choices[key].fromJson(jsonChoices[key]));
	    }
	
	    function incorrperateJsonNodes(json, node) {
	      const decisionTree = new DecisionTree(json._tree);
	
	      let newNode;
	      if (node !== undefined) {
	        newNode = node.attachTree(decisionTree);
	      } else {
	        root = wrapNode(decisionTree);
	        rootWrapper.node = root.node;
	        newNode = root.node;
	      }
	      newNode.forEach((n) =>
	          wrapNode(n));
	      dataSync.fromJson(json._connectionList);
	      updateChoices(json._choices);
	      return node;
	    }
	
	    let rootWrapper = wrapNode();
	    if (formatPayload && formatPayload._TYPE === this.constructor.name) incorrperateJsonNodes(formatPayload);
	    return rootWrapper;
	  }
	}
	
	LogicTree.LogicWrapper = LogicWrapper;
	
	module.exports = LogicTree;
	
});


RequireJS.addFunction('./public/js/utils/custom-event-delay.js',
function (require, exports, module) {
	

	
	
	class CustomEvent {
	  constructor(name, delay) {
	    if (delay === undefined) delay = 0;
	    let triggerId = 0;
	    const watchers = [];
	    this.name = name;
	
	    let lastTriggerTime;
	    let lastTriggerId;
	    const runFuncs = (e, detail, tId) => {
	      const time = new Date().getTime();
	      if (lastTriggerId === tId ) {
	        if (lastTriggerTime + delay < time) {
	          watchers.forEach((func) => func(e, detail));
	        } else {
	          setTimeout(() => {
	            runFuncs(e, detail, tId);
	          }, delay);
	        }
	      }
	    }
	
	    this.on = function (func) {
	      if ((typeof func) === 'function') {
	        watchers.push(func);
	      } else {
	        return 'on' + name;
	      }
	    }
	
	    this.trigger = function (element, detail) {
	      element = element ? element : window;
	      lastTriggerTime = new Date().getTime();
	      const tId = triggerId + 1;
	      triggerId += 1;
	      lastTriggerId = tId;
	      runFuncs(element, detail, tId);
	      this.event.detail = detail;
	      if(document.createEvent){
	          element.dispatchEvent(this.event);
	      } else {
	          element.fireEvent("on" + this.event.eventType, this.event);
	      }
	    }
	//https://stackoverflow.com/questions/2490825/how-to-trigger-event-in-javascript
	    this.event;
	    if(document.createEvent){
	        this.event = document.createEvent("HTMLEvents");
	        this.event.initEvent(name, true, true);
	        this.event.eventName = name;
	    } else {
	        this.event = document.createEventObject();
	        this.event.eventName = name;
	        this.event.eventType = name;
	    }
	  }
	}
	
	module.exports = CustomEvent;
	
});


RequireJS.addFunction('./public/js/utils/custom-event.js',
function (require, exports, module) {
	

	
	
	class CustomEvent {
	  constructor(name) {
	    const watchers = [];
	    this.name = name;
	
	    const runFuncs = (elem, detail) =>
	    watchers.forEach((func) => {
	      try {
	        func(elem, detail);
	      } catch (e) {
	        console.error(e);
	      }
	    });
	
	
	    this.on = function (func) {
	      if ((typeof func) === 'function') {
	        watchers.push(func);
	      } else {
	        return 'on' + name;
	      }
	    }
	
	    this.trigger = function (element, detail) {
	      element = element ? element : window;
	      runFuncs(element, detail);
	      this.event.detail = detail;
	      if(document.createEvent){
	          element.dispatchEvent(this.event);
	      } else {
	          element.fireEvent("on" + this.event.eventType, this.event);
	      }
	    }
	//https://stackoverflow.com/questions/2490825/how-to-trigger-event-in-javascript
	    this.event;
	    if(document.createEvent){
	        this.event = document.createEvent("HTMLEvents");
	        this.event.initEvent(name, true, true);
	        this.event.eventName = name;
	    } else {
	        this.event = document.createEventObject();
	        this.event.eventName = name;
	        this.event.eventType = name;
	    }
	  }
	}
	
	CustomEvent.all = (obj, ...eventNames) => {
	  if (obj.on === undefined) obj.on = {};
	  if (obj.trigger === undefined) obj.trigger = {};
	  for (let index = 0; index < eventNames.length; index++) {
	    const name = eventNames[index];
	    const e = new CustomEvent(name);
	    obj.on[name] = e.on;
	    obj.trigger[name] = (...args) => e.trigger.apply(e, args);
	  }
	}
	
	module.exports = CustomEvent;
	
});


RequireJS.addFunction('./public/js/utils/data-sync.js',
function (require, exports, module) {
	

	class DataSync {
	  constructor(idAttr, getById) {
	    let connections = {};
	    let lastValue = {};
	    let idMap = {};
	
	    const getId = (objOid) => !(objOid instanceof Object) ? objOid :
	      ((typeof objOid[idAttr] === 'function' ? objOid[idAttr]() : objOid[idAttr]));
	
	    const getArray = (elems) => !elems ? [] : (elems.length === 1 ? elems[0] : elems);
	
	
	    function makeSyncronous(key,...objOids) {
	      objOids = getArray(objOids);
	      for (let index = 1; index < objOids.length; index += 1) {
	        let id;
	        const obj1Id = getId(objOids[index - 1]);
	        const obj2Id = getId(objOids[index]);
	        idMap[obj1Id] = idMap[obj1Id] || {};
	        idMap[obj2Id] = idMap[obj2Id] || {};
	        if (idMap[obj1Id][key] === undefined) {
	          if (idMap[obj2Id][key] === undefined) {
	            id = String.random();
	          } else {
	            id = idMap[obj2Id][key];
	          }
	        } else { id = idMap[obj1Id][key]; }
	        idMap[obj1Id][key] = id;
	        idMap[obj2Id][key] = id;
	        connections[id] = connections[id] || [];
	        if (connections[id].indexOf(obj1Id) === -1) {
	          connections[id].push(obj1Id)
	        }
	        if (connections[id].indexOf(obj2Id) === -1) {
	          connections[id].push(obj2Id)
	        }
	      }
	    }
	
	    function unSync(key,...objOids) {
	      objOids = getArray(objOids);
	      for (let index = 1; index < objOids.length; index += 1) {
	        const id = getId(objOids[index]);
	        const connId = idMap[id][key];
	        const conns = connections[connId];
	        let tIndex;
	        while ((tIndex = conns.indexOf(id)) !== -1) conns.split(tIndex, 1);
	        delete idMap[id][key];
	      }
	    }
	
	    function update(key, value, objOid) {
	      const id = getId(objOid);
	      if (!idMap[id] || !idMap[id][key]) return;
	      const connId = idMap[id] && idMap[id][key];
	      if (connId === undefined) return;
	      if (lastValue[connId] !== value) {
	        lastValue[connId] = value;
	        const objIds = connections[connId];
	        for (let index = 0; objIds && index < objIds.length; index ++) {
	          const obj = getById(objIds[index]);
	          if (obj !== undefined) obj[key](value);
	        }
	      }
	    }
	
	    function shouldRun(hasRan, validIds, id) {
	      return !hasRan && (validIds === null || validIds.indexOf(id) !== -1);
	    }
	
	    function forEach(func, ...objOids) {
	      objOids = getArray(objOids);
	      let alreadyRan = {};
	      let validIds = objOids === undefined ? null :
	                      objOids.map((objOid) => getId(objOid));
	      let ids = Object.keys(idMap);
	      for (let index = 0; index < ids.length; index += 1) {
	        const id = ids[index];
	        const idKeys = Object.keys(idMap[id]);
	        for (let iIndex = 0; iIndex < idKeys.length; iIndex += 1) {
	          const idKey = idKeys[iIndex];
	          const connectionId = idMap[id][idKey];
	          if (shouldRun(alreadyRan[connectionId], validIds, id)) {
	            const connIds = connections[connectionId];
	            const applicableConnections = [];
	            for (let cIndex = 0; cIndex < connIds.length; cIndex += 1) {
	              if (shouldRun(alreadyRan[connectionId], validIds, id)) {
	                applicableConnections.push(connIds[cIndex]);
	              }
	            }
	            if (applicableConnections.length === 0) throw new Error('This should never happen');
	            func(idKey, applicableConnections);
	            alreadyRan[connectionId] = true;
	          }
	        }
	      }
	    }
	
	    function fromJson(connections) {
	      const keys = Object.keys(connections);
	      keys.forEach((key) => {
	        this.addConnection(key);
	        const groups = connections[key];
	        groups.forEach((group) => {
	          this[`${key}Sync`](group);
	        });
	      });
	    }
	
	
	    function toJson(...objOids) {
	      objOids = getArray(objOids);
	      const connects = {};
	      forEach((key, connections) => {
	        if (connects[key] === undefined) connects[key] = [];
	        connects[key].push(connections);
	      }, ...objOids);
	      return connects;
	    }
	
	    this.addConnection = (key) => {
	      this[`${key}Sync`] = (...objOids) => makeSyncronous(key, ...objOids);
	      this[`${key}UnSync`] = (...objOids) => makeSyncronous(key, ...objOids);
	      this[`${key}Update`] = (value, objOid) => update(key,value, objOid);
	    }
	    this.toJson = toJson;
	    this.fromJson = fromJson;
	  }
	}
	
	module.exports = DataSync;
	
});


RequireJS.addFunction('./public/js/utils/decision-tree.js',
function (require, exports, module) {
	

	const Lookup = require('./object/lookup')
	const REMOVAL_PASSWORD = String.random();
	
	// terminology
	// name - String to define state;
	// payload - data returned for a given state
	//             - @_UNIQUE_NAME_GROUP - An Identifier used to insure all nodes of multople trees have a unique name.
	//                          note: only applicable on root node. governs entire tree
	// stateObject - object defining states {name: [payload]...}
	// states - array of availible state names.
	// node - {name, states, payload, then, addState, addStates};
	// then(name) - a function to set a following state.
	// next(name) - a function to get the next state.
	// back() - a function to move back up the tree.
	// top() - a function to get root;
	// subtree(conditions, parent) - returns a subtree.
	//    @conditions - object identifying conditions for each name or _DEFAULT for undefined
	//    @parent - can be used to atach a copy to another branch or tree
	// returns all functions return current node;
	class DecisionNode extends Lookup{
	  constructor(tree, name, instancePayload, parent) {
	    super(instancePayload && instancePayload._nodeId ?
	              instancePayload._nodeId : String.random(7));
	    Object.getSet(this, 'name');
	    const stateMap = {};
	    let jump;
	    let isComplete = false; // null : requires evaluation
	    instancePayload = instancePayload || {};
	    const formatId = (nodeId) =>
	      nodeId.replace(/^decision-node-(.*)$/, '$1') || nodeId;
	    const instance = this;
	    this.nodeId = () => DecisionNode.decode(this.id()).id;
	    instancePayload._nodeId = this.nodeId();
	    tree.nodeMap[this.nodeId()];
	    // tree.nodeMap[instancePayload._nodeId] = this;
	    this.isTree = (t) => t === tree;
	    this.setValue = (key, value) => instancePayload[key] = value;
	    this.getByName = (n) => tree.stateTemplates[n];
	    this.tree = () => tree;
	    this.getNode = (nodeOid) => nodeOid instanceof DecisionNode ? nodeOid : tree.idMap[formatId(nodeOid)];
	    this.name = name.toString();
	    this.states = () => Object.values(stateMap);
	    this.instancePayload = () => instancePayload;
	    this.set = (key, value) => instancePayload[key] = value;
	    this.fromJson = undefined;
	    this.instanceCount = (n) => tree.instanceCount(n || this.name);
	    this.lastInstance = () => tree.instanceCount(this.name) === 1;
	    this.stateDefined = tree.stateDefined;
	    this.payload = () => {
	      const copy = JSON.clone(tree.stateConfigs[name]) || {};
	      Object.keys(instancePayload).forEach((key) => {
	        copy[key] = instancePayload[key];
	      });
	      return copy;
	    };
	    this.jump = (name) => {
	      if (name) jump = tree.getState(name, parent);
	      return jump;
	    };
	    this.getNodeByPath = tree.getNodeByPath;
	    this.isLeaf = () => Object.keys(stateMap).length === 0;
	    this.stateNames = () => Object.keys(stateMap);
	    this.structureChanged = () => {
	      isComplete = null;
	      if (parent) parent.structureChanged();
	    }
	    this.remove = (node, password) => {
	      if (node === undefined) {
	        tree.remove(this, REMOVAL_PASSWORD);
	        tree = undefined;
	      } else if (REMOVAL_PASSWORD !== password) {
	        throw new Error('Attempting to remove node without going through the proper process find the node object you want to remove and call node.remove()');
	      } else {
	        let removed = false;
	        Object.keys(stateMap).forEach((name) => {
	          const realNode = stateMap[name];
	          if (realNode === node) {
	            delete stateMap[name];
	            removed = true;
	          }
	        });
	      }
	    }
	
	    this.validState = (name) => name !== undefined && instance.stateNames().indexOf(name.toString()) !== -1;
	
	    function attachTree(t) {
	      return t.subtree(null, instance, tree);
	    }
	
	    this.then = (name, instancePayload, conditional) => {
	      if (name instanceof DecisionNode) return attachTree(name);
	      if (Array.isArray(name)) {
	        const returnNodes = [];
	        for (let index = 0; index < name.length; index += 1) {
	          returnNodes.push(this.then(name[index]));
	        }
	        return returnNodes;
	      }
	      this.structureChanged();
	      const newState = tree.getState(name, this, instancePayload);
	      if ((typeof conditional) === 'string') {
	        const stateId = `${this.name}:${conditional}`;
	        stateMap[stateId] = tree.getState(stateId, this, instancePayload);
	        stateMap[stateId].jump(newState);
	      } else {
	        stateMap[name] = newState;
	      }
	      if (tree.stateTemplates[name] === undefined)
	        tree.stateTemplates[name] = newState;
	      return newState === undefined ? undefined : newState.jump() || newState;
	    }
	    this.addState = (name, payload) => tree.addState(name, payload) && this;
	    this.addStates = (sts) => tree.addStates(sts) && this;
	    this.next = (name) => {
	      const state = stateMap[name];
	      return state === undefined ? undefined : state.jump() || state;
	    }
	
	    this.nameTaken = tree.nameTaken;
	
	    this.back = () => parent;
	    this.top = () => tree.rootNode;
	    this.isRoot = () => !(parent instanceof DecisionNode)
	
	    this.getRoot = () => {
	      const root = this;
	      while (!root.isRoot()) root = root.back();
	      return root;
	    }
	
	    this.copy = (t) => new DecisionNode(t || tree, this.name, instancePayload);
	
	    // Breath First Search
	    this.forEach = (func) => {
	      const stateKeys = Object.keys(stateMap);
	      func(this);
	      for(let index = 0; index < stateKeys.length; index += 1) {
	        const state = stateMap[stateKeys[index]];
	        state.forEach(func);
	      }
	    }
	
	    this.forEachChild = (func) => {
	      const stateKeys = Object.keys(stateMap);
	      for(let index = 0; index < stateKeys.length; index += 1) {
	        const state = stateMap[stateKeys[index]];
	        func(state);
	      }
	    }
	    this.children = () => {
	      const children = [];
	      this.forEachChild((child) => children.push(child));
	      return children;
	    }
	
	    this.map = (func) => {
	      const ids = [];
	      this.forEach((node) => ids.push(func(node)));
	      return ids;
	    }
	
	    this.nodes = () => {
	      return this.map((node) => node);
	    }
	
	    this.leaves = () => {
	      const leaves = [];
	      this.forEach((node) => {
	        if (node.isLeaf()) leaves.push(node);
	      });
	      return leaves;
	    }
	
	    this.addChildren = (nodeId) => {
	      const orig = this.getNode(nodeId);
	      const states = orig.states();
	      states.forEach((state) => this.then(state));
	      return this;
	    }
	
	    this.stealChildren = (nodeOid) => {
	      return this.getNode(nodeOid).addChildren(this);
	    }
	
	    this.conditionsSatisfied = tree.conditionsSatisfied;
	
	    this.change = (name) => {
	      const newNode = this.back().then(name);
	      const root = this.top();
	      newNode.stealChildren(this);
	      this.remove();
	    }
	
	    this.subtree = (conditions, parent, t) => {
	      if (parent && !parent.conditionsSatisfied(conditions, this)) return undefined
	      conditions = conditions instanceof Object ? conditions : {};
	      const stateKeys = Object.keys(stateMap);
	      let copy;
	      if (parent === undefined) copy = this.copy(t);
	      else {
	        const target = t === undefined ? parent : t;
	        const nameTaken = target.nameTaken(this.name);
	        try {
	          if (!nameTaken) target.addState(this.name, tree.stateConfigs[this.name] || {});
	        } catch (e) {
	          target.nameTaken(this.name);
	          throw e;
	        }
	        copy = parent.then(this.name, instancePayload);
	      }
	
	      for(let index = 0; index < stateKeys.length; index += 1) {
	        const state = stateMap[stateKeys[index]];
	        state.subtree(conditions, copy, t);
	      }
	      return copy;
	    }
	
	    this.nodeOnlyToJson = (noStates) => {
	      const json = {nodeId: this.nodeId(), name, states: [],
	                    payload: Object.fromJson(instancePayload)};
	      if (noStates !== true) {
	        this.states().forEach((state) =>
	          json.states.push(state.nodeOnlyToJson()));
	      }
	      return json;
	    }
	    this.toJson = (noStates) => {
	      const json = tree.toJson(this, noStates);
	      json.name = this.name;
	      json.payload = Object.fromJson(instancePayload);
	      json.nodes = this.nodeOnlyToJson(noStates);
	      return json;
	    }
	
	    this.declairedName = tree.declairedName;
	    this.toString = (tabs, attr) => {
	      tabs = tabs || 0;
	      const tab = new Array(tabs).fill('  ').join('');
	      let str = `${tab}${this.name}`;
	      str += attr ? `) ${this.payload()[attr]}\n` : '\n';
	      const stateKeys = Object.keys(stateMap);
	      for(let index = 0; index < stateKeys.length; index += 1) {
	        str += stateMap[stateKeys[index]].toString(tabs + 1, attr);
	      }
	      return str;
	    }
	    this.attachTree = attachTree;
	    this.treeToJson = tree.toJson;
	    this.conditionsSatisfied = tree.conditionsSatisfied;
	  }
	}
	DecisionNode.DO_NOT_CLONE = true;
	DecisionNode.stateMap = {};
	
	
	class DecisionTree {
	  constructor(name, payload) {
	    let json;
	    if (name._TYPE === 'DecisionTree') {
	      json = name;
	      payload = json.payload;
	      name = json.name;
	    }
	    const names = {};
	    name = name || String.random();
	    payload = payload || {};
	    const stateConfigs = {};
	    const idMap = {};
	    this.idMap = idMap;
	    const nodeMap = {};
	    Object.getSet(this, {name, stateConfigs, payload});
	    const tree = this;
	    tree.stateTemplates = {};
	
	    this.nameTaken = (n) => Object.keys(tree.stateConfigs).indexOf(n) !== -1;
	
	    function addState(name, payload) {
	      if (tree.declairedName(name)) {
	        throw new Error('Name already declared: This requires unique naming possibly relitive to other trees use DecisionTree.undeclairedName(name) to validate names')
	      }
	      tree.declareName(name);
	      return stateConfigs[name] = payload;
	    }
	
	    function stateDefined(name) {
	      const exists = false;
	      tree.rootNode.forEach((node) =>
	        exists = exists || node.name === name);
	      return exists;
	    }
	
	    function instanceCount(name) {
	      let count = 0;
	      tree.rootNode.forEach((node) =>
	        count += node.name === name ? 1 : 0);
	      return count;
	    }
	
	    function remove(node, password) {
	      if (!node.isTree(tree)) throw new Error('Node has already been removed');
	      let removeList = [node];
	      let index = 0;
	      let currNode;
	      while (currNode = removeList[index]) {
	          currNode.back().remove(currNode, password);
	          removeList = removeList.concat(currNode.states());
	          index += 1;
	      }
	      names[node.name] = undefined;
	    }
	
	    function addStates(sts) {
	      if ((typeof sts) !== 'object') throw new Error('Argument must be an object\nFormat: {[name]: payload...}');
	      const keys = Object.keys(sts);
	      keys.forEach((key) => addState(key, sts[key]));
	    }
	
	    function getState(name, parent, instancePayload) {
	      const node = new DecisionNode(tree, name, instancePayload, parent);
	      idMap[node.nodeId()] = node;
	      return node;
	    }
	
	    const toJson = this.toJson;
	    this.toJson = (node, noStates) => {
	      node = node || this.rootNode;
	      const json = {stateConfigs: {}, _TYPE: this.constructor.name};
	      if (noStates) {
	        json.stateConfigs[name] = stateConfigs[node.name];
	      } else {
	        const names = Array.isArray(node) ? node : node.map((n) => n.name);
	        names.forEach((name) => {
	          const s = stateConfigs[name];
	          json.stateConfigs[name] = s && s.toJson ? s.toJson() : s;
	        });
	      }
	
	      return json;
	    }
	
	    function conditionsSatisfied(conditions, state) {
	      const parent = state.back()
	      if (parent === null) return true;
	      conditions = conditions || {};
	      const cond = conditions[state.name] === undefined ?
	                    conditions._DEFAULT : conditions[state.name];
	      const func = (typeof cond) === 'function' ? cond : null;
	      if (func && !func(state)) {
	        return false;
	      }
	      return parentConditionsSatisfied(conditions, state);
	    }
	
	    function parentConditionsSatisfied(conditions, state) {
	      if ((typeof state.back) !== 'function') {
	        console.log('here')
	      }
	      const parent = state.back();
	      if (parent === null) return true;
	      conditions = conditions || {};
	      const cond = conditions[parent.name] === undefined ?
	                    conditions._DEFAULT : conditions[parent.name];
	      const noRestrictions = cond === undefined;
	      const regex = cond instanceof RegExp ? cond : null;
	      const target = (typeof cond) === 'string' ? cond : null;
	      const func = (typeof cond) === 'function' ? cond : null;
	      if (noRestrictions || (regex && state.name.match(regex)) ||
	              (target !== null && state.name === target) ||
	              (func && func(state))) {
	        return parentConditionsSatisfied(conditions, parent);
	      }
	      return false;
	    }
	
	    function getNodeByPath(...path) {
	      let currNode = tree.rootNode;
	      path.forEach((name) => currNode = currNode.next(name));
	      return currNode;
	    }
	
	    this.remove = remove;
	    this.getNodeByPath = getNodeByPath;
	    this.conditionsSatisfied = conditionsSatisfied;
	    this.getState = getState;
	    this.addState = addState;
	    this.addStates = addStates;
	    this.nodeMap = nodeMap;
	    this.instanceCount = instanceCount;
	    this.stateConfigs = stateConfigs;
	
	    this.rootNode = new DecisionNode(tree, name, payload, null);
	    idMap[this.rootNode.nodeId()] = this.rootNode;
	    payload._nodeId = this.rootNode.nodeId();
	    tree.declareName = (name) => names[name] = true;
	    tree.declairedName = (name) => !!names[name];
	
	    if (json !== undefined) {
	      addStates(Object.fromJson(json.stateConfigs));
	      let index = 0;
	      let jsons = [json.nodes];
	      let currJson;
	      nodeMap[jsons[index].name] = this.rootNode;
	      while (currJson = jsons[index]) {
	        currJson.states.forEach((state) => {
	          jsons.push(state);
	          state.instancePayload = state.instancePayload || {};
	          state.instancePayload._nodeId = state.nodeId;
	          nodeMap[state.name] = nodeMap[currJson.name].then(state.name, state.instancePayload);
	        });
	        index++;
	      }
	    }
	
	    return this.rootNode;
	  }
	}
	
	DecisionTree.DecisionNode = DecisionNode;
	module.exports = DecisionTree;
	
});


RequireJS.addFunction('./public/js/utils/dom-utils.js',
function (require, exports, module) {
	
const frag = document.createDocumentFragment();
	function validSelector (selector) {
	  try {
	    frag.querySelector(selector)
	    return selector;
	  } catch (e) {
	    const errMsg = `Invalid Selector: '${selector}'` ;
	    console.error(errMsg);
	    return null;
	  }
	};
	const VS = validSelector;
	
	function parseSeperator(string, seperator, isRegex) {
	  if (isRegex !== true) {
	    seperator = seperator.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&');
	  }
	  var keyValues = string.match(new RegExp('.*?=.*?(' + seperator + '|$)', 'g'));
	  var json = {};
	  for (let index = 0; keyValues && index < keyValues.length; index += 1) {
	    var split = keyValues[index].match(new RegExp('\\s*(.*?)\\s*=\\s*(.*?)\\s*(' + seperator + '|$)'));
	    if (split) {
	      json[split[1]] = split[2];
	    }
	  }
	  return json;
	}
	
	
	const du = {create: {}, class: {}, cookie: {}, param: {}, style: {}, is: {},
	      scroll: {}, input: {}, on: {}, move: {}, url: {}, fade: {}, position: {}};
	du.find = (selector) => document.querySelector(selector);
	du.find.all = (selector) => document.querySelectorAll(selector);
	du.validSelector = VS;
	
	du.create.element = function (tagname, attributes) {
	  const elem = document.createElement(tagname);
	  const keys = Object.keys(attributes || {});
	  keys.forEach((key) => elem.setAttribute(key, attributes[key]));
	  return elem;
	}
	
	// Ripped off of: https://ourcodeworld.com/articles/read/189/how-to-create-a-file-and-generate-a-download-with-javascript-in-the-browser-without-a-server
	du.download = (filename, contents) => {
	  var element = document.createElement('a');
	  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(contents));
	  element.setAttribute('download', filename);
	
	  element.style.display = 'none';
	  document.body.appendChild(element);
	
	  element.click();
	
	  document.body.removeChild(element);
	}
	
	function keepInBounds (elem, minimum) {
	  function checkDir(dir) {
	    const rect = elem.getBoundingClientRect();
	    if (rect[dir] < minimum) {
	      elem.style[dir] = minimum + 'px';
	    }
	  }
	  checkDir('left');
	  checkDir('right');
	  checkDir('top');
	  checkDir('bottom');
	}
	
	du.zIndex = function (elem) {
	  return Number.parseInt(document.defaultView.getComputedStyle(elem, null)
	    .getPropertyValue("z-index"), 10);
	}
	du.move.inFront = function (elem, timeout) {
	  setTimeout(function () {
	    var exclude = du.find.downAll('*', elem);
	    exclude.push(elem);
	    var elems = document.querySelectorAll('*');
	    var highest = Number.MIN_SAFE_INTEGER;
	    for (var i = 0; i < elems.length; i++) {
	      const e = elems[i];
	      if (exclude.indexOf(e) === -1) {
	        var zindex = du.zIndex(e);
	      }
	      if (zindex > highest) highest = zindex;
	    }
	    if (highest < Number.MAX_SAFE_INTEGER) elem.style.zIndex = highest + 1;
	  },  timeout || 0);
	}
	
	du.move.relitive = function (elem, target, direction, props) {
	  props = props || {};
	  const clientHeight = document.documentElement.clientHeight;
	  const clientWidth = document.documentElement.clientWidth;
	  const rect = target.getBoundingClientRect();
	
	  const style = {};
	  const padding = props.padding || 5;
	  style.cursor = props.cursor || 'unset';
	  style.padding = `${padding}px`;
	  style.position = props.position || 'absolute';
	  style.backgroundColor = props.backgroundColor || 'transparent';
	
	  const scrollY =  props.isFixed ? 0 : window.scrollY;
	  const scrollX =  props.isFixed ? 0 : window.scrollX;
	  const isTop = direction.indexOf('top') !== -1;
	  const isBottom = direction.indexOf('bottom') !== -1;
	  const isRight = direction.indexOf('right') !== -1;
	  const isLeft = direction.indexOf('left') !== -1;
	  if (isTop) {
	    style.top = rect.top - elem.clientWidth - padding + scrollY;
	  } else { style.top = 'unset'; }
	
	  if (isBottom) {
	    style.bottom = (clientHeight - rect.bottom - elem.clientHeight) - padding - scrollY + 'px';
	  } else { style.bottom = 'unset'; }
	
	  if (!isTop && !isBottom) {
	    style.bottom = (clientHeight - rect.bottom + rect.height/2 - elem.clientHeight / 2) - padding - scrollY + 'px';
	  }
	
	  if (isRight) {
	    style.right = clientWidth - rect.right - elem.clientWidth - padding - scrollX + 'px';
	  } else { style.right = 'unset'; }
	
	  if (isLeft) {
	    style.left = rect.left - padding - elem.clientWidth + scrollX;
	  } else { style.left = 'unset'; }
	
	  if (!isLeft && ! isRight) {
	    style.right = clientWidth - rect.right + rect.width/2 - elem.clientWidth/2 - padding - scrollX + 'px';
	  }
	
	  du.style(elem, style);
	  keepInBounds(elem, padding);
	}
	
	du.move.below = function (elem, target) {
	  du.move.relitive(elem, target, 'bottom');
	}
	
	du.move.above = function (elem, target) {
	  du.move.relitive(elem, target, 'bottom');
	}
	
	du.find.up = function (selector, node) {
	  selector = VS(selector);
	  if (node instanceof HTMLElement) {
	    if (node.matches(selector)) {
	      return node;
	    } else {
	      return du.find.up(selector, node.parentNode);
	    }
	  }
	}
	
	function visibility(hide, targets) {
	  targets = Array.isArray(targets) ? targets : [targets];
	  for (let index = 0; index < targets.length; index += 1) {
	    const target = targets[index];
	    if ((typeof target) === 'string') {
	      targets = targets.concat(Array.from(document.querySelectorAll(target)));
	    } else if (target instanceof HTMLElement) {
	      target.hidden = hide;
	    } else if (Array.isArray(target) || target instanceof NodeList || target instanceof HTMLCollection) {
	      targets = targets.concat(Array.from(target));
	    }
	  }
	}
	
	du.hide = (...targets) => visibility(true, targets);
	du.show = (...targets) => visibility(false, targets);
	
	du.id = function (id) {return document.getElementById(id);}
	
	du.appendError = (target, message) => {
	  return function (e) {
	    const parent = target.parentNode;
	    const error = document.createElement('div');
	    error.className = 'error';
	    error.innerHTML = message;
	    parent.insertBefore(error, target.nextElementSibling)
	  }
	}
	
	const jsAttrReg = /<([a-zA-Z]{1,}[^>]{1,})(\s|'|")on[a-z]{1,}=/;
	du.innerHTML = (text, elem) => {
	  if (text === undefined) return undefined;
	  const clean = text.replace(/<script(| [^<]*?)>/, '').replace(jsAttrReg, '<$1');
	  if (clean !== text) {
	    throw new JsDetected(text, clean);
	  }
	  if (elem !== undefined) elem.innerHTML = clean;
	  return clean;
	}
	
	du.find.upAll = function(selector, node) {
	  const elems = [];
	  let elem = node;
	  selector = VS(selector);
	  while(elem = du.find.up(selector, elem)) {
	    elems.push(elem);
	    elem = elem.parentElement;
	  }
	  return elems;
	}
	
	du.depth = function(node) {return upAll('*', node).length};
	
	du.find.downInfo = function (selector, node, distance, leafSelector) {
	  const nodes = node instanceof HTMLCollection ? node : [node];
	  distance = distance || 0;
	  selector = VS(selector);
	
	  function recurse (node, distance) {
	    if (node instanceof HTMLElement) {
	      if (node.matches(selector)) {
	        return { node, distance, matches: [{node, distance}]};
	      }
	    }
	    return { distance: Number.MAX_SAFE_INTEGER, matches: [] };
	  }
	
	  let matches = [];
	  let found = { distance: Number.MAX_SAFE_INTEGER };
	  for (let index = 0; index < nodes.length; index += 1) {
	    const currNode = nodes[index];
	    const maybe = recurse(currNode, ++distance);
	    if (maybe.node) {
	      matches = matches.concat(maybe.matches);
	      found = maybe.distance < found.distance ? maybe : found;
	
	    }
	    if (!leafSelector || !currNode.matches(leafSelector)) {
	      const childRes = du.find.downInfo(selector, currNode.children, distance + 1, leafSelector);
	      matches = matches.concat(childRes.matches);
	      found = childRes.distance < found.distance ? childRes : found;
	    }
	  }
	  found.matches = matches
	  found.list = matches.map((match) => match.node);
	  return found;
	}
	
	du.find.down = function(selector, node) {return du.find.downInfo(selector, node).node};
	du.find.downAll = function(selector, node) {return du.find.downInfo(selector, node).list};
	
	du.find.closest = function(selector, node) {
	  const visited = [];
	  selector = VS(selector);
	  function recurse (currNode, distance) {
	    let found = { distance: Number.MAX_SAFE_INTEGER };
	    if (!currNode || (typeof currNode.matches) !== 'function') {
	      return found;
	    }
	    visited.push(currNode);
	    if (currNode.matches(selector)) {
	      return { node: currNode, distance };
	    } else {
	      for (let index = 0; index < currNode.children.length; index += 1) {
	        const child = currNode.children[index];
	        if (visited.indexOf(child) === -1) {
	          const maybe = recurse(child, distance + index + 1);
	          found = maybe && maybe.distance < found.distance ? maybe : found;
	        }
	      }
	      if (visited.indexOf(currNode.parentNode) === -1) {
	        const maybe = recurse(currNode.parentNode, distance + 1);
	        found = maybe && maybe.distance < found.distance ? maybe : found;
	      }
	      return found;
	    }
	  }
	
	  return recurse(node, 0).node;
	}
	
	
	const selectors = {};
	let matchRunIdCount = 0;
	function getTargetId(target) {
	  if((typeof target.getAttribute) === 'function') {
	    let targetId = target.getAttribute('du-match-run-id');
	    if (targetId === null || targetId === undefined) {
	      targetId = matchRunIdCount + '';
	      target.setAttribute('du-match-run-id', matchRunIdCount++)
	    }
	    return targetId;
	  }
	  return target === document ?
	        '#document' : target === window ? '#window' : undefined;
	}
	
	
	
	function runMatch(event) {
	  const  matchRunTargetId = getTargetId(event.currentTarget);
	  const selectStrs = Object.keys(selectors[matchRunTargetId][event.type]);
	  selectStrs.forEach((selectStr) => {
	    const target = du.find.up(selectStr, event.target);
	    const everything = selectStr === '*';
	    if (everything || target) {
	      selectors[matchRunTargetId][event.type][selectStr].forEach((func) => func(target, event));
	    }
	  })
	}
	
	du.is.hidden = function (target) {
	  const elem = du.find.up('[hidden]', target);
	  return elem !== undefined;
	}
	
	du.class.add = function(target, clazz) {
	  du.class.remove(target, clazz);
	  target.className += ` ${clazz}`;
	}
	
	du.class.swap = function(target, newClass, oldClass) {
	  du.class.remove(target, oldClass);
	  du.class.add(target, newClass)
	}
	
	function classReg(clazz) {
	  return new RegExp(`(^| )(${clazz}( |$)){1,}`, 'g');
	}
	
	du.class.remove = function(target, clazz) {
	  if (!(target instanceof HTMLElement)) return;
	  target.className = target.className.replace(classReg(clazz), ' ').trim();
	}
	
	du.class.has = function(target, clazz) {
	  return target.className.match(classReg(clazz));
	}
	
	du.class.toggle = function(target, clazz) {
	  if (du.class.has(target, clazz)) du.class.remove(target, clazz);
	  else du.class.add(target, clazz);
	}
	let lastKeyId;
	let keyPressId = 0;
	function onKeycombo(event, func, args) {
	  const keysDown = {};
	  const allPressed = () => {
	    let is = true;
	    const keys = Object.keys(keysDown);
	    const minTime = new Date().getTime() - 1000;
	    for (let index = 0; index < keys.length; index++) {
	      if (keysDown[keys[index]] < minTime) delete keysDown[keys[index]];
	    }
	    for (let index = 0; is && index < args.length; index += 1) {
	      is = is && keysDown[args[index]];
	    }
	    return is;
	  }
	  const keysString = () => Object.keys(keysDown).sort().join('/');
	  const setComboObj = (event) => {
	    const id = keysString;
	    const firstCall = lastKeyId !== id;
	    event.keycombonation = {
	      allPressed: allPressed(),
	      keysDown: JSON.clone(keysDown),
	      keyPressId: firstCall ? ++keyPressId : keyPressId,
	      firstCall, id
	    }
	  }
	
	  const keyup = (target, event) => {
	    delete keysDown[event.key];
	    setComboObj(event);
	    if (event.keycombonation.firstCall && args.length === 0) {
	      setComboObj(event);
	      func(target, event);
	    }
	  }
	  const keydown = (target, event) => {
	    keysDown[event.key] = new Date().getTime();
	    setComboObj(event);
	
	    if (event.keycombonation.firstCall && event.keycombonation.allPressed) {
	      func(target, event);
	    }
	  }
	  du.on.match('keyup', '*', keyup);
	  return {event: 'keydown', func: keydown};
	}
	
	const argEventReg = /^(.*?)(|:(.*))$/;
	function filterCustomEvent(event, func) {
	  const split = event.split(/[\(\),]/).filter(str => str);;
	  event = split[0];
	  const args = split.slice(1).map((str, i) => str === ' ' ? ' ' : str.trim());
	  let customEvent = {func, event};
	  switch (event) {
	    case 'enter':
	      customEvent.func = (target, event) => event.key === 'Enter' && func(target, event);
	      customEvent.event = 'keydown';
	      break;
	    case 'keycombo':
	      customEvent = onKeycombo(event, func, args);
	    break;
	  }
	  return customEvent;
	}
	
	du.on.match = function(event, selector, func, target) {
	  const events = event.split(':');
	  if (events.length > 1) return events.forEach((e) => du.on.match(e, selector, func, target));
	  const filter = filterCustomEvent(event, func);
	  target = target || document;
	  selector = VS(selector);
	  if (selector === null) return;
	  if ((typeof func) !== 'function') console.warn(`Attempting to create an event without calling function.\nevent: "${event}"\nselector: ${selector}`)
	  const  matchRunTargetId = getTargetId(target);
	  if (selectors[matchRunTargetId] === undefined) {
	    selectors[matchRunTargetId] = {};
	  }
	  if (selectors[matchRunTargetId][filter.event] === undefined) {
	    selectors[matchRunTargetId][filter.event] = {};
	    target.addEventListener(filter.event, runMatch);
	  }
	  if ( selectors[matchRunTargetId][filter.event][selector] === undefined) {
	    selectors[matchRunTargetId][filter.event][selector] = [];
	  }
	
	  const selectorArray = selectors[matchRunTargetId][filter.event][selector];
	  // if (selectorArray.indexOf(func) !== -1) {
	    selectorArray.push(filter.func);
	  // }
	}
	
	du.cookie.set = function(name, value, lifeMilliSecs) {
	  if (value instanceof Object) {
	    value = JSON.stringify(value);
	  }
	  const expireDate = new Date();
	  expireDate.setTime(expireDate.getTime() + (lifeMilliSecs || (8035200000))); //93 days by default
	  document.cookie = `${name}=${value}; expires=${expireDate.toUTCString()}`;
	}
	
	du.cookie.get = function(name, seperator) {
	  const cookie = parseSeperator(document.cookie, ';')[name];
	  if (seperator === undefined) return cookie;
	  const values = cookie === undefined ? [] : cookie.split(seperator);
	  if (arguments.length < 3) return values;
	  let obj = {};
	  for (let index = 2; index < arguments.length; index += 1) {
	    const key = arguments[index];
	    const value = values[index - 2];
	    obj[key] = value;
	  }
	  return obj;
	}
	
	du.url.breakdown = function () {
	  const breakdown = {};
	  const hashMatch = window.location.href.match(/(.*?)#(.*)/, '$1');
	  let noHash;
	  if (hashMatch) {
	    noHash = hashMatch[1];
	    breakdown.hashtag = hashMatch[2]
	  } else {
	    noHash = window.location.href;
	  }
	  const domainMatch = noHash.match(/(.*?):\/\/([^\/]*?)(:([0-9]{1,5})|)(\/[^?^#]*)/)
	  breakdown.protocol = domainMatch[1];
	  breakdown.domain = domainMatch[2];
	  breakdown.port = domainMatch[4] || undefined;
	  breakdown.path = domainMatch[5];
	
	  const urlMatch = noHash.match(/.*?:\/\/([^.]{1,})\.([^\/]*?)\.([^.^\/]{1,})(\/.*)/);
	  if (urlMatch) {
	    breakdown.subdomain = urlMatch[1];
	    breakdown.secondLevelDomain = urlMatch[2];
	    breakdown.topLevelDomaian = urlMatch[3]
	  }
	  breakdown.paramStr = noHash.substr(noHash.indexOf('?') + 1);
	
	  breakdown.params = parseSeperator(breakdown.paramStr, '&');
	  return breakdown;
	}
	
	du.url.build = function (b) {
	  const paramArray = [];
	  Object.keys(b.params).forEach((key) => paramArray.push(`${key}=${b.params[key]}`));
	  const paramStr = paramArray.length > 0 ? `?${paramArray.join('&')}` : '';
	  const portStr = b.port ? `:${b.port}` : '';
	  const hashStr = b.hashtag ? `#${b.hashtag}` : '';
	  return `${b.protocol}://${b.domain}${portStr}${b.path}${paramStr}${hashStr}`;
	}
	
	du.url.change = function (url) {
	  window.history.pushState(null,"", url);
	}
	
	du.param.get = function(name) {
	  let params = du.url.breakdown().params;
	  const value = params[name];
	  if (value === undefined) return undefined;
	  return decodeURI(value);
	}
	
	du.param.remove = function (name) {
	  const breakdown = du.url.breakdown();
	  delete breakdown.params[name];
	  du.url.change(du.url.build(breakdown));
	}
	
	du.style = function(elem, style, time) {
	  const save = {};
	  const keys = Object.keys(style);
	  keys.forEach((key) => {
	    save[key] = elem.style[key];
	    elem.style[key] = style[key];
	  });
	
	  if (time) {
	    setTimeout(() => {
	      keys.forEach((key) => {
	        elem.style[key] = save[key];
	      });
	    }, time);
	  }
	}
	
	function center(elem) {
	  const rect = elem.getBoundingClientRect();
	  const x = rect.x + (rect.height / 2);
	  const y = rect.y + (rect.height / 2);
	  return {x, y, top: rect.top};
	}
	
	du.scroll.can = function (elem) {
	    const horizontallyScrollable = elem.scrollWidth > elem.clientWidth;
	    const verticallyScrollable = elem.scrollHeight > elem.clientHeight;
	    return elem.scrollWidth > elem.clientWidth || elem.scrollHeight > elem.clientHeight;
	};
	
	du.scroll.parents = function (elem) {
	  let scrollable = [];
	  if (elem instanceof HTMLElement) {
	    if (du.scroll.can(elem)) {
	      scrollable.push(elem);
	    }
	    return du.scroll.parents(elem.parentNode).concat(scrollable);
	  }
	  return scrollable;
	}
	
	du.scroll.intoView = function(elem, divisor, delay, scrollElem) {
	  let scrollPidCounter = 0;
	  const lastPosition = {};
	  let highlighted = false;
	  function scroll(scrollElem) {
	    return function() {
	      const scrollCenter = center(scrollElem);
	      const elemCenter = center(elem);
	      const fullDist = Math.abs(scrollCenter.y - elemCenter.y);
	      const scrollDist = fullDist > 5 ? fullDist/divisor : fullDist;
	      const yDiff = scrollDist * (elemCenter.y < scrollCenter.y ? -1 : 1);
	      scrollElem.scroll(0, scrollElem.scrollTop + yDiff);
	      if (elemCenter.top !== lastPosition[scrollElem.scrollPid]
	            && (scrollCenter.y < elemCenter.y - 2 || scrollCenter.y > elemCenter.y + 2)) {
	        lastPosition[scrollElem.scrollPid] = elemCenter.top;
	        setTimeout(scroll(scrollElem), delay);
	      } else if(!highlighted) {
	        highlighted = true;
	        du.style.temporary(elem, 2000, {
	          borderStyle: 'solid',
	          borderColor: '#07ff07',
	          borderWidth: '5px'
	        });
	      }
	    }
	  }
	  const scrollParents = du.scroll.parents(elem);
	  scrollParents.forEach((scrollParent) => {
	    scrollParent.scrollPid = scrollPidCounter++;
	    setTimeout(scroll(scrollParent), 100);
	  });
	}
	
	du.fade.out = (elem, disapearAt, func) => {
	  const origOpacity = elem.style.opacity;
	  let stopFade = false;
	  function reduceOpacity () {
	    if (stopFade) return;
	    elem.style.opacity -= .005;
	    if (elem.style.opacity <= 0) {
	      elem.style.opacity = origOpacity;
	      func(elem);
	    } else {
	      setTimeout(reduceOpacity, disapearAt * 2 / 600 * 1000);
	    }
	  }
	
	  elem.style.opacity = 1;
	  setTimeout(reduceOpacity, disapearAt / 3 * 1000);
	  return () => {
	    stopFade = true;
	    elem.style.opacity = origOpacity;
	  };
	}
	
	
	
	du.cookie.remove = function (name) {
	  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:01 GMT;`;
	}
	
	let copyTextArea;
	du.copy = (textOelem) => {
	  if (copyTextArea === undefined) {
	    copyTextArea = du.create.element('textarea', {id: 'du-copy-textarea'});
	    document.body.append(copyTextArea);
	  }
	
	  copyTextArea.value = textOelem;
	  copyTextArea.innerText = textOelem;
	
	  copyTextArea.select();
	  document.execCommand("copy");
	}
	
	const attrReg = /^[a-zA-Z-]*$/;
	du.uniqueSelector = function selector(focusElem) {
	  if (!focusElem) return '';
	  let selector = '';
	  let percice;
	  let attrSelector;
	  let currSelector;
	  let currElem = focusElem;
	  do {
	    attrSelector = `${currElem.tagName}${currElem.id ? '#' + currElem.id : ''}`;
	
	    currSelector = `${attrSelector}${selector}`;
	    let found = du.find.all(currSelector);
	    percice = found && (found.length === 1 || (selector.length > 0 && found[0] === focusElem));
	    if (!percice) {
	      const index = Array.from(currElem.parentElement.children).indexOf(currElem);
	      selector = ` > :nth-child(${index + 1})${selector}`;
	      currElem = currElem.parentElement;
	      if (currElem === null) return '';
	    }
	  } while (!percice);
	  return currSelector;
	}
	
	class FocusInfo {
	  constructor() {
	    this.elem = document.activeElement;
	    if (this.elem) {
	      this.selector = du.uniqueSelector(this.elem);
	      this.start =  this.elem.selectionStart;
	      this.end = this.elem.selectionEnd;
	    } else return null;
	  }
	}
	
	du.focusInfo = function () { return new FocusInfo();}
	
	du.focus = function (selector) {
	  if ((typeof selector) === 'string') {
	    const elem = du.find(selector);
	    if (elem) elem.focus();
	  } else if (selector instanceof FocusInfo) {
	    const elem = du.find(selector.selector);
	    if (elem) {
	      elem.focus();
	      if (Number.isFinite(selector.start) && Number.isFinite(selector.end)) {
	        elem.selectionStart = selector.start;
	        elem.selectorEnd = selector.end;
	      }
	    }
	  }
	}
	
	// Stolen From: https://stackoverflow.com/a/66569574
	// Should write and test my own but bigger fish
	const cssUnitReg = new RegExp(/^((-|)[0-9]{1,})([a-zA-Z]{1,4})$/);
	du.convertCssUnit = function( cssValue, target ) {
	    target = target || document.body;
	    const supportedUnits = {
	        // Absolute sizes
	        'px': value => value,
	        'cm': value => value * 38,
	        'mm': value => value * 3.8,
	        'q': value => value * 0.95,
	        'in': value => value * 96,
	        'pc': value => value * 16,
	        'pt': value => value * 1.333333,
	        // Relative sizes
	        'rem': value => value * parseFloat( getComputedStyle( document.documentElement ).fontSize ),
	        'em': value => value * parseFloat( getComputedStyle( target ).fontSize ),
	        'vw': value => value / 100 * window.innerWidth,
	        'vh': value => value / 100 * window.innerHeight,
	        // Times
	        'ms': value => value,
	        's': value => value * 1000,
	        // Angles
	        'deg': value => value,
	        'rad': value => value * ( 180 / Math.PI ),
	        'grad': value => value * ( 180 / 200 ),
	        'turn': value => value * 360
	    };
	
	    // If is a match, return example: [ "-2.75rem", "-2.75", "rem" ]
	    const matches = String.prototype.toString.apply( cssValue ).trim().match(cssUnitReg);
	
	    if ( matches ) {
	        const value = Number( matches[ 1 ] );
	        const unit = matches[ 3 ].toLocaleLowerCase();
	        // Sanity check, make sure unit conversion function exists
	        if ( unit in supportedUnits ) {
	            return supportedUnits[ unit ]( value );
	        }
	    }
	
	    return cssValue;
	};
	
	try {
	  module.exports = du;
	} catch (e) {}
	
});


RequireJS.addFunction('./public/js/utils/endpoints.js',
function (require, exports, module) {
	
class Endpoints {
	  constructor(config, host) {
	    const instance = this;
	    let environment;
	
	    if ((typeof config) !== 'object') {
	      host = config;
	      config = Endpoints.defaultConfig;
	    }
	
	    host = host || '';
	    this.setHost = (newHost) => {
	      if ((typeof newHost) === 'string') {
	        if (config._envs[newHost]) environment = newHost;
	        host = config._envs[newHost] || newHost;
	      }
	    };
	    this.setHost(host);
	    this.getHost = (env) => env === undefined ? host : config._envs[env];
	    this.getEnv = () => environment;
	
	    const endPointFuncs = {setHost: this.setHost, getHost: this.getHost, getEnv: this.getEnv};
	    this.getFuncObj = function () {return endPointFuncs;};
	
	
	    function build(str) {
	      const pieces = str.split(/:[a-zA-Z0-9]*/g);
	      const labels = str.match(/:[a-zA-Z0-9]*/g) || [];
	      return function () {
	        let values = [];
	        if (arguments[0] === null || (typeof arguments[0]) !== 'object') {
	          values = arguments;
	        } else {
	          const obj = arguments[0];
	          labels.map((value) => values.push(obj[value.substr(1)] !== undefined ? obj[value.substr(1)] : value))
	        }
	        let endpoint = '';
	        for (let index = 0; index < pieces.length; index += 1) {
	          const arg = values[index];
	          let value = '';
	          if (index < pieces.length - 1) {
	            value = arg !== undefined ? encodeURIComponent(arg) : labels[index];
	          }
	          endpoint += pieces[index] + value;
	        }
	        return `${host}${endpoint}`;
	      }
	    }
	
	    function configRecurse(currConfig, currFunc) {
	      const keys = Object.keys(currConfig);
	      for (let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        const value = currConfig[key];
	        if (key.indexOf('_') !== 0) {
	          if (value instanceof Object) {
	            currFunc[key] = {};
	            configRecurse(value, currFunc[key]);
	          } else {
	            currFunc[key] = build(value);
	          }
	        } else {
	          currFunc[key] = value;
	        }
	      }
	    }
	
	    configRecurse(config, endPointFuncs);
	  }
	}
	
	module.exports = Endpoints;
	
});


RequireJS.addFunction('./public/js/utils/string-math-evaluator.js',
function (require, exports, module) {
	let FunctionCache;
	try {
	  FunctionCache = require('./services/function-cache.js');
	} catch(e) {
	
	}
	
	function regexToObject (str, reg) {
	  const match = str.match(reg);
	  if (match === null) return null;
	  const returnVal = {};
	  for (let index = 2; index < arguments.length; index += 1) {
	    const attr = arguments[index];
	    if (attr) returnVal[attr] = match[index - 1];
	  }
	  return returnVal;
	}
	
	class StringMathEvaluator {
	  constructor(globalScope, resolver) {
	    globalScope = globalScope || {};
	    const instance = this;
	    let splitter = '.';
	
	    function resolve (path, currObj, globalCheck) {
	      if (path === '') return currObj;
	      // TODO: this try is a patch... resolve path/logic needs to be mapped properly
	      try {
	        const resolved = !globalCheck && resolver && resolver(path, currObj);
	        if (Number.isFinite(resolved)) return resolved;
	      } catch (e) {}
	      try {
	        if ((typeof path) === 'string') path = path.split(splitter);
	        for (let index = 0; index < path.length; index += 1) {
	          currObj = currObj[path[index]];
	        }
	        if (currObj === undefined && !globalCheck) throw Error('try global');
	        return currObj;
	      }  catch (e) {
	        if (!globalCheck) return resolve(path, globalScope, true);
	      }
	    }
	
	    function multiplyOrDivide (values, operands) {
	      const op = operands[operands.length - 1];
	      if (op === StringMathEvaluator.multi || op === StringMathEvaluator.div) {
	        const len = values.length;
	        values[len - 2] = op(values[len - 2], values[len - 1])
	        values.pop();
	        operands.pop();
	      }
	    }
	
	    const resolveArguments = (initialChar, func) => {
	      return function (expr, index, values, operands, scope, path) {
	        if (expr[index] === initialChar) {
	          const args = [];
	          let endIndex = index += 1;
	          const terminationChar = expr[index - 1] === '(' ? ')' : ']';
	          let terminate = false;
	          let openParenCount = 0;
	          while(!terminate && endIndex < expr.length) {
	            const currChar = expr[endIndex++];
	            if (currChar === '(') openParenCount++;
	            else if (openParenCount > 0 && currChar === ')') openParenCount--;
	            else if (openParenCount === 0) {
	              if (currChar === ',') {
	                args.push(expr.substr(index, endIndex - index - 1));
	                index = endIndex;
	              } else if (openParenCount === 0 && currChar === terminationChar) {
	                args.push(expr.substr(index, endIndex++ - index - 1));
	                terminate = true;
	              }
	            }
	          }
	
	          for (let index = 0; index < args.length; index += 1) {
	            const stringMatch = args[index].match(StringMathEvaluator.stringReg);
	            if (stringMatch) {
	              args[index] = stringMatch[1];
	            } else {
	              args[index] =  instance.eval(args[index], scope);
	            }
	          }
	          const state = func(expr, path, scope, args, endIndex);
	          if (state) {
	            values.push(state.value);
	            return state.endIndex;
	          }
	        }
	      }
	    };
	
	    function chainedExpressions(expr, value, endIndex, path) {
	      if (expr.length === endIndex) return {value, endIndex};
	      let values = [];
	      let offsetIndex;
	      let valueIndex = 0;
	      let chained = false;
	      do {
	        const subStr = expr.substr(endIndex);
	        const offsetIndex = isolateArray(subStr, 0, values, [], value, path) ||
	                            isolateFunction(subStr, 0, values, [], value, path) ||
	                            (subStr[0] === '.' &&
	                              isolateVar(subStr, 1, values, [], value));
	        if (Number.isInteger(offsetIndex)) {
	          value = values[valueIndex];
	          endIndex += offsetIndex - 1;
	          chained = true;
	        }
	      } while (offsetIndex !== undefined);
	      return {value, endIndex};
	    }
	
	    const isolateArray = resolveArguments('[',
	      (expr, path, scope, args, endIndex) => {
	        endIndex = endIndex - 1;
	        let value = resolve(path, scope)[args[args.length - 1]];
	        return chainedExpressions(expr, value, endIndex, '');
	      });
	
	    const isolateFunction = resolveArguments('(',
	      (expr, path, scope, args, endIndex) =>
	          chainedExpressions(expr, resolve(path, scope).apply(null, args), endIndex, ''));
	
	    function isolateParenthesis(expr, index, values, operands, scope) {
	      const char = expr[index];
	      if (char === ')') throw new Error('UnExpected closing parenthesis');
	      if (char === '(') {
	        let openParenCount = 1;
	        let endIndex = index + 1;
	        while(openParenCount > 0 && endIndex < expr.length) {
	          const currChar = expr[endIndex++];
	          if (currChar === '(') openParenCount++;
	          if (currChar === ')') openParenCount--;
	        }
	        if (openParenCount > 0) throw new Error('UnClosed parenthesis');
	        const len = endIndex - index - 2;
	        values.push(instance.eval(expr.substr(index + 1, len), scope));
	        multiplyOrDivide(values, operands);
	        return endIndex;
	      }
	    };
	
	    function isolateOperand (char, operands) {
	      if (char === ')') throw new Error('UnExpected closing parenthesis');
	      switch (char) {
	        case '*':
	        operands.push(StringMathEvaluator.multi);
	        return true;
	        break;
	        case '/':
	        operands.push(StringMathEvaluator.div);
	        return true;
	        break;
	        case '+':
	        operands.push(StringMathEvaluator.add);
	        return true;
	        break;
	        case '-':
	        operands.push(StringMathEvaluator.sub);
	        return true;
	        break;
	      }
	      return false;
	    }
	
	    function isolateValueReg(reg, resolver) {
	      return function (expr, index, values, operands, scope) {
	        const match = expr.substr(index).match(reg);
	        let args;
	        if (match) {
	          let endIndex = index + match[0].length;
	          let value = resolver(match[0], scope);
	          if (!Number.isFinite(value)) {
	            const state = chainedExpressions(expr, scope, endIndex, match[0]);
	            if (state !== undefined) {
	              value = state.value;
	              endIndex = state.endIndex;
	            }
	          }
	          values.push(value);
	          multiplyOrDivide(values, operands);
	          return endIndex;
	        }
	      }
	    }
	
	    function convertFeetInchNotation(expr) {
	      expr = expr.replace(StringMathEvaluator.footInchReg, '($1*12+$2)') || expr;
	      expr = expr.replace(StringMathEvaluator.inchReg, '$1') || expr;
	      expr = expr.replace(StringMathEvaluator.footReg, '($1*12)') || expr;
	      return expr = expr.replace(StringMathEvaluator.multiMixedNumberReg, '($1+$2)') || expr;
	    }
	    function addUnexpressedMultiplicationSigns(expr) {
	      expr = expr.replace(/([0-9]{1,})(\s*)([a-zA-Z]{1,})/g, '$1*$3');
	      expr = expr.replace(/([a-zA-Z]{1,})\s{1,}([0-9]{1,})/g, '$1*$2');
	      expr = expr.replace(/\)([^a-z^A-Z^$^\s^)^+^\-^*^\/])/g, ')*$1');
	      expr = expr.replace(/-([a-z(])/g, '-1*$1');
	      return expr.replace(/([^a-z^A-Z^\s^$^(^+^\-^*^\/])\(/g, '$1*(');
	    }
	
	    const isolateNumber = isolateValueReg(StringMathEvaluator.decimalReg, Number.parseFloat);
	    const isolateVar = isolateValueReg(StringMathEvaluator.varReg, resolve);
	
	    function evaluate(expr, scope, percision) {
	      if (Number.isFinite(expr))
	        return expr;
	      expr = new String(expr);
	      expr = addUnexpressedMultiplicationSigns(expr);
	      expr = convertFeetInchNotation(expr);
	      scope = scope || globalScope;
	      const allowVars = (typeof scope) === 'object';
	      let operands = [];
	      let values = [];
	      let prevWasOpperand = true;
	      for (let index = 0; index < expr.length; index += 1) {
	        const char = expr[index];
	        if (prevWasOpperand) {
	          try {
	            let newIndex = isolateNumber(expr, index, values, operands, scope);
	            if (!newIndex && isolateOperand(char, operands))
	                throw new Error(`Invalid operand location ${expr.substr(0,index)}'${expr[index]}'${expr.substr(index + 1)}`);
	            newIndex ||= isolateParenthesis(expr, index, values, operands, scope) ||
	                (allowVars && isolateVar(expr, index, values, operands, scope));
	            if (Number.isInteger(newIndex)) {
	              index = newIndex - 1;
	              prevWasOpperand = false;
	            }
	          } catch (e) {
	            console.error(e);
	            return NaN;
	          }
	        } else {
	          prevWasOpperand = isolateOperand(char, operands);
	        }
	      }
	      if (prevWasOpperand) return NaN;
	
	      let value = values[0];
	      for (let index = 0; index < values.length - 1; index += 1) {
	        value = operands[index](values[index], values[index + 1]);
	        values[index + 1] = value;
	      }
	
	      if (Number.isFinite(value)) {
	        value = value;
	        return value;
	      }
	      return NaN;
	    }
	
	    function evalObject(obj, scope) {
	      const returnObj = Object.forEachConditional(obj, (value, key, object) => {
	        value = evaluate(value, scope);
	        if (!Number.isNaN(value)) object[key] = value;
	      }, (value) => (typeof value) === 'string');
	      return returnObj;
	    }
	
	    this.eval = FunctionCache ? new FunctionCache(evaluate, this, 'sme') : evaluate;
	    this.evalObject = FunctionCache ? new FunctionCache(evalObject, this, 'sme') : evalObject;
	  }
	}
	
	StringMathEvaluator.regex = /^\s*(([0-9]*)\s{1,}|)(([0-9]{1,})\s*\/([0-9]{1,})\s*|)$/;
	
	const mixNumberRegStr = "([0-9]{1,})\\s{1,}(([0-9]{1,})\\/([0-9]{1,}))";
	StringMathEvaluator.mixedNumberReg = new RegExp(`^${mixNumberRegStr}$`);
	StringMathEvaluator.multiMixedNumberReg = new RegExp(mixNumberRegStr, 'g');///([0-9]{1,})\s{1,}([0-9]{1,}\/[0-9]{1,})/g;
	StringMathEvaluator.fractionOrMixedNumberReg = /(^([0-9]{1,})\s|^){1,}([0-9]{1,}\/[0-9]{1,})$/;
	StringMathEvaluator.footInchReg = /\s*([0-9]{1,})\s*'\s*([0-9\/ ]{1,})\s*"\s*/g;
	StringMathEvaluator.footReg = /\s*([0-9]{1,})\s*'\s*/g;
	StringMathEvaluator.inchReg = /\s*([0-9]{1,})\s*"\s*/g;
	StringMathEvaluator.evaluateReg = /[-\+*/]|^\s*[0-9]{1,}\s*$/;
	const decimalRegStr = "((-|)(([0-9]{1,}\\.[0-9]{1,})|[0-9]{1,}(\\.|)|(\\.)[0-9]{1,}))";
	StringMathEvaluator.decimalReg = new RegExp(`^${decimalRegStr}`);///^(-|)(([0-9]{1,}\.[0-9]{1,})|[0-9]{1,}(\.|)|(\.)[0-9]{1,})/;
	StringMathEvaluator.multiDecimalReg = new RegExp(decimalRegStr, 'g');
	StringMathEvaluator.varReg = /^((\.|)([$_a-zA-Z][$_a-zA-Z0-9\.]*))/;
	StringMathEvaluator.stringReg = /\s*['"](.*)['"]\s*/;
	StringMathEvaluator.multi = (n1, n2) => n1 * n2;
	StringMathEvaluator.div = (n1, n2) => n1 / n2;
	StringMathEvaluator.add = (n1, n2) => n1 + n2;
	StringMathEvaluator.sub = (n1, n2) => n1 - n2;
	
	const npf = Number.parseFloat;
	StringMathEvaluator.convert = {eqn: {}};
	StringMathEvaluator.convert.metricToImperial = (value) => {
	  value = npf(value);
	  return value / 2.54;
	}
	
	StringMathEvaluator.resolveMixedNumber = (value) => {
	  const match = value.match(StringMathEvaluator.mixedNumberReg);
	  if (match) {
	    value = npf(match[1]) + (npf(match[3]) / npf(match[4]));
	  }
	  value = npf(value);
	  return value;
	}
	
	StringMathEvaluator.convert.imperialToMetric = (value) => {
	  value = npf(value);
	  return value * 2.54;
	}
	
	StringMathEvaluator.convert.eqn.metricToImperial = (str) =>
	  str.replace(StringMathEvaluator.multiDecimalReg, StringMathEvaluator.convert.metricToImperial);
	
	StringMathEvaluator.convert.eqn.imperialToMetric = (str) =>
	  str.replace(StringMathEvaluator.multiMixedNumberReg, StringMathEvaluator.resolveMixedNumber)
	  .replace(StringMathEvaluator.multiDecimalReg, StringMathEvaluator.convert.imperialToMetric);
	
	StringMathEvaluator.primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
	
	
	StringMathEvaluator.reduce = function(numerator, denominator) {
	  let reduced = true;
	  while (reduced) {
	    reduced = false;
	    for (let index = 0; index < StringMathEvaluator.primes.length; index += 1) {
	      const prime = StringMathEvaluator.primes[index];
	      if (prime >= denominator) break;
	      if (numerator % prime === 0 && denominator % prime === 0) {
	        numerator = numerator / prime;
	        denominator = denominator / prime;
	        reduced = true;
	        break;
	      }
	    }
	  }
	  if (numerator === 0) {
	    return '';
	  }
	  return `${numerator}/${denominator}`;
	}
	
	StringMathEvaluator.parseFraction = function (str) {
	  const regObj = regexToObject(str, StringMathEvaluator.regex, null, 'integer', null, 'numerator', 'denominator');
	  regObj.integer = Number.parseInt(regObj.integer) || 0;
	  regObj.numerator = Number.parseInt(regObj.numerator) || 0;
	  regObj.denominator = Number.parseInt(regObj.denominator) || 0;
	  if(regObj.denominator === 0) {
	    regObj.numerator = 0;
	    regObj.denominator = 1;
	  }
	  regObj.decimal = regObj.integer + (regObj.numerator / regObj.denominator);
	  return regObj;
	}
	
	StringMathEvaluator.toFraction = function (decimal, accuracy) {
	  if (decimal === NaN) return NaN;
	  accuracy = accuracy || '1/1000'
	  const fracObj = StringMathEvaluator.parseFraction(accuracy);
	  const denominator = fracObj.denominator;
	  if (fracObj.decimal === 0 || fracObj.integer > 0 || denominator > 1000) {
	    throw new Error('Please enter a fraction with a denominator between (0, 1000]')
	  }
	  let remainder = decimal;
	  let currRemainder = remainder;
	  let value = 0;
	  let numerator = 0;
	  while (currRemainder > 0) {
	    numerator += fracObj.numerator;
	    currRemainder -= fracObj.decimal;
	  }
	  const diff1 = decimal - ((numerator - fracObj.numerator) / denominator);
	  const diff2 = (numerator / denominator) - decimal;
	  numerator -= diff1 < diff2 ? fracObj.numerator : 0;
	  const integer = Math.floor(numerator / denominator);
	  numerator = numerator % denominator;
	  const fraction = StringMathEvaluator.reduce(numerator, denominator);
	  return (integer && fraction ? `${integer} ${fraction}` :
	            (integer ? `${integer}` : (fraction ? `${fraction}` : '0')));
	}
	
	try {
	  module.exports = StringMathEvaluator;
	} catch (e) {/* TODO: Consider Removing */}
	
});


RequireJS.addFunction('./public/js/utils/lists/expandable.js',
function (require, exports, module) {
	

	
	const CustomEvent = require('../custom-event.js');
	const du = require('../dom-utils.js');
	const $t = require('../$t.js');
	
	// properties
	//  required: {
	//  getHeader: function returns html header string,
	//  getBody: function returns html body string,
	//}
	//  optional: {
	//  list: list to use, creates on undefined
	//  getObject: function returns new list object default is generic js object,
	//  parentSelector: cssSelector only reqired for refresh function,
	//  listElemLable: nameOfElementType changes add button label,
	//  dontOpenOnAdd: by default the active element will be switched to newly added elements.
	//  hideAddBtn: defaults to false,
	//  startClosed: all tabs are closed on list open.
	//  input: true - require user to enter text before adding new
	//  inputOptions: array of autofill inputs
	//  inputs: [{placeholder, autofill},...]
	//  inputValidation: function to validate input fields
	//  type: defaults to list,
	//  selfCloseTab: defalts to true - allows clicking on header to close body,
	//  findElement: used to find elemenents related to header - defaults to closest
	//  removeButton: true by default;
	//}
	class Expandable {
	  constructor(props) {
	    const afterRenderEvent = new CustomEvent('afterRender');
	    const afterAddEvent = new CustomEvent('afterAdd');
	    const afterRefreshEvent = new CustomEvent('afterRefresh');
	    const afterRemovalEvent = new CustomEvent('afterRemoval');
	    const instance = this;
	    const renderBodyOnOpen = props.renderBodyOnOpen === false ? false : true;
	    props.getObject = props.getObject || (() => ({}));
	    props.ERROR_CNT_ID = `expandable-error-msg-cnt-${props.id}`;
	    props.inputTreeId = `expandable-input-tree-cnt-${props.id}`;
	    props.type = props.type || 'list';
	    props.findElement = props.findElement || ((selector, target) =>  du.find.closest(selector, target));
	    props.selfCloseTab = props.selfCloseTab === undefined ? true : props.selfCloseTab;
	    props.getObject = props.getObject || (() => {});
	    props.inputs = props.inputs || [];
	    props.list = props.list || [];
	    // props.list.DO_NOT_CLONE = true;
	    this.hasBody = () => (typeof this.getBody) === 'function';
	    this.getHeader = props.getHeader; delete props.getHeader;
	    this.getBody = props.getBody; delete props.getBody;
	    props.id = Expandable.lists.length;
	    const firstKey = Object.keys(props.list)[0];
	    props.activeKey = firstKey || 0; //TODO ???
	    Object.getSet(this, props, 'listElemLable');
	    let pendingRefresh = false;
	    let lastRefresh = new Date().getTime();
	    const storage = {};
	    Expandable.lists[props.id] = this;
	    this.inputTree = () => props.inputTree;
	    this.parentSelector = () => props.parentSelector;
	
	    this.errorCntId = () => props.ERROR_CNT_ID;
	    function setErrorMsg(msg) {
	        du.id(props.ERROR_CNT_ID).innerHTML = msg;
	    }
	
	    function values() {
	      const values = {};
	      props.inputs.forEach((input) =>
	        values[input.placeholder] = du.id(input.id).value);
	      return values;
	    }
	
	    function getCnt() {
	      return document.querySelector(`.expandable-list[ex-list-id='${props.id}']`);
	    }
	
	    function getBodyCnt() {
	      return du.find.down('.expand-body', getCnt());
	    }
	
	    function getInputCnt() {
	      const cnt = du.find.down('.expand-input-cnt', getCnt());
	      return cnt;
	    }
	    //changes....
	    this.values = values;
	    this.getInputCnt = getInputCnt;
	
	    this.add = (vals) => {
	      const inputValues = vals || values();
	      if ((typeof props.inputValidation) !== 'function' ||
	              props.inputValidation(inputValues) === true) {
	          const obj = props.getObject(inputValues, getInputCnt());
	          const key = this.getKey(vals, obj);
	          props.list[key] = obj;
	          if (!props.dontOpenOnAdd) this.activeKey(key);
	          this.refresh();
	          afterAddEvent.trigger();
	      } else {
	        const errors = props.inputValidation(inputValues);
	        let errorStr;
	        if ((typeof errors) === 'object') {
	          const keys = Object.keys(errors);
	          errorStr = Object.values(errors).join('<br>');
	        } else {
	          errorStr = `Error: ${errors}`;
	        }
	        setErrorMsg(errorStr);
	      }
	    };
	    this.hasInputTree = () =>
	      this.inputTree() && this.inputTree().constructor.name === 'LogicWrapper';
	    if (this.hasInputTree())
	      props.inputTree.onSubmit(this.add);
	    props.hasInputTree = this.hasInputTree;
	
	    this.isSelfClosing = () => props.selfCloseTab;
	    this.remove = (removed) => {
	      afterRemovalEvent.trigger(undefined, removed);
	      this.refresh();
	    }
	    this.html = () =>
	      Expandable[`${instance.type().toCamel()}Template`].render(this);
	    this.afterRender = (func) => afterRenderEvent.on(func);
	    this.afterAdd = (func) => afterAddEvent.on(func);
	    this.afterRemoval = (func) => afterRemovalEvent.on(func);
	    this.refresh = (type) => {
	      this.type((typeof type) === 'string' ? type : props.type);
	      if (!pendingRefresh) {
	        pendingRefresh = true;
	        setTimeout(() => {
	          props.inputs.forEach((input) => input.id = input.id || String.random(7));
	          const parent = document.querySelector(props.parentSelector);
	          const focusInfo = du.focusInfo();
	          const html = this.html();
	          if (parent && html !== undefined) {
	            parent.innerHTML = html;
	            du.focus(focusInfo);
	            afterRefreshEvent.trigger();
	          }
	          pendingRefresh = false;
	        }, 100);
	      }
	    };
	    this.activeKey = (value) => value === undefined ? props.activeKey : (props.activeKey = value);
	    this.getKey = () => this.list().length;
	    this.active = () => props.list[this.activeKey()];
	    // TODO: figure out why i wrote this and if its neccisary.
	    this.value = (key) => (key2, value) => {
	      if (props.activeKey === undefined) props.activeKey = 0;
	      if (key === undefined) key = props.activeKey;
	      if (storage[key] === undefined) storage[key] = {};
	      if (value === undefined) return storage[key][key2];
	      storage[key][key2] = value;
	    }
	    this.inputHtml = () => this.hasInputTree() ?
	          this.inputTree().payload().html() : Expandable.inputRepeatTemplate.render(this);
	    this.set = (key, value) => props.list[key] = value;
	    this.get = (key) => props.list[key];
	    this.renderBody = (target) => {
	      const headerSelector = `.expand-header[ex-list-id='${props.id}'][key='${this.activeKey()}']`;
	      target = target || document.querySelector(headerSelector);
	      if (target !== null) {
	        const id = target.getAttribute('ex-list-id');
	        const list = Expandable.lists[id];
	        const headers = du.find.up('.expandable-list', target).querySelectorAll('.expand-header');
	        const bodys = du.find.up('.expandable-list', target).querySelectorAll('.expand-body');
	        const rmBtns = du.find.up('.expandable-list', target).querySelectorAll('.expandable-item-rm-btn');
	        headers.forEach((header) => header.className = header.className.replace(/(^| )active( |$)/g, ''));
	        bodys.forEach((body) => body.style.display = 'none');
	        rmBtns.forEach((rmBtn) => rmBtn.style.display = 'none');
	        const body = bodys.length === 1 ? bodys[0] : du.find.closest('.expand-body', target);
	        if (this.hasBody()) {
	          body.style.display = 'block';
	        }
	        const key = target.getAttribute('key');
	        this.activeKey(key);
	        if (renderBodyOnOpen) body.innerHTML = this.htmlBody(key);
	        if (props.removeButton !== false) target.parentElement.querySelector('.expandable-item-rm-btn').style.display = 'block';
	        target.className += ' active' + (this.hasBody() ? '' : ' no-body');
	        afterRenderEvent.trigger();
	        // du.scroll.intoView(target.parentElement, 3, 25, document.body);
	      }
	    };
	    afterRefreshEvent.on(() => {if (!props.startClosed)this.renderBody()});
	
	    this.htmlBody = (key) => {
	      getBodyCnt().setAttribute('key', key);
	      return this.hasBody() ? this.getBody(this.list()[key], key) : '';
	    }
	    this.list = () => props.list;
	    this.refresh();
	    // setTimeout(() => {
	    //   const headerSelector = `.expand-header[ex-list-id='${props.id}'][key='${this.activeKey()}']`;
	    //   const activeHeader = du.find(headerSelector);
	    //   if (activeHeader) activeHeader.click();
	    // }, 2000);
	  }
	}
	Expandable.lists = [];
	Expandable.DO_NOT_CLONE = true;
	Expandable.inputRepeatTemplate = new $t('expandable/input-repeat');
	Expandable.listTemplate = new $t('expandable/list');
	Expandable.pillTemplate = new $t('expandable/pill');
	Expandable.sidebarTemplate = new $t('expandable/sidebar');
	Expandable.topAddListTemplate = new $t('expandable/top-add-list');
	Expandable.getIdAndKey = (target, level) => {
	  level ||= 0;
	  const elems = du.find.upAll('.expand-header,.expand-body', target);
	  if (elems.length < level + 1) return undefined;
	  const cnt = elems[level];
	  const id = Number.parseInt(cnt.getAttribute('ex-list-id'));
	  const key = cnt.getAttribute('key');
	  return {id, key};
	}
	Expandable.getValueFunc = (target) => {
	  const idKey = Expandable.getIdAndKey(target);
	  return Expandable.lists[idKey.id].value(idKey.key);
	}
	
	Expandable.get = (target, level) => {
	  const idKey = Expandable.getIdAndKey(target, level);
	  if (idKey === undefined) return undefined;
	  return Expandable.lists[idKey.id].get(idKey.key);
	}
	
	Expandable.bySelector = (parentSelector) => {
	  const lists = Expandable.lists;
	  const expandKeys = Object.keys(lists);
	  if (expandKeys.length > 1000) console.warn.subtle(1000, 'Its time to start freeing expandable list data');
	  for (let i = 0; i < expandKeys.length; i++) {
	    const key = expandKeys[index];
	    if (lists[key].parentSelector() === parentSelector) return lists[key];
	  }
	  return null;
	}
	
	Expandable.list = (target) => {
	  const idKey = Expandable.getIdAndKey(target);
	  return Expandable.lists[idKey.id];
	}
	
	Expandable.set = (target, value) => {
	  const idKey = Expandable.getIdAndKey(target);
	  Expandable.lists[idKey.id].set(idKey.key, value);
	}
	
	Expandable.value = (key, value, target) => {
	  return Expandable.getValueFunc(target)(key, value);
	}
	du.on.match('click', '.expandable-list-add-btn', (target) => {
	  const id = target.getAttribute('ex-list-id');
	  Expandable.lists[id].add();
	});
	du.on.match('click', '.expandable-item-rm-btn', (target) => {
	  const id = target.getAttribute('ex-list-id');
	  const key = target.getAttribute('key');
	  Expandable.lists[id].remove(key);
	});
	Expandable.closeAll = (header) => {
	  const hello = 'world';
	}
	
	du.on.match('click', '.expand-header', (target, event) => {
	  const isActive = target.matches('.active');
	  const id = target.getAttribute('ex-list-id');
	  const list = Expandable.lists[id];
	  if (list) {
	    if (isActive && !event.target.tagName.match(/INPUT|SELECT/)) {
	      du.class.remove(target, 'active');
	      du.find.closest('.expand-body', target).style.display = 'none';
	      list.activeKey(null);
	      target.parentElement.querySelector('.expandable-item-rm-btn').style.display = 'none';
	    } else if (!isActive) {
	      list.renderBody(target);
	    }
	  }
	});
	
	function getExpandObject(elem) {
	  const exListElem = du.find.up('[ex-list-id]', elem);
	  if (!exListElem) return undefined;
	  const listId = exListElem.getAttribute('ex-list-id');
	  return Expandable.lists[listId];
	}
	
	du.on.match('click', '.input-open-cnt', (target) => {
	  const inputCnts = document.querySelectorAll('.expand-input-cnt');
	  const expandList = getExpandObject(target);
	  if (expandList && !expandList.hasInputTree()) expandList.add();
	  else {
	    const inputOpenCnts = document.querySelectorAll('.input-open-cnt');
	    const closest = du.find.closest('.expand-input-cnt', target);
	    inputCnts.forEach((elem) => elem.hidden = true);
	    inputOpenCnts.forEach((elem) => elem.hidden = false);
	    target.hidden = true;
	    if (closest) closest.hidden = false;
	  }
	});
	
	module.exports = Expandable
	
});


RequireJS.addFunction('./public/js/utils/lists/expandable-object.js',
function (require, exports, module) {
	

	
	const CustomEvent = require('../custom-event.js');
	const du = require('../dom-utils.js');
	const $t = require('../$t.js');
	const Expandable = require('./expandable');
	
	
	class ExpandableObject extends Expandable {
	  constructor(props) {
	    props.list = props.list || {};
	    let idAttr, mappedObject;
	    if (props.idAttribute) {
	      idAttr = props.idAttribute;
	      mappedObject = props.mappedObject || {}
	    }
	    super(props);
		//TODO: Set aciveKey
	
	    const superRemove = this.remove;
	    this.remove = (key) => {
	      const removed = props.list[key];
	      delete props.list[key];
	      superRemove(removed);
	    }
	
	    function undefinedAttr(attr, object) {
	      if (object === undefined) return attr;
	      let currAttr = attr;
	      let count = 1;
	      while(object[currAttr] !== undefined) {
	        if (object[currAttr] === object) return currAttr;
	        currAttr = `${attr}-${count++}`;
	      }
	      return currAttr;
	    }
	
	    const valOfunc = (obj, attr) => (typeof obj[attr]) === 'function' ? obj[attr]() : obj[attr];
	    this.updateMapped = (obj) => {
	      if (idAttr === undefined) return;
	      obj = obj || props.list[this.activeKey()];
	      if (obj) {
	        const name = undefinedAttr(valOfunc(obj, idAttr), mappedObject);
	        if (name !== obj._EXPAND_LAST_OBJECT_NAME) {
	          mappedObject[name] = mappedObject[obj._EXPAND_LAST_OBJECT_NAME];
	          delete mappedObject[obj._EXPAND_LAST_OBJECT_NAME];
	          obj._EXPAND_LAST_OBJECT_NAME = name;
	        }
	      }
	    }
	    this.getMappedObject = () => mappedObject;
	
	    this.getKey = (values, object) => {
	      if (object && object._EXPAND_KEY === undefined) {
	        object._EXPAND_KEY = String.random();
	        object._EXPAND_LAST_OBJECT_NAME = undefinedAttr(valOfunc(object, idAttr), mappedObject);
	        if (idAttr !== undefined) mappedObject[object._EXPAND_LAST_OBJECT_NAME] = object;
	      }
	      if (!props.dontOpenOnAdd && object) this.activeKey(object._EXPAND_KEY);
	      if (idAttr) this.updateMapped(object);
	      return this.activeKey() || undefined;
	    }
	  }
	}
	module.exports = ExpandableObject
	
});


RequireJS.addFunction('./public/js/utils/lists/expandable-list.js',
function (require, exports, module) {
	

	
	const CustomEvent = require('../custom-event.js');
	const du = require('../dom-utils.js');
	const $t = require('../$t.js');
	const Expandable = require('./expandable');
	
	class ExpandableList extends Expandable {
	  constructor(props) {
	    super(props);
	    const superRemove = this.remove;
	    this.remove = (index) => {
	      superRemove(props.list.splice(index, 1)[0]);
	      this.refresh();
	    }
	  }
	}
	
	module.exports = ExpandableList
	
});


RequireJS.addFunction('./public/js/utils/collections/collection.js',
function (require, exports, module) {
	

	
	
	class Collection {
	  constructor(members) {
	    const list = [];
	    const instance = this;
	
	    function runForEach(func) {
	      let bool = true;
	      for (let index = 0; index < members.length; index += 1) {
	        bool = func(members[index]) && bool;
	      }
	      return bool;
	    }
	    function refMember(name) {
	      instance[name] = () => {
	        const attrId = list[0][name]();
	        return attrId;
	      }
	    };
	    runForEach(refMember);
	
	    this.options = () => list[0].options() || [];
	    this.cost = () => {
	      let totalCost = 0;
	      list.forEach((el) => totalCost += el.cost());
	      return totalCost;
	    }
	    this.belongs = (el) =>
	      list.length === 0 ||
	        runForEach((member) => el[member]() === list[0][member]());
	
	    this.add = (elem) => {
	      if (!this.belongs(elem)) throw new Error ('Cannot add element that does not belong.');
	      list.push(elem);
	      runForEach(refMember);
	    }
	    this.list = list;
	    this.typeId = () => {
	      let typeId = '';
	      runForEach((member) => typeId += `:${list[0][member]()}`);
	      return typeId;
	    }
	  }
	}
	
	Collection.create = function (members, objs) {
	  let collections = {};
	  for (let index = 0; index < objs.length; index += 1) {
	    let collection = new Collection(members);
	    collection.add(objs[index]);
	    const typeId = collection.typeId();
	    if (collections[typeId] === undefined) {
	      collections[typeId] = collection;
	    } else {
	      collections[typeId].add(objs[index]);
	    }
	  }
	  return Object.values(collections);
	}
	
	module.exports = Collection;
	
	
	
	
	
});


RequireJS.addFunction('./public/js/utils/collections/notification.js',
function (require, exports, module) {
	
const CustomEvent = require('../custom-event');
	
	function searchAndConvert(obj, parentPath, beforeEvent, afterEvent) {
	  const proxy = new Proxy(obj, {set: notify(parentPath, beforeEvent, afterEvent)});
	  const keys = Object.keys(obj);
	  for (let index = 0; index < keys.length; index++) {
	    const key = keys[index];
	    const path = parentPath ? `${parentPath}.${key}` : key;
	    if (obj[key] instanceof Object)
	      obj[key] = new Notifiction(true, obj[key], path, beforeEvent, afterEvent);
	  }
	  return proxy;
	}
	
	function notify(parentPath, beforeEvent, afterEvent) {
	  return (target, key, value) => {
	    const change = target[key] !== value;
	    const path = parentPath ? `${parentPath}.${key}` : key;
	    if (change) {
	      if (target.isRecusive() && value instanceof Object) value = new Notifiction(true, value, path, beforeEvent, afterEvent);
	    }
	    const detail = {target, path, old: target[key], new: value};
	    if (change) beforeEvent.trigger(null, detail);
	    target[key] = value;
	    if (change) afterEvent.trigger(null, detail);
	    return true;
	  }
	}
	
	class Notifiction {
	  constructor(recursive, object, path, beforeChangeEvent, afterChangeEvent) {
	    path ||= '';
	    const instance = this;
	    afterChangeEvent ||= new CustomEvent('afterChange');
	    beforeChangeEvent ||= new CustomEvent('beforeChange');
	    let proxy;
	    if (recursive) {
	      proxy = searchAndConvert(object || this, path, beforeChangeEvent, afterChangeEvent);
	    } else {
	      proxy = new Proxy(object || this, {set: notify(path, beforeChangeEvent, afterChangeEvent)})
	    }
	
	    Object.defineProperty(proxy, "isRecusive", {
	        writable: false,
	        enumerable: false,
	        configurable: false,
	        value: () => recursive === true
	    });
	    Object.defineProperty(proxy, "onAfterChange", {
	        writable: false,
	        enumerable: false,
	        configurable: false,
	        value: afterChangeEvent.on
	    });
	    Object.defineProperty(proxy, "onBeforeChange", {
	        writable: false,
	        enumerable: false,
	        configurable: false,
	        value: beforeChangeEvent.on
	    });
	    Object.defineProperty(proxy, "deleteAll", {
	        writable: false,
	        enumerable: false,
	        configurable: false,
	        value: () => {
	          const keys = Object.keys(instance);
	          for (let index = 0; index < keys.length; index++) {
	            delete instance[keys[index]];
	          }
	        }
	    });
	
	    return proxy;
	  }
	}
	
	class NotifictionArray extends Notifiction {
	  constructor(recursive, array, path, beforeChangeEvent, afterChangeEvent) {
	    super(recursive, array || [], path, beforeChangeEvent, afterChangeEvent);
	  }
	}
	
	const notifyArr = new Notifiction();
	// notifyArr.onAfterChange(console.log);
	// notifyArr.onBeforeChange(console.error);
	notifyArr[4] = 'poop';
	notifyArr.pickls = 5;
	notifyArr[4] = 'y diapers';
	notifyArr[0] = [];
	notifyArr[0][69] = 'sooo fine'
	notifyArr[0][6] = {}
	notifyArr[0][6].punk = [1,2,3,4,66]
	notifyArr[0][6].punk.skittles = 'taste the rainbow'
	notifyArr[0][6].punk.skittles = 'uck!'
	
	Notifiction.Array = NotifictionArray;
	module.exports = Notifiction;
	
});


RequireJS.addFunction('./public/js/utils/services/function-cache.js',
function (require, exports, module) {
	
const cacheState = {};
	const cacheFuncs = {};
	
	class FunctionCache {
	  constructor(func, context, group, assem) {
	    if ((typeof func) !== 'function') return func;
	    let cache = {};
	    cacheFunc.group = () => {
	      const gp = (typeof group === 'function') ? group() : group || 'global';
	      if (cacheFuncs[gp] === undefined) cacheFuncs[gp] = [];
	      cacheFuncs[gp].push(cacheFunc);
	      return gp;
	    }
	
	    function cacheFunc() {
	      if (FunctionCache.isOn(cacheFunc.group())) {
	        let c = cache;
	        for (let index = 0; index < arguments.length; index += 1) {
	          if (c[arguments[index]] === undefined) c[arguments[index]] = {};
	          c = c[arguments[index]];
	        }
	        if (c[arguments[index]] === undefined) c[arguments[index]] = {};
	
	        if (c.__FunctionCache === undefined) {
	          FunctionCache.notCahed++
	          c.__FunctionCache = func.apply(context, arguments);
	        } else FunctionCache.cached++;
	        return c.__FunctionCache;
	      }
	      FunctionCache.notCahed++
	      return func.apply(context, arguments);
	    }
	    cacheFunc.clearCache = () => cache = {};
	    return cacheFunc;
	  }
	}
	
	FunctionCache.cached = 0;
	FunctionCache.notCahed = 0;
	FunctionCache.on = (group) => {
	  FunctionCache.cached = 0;
	  FunctionCache.notCahed = 0;
	  cacheState[group] = true;
	}
	FunctionCache.off = (group) => {
	  const cached = FunctionCache.cached;
	  const total = FunctionCache.notCahed + cached;
	  const percent = (cached / total) * 100;
	  console.log(`FunctionCache report: ${cached}/${total} %${percent}`);
	  cacheState[group] = false;
	  cacheFuncs[group].forEach((func) => func.clearCache());
	}
	let disabled = false;
	FunctionCache.isOn = (group) => !disabled && cacheState[group];
	FunctionCache.disable = () => disabled = true;
	FunctionCache.enable = () => disabled = false;
	module.exports = FunctionCache;
	
});


RequireJS.addFunction('./public/js/utils/services/state-history.js',
function (require, exports, module) {
	
class StateHistory {
	  constructor(getState, setState, minTimeInterval) {
	    let states = [];
	    let index = 0;
	    minTimeInterval = minTimeInterval || 400;
	    const instance = this;
	    let lastStateReqTime;
	
	
	    const indexHash = () => states[index].hash;
	    this.states = () => JSON.clone(states);
	    this.toString = () => {
	      let str = ''
	      states.forEach((s, i) => i === index ?
	                        str += `(${s.hash}),` :
	                        str += `${s.hash},`);
	      return str.substr(0, str.length - 1);
	    }
	
	    function getNewState(reqTime) {
	      if (reqTime === lastStateReqTime) {
	        const currState = getState();
	        const currHash = JSON.stringify(currState).hash();
	        if (states.length === 0 || currHash !== indexHash()) {
	          if (states && states.length - 1 > index) states = states.slice(0, index + 1);
	          states.push({hash: currHash, json: currState});
	          index = states.length - 1;
	          console.log(instance.toString());
	        }
	      }
	    }
	    getNewState();
	
	    this.index = (i) => {
	      if (i > -1 && i < states.length) index = i;
	      return index;
	    }
	
	    // this.clone = (getState) => {
	    //   const sh = new StateHistory(getState, minTimeInterval, this.states());
	    //   sh.index(index);
	    //   return sh;
	    // }
	
	    this.newState = () => {
	      const thisReqTime = new Date().getTime();
	      lastStateReqTime = thisReqTime;
	      setTimeout(() => getNewState(thisReqTime), minTimeInterval);
	    }
	
	    this.forceState = () => {
	      lastStateReqTime = 0;
	      getNewState(0);
	    }
	
	    this.canGoBack = () => index > 0;
	    this.canGoForward = () => index < states.length - 1;
	
	    this.back = () => {
	      if (this.canGoBack()) {
	        const state = states[--index];
	        lastStateReqTime = 0;
	        console.log(this.toString());
	        setState(state.json);
	        return state.json;
	      }
	    }
	
	    this.forward = () => {
	      if (this.canGoForward()) {
	        const state = states[++index];
	        lastStateReqTime = 0;
	        console.log(this.toString());
	        setState(state.json);
	        return state.json;
	      }
	    }
	  }
	}
	
	module.exports = StateHistory;
	
});


RequireJS.addFunction('./public/js/utils/test/test.js',
function (require, exports, module) {
	

	
	
	
	Error.stackInfo = (steps) => {
	  steps = steps || 1;
	  const err = new Error();
	  const lines = err.stack.split('\n');
	  const match = lines[steps].match(/at (([a-zA-Z\.]*?) |)(.*\.js):([0-9]{1,}):([0-9]{1,})/);;
	  if (match) {
	    return {
	      filename: match[3].replace(/^\(/, ''),
	      function: match[2],
	      line: match[4],
	      character: match[5]
	    }
	  }
	}
	
	Error.reducedStack = (msg, steps) => {
	  steps = steps || 1;
	  const err = new Error();
	  let lines = err.stack.split('\n');
	  lines = lines.splice(steps);
	  return `Error: ${msg}\n${lines.join('\n')}`;
	}
	
	class ArgumentAttributeTest {
	  constructor(argIndex, value, name, errorCode, errorAttribute) {
	    function fail (ts, func, actualErrorCode, args) {
	      ts.fail('AttributeTest Failed: use null if test was supposed to succeed' +
	      `\n\tFunction: '${func.name}'` +
	      `\n\tArgument Index: '${argIndex}'` +
	      `\n\tName: '${name}'` +
	      `\n\tValue: '${value}'` +
	      `\n\tErrorCode: '${actualErrorCode}' !== '${errorCode}'`);
	    }
	
	    this.run = function (ts, func, args, thiz) {
	      thiz = thiz || null;
	      const testArgs = [];
	      for (let index = 0; index < args.length; index += 1) {
	        const obj = args[index];
	        let arg;
	        if (index === argIndex) {
	          if (name) {
	            arg = JSON.parse(JSON.stringify(obj));
	            arg[name] = value;
	          } else {
	            arg = value;
	          }
	        }
	        testArgs.push(arg);
	      }
	      try {
	        func.apply(thiz, testArgs)
	        if (errorCode || errorCode !== null) fail(ts, func, null, arguments);
	      } catch (e) {
	        errorAttribute = errorAttribute || 'errorCode';
	        const actualErrorCode = e[errorAttribute];
	        if (errorCode !== undefined &&
	              (errorCode === null || actualErrorCode !== errorCode))
	          fail(ts, func, actualErrorCode, arguments);
	      }
	    }
	  }
	}
	
	class FunctionArgumentTestError extends Error {
	  constructor(argIndex, errorAttribute) {
	    super();
	    this.message = 'errorCode should be null if no error thrown and undefined if no errorCode';
	    if (argIndex === undefined) {
	      this.message += '\n\targIndex must be defined.';
	    }
	    if (errorAttribute === undefined) {
	      this.message += '\n\terrorAttribute must be defined.';
	    }
	  }
	}
	
	const failureError = new Error('Test Failed');
	
	class FunctionArgumentTest {
	  constructor(ts, func, args, thiz) {
	    if (!(ts instanceof TestStatus))
	      throw new Error('ts must be a valid instance of TestStatus');
	    if ((typeof func) !== 'function')
	      throw new Error("Function must be defined and of type 'function'");
	    if (!Array.isArray(args) || args.length === 0)
	      throw new Error("This is not a suitable test for a function without arguments");
	    const funcArgTests = [];
	    let argIndex, errorCode;
	    let errorAttribute = 'errorCode';
	    this.setIndex = (i) => {argIndex = i; return this;}
	    this.setErrorCode = (ec) => {errorCode = ec; return this;}
	    this.setErrorAttribute = (ea) => {errorAttribute = ea; return this};
	    const hasErrorCode =  errorCode !== undefined;
	    this.run = () => {
	      funcArgTests.forEach((fat) => {
	        fat.run(ts, func, args, thiz);
	      });
	      return this;
	    }
	    this.add = (name, value) =>  {
	      if (errorAttribute === undefined || argIndex === undefined)
	        throw new FunctionArgumentTestError(argIndex, errorAttribute);
	      const at = new ArgumentAttributeTest(argIndex, value, name, errorCode, errorAttribute);
	      funcArgTests.push(at);
	      return this;
	    }
	  }
	}
	
	function round(value, accuracy) {
	  if (accuracy === undefined) return value;
	  return Math.round(value * accuracy) / accuracy;
	}
	// ts for short
	class TestStatus {
	  constructor(testName) {
	    let assertT = 0;
	    let assertC = 0;
	    let success = false;
	    let fail = false;
	    let failOnError = true;
	    let instance = this;
	    function printError(msg, stackOffset) {
	      stackOffset = stackOffset || 4;
	      console.error(`%c${Error.reducedStack(msg, stackOffset)}`, 'color: red');
	    }
	    function assert(b) {
	      assertT++;
	      if (b === true) {
	        assertC++;
	        TestStatus.successAssertions++;
	        return true;
	      }
	      TestStatus.failAssertions++;
	      return false;
	    }
	    function successStr(msg) {
	      console.log(`%c ${testName} - Successfull (${assertC}/${assertT})${
	          msg ? `\n\t\t${msg}` : ''}`, 'color: green');
	    }
	    const possiblyFail = (msg) => failOnError ? instance.fail(msg, 6) : printError(msg, 5);
	
	    this.assertTrue = (b, msg) => !assert(b) &&
	                            possiblyFail(`${msg}\n\t\t'${b}' should be true`);
	    this.assertFalse = (b, msg) => !assert(b === false) &&
	                            possiblyFail(`${msg}\n\t\t'${b}' should be false`);
	    this.assertEquals = (a, b, msg, acc) => !assert(round(a, acc) === round(b, acc)) &&
	                            possiblyFail(`${msg}\n\t\t'${a}' === '${b}' should be true`);
	    this.assertNotEquals = (a, b, msg, acc) => !assert(round(a, acc) !== round(b, acc)) &&
	                            possiblyFail(`${msg}\n\t\t'${a}' !== '${b}' should be true`);
	    this.assertTolerance = (n1, n2, tol, msg, stackOffset) => {
	      !assert(Math.abs(n1-n2) < tol) &&
	      possiblyFail(`${msg}\n\t\t${n1} and ${n2} are not within tolerance ${tol}`, stackOffset);
	    }
	    this.fail = (msg, stackOffset) => {
	      fail = true;
	      printError(msg, stackOffset);
	      throw failureError;
	    };
	    this.success = (msg, stackOffset) => (success = true) && successStr(msg, stackOffset);
	  }
	}
	
	TestStatus.successCount = 0;
	TestStatus.failCount = 0;
	TestStatus.successAssertions = 0;
	TestStatus.failAssertions = 0;
	
	const Test = {
	  tests: {},
	  add: (name, func) => {
	    if ((typeof func) === 'function') {
	      if (Test.tests[name] ===  undefined) Test.tests[name] = [];
	      Test.tests[name].push(func);
	    }
	  },
	  run: () => {
	    const testNames = Object.keys(Test.tests);
	    for (let index = 0; index < testNames.length; index += 1) {
	      const testName = testNames[index];
	      try {
	        Test.tests[testName].forEach((testFunc) => testFunc(new TestStatus(testName)));
	        TestStatus.successCount++;
	      } catch (e) {
	        TestStatus.failCount++;
	        if (e !== failureError)
	          console.log(`%c ${e.stack}`, 'color: red')
	      }
	    }
	    const failed = (TestStatus.failCount + TestStatus.failAssertions) > 0;
	    console.log(`\n%c Successfull Tests:${TestStatus.successCount} Successful Assertions: ${TestStatus.successAssertions}`, 'color: green');
	    console.log(`%c Failed Tests:${TestStatus.failCount} Failed Assertions: ${TestStatus.failAssertions}`, !failed ? 'color:green' : 'color: red');
	  }
	}
	
	exports.ArgumentAttributeTest = ArgumentAttributeTest;
	exports.FunctionArgumentTestError = FunctionArgumentTestError;
	exports.FunctionArgumentTest = FunctionArgumentTest;
	exports.TestStatus = TestStatus;
	exports.Test = Test;
	
});


RequireJS.addFunction('./public/js/utils/object/lookup.js',
function (require, exports, module) {
	
class IdString extends String {
	  constructor(...ids) {
	    let id = '';
	    for (let index = 0; index < ids.length; index++) {
	      id += `${ids[index]}_`;
	    }
	    id = id.substring(0, id.length - 1);
	    if (id.length === 0) {
	      console.warn('Not sure if this is a problem');
	    }
	    super(id);
	    this.split = () => {
	      return id.split('_');
	    }
	    this.toJson = () => new String(id);
	    this.index = (index) => this.split().at(index);
	    this.equals = (other) => `${this}` ===`${other}`;
	    this.equivalent = (other, ...indicies) => {
	      if (indicies.length === 0) return this.equals(other);
	      const thisSplit = this.split();
	      const otherSplit = other.split();
	      for (let index = 0; index < indicies.length; index++) {
	        const i = indicies[index];
	        if (thisSplit[i] !== otherSplit[i]) return false;
	      }
	      return true;
	    }
	  }
	}
	
	
	
	class Lookup {
	  constructor(id, attr, singleton) {
	    Lookup.convert(this, attr, id, singleton);
	  }
	}
	
	Lookup.convert = function (obj, attr, id, singleton) {
	  if (id) {
	    const decoded = Lookup.decode(id);
	    if (decoded) {
	      id = decoded.id;
	    } else if (id._TYPE !== undefined) {
	      id = Lookup.decode(id[id[Lookup.ID_ATTRIBUTE]]).id;
	    }
	  }
	
	  const cxtr = obj.constructor;
	  const cxtrName = cxtr.name;
	  id = new IdString(cxtrName, id || String.random());
	  let group;
	  if (singleton && cxtr.get(id)) return cxtr.get(id);
	
	  let constructedAt = new Date().getTime();
	  let modificationWindowOpen = true;
	  attr = attr || 'id';
	    Object.getSet(obj, attr, Lookup.ID_ATTRIBUTE);
	  obj.lookupGroup = (g) => {
	    if (group === undefined && g !== undefined) {
	      if (Lookup.groups[g] === undefined) Lookup.groups[g] = [];
	      group = g;
	      Lookup.groups[g].push(obj);
	    }
	    return group;
	  }
	
	  obj.lookupRelease = () => {
	    if (cxtr.reusable === true) {
	      if (Lookup.freeAgents[cxtr.name] === undefined) Lookup.freeAgents[cxtr.name] = [];
	      Lookup.freeAgents[cxtr.name].push(obj);
	      const index = Lookup.groups[group] ? Lookup.groups[group].indexOf(obj) : -1;
	      if (index !== -1) Lookup.groups[group].splice(index, 1);
	    }
	    delete Lookup.byId[cxtr.name][obj[attr]().index(-1)];
	  }
	
	
	  obj[Lookup.ID_ATTRIBUTE] = () => attr;
	  obj[attr] = (idStr) => {
	    if (modificationWindowOpen) {
	      if (idStr instanceof IdString) {
	        let objId = idStr.index(-1);
	        id = new IdString(cxtrName, objId);
	        Lookup.byId[cxtr.name][id.index(-1)] = obj;
	        modificationWindowOpen = false;
	      } else if (constructedAt < new Date().getTime() - 200) {
	        modificationWindowOpen = false;
	      }
	    }
	    return id;
	  }
	
	  function registerConstructor() {
	    if (Lookup.byId[cxtr.name] === undefined) {
	      Lookup.byId[cxtr.name] = {};
	      Lookup.constructorMap[cxtr.name] = cxtr;
	    }
	  }
	
	  function addSelectListFuncToConstructor() {
	    if(cxtr.selectList === Lookup.selectList) {
	      cxtr.get = (id) => Lookup.get(id, cxtr);
	      if (cxtr.instance === undefined) cxtr.instance = () => Lookup.instance(cxtr.name);
	      Lookup.byId[cxtr.name] = {};
	      cxtr.selectList = () => Lookup.selectList(cxtr.name);
	    }
	  }
	
	  registerConstructor();
	  addSelectListFuncToConstructor();
	
	
	  Lookup.byId[cxtrName][id.index(-1)] = obj;
	  if (obj.toString === undefined) obj.toString = () => obj[attr]();
	}
	
	Lookup.ID_ATTRIBUTE = 'ID_ATTRIBUTE';
	Lookup.byId = {Lookup};
	Lookup.constructorMap = {};
	Lookup.groups = {};
	Lookup.freeAgents = {};
	
	Lookup.get = (id, cxtr) => {
	  const decoded = Lookup.decode(id);
	  let decodedId, decodedCxtr;
	  if (decoded) {
	    decodedId = decoded.id;
	    decodedCxtr = decoded.constructor;
	  }
	  id = decodedId || id;
	  cxtr = cxtr || decodedCxtr || Lookup;
	  const instance = Lookup.byId[cxtr.name][id] || (decodedCxtr && Lookup.byId[decodedCxtr.name][id]);
	  return instance;
	}
	Lookup.selectList = (className) => {
	  return Object.keys(Lookup.byId[className]);
	}
	Lookup.instance = (cxtrName) => {
	  const agents = Lookup.freeAgents[cxtrName];
	  if (!agents || agents.length === 0) {
	    return new (Lookup.constructorMap[cxtrName])();
	  }
	
	  const index = agents.length - 1;
	  const agent = agents[index];
	  agents.splice(index, 1);
	  return agent;
	}
	Lookup.decode = (id) => {
	  if ((typeof id) === 'string') id = new IdString(id);
	  if (!(id instanceof IdString)) return;
	  const cxtrId = id.index(0);
	  const objId = id.index(-1);
	  return {
	    constructor: cxtrId === objId ? undefined : Lookup.constructorMap[cxtrId],
	    id: objId
	  };
	}
	Lookup.release = (group) => {
	  const groupList = Lookup.groups[group];
	  if (groupList === undefined) return;
	  Lookup.groups[group] = [];
	  for (let index = 0; index < groupList.length; index += 1) {
	    groupList[index].release();
	  }
	}
	
	try {
	  module.exports = Lookup;
	} catch (e) {/* TODO: Consider Removing */}
	
});


RequireJS.addFunction('./public/js/utils/display/catch-all.js',
function (require, exports, module) {
	const du = require('../dom-utils');
	
	class CatchAll {
	  constructor(container) {
	    const instance = this;
	    container = container;
	    let events = Array.from(arguments).splice(1);
	    events = events.length > 0 ? events : CatchAll.allMouseEvents;
	
	    const backdrop = document.createElement('DIV');
	    this.backdrop = backdrop;
	
	    this.hide = () => {
	      backdrop.hidden = true;
	      backdrop.style.zIndex = 0;
	    };
	    this.show = () => {
	      backdrop.hidden = false
	      instance.updateZindex();
	    };
	
	    this.updateZindex = () => setTimeout(() => {
	      if (container) {
	        if (container.style.zIndex === '') {
	          container.style.zIndex = 2;
	        }
	        backdrop.style.zIndex = Number.parseInt(container.style.zIndex) - 1;
	      } else {
	        backdrop.style.zIndex = CatchAll.findHigestZindex() + 1;
	      }
	    }, 200);
	
	    this.on = (eventName, func) => backdrop.addEventListener(eventName, func);
	
	    backdrop.style.position = 'fixed';
	    backdrop.style.backgroundColor = 'transparent';
	
	    // backdrop.style.cursor = 'none';
	    backdrop.style.top = 0;
	    backdrop.style.bottom = 0;
	    backdrop.style.right = 0;
	    backdrop.style.left = 0;
	    const stopPropagation = (e) => e.stopPropagation();
	    events.forEach((eventName) => instance.on(eventName, stopPropagation));
	    CatchAll.container.append(backdrop);
	
	    this.updateZindex();
	    this.hide();
	  }
	}
	
	
	CatchAll.allMouseEvents = ['auxclick', 'click', 'contextmenu', 'dblclick',
	                        'mousedown', 'mouseenter', 'mouseleave', 'mousemove',
	                        'mouseover', 'mouseout', 'mouseup', 'pointerlockchange',
	                        'pointerlockerror', 'select', 'wheel'];
	
	// Ripped off of: https://stackoverflow.com/a/1120068
	CatchAll.findHigestZindex = function () {
	  var elems = document.querySelectorAll('*');
	  var highest = Number.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);
	  for (var i = 0; i < elems.length; i++)
	  {
	    var zindex = Number.parseInt(
	      document.defaultView.getComputedStyle(elems[i], null).getPropertyValue("z-index"),
	      10
	    );
	    if (zindex > highest && zindex !== 2147483647)
	    {
	      highest = zindex;
	    }
	  }
	  return highest;
	}
	
	CatchAll.container = du.create.element('div', {id: 'catch-all-cnt'});
	document.body.append(CatchAll.container);
	
	module.exports = CatchAll;
	
});


RequireJS.addFunction('./public/js/utils/display/drag-drop.js',
function (require, exports, module) {
	
const $t = require('../$t');
	const CatchAll = require('./catch-all');
	const du = require('../dom-utils');
	const Resizer = require('./resizer');
	
	class DragDropResize {
	  constructor (props) {
	    props = props || {};
	    const id = Math.floor(Math.random() * 1000000);
	    const POPUP_CNT_ID = 'place-popup-cnt-id-' + id;
	    const POPUP_CONTENT_ID = 'place-popup-content-id-' + id;
	    const POPUP_CONTENT_CNT_ID = 'place-popup-content-cnt-id-' + id;
	    const MAXIMIZE_BTN_ID = 'place-maximize-id-' + id;
	    const POPUP_HEADER_CNT_ID = 'place-header-cnt-id-' + id;
	    const MINIMIZE_BTN_ID = 'place-minimize-id-' + id;
	    const MAX_MIN_CNT_ID = 'place-max-min-id-' + id;
	    const CLOSE_BTN_ID = 'place-close-btn-id-' + id;
	    const MOVE_BTN_ID = 'place-MOVE-btn-id-' + id;
	    const BACK_BTN_ID = 'place-back-btn-id-' + id;
	    const FORWARD_BTN_ID = 'place-forward-btn-id-' + id;
	    const HISTORY_BTN_ID = 'place-history-btn-id-' + id;
	    const position = props.position || 'absolute';
	    const template = new $t('place');
	    let lastMoveEvent, prevLocation, minLocation, selectElem,
	        currElem, hasMoved;
	    const instance = this;
	    const closeFuncs = [];
	
	    let width = props.width || 'fit-content';
	    let height = props.height || 'fit-content';
	    this.getDems = props.getDems || ( () => { return {width, height}; } );
	    this.setDems = props.setDems || ( (w, h) => { width = w; height = h; } );
	
	    this.hasMoved = () => hasMoved;
	    function onResizeEvent() {
	      const rect = popupCnt.getBoundingClientRect();
	      if (!Resizer.isLocked(popupCnt)) instance.setDems({width: rect.width + 'px', height: rect.height + 'px'});
	    }
	
	    const defaultStyle = `position: ${position};`;
	
	    this.close = () => {
	      getPopupElems().cnt.style.display = 'none';
	      Resizer.hide(popupCnt);
	      closeFuncs.forEach((func) => func());
	      middleSize();
	      backdrop.hide();
	      histCnt.hidden = true;
	    }
	    this.hide = this.close;
	
	    this.updateZindex = () => {
	      const highestZ = CatchAll.findHigestZindex();
	      popupCnt.style.zIndex = highestZ + 2;
	      backdrop.backdrop.style.zIndex = highestZ - 1;
	    }
	
	    this.show = () => {
	      if (instance.hidden()) {
	        if (!props.noBackdrop) backdrop.show();
	        updateControls();
	        const css = {display: 'block',
	        height: Resizer.isLocked(popupCnt) ? undefined : instance.getDems().height,
	        width: Resizer.isLocked(popupCnt) ? undefined : instance.getDems().width};
	        if (Number.isFinite(css.height)) css.height = css.height + 'px';
	        if (Number.isFinite(css.width)) css.width = css.width + 'px';
	
	        setCss(css);
	        if (!Resizer.isLocked(popupCnt)) Resizer.show(popupCnt);
	      }
	      this.updateZindex();
	      // updateHistZindex();
	      return instance;
	    };
	
	    this.hidden = () => getPopupElems().cnt.style.display === 'none';
	
	    this.withinPopup = (offset) => {
	      const rect = getPopupElems().cnt.getBoundingClientRect();
	      if (lastMoveEvent) {
	        const withinX = lastMoveEvent.clientX < rect.right - offset && rect.left + offset < lastMoveEvent.clientX;
	        const withinY = lastMoveEvent.clientY < rect.bottom - offset && rect.top + offset < lastMoveEvent.clientY;
	        return withinX && withinY;
	      }
	      return false;
	    }
	
	    function updateHistZindex() {
	      histCnt.style.zIndex = Number.parseInt(popupCnt.style.zIndex) + 1;
	    }
	
	    function getRelitiveRect(elem) {
	      let rect;
	      if (elem instanceof HTMLElement) {
	        rect = elem.getBoundingClientRect();
	      } else if (elem.x !== undefined && elem.y !== undefined) {
	        const x = (typeof elem.x === 'function') ? elem.x() : elem.x;
	        const y = (typeof elem.y === 'function') ? elem.y() : elem.y;
	        return {
	          top: y,
	          bottom: y,
	          right: x,
	          left: x,
	          width: 0,
	          height: 0
	        }
	      } else {
	        rect = {top: 0, bottom: 0, right: 0, left: 0, width: 100, height: 100};
	        console.warn('unknown DragDrops position element:', elem);
	      }
	
	      const absRect = {};
	      const scrollOffset = getScrollOffset();
	      absRect.top = rect.top + scrollOffset.y;
	      absRect.bottom = rect.bottom + scrollOffset.y;
	      absRect.right = rect.right + scrollOffset.x;
	      absRect.left = rect.left + scrollOffset.x;
	      absRect.width = rect.width;
	      absRect.height = rect.height;
	      return absRect
	    }
	
	    this.back = () => setCss(prevLocation);
	
	    function positionOnElement(elem, container) {
	      currElem = elem || currElem;
	      container = container || getPopupElems().cnt;
	      instance.show();
	      let rect = getRelitiveRect(currElem);
	      let popRect = getRelitiveRect(container);
	      let padding = 8;
	
	      let top = `${rect.top}px`;
	      const position = {};
	      position.close = instance.close;
	      position.top = () =>{setCss({top: rect.top - popRect.height - padding + 'px'}, container); return position;};
	      position.bottom = () =>{setCss({top: rect.bottom + padding + 'px'}, container); return position;};
	      position.left = () =>{setCss({left: rect.left - popRect.width - padding + 'px'}, container); return position;};
	      position.right = () =>{setCss({left: rect.right + padding + 'px'}, container); return position;};
	      position.center = () =>{
	              let left = rect.left - (popRect.width / 2) + (rect.width / 2);
	              let top = rect.top - (popRect.height / 2) + (rect.height / 2);
	              setCss({left: left + 'px', top: top + 'px'}, container);
	              return position;};
	      position.inView = () =>{
	        // TODO: Fix or remove
	        let popRect = getRelitiveRect(container || getPopupElems().cnt);
	        const left = (popRect.left > 10 ? popRect.left : 10) + 'px';
	        const right = (popRect.right > 10 ? popRect.right : 10) + 'px';
	        const top = (popRect.top > 10 ? popRect.top : 10) + 'px';
	        const bottom = (popRect.bottom > 10 ? popRect.bottom : 10) + 'px';
	        setCss({left, right, top, bottom}, container);
	        return position;};
	      position.maximize = instance.maximize.bind(position);
	      position.minimize = instance.minimize.bind(position);
	      if (window.innerHeight / 2 > rect.top - window.scrollY) {
	        position.center().bottom().inView();
	      } else {
	        position.center().top().inView();
	      }
	
	      return position;
	    }
	
	    this.position = positionOnElement;
	    this.select = () => {
	      if (window.getSelection().toString().trim()) {
	        selectElem = window.getSelection().getRangeAt(0);
	        currElem = selectElem;
	      }
	      return positionOnElement(selectElem);
	    };
	    this.top = () => setCss({top:0,bottom:''});
	    this.left = () => setCss({right:'',left:0});
	    this.bottom = () => setCss({top:'',bottom:0});
	    this.right = () => setCss({right:0,left:''});
	
	    this.center = function () {
	      const popRect = getPopupElems().cnt.getBoundingClientRect();
	      const top = `${(window.innerHeight / 2) - (popRect.height / 2)}px`;
	      const left = `${(window.innerWidth / 2) - (popRect.width / 2)}px`;
	      setCss({top,left, right: '', bottom: ''});
	      return instance;
	    }
	
	    function showElem(id, show) {
	      popupCnt.hidden = !show;
	    }
	
	    function updateControls() {
	      showElem(MINIMIZE_BTN_ID, !props.hideMin && (isMaximized || props.tabText !== undefined));
	      showElem(MAXIMIZE_BTN_ID, !props.hideMax && !isMaximized());
	      const hasPast = props.hasPast ? props.hasPast() : false;
	      showElem(BACK_BTN_ID, hasPast);
	      const hasFuture = props.hasFuture ? props.hasFuture() : false;
	      showElem(FORWARD_BTN_ID, hasFuture);
	      showElem(HISTORY_BTN_ID, hasFuture || hasPast);
	
	    }
	
	    function middleSize() {
	      if (minLocation) {
	        setCss({position, transform: 'unset', top: 'unset', bottom: 'unset', right: 'unset', left: 'unset', width: instance.getDems().width})
	        setCss(minLocation);
	        showElem(POPUP_HEADER_CNT_ID, false);
	        showElem(POPUP_CONTENT_CNT_ID, true);
	        prevLocation = minLocation;
	        minLocation = undefined;
	        updateControls();
	        return true;
	      }
	      return false;
	    }
	
	    this.maximize = function () {
	      if (!middleSize()) {
	        setCss({position: 'fixed', top: 0, bottom: 0, right: 0, left:0, maxWidth: 'unset', maxHeight: 'unset', width: 'unset', height: '95vh'})
	        minLocation = prevLocation;
	        updateControls();
	      }
	      return this;
	    }
	
	    this.minimize = function () {
	      if (!middleSize() && props.tabText) {
	        console.log('tab-it')
	        tabHeader.innerText = props.tabText();
	        showElem(POPUP_HEADER_CNT_ID, true);
	        showElem(POPUP_CONTENT_CNT_ID, false);
	        setCss({left: 0, right: 0, bottom: 0, maxWidth: 'unset', maxHeight: 'unset', minWidth: 'unset',
	                minHeight: 'unset', width: 'fit-content', height: 'fit-content',
	                transform: 'rotate(90deg)'});
	        minLocation = prevLocation;
	        const rect = popupCnt.getBoundingClientRect();
	        const left = (rect.width - rect.height)/2 + 'px';
	        setCss({left});
	        DragDropResize.events.tabbed.trigger(getPopupElems().cnt);
	      }
	      return this;
	    }
	
	    function setCss(rect, container) {
	      if (container === undefined) {
	        const popRect = getPopupElems().cnt.getBoundingClientRect();
	        const top = getPopupElems().cnt.style.top;
	        const bottom = getPopupElems().cnt.style.bottom;
	        const left = getPopupElems().cnt.style.left;
	        const right = getPopupElems().cnt.style.right;
	        const maxWidth = getPopupElems().cnt.style.maxWidth;
	        const maxHeight = getPopupElems().cnt.style.maxHeight;
	        const width = getPopupElems().cnt.style.width;
	        const height = getPopupElems().cnt.style.height;
	        prevLocation = {top, bottom, left, right, maxWidth, maxHeight, width, height}
	        setTimeout(() => Resizer.position(popupCnt), 0);
	      }
	      du.style(container || getPopupElems().cnt, rect);
	      return instance;
	    }
	    this.setCss = setCss;
	
	    this.onClose = (func) => closeFuncs.push(func);
	
	    function updateContent(html) {
	      du.innerHTML(html, getPopupElems().content);
	      return instance;
	    }
	    this.updateContent = updateContent;
	
	    function isMaximized() {
	      return minLocation !== undefined;
	    }
	    this.isMaximized = isMaximized;
	
	    function getScrollOffset() {
	      let x,y;
	      if (props.position === 'fixed') {
	        y = 0;
	        x = 0;
	      } else {
	        y = window.scrollY;
	        x = window.scrollX;
	      }
	      return {x, y}
	    }
	
	    let moving;
	    function move(e) {
	      console.log('moving!');
	      backdrop.show();
	      Resizer.hide(popupCnt);
	      const rect = popupCnt.getBoundingClientRect();
	      const scrollOffset = getScrollOffset();
	      moving = {clientX: e.clientX + scrollOffset.x,
	                  clientY: e.clientY + scrollOffset.y,
	                  top: rect.top + scrollOffset.y,
	                  left: rect.left + scrollOffset.x};
	      DragDropResize.events.dragstart.trigger(getPopupElems().cnt);
	    }
	
	    function get(name) {
	      const prop = props[name];
	      if ((typeof prop) === 'function') return prop();
	      return prop;
	    }
	
	    function stopMoving() {
	      moving = undefined;
	      backdrop.hide();
	      Resizer.position(popupCnt);
	      DragDropResize.events.dragend.trigger(getPopupElems().cnt);
	      DragDropResize.events.drop.trigger(getPopupElems().cnt);
	      if (!Resizer.isLocked(popupCnt)) Resizer.show(popupCnt);
	    }
	
	    function backdropClick() {
	      if (moving) stopMoving();
	      else instance.close();
	    }
	
	    const tempElem = document.createElement('div');
	    tempElem.append(document.createElement('div'));
	    const tempHtml = template.render({POPUP_CNT_ID, POPUP_CONTENT_ID,
	        MINIMIZE_BTN_ID, MAXIMIZE_BTN_ID, MAX_MIN_CNT_ID, CLOSE_BTN_ID,
	        HISTORY_BTN_ID, FORWARD_BTN_ID, BACK_BTN_ID, MOVE_BTN_ID,
	        POPUP_HEADER_CNT_ID, POPUP_CONTENT_CNT_ID,
	        props});
	    du.innerHTML(tempHtml, tempElem.children[0]);
	    // tempElem.children[0].style = defaultStyle;
	    DragDropResize.container.append(tempElem);
	
	    const popupContent = tempElem.children[0];
	    const popupCnt = tempElem;
	    popupCnt.className = 'drag-drop-popup-cnt';
	    const histCnt = document.createElement('DIV');
	    const tabHeader = du.id(POPUP_HEADER_CNT_ID);
	    if (tabHeader) {
	      tabHeader.onclick = this.maximize;
	    }
	    const histFilter = document.createElement('input');
	    histFilter.placeholder = 'filter';
	    const histDisplayCnt = document.createElement('DIV');
	    histCnt.append(histFilter);
	    histCnt.append(histDisplayCnt);
	    histDisplayCnt.style.maxHeight = '20vh';
	    histDisplayCnt.style.overflow = 'auto';
	    histCnt.style.position = position;
	    histCnt.hidden = true;
	    histCnt.className = 'place-history-cnt';
	    DragDropResize.container.append(histCnt);
	    popupCnt.style = defaultStyle;
	    popupCnt.addEventListener(Resizer.events.resize.name, onResizeEvent);
	    du.on.match('click', `${MAXIMIZE_BTN_ID}`, instance.maximize);
	    du.on.match('click', `${MINIMIZE_BTN_ID}`, instance.minimize);
	    du.on.match('click', `${CLOSE_BTN_ID}`, instance.close);
	    du.on.match('click', `${MOVE_BTN_ID}`, move);
	    // if (props.back) {
	    //   document.getElementById(BACK_BTN_ID).onclick = () => {
	    //     props.back();
	    //     updateControls();
	    //     event.stopPropagation();
	    //     histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //   }
	    // }
	    // if (props.forward) {
	    //   document.getElementById(FORWARD_BTN_ID).onclick = () => {
	    //     props.forward();
	    //     updateControls();
	    //     event.stopPropagation();
	    //     histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //   }
	    // }
	    // if (props.historyDisplay) {
	    //   const historyBtn = document.getElementById(HISTORY_BTN_ID);
	    //   historyBtn.onclick = (event) => {
	    //     histCnt.hidden = false;
	    //     histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //     positionOnElement(historyBtn, histCnt).center().bottom();
	    //     updateHistZindex();
	    //     event.stopPropagation();
	    //   }
	    //   histCnt.onclick = (event) => {
	    //     event.stopPropagation();
	    //   }
	    //   histDisplayCnt.onclick = (event) => {
	    //     event.stopPropagation();
	    //     if ((typeof props.historyClick) === 'function') {
	    //       props.historyClick(event);
	    //       updateControls();
	    //       histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //       histFilter.focus();
	    //     }
	    //   }
	    //   histFilter.onkeyup = () => {
	    //     histDisplayCnt.innerHTML = props.historyDisplay(histFilter.value);
	    //     histFilter.focus();
	    //   }
	    // }
	
	    popupCnt.onclick = (e) => {
	      histCnt.hidden = true;
	      // if (e.target.tagName !== 'A')
	      // e.stopPropagation()
	    };
	
	    // CssFile.apply('place');
	
	
	    function getPopupElems() {
	      return {cnt: popupCnt, content: popupContent};
	    }
	
	    let lastDragNotification = new Date().getTime()
	    let lastMove = new Date().getTime()
	    function mouseMove(e) {
	      const time = new Date().getTime();
	      const scrollOffset = getScrollOffset();
	      lastMoveEvent = {clientX: e.clientX + scrollOffset.x,
	                      clientY: e.clientY + scrollOffset.y};
	      if (moving && lastMove < time + 100) {
	        console.log('moving')
	        const dy = moving.clientY - lastMoveEvent.clientY;
	        const dx = moving.clientX - lastMoveEvent.clientX;
	        const rect = popupCnt.getBoundingClientRect();
	        popupCnt.style.top = moving.top - dy + 'px';
	        popupCnt.style.left = moving.left - dx + 'px';
	        if (lastDragNotification + 350 < time) {
	          DragDropResize.events.drag.trigger(getPopupElems().cnt);
	          lastDragNotification = time;
	        }
	      }
	    }
	
	    function on(eventName, func) {
	      getPopupElems().content.addEventListener(eventName, func);
	    }
	    this.on = on;
	
	    const cancelFade = du.fade.out(getPopupElems().cnt, 10, instance.close);
	    getPopupElems().cnt.addEventListener('mouseover', cancelFade);
	
	
	    this.container = () => getPopupElems().cnt;
	    this.lockSize = () => Resizer.lock(popupCnt);
	    this.unlockSize = () => Resizer.unlock(popupCnt);
	
	    if (props.resize !== false){
	      Resizer.all(popupCnt, props.position);
	    }
	    const backdrop = new CatchAll(popupCnt);
	    backdrop.on('click', backdropClick);
	    backdrop.on('mousemove', mouseMove);
	
	    Resizer.position(popupCnt);
	  }
	}
	
	DragDropResize.events = {};
	DragDropResize.container = du.create.element('div', {id: 'drag-drop-resize'});
	document.body.append(DragDropResize.container);
	DragDropResize.events.drag = new CustomEvent ('drag');
	DragDropResize.events.dragend = new CustomEvent ('dragend');
	DragDropResize.events.dragstart = new CustomEvent ('dragstart');
	DragDropResize.events.drop = new CustomEvent ('drop');
	DragDropResize.events.tabbed = new CustomEvent ('tabbed');
	
	// drag	An element or text selection is being dragged (fired continuously every 350ms).
	// dragend	A drag operation is being ended (by releasing a mouse button or hitting the escape key).
	// dragstart	The user starts dragging an element or text selection.
	// drop	An element is dropped on a valid drop target.
	
	module.exports = DragDropResize;
	
});


RequireJS.addFunction('./public/js/utils/display/pop-up.js',
function (require, exports, module) {
	const DragDropResize = require('./drag-drop');
	
	class PopUp {
	  constructor (props) {
	    props = props || {}
	    const instance = this;
	    const htmlFuncs = {};
	    let forceOpen = false;
	    let lockOpen = false;
	    let currFuncs, currElem;
	    let canClose = false;
	
	    const popupCnt = new DragDropResize(props);
	
	    popupCnt.hide();
	
	    this.position = () => popupCnt;
	    this.positionOnElement = popupCnt.position;
	
	
	    this.softClose = () => {
	      if (!lockOpen) {
	        instance.close();
	      }
	    }
	
	    this.close = popupCnt.close;
	
	    this.show = () => {
	      popupCnt.show();
	    };
	
	    function getFunctions(elem) {
	      let foundFuncs;
	      const queryStrs = Object.keys(htmlFuncs);
	      queryStrs.forEach((queryStr) => {
	        if (elem.matches(queryStr)) {
	          if (foundFuncs) {
	            throw new Error('Multiple functions being invoked on one hover event');
	          } else {
	            foundFuncs = htmlFuncs[queryStr];
	          }
	        }
	      });
	      return foundFuncs;
	    }
	
	    function on(queryStr, funcObj) {
	      if (htmlFuncs[queryStr] !== undefined) throw new Error('Assigning multiple functions to the same selector');
	      htmlFuncs[queryStr] = funcObj;
	    }
	    this.on = on;
	
	    this.onClose = popupCnt.onClose;
	
	    function updateContent(html) {
	      popupCnt.updateContent(html);
	      if (currFuncs && currFuncs.after) currFuncs.after();
	      return instance;
	    }
	    this.updateContent = updateContent;
	
	    this.open = (html, positionOn) => {
	      this.updateContent(html);
	      popupCnt.position(positionOn);
	      this.show();
	    }
	
	    this.container = popupCnt.container;
	    this.hasMoved = popupCnt.hasMoved;
	    this.lockSize = popupCnt.lockSize;
	    this.unlockSize = popupCnt.unlockSize;
	
	    document.addEventListener('click', this.forceClose);
	  }
	}
	
	module.exports = PopUp;
	
});


RequireJS.addFunction('./public/js/utils/display/resizer.js',
function (require, exports, module) {
	const CatchAll = require('./catch-all');
	const du = require('../dom-utils');
	const CustomEvent = require('../custom-event');
	
	class Resizer {
	  constructor (elem, axisObj, cursor) {
	    const instance = this;
	    const minimumSize = 40;
	    let resizeId = elem.getAttribute(Resizer.resizeAttr);
	    let sizeLocked = false;
	
	    if (!resizeId) {
	      resizeId = 'resize-' + Math.floor(Math.random() * 1000000);
	      elem.setAttribute(Resizer.resizeAttr, resizeId);
	    }
	
	    this.show = () => {this.container.hidden = false; this.position()};
	    this.hide = () => this.container.hidden = true;
	
	    function updateZindex(zIndex) {
	      if (instance.container.hidden === false) {
	        instance.container.style.zIndex = zIndex;
	        elem.style.zIndex = zIndex;
	        Resizer.backdrop.updateZindex();
	        instance.position();
	      }
	    }
	    this.updateZindex = updateZindex;
	    elem.addEventListener('click', () => Resizer.updateZindex(elem));
	
	
	    if (resizeId) {
	      if (!Resizer.collections[resizeId]) {
	        Resizer.collections[resizeId] = [];
	      }
	      Resizer.collections[resizeId].push(this);
	    }
	    const padding = 8;
	    let resize = false;
	    let lastPosition;
	    this.getPadding = () => padding;
	
	    const attrs = Object.values(axisObj);
	    const top = attrs.indexOf('top') !== -1;
	    const bottom = attrs.indexOf('bottom') !== -1;
	    const left = attrs.indexOf('left') !== -1;
	    const right = attrs.indexOf('right') !== -1;
	
	    this.container = document.createElement('DIV');
	    this.container.style.cursor = cursor;
	    this.container.style.padding = padding/2 + 'px';
	    this.container.style.position = axisObj.position || 'absolute';
	    this.container.style.backgroundColor = 'transparent';
	    Resizer.container.append(this.container);
	
	    function getComputedSize(element, property) {
	      return Number.parseInt(window.getComputedStyle(element).getPropertyValue(property));
	    }
	
	    function resizeCnt (event) {
	      if (resize) {
	        Resizer.updateZindex(elem);
	        let dy = resize.clientY - event.clientY;
	        let dx = resize.clientX - event.clientX;
	        let minHeight = getComputedSize(elem, 'min-height');
	        let minWidth = getComputedSize(elem, 'min-width');
	        if (axisObj.x) {
	          if (left) dx *= -1;
	          const newWidth = lastPosition.width - dx;
	          if (newWidth > minWidth) {
	            if (left) {
	              elem.style.left = lastPosition.left + dx + 'px';
	            }
	            elem.style.width = newWidth + 'px'
	          }
	        }
	        if (axisObj.y) {
	          if (top) dy *= -1;
	          const newHeight = lastPosition.height - dy;
	          if (newHeight > minHeight) {
	            if (top) {
	              elem.style.top = lastPosition.top + window.scrollY + dy + 'px';
	            }
	            elem.style.height = newHeight + 'px'
	          }
	        }
	      }
	    }
	
	    this.container.onmousedown = (e) => {
	      resize = e;
	      Resizer.backdrop.show();
	      lastPosition = elem.getBoundingClientRect();
	      // e.stopPropagation();
	      // e.preventDefault();
	    }
	
	    function stopResizing() {
	      if (resize) {
	        resize = undefined;
	        Resizer.position(elem);
	        Resizer.backdrop.hide();
	        Resizer.events.resize.trigger(elem);
	      }
	    }
	
	    function isFixed() {
	      return axisObj.position && axisObj.position === 'fixed';
	    }
	
	    // this.container.addEventListener('click',
	    // (e) =>
	    // e.stopPropagation()
	    // );
	    Resizer.backdrop.on('mouseup', stopResizing);
	    this.container.onmouseup = stopResizing;
	
	    this.container.onmousemove = resizeCnt;
	    Resizer.backdrop.on('mousemove', (event) =>
	    resizeCnt(event));
	    this.position = function () {
	      const height = document.documentElement.clientHeight;
	      const width = document.documentElement.clientWidth;
	      const rect = elem.getBoundingClientRect();
	      const cntStyle = instance.container.style;
	      const scrollY =  isFixed() ? 0 : window.scrollY;
	      const scrollX =  isFixed() ? 0 : window.scrollX;
	      if (top) {
	        cntStyle.top = rect.top - padding + scrollY + 'px';
	      } else if (!bottom) {
	        cntStyle.top = rect.top + scrollY + 'px';
	      }
	
	      if (bottom) {
	        cntStyle.bottom = (height - rect.bottom) - padding - scrollY + 'px';
	      } else if (!top) {
	        cntStyle.bottom = (height - rect.bottom) - scrollY + 'px';
	      }
	
	      if (right) {
	        cntStyle.right = (width - rect.right) - padding - scrollX + 'px';
	      } else if (!left) {
	        cntStyle.right = (width - rect.right) - scrollX + 'px';
	      }
	
	      if (left) {
	        cntStyle.left = rect.left - padding + scrollX + 'px';
	      } else if (!right) {
	        cntStyle.left = rect.left + scrollX + 'px';
	      }
	    }
	  }
	}
	
	Resizer.container = du.create.element('div', {id: 'resizer-cnt'});
	document.body.append(Resizer.container);
	
	Resizer.lastZindexSearch = new Date().getTime();
	Resizer.zIndex = (zindex) => {
	  const time = new Date().getTime();
	  if (time > Resizer.lastZindexSearch + 500) {
	    Resizer.zed = CatchAll.findHigestZindex();
	    lastZindexSearch = time;
	  }
	  return Resizer.zed;
	}
	Resizer.container.id = 'resize-id-id';
	// Resizer.container.addEventListener('click', (e) => e.stopPropagation());
	Resizer.events = {};
	Resizer.events.resize = new CustomEvent ('resized')
	
	Resizer.backdrop = new CatchAll();
	
	Resizer.resizeAttr = 'resizer-id'
	Resizer.collections = {};
	Resizer.position = function (elem) {
	  const resizeId = elem.getAttribute(Resizer.resizeAttr);
	  const collection = Resizer.collections[resizeId];
	  if (collection) {
	    collection.forEach((item) => item.position());
	  }
	}
	Resizer.onEach = function (elem, func) {
	  const callArgs = Array.from(arguments).splice(2);
	  const resizeId = elem.getAttribute(Resizer.resizeAttr);
	  const collection = Resizer.collections[resizeId];
	  if (collection) {
	    collection.forEach((item) => item[func](...callArgs));
	  }
	}
	Resizer.hide = (elem) => Resizer.onEach(elem, 'hide');
	Resizer.show = (elem) => {
	    if (!Resizer.isLocked(elem)) {
	      Resizer.onEach(elem, 'show');
	      Resizer.updateZindex(elem);
	    }
	};
	Resizer.updateZindex = (elem, callback) => {
	  const highestZIndex = Resizer.zIndex() - 3;
	  if (!elem.style.zIndex ||
	      (elem.style.zIndex.match(/[0-9]{1,}/) &&
	        highestZIndex > Number.parseInt(elem.style.zIndex))) {
	    Resizer.onEach(elem, 'updateZindex', highestZIndex + 4);
	  }
	}
	
	{
	  const locked = {};
	  Resizer.lock = (elem) => locked[elem.getAttribute(Resizer.resizeAttr)] = true;
	  Resizer.unlock = (elem) => locked[elem.getAttribute(Resizer.resizeAttr)] = false;
	  Resizer.isLocked  = (elem) => locked[elem.getAttribute(Resizer.resizeAttr)];
	}
	
	Resizer.all = (elem, position) => {
	  new Resizer(elem, {y: 'top', position}, 'n-resize');
	  new Resizer(elem, {y: 'bottom', position}, 's-resize');
	  new Resizer(elem, {x: 'right', position}, 'e-resize');
	  new Resizer(elem, {x: 'left', position}, 'w-resize', position);
	  new Resizer(elem, {x: 'right', y: 'top', position}, 'ne-resize');
	  new Resizer(elem, {x: 'left', y: 'top', position}, 'nw-resize');
	  new Resizer(elem, {x: 'right', y: 'bottom', position}, 'se-resize');
	  new Resizer(elem, {x: 'left', y: 'bottom', position}, 'sw-resize');
	}
	
	module.exports = Resizer;
	
});


RequireJS.addFunction('./public/js/utils/object/key-value.js',
function (require, exports, module) {
	
const Lookup = require('./lookup');
	const Notifiction = require('../collections/notification.js');
	const NotifictionArray = Notifiction.Array;
	const CustomEvent = require('../custom-event.js');
	
	function updateParent(keyValue) {
	  return (target, detail) => {
	    if (detail.new instanceof KeyValue) {
	      const parentAttr = detail.new.value.parentAttribute();
	      if (parentAttr) detail.new[parentAttr](keyValue);
	    }
	  }
	}
	
	/**
	  properties:
	    @childrenAttribute - Attribute that defines children an object or an array;
	    @object - true iff you want an object for your children
	    @parentAttribute - Attribute that defines parent setting/getting function;
	    @keyMapFunction - function will be called to convert keys before processing.
	    @id - Lookup id
	    @idAttr - attribute for Lookup id.
	    @evaluators - an object whos attributes are types, the values are functions to resolve said type
	**/
	class KeyValue extends Lookup {
	  constructor(properties) {
	    super(properties.id, properties.idAttr);
	    const childAttr = properties.childrenAttribute;
	    const parentAttr = properties.parentAttribute;
	    const customFuncs = [];
	
	
	    if (childAttr) {
	      if (properties.object) this[childAttr] = new Notifiction(false);
	      else this[childAttr] = new NotifictionArray(false);
	      this[childAttr].onAfterChange(updateParent(this));
	      this.getRoot = () => {
	        let curr = this;
	        while(curr.parentAssembly() !== undefined) curr = curr.parentAssembly();
	        return curr;
	      }
	    }
	
	    function runCustomFunctions(code, value) {
	      for (let index = 0; index < customFuncs; index++) {
	        const customVal = customFuncs[index](code, value);
	        if(customVal) return customVal;
	      }
	    }
	
	    const parentJson = this.toJson;
	    this.toJson = () => {
	      const json = (typeof parentJson) === 'function' ? parentJson() : {};
	      json.value = {values: this.value.values};
	      return json;
	    }
	
	    this.value = (key, value) => {
	      try {
	        const formatted = (typeof this.value.keyFormatter) === 'function' ? this.value.keyFormatter(key) : undefined;
	        if (formatted !== undefined) key = formatted;
	        const customVal = runCustomFunctions(key, value)
	        if(customVal !== undefined) return customVal;
	
	        if (value !== undefined) {
	          this.value.values[key] = value;
	        } else {
	          const instVal = this.value.values[key];
	          if (instVal !== undefined && instVal !== null) {
	            const evaluator = this.value.evaluators[(typeof instVal)];
	            if (evaluator) return evaluator(instVal);
	            return instVal;
	          }
	          const parent = this[parentAttr]();
	          if (parent) return parent.value(key);
	          else {
	            const defaultFunction = this.value.defaultFunction;
	            if (defaultFunction) {
	              value = (typeof this.value.defaultFunction) === 'function' ? this.value.defaultFunction(key, value) : undefined;
	              if (value === undefined) throw new Error();
	              return value;
	            }
	          }
	        }
	      } catch (e) {
	        console.error(`Failed to resolve key: '${key}'`);
	        throw e;
	        return NaN;
	      }
	    }
	    this.value.all = (valueObj) => {
	      Object.merge(this.value.values, valueObj);
	    }
	
	
	    this.value.values = {};
	    this.value.evaluators = properties.evaluators || {};
	    this.value.defaultFunction = properties.defaultFunction;
	    this.value.keyFormatter = properties.keyFormatter;
	    this.value.parentAttribute = () => parentAttr;
	    this.value.childrenAttribute = () => childAttr;
	    this.value.addCustomFunction = (func) => (typeof func) === 'function' && customFuncs.push(func);
	  }
	}
	
	module.exports = KeyValue;
	
});


RequireJS.addFunction('./public/js/utils/object/imposter.js',
function (require, exports, module) {
	
class Imposter {
	  constructor(object, cuckooEggs) {
	    const imposter = new (object.constructor)();
	    cuckooEggs ||= {};
	    const cuckooKeys = Object.keys(cuckooEggs);
	
	    const keys = Object.keys(object);
	    for (let index = 0; index < keys.length; index++) {
	      const key = keys[index];
	      if (cuckooEggs[key] === undefined) {
	        if ((typeof object[key]) === 'function') {
	          imposter[key] = object[key];
	        } else {
	          Object.defineProperty(imposter, key, {
	            get() {
	              return object[key];
	            },
	            set(value) {
	              object[key] = value;
	            }
	          });
	        }
	      }
	    }
	
	    for (let index = 0; index < cuckooKeys.length; index++) {
	      const key = cuckooKeys[index];
	      imposter[key] = cuckooEggs[key];
	    }
	
	    imposter.equals = (obj) => {
	      if (obj === object) return true;
	      return object.equals(obj);
	    }
	
	    return imposter;
	  }
	}
	
	module.exports = Imposter;
	
});


RequireJS.addFunction('./public/js/utils/services/no-activity-runner.js',
function (require, exports, module) {
	
class NoActivityRunner {
	  constructor(timelapse, noActivityFunc) {
	    let pending = false;
	    let callCount = 0;
	
	    const secondCallback = (callId) => () => {
	      if (callId === callCount) noActivityFunc();
	    }
	    const firstCallback = () => {
	      pending = false;
	      setTimeout(secondCallback(callCount), timelapse);
	    }
	
	    return () => {
	      callCount++;
	      if (!pending) {
	        setTimeout(firstCallback, timelapse);
	      }
	    }
	  }
	}
	
	module.exports = NoActivityRunner;
	
});


RequireJS.addFunction('./public/js/utils/input/bind.js',
function (require, exports, module) {
	
const du = require('../dom-utils');
	const Input = require('./input');
	
	const defaultDynamInput = (value, type) => new Input({type, value});
	
	module.exports = function(selector, objOrFunc, props) {
	  let lastInputTime = {};
	  props = props || {};
	  const validations = props.validations || {};
	  const inputs = props.inputs || {};
	
	  const resolveTarget = (elem) => du.find.down('[prop-update]', elem);
	  const getValue = (updatePath, elem) => {
	    const input = Object.pathValue(inputs, updatePath);
	    return input ? input.value() : elem.value;
	  }
	  const getValidation = (updatePath) => {
	    let validation = Object.pathValue(validations, updatePath);
	    const input = Object.pathValue(inputs, updatePath);
	    if (input) {
	      validation = input.validation;
	    }
	    return validation;
	  }
	
	  function update(elem) {
	    const target = resolveTarget(elem);
	    elem = du.find.down('input,select,textarea', elem);
	    const updatePath = elem.getAttribute('prop-update') || elem.getAttribute('name');
	    elem.id = elem.id || String.random(7);
	    const thisInputTime = new Date().getTime();
	    lastInputTime[elem.id] = thisInputTime;
	    setTimeout(() => {
	      if (thisInputTime === lastInputTime[elem.id]) {
	        const validation = getValidation(updatePath);
	        if (updatePath !== null) {
	          const newValue = getValue(updatePath, elem);
	          if ((typeof validation) === 'function' && !validation(newValue)) {
	            console.error('badValue')
	          } else if ((typeof objOrFunc) === 'function') {
	            objOrFunc(updatePath, elem.value, elem);
	          } else {
	            Object.pathValue(objOrFunc, updatePath, elem.value);
	          }
	
	          if (target.tagname !== 'INPUT' && target.children.length === 0) {
	            target.innerHTML = newValue;
	          }
	        }
	      }
	    }, 20);
	  }
	  const makeDynamic = (target) => {
	    target = resolveTarget(target);
	    if (target.getAttribute('resolved') === null) {
	      target.setAttribute('resolved', 'dynam-input');
	      const value = target.innerText;
	      const type = target.getAttribute('type');
	      const updatePath = target.getAttribute('prop-update') || target.getAttribute('name');
	      const input = Object.pathValue(inputs, updatePath) || defaultDynamInput(value, type);
	
	      target.innerHTML = input.html();
	      const id = (typeof input.id === 'function') ? input.id() : input.id;
	      const inputElem = du.find.down(`#${id}`, target);
	      du.class.add(inputElem, 'dynam-input');
	      inputElem.setAttribute('prop-update', updatePath);
	      inputElem.focus();
	    }
	  }
	
	  du.on.match('change:keyup:enter', selector, update);
	  du.on.match('click', selector, makeDynamic);
	}
	
	
	const undoDynamic = (target) => {
	  const parent = du.find.up('[resolved="dynam-input"]', target)
	  parent.innerText = target.value;
	  parent.removeAttribute('resolved');
	}
	
	du.on.match('focusout', '.dynam-input', undoDynamic);
	
});


RequireJS.addFunction('./public/js/utils/input/data-list.js',
function (require, exports, module) {
	
const $t = require('../$t');
	const du = require('../dom-utils');
	
	//TODO: shoould remove datalist from input object... bigger fish
	class DataList {
	  constructor(input) {
	    let list = [];
	    const id = `data-list-${String.random()}`;
	    this.id = () => id;
	    this.list = () => list;
	    this.getElem = () => {
	      let elem = du.id(id);
	      if (!elem)  elem = du.create.element('datalist', {id});
	      du.find('body').append(elem);
	      return elem;
	    }
	    this.update = () => {
	      const elem = this.getElem();
	      elem.innerHTML = DataList.template.render(this);
	      const inputElem = input && input.get();
	      if (inputElem) {
	        inputElem.setAttribute('list', this.id());
	      }
	    }
	    this.setList = (newList) => {
	      if (!Array.isArray(newList) || newList.equals(list)) return
	      list = newList;
	      this.update();
	    }
	  }
	}
	
	DataList.template = new $t('input/data-list');
	
	module.exports = DataList;
	
});


RequireJS.addFunction('./public/js/utils/input/input.js',
function (require, exports, module) {
	

	
	
	
	const $t = require('../$t');
	const du = require('../dom-utils');
	const Lookup = require('../object/lookup')
	/*
	supported attributes: type, placeholder, name, class, value
	label: creates a text label preceeding input.
	clearOnClick: removes value when clicked.
	list: creates a dropdown with list values.
	default: the default value if input is invalid.
	targetAttr: attribute which defines the inputs value.
	format: attribute which defines a function used to format value.
	validation: Accepts
	                Array: value must be included
	                Regex: value must match
	                Function: value is arg1, must return true
	errorMsg: Message that shows when validation fails.
	
	*/
	class Input extends Lookup {
	  constructor(props) {
	    const id = props.id || `input-${String.random(7)}`;
	    super(id);
	    props.hidden = props.hide || false;
	    props.list = props.list || [];
	    Object.getSet(this, props, 'hidden', 'type', 'label', 'name', 'placeholder',
	                            'class', 'list', 'value', 'inline');
	
	    const immutableProps = {
	      _IMMUTABLE: true,
	      targetAttr: props.targetAttr || 'value',
	      errorMsg: props.errorMsg || 'Error',
	      errorMsgId: props.errorMsgId || `error-msg-${this.id()}`,
	    }
	    Object.getSet(this, immutableProps)
	
	    this.clone = (properties) => {
	      const json = this.toJson();
	      json.validation = props.validation;
	      delete json.id;
	      delete json.errorMsgId;
	      Object.set(json, properties);
	      return new this.constructor(json);
	    }
	
	    const instance = this;
	    const forAll = Input.forAll(this.id());
	
	    this.hide = () => forAll((elem) => {
	      const cnt = du.find.up('.input-cnt', elem);
	      this.hidden(cnt.hidden = true);
	    });
	    this.show = () => forAll((elem) => {
	      const cnt = du.find.up('.input-cnt', elem);
	      this.hidden(cnt.hidden = false);
	    });
	
	    let valid;
	    let value = props.value;
	
	    const idSelector = `#${this.id()}`;
	
	    const html = this.constructor.html(this);
	    if ((typeof html) !== 'function') throw new Error('props.html must be defined as a function');
	    this.html = () =>
	     html();
	
	    function valuePriority (func) {
	      return (elem, event) => func(elem[instance.targetAttr()], elem, event);
	    }
	    this.attrString = () => Input.attrString(this.targetAttr(), this.value());
	
	    function getElem(id) {return document.getElementById(id);}
	    this.get = () => getElem(this.id());
	
	    this.on = (eventType, func) => du.on.match(eventType, idSelector, valuePriority(func));
	    this.valid = () => this.setValue();
	    function getValue() {
	      const elem = getElem(instance.id());
	      let val = value;
	      if (elem) val = elem[instance.targetAttr()];
	      if (val === undefined) val = props.default;
	      return val;
	    }
	    this.updateDisplay = () => {
	      const elem = getElem(instance.id());
	      if (elem) elem[instance.targetAttr()] = this.value();
	    };
	    this.setValue = (val, force) => {
	      if (val === undefined) val = getValue();
	      if(force || this.validation(val)) {
	        valid = true;
	        value = val;
	        const elem = getElem(instance.id());
	        if (elem) elem.value = value;
	        return true;
	      }
	      valid = false;
	      value = undefined;
	      return false;
	    }
	    this.value = () => {
	      const unformatted = (typeof value === 'function') ? value() : getValue() || '';
	      return (typeof props.format) !== 'function' ? unformatted : props.format(unformatted);
	    }
	    this.doubleCheck = () => {
	      valid = undefined;
	      this.validate();
	      return valid;
	    }
	    this.validation = function(val) {
	      const elem = getElem(instance.id);
	      val = val === undefined && elem ? elem.value : val;
	      if (val === undefined) return false;
	      if (valid !== undefined && val === value) return valid;
	      let valValid = true;
	      if (props.validation instanceof RegExp) {
	        valValid = val.match(props.validation) !== null;
	      }
	      else if ((typeof props.validation) === 'function') {
	        valValid = props.validation.apply(null, arguments);
	      }
	      else if (Array.isArray(props.validation)) {
	        valValid = props.validation.indexOf(val) !== -1;
	      }
	
	      return valValid;
	    };
	
	    this.validate = (target) => {
	      target = target || getElem(instance.id());
	      if (target) {
	        if (this.setValue(target[this.targetAttr()])) {
	          getElem(this.errorMsgId()).hidden = true;
	          valid = true;
	        } else {
	          getElem(this.errorMsgId()).hidden = false;
	          valid = false;
	        }
	      }
	    }
	
	    if (props.clearOnDblClick) {
	      du.on.match(`dblclick`, `#${this.id()}`, () => {
	        const elem = getElem(this.id());
	        if (elem) elem.value = '';
	      });
	    } else if (props.clearOnClick) {
	      du.on.match(`mousedown`, `#${this.id()}`, () => {
	        const elem = getElem(this.id());
	        if (elem) elem.value = '';
	      });
	    }
	  }
	}
	
	function runValidate(elem) {
	  const input = Lookup.get(elem.id);
	  if (input) input.validate(elem);
	}
	
	du.on.match(`change`, `input`, runValidate);
	du.on.match(`keyup`, `input`, runValidate);
	du.on.match(`change`, `select`, runValidate);
	du.on.match(`keyup`, `select`, runValidate);
	
	Input.forAll = (id) => {
	  const idStr = `#${id}`;
	  return (func) => {
	    const elems = document.querySelectorAll(idStr);
	    for (let index = 0; index < elems.length; index += 1) {
	      func(elems[index]);
	    }
	  }
	}
	
	Input.template = new $t('input/input');
	Input.html = (instance) => () => Input.template.render(instance);
	Input.flagAttrs = ['checked', 'selected'];
	Input.attrString = (targetAttr, value) =>{
	  if (Input.flagAttrs.indexOf(targetAttr) !== -1) {
	    return value === true ? targetAttr : '';
	  }
	  return `${targetAttr}='${value}'`
	}
	
	Input.DO_NOT_CLONE = true;
	
	module.exports = Input;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/hover-map.js',
function (require, exports, module) {
	
const Line2d = require('./objects/line')
	const Vertex2d = require('./objects/vertex')
	class HoverObject2d {
	  constructor(lineOrVertex, tolerance, target) {
	    tolerance ||= 2;
	    const toleranceFunction = (typeof tolerance) === 'function';
	    const targetFunction = (typeof lineOrVertex) === 'function';
	    function getTolerence() {
	      if (toleranceFunction) return tolerance();
	      return tolerance;
	    }
	    function vertexHovered(targetVertex, hoverVertex) {
	      if(targetVertex.distance(hoverVertex) < getTolerence())
	        return targetVertex.distance(hoverVertex);
	    }
	
	    function lineHovered(targetLine, hoverVertex) {
	      const tol = getTolerence();
	      const hv = hoverVertex;
	      const sv = targetLine.startVertex();
	      const ev = targetLine.endVertex();
	      let toleranceAcceptible = false;
	      if (targetLine.isVertical()) {
	        toleranceAcceptible = Math.abs(sv.x() - hv.x()) < tol &&
	              ((sv.y() > hv.y() && ev.y() < hv.y()) ||
	              (sv.y() < hv.y() && ev.y() > hv.y()));
	      } else if (targetLine.isHorizontal()) {
	        toleranceAcceptible = Math.abs(sv.y() - hv.y()) < tol &&
	              ((sv.x() > hv.x() && ev.x() < hv.x()) ||
	              (sv.x() < hv.x() && ev.x() > hv.x()));
	      } else if (Math.abs(sv.y() - ev.y()) < Math.abs(sv.x() - ev.x())) {
	        const yValue = targetLine.y(hv.x());
	        toleranceAcceptible = yValue + tol > hv.y() && yValue - tol < hv.y();
	      } else {
	        const xValue = targetLine.x(hv.y());
	        toleranceAcceptible = xValue + tol > hv.x() && xValue - tol < hv.x();
	      }
	
	      if (toleranceAcceptible) {
	        const closestPoint = targetLine.closestPointOnLine(hoverVertex);
	        if (targetLine.withinSegmentBounds(closestPoint)) {
	          return closestPoint.distance(hoverVertex) + .1;
	        }
	      }
	      return false;
	    }
	
	    this.target = () => target || lineOrVertex;
	
	    this.hovering = (hoverVertex) => {
	      const lov = targetFunction ? lineOrVertex() : lineOrVertex;
	      if (lov instanceof Line2d)
	        return lineHovered(lov, hoverVertex);
	      return vertexHovered(lov, hoverVertex);
	    }
	  }
	}
	
	class HoverMap2d {
	  constructor() {
	    let hoverObjects = [];
	
	    this.clear = () => hoverObjects = [] || true;
	    this.add = (object, tolerance, target) => {
	      const hovObj = new HoverObject2d(object, tolerance, target);
	      if (object instanceof Line2d) {
	        hoverObjects.push(hovObj);
	      } else {
	        hoverObjects = [hovObj].concat(hoverObjects);
	      }
	    }
	    this.hovering = (x, y) => {
	      const vertex = x instanceof Vertex2d ? x : new Vertex2d(x, y);
	      let hoveringObj = null;
	      for (let index = 0; index < hoverObjects.length; index++) {
	        const hoverObj = hoverObjects[index];
	        const distance = hoverObj.hovering(vertex);
	        if (distance) {
	          const target = hoverObj.target();
	          if (hoveringObj === null || distance < hoveringObj.distance) {
	            hoveringObj = {target, distance};
	          }
	        }
	      }
	      return hoveringObj && hoveringObj.target;
	    }
	  }
	}
	
	HoverMap2d.HoverObject2d = HoverObject2d;
	module.exports = HoverMap2d;
	
});


RequireJS.addFunction('./public/js/utils/input/decision/decision.js',
function (require, exports, module) {
	

	
	
	
	const DecisionTree = require('../../decision-tree.js');
	const LogicTree = require('../../logic-tree.js');
	const LogicWrapper = LogicTree.LogicWrapper
	const Input = require('../input.js');
	const du = require('../../dom-utils');
	const $t = require('../../$t');
	
	const ROOT_CLASS = 'decision-input-tree';
	
	function isComplete(wrapper) {
	  return wrapper.isComplete() && DecisionInputTree.validate(wrapper)
	}
	
	class ValueCondition {
	  constructor(name, accepted, payload) {
	    Object.getSet(this, {name, accepted});
	    this.payload = payload;
	    this.condition = (wrapper) => {
	        let value;
	        wrapper.root().node.forEach((node) => {
	          node.payload().inputArray.forEach((input) => {
	            if (input.name() === name) value = input.value();
	          });
	        });
	        if (Array.isArray(accepted)) {
	          for (let index = 0; index < accepted.length; index +=1) {
	            if (value === accepted[index]) return true;
	          }
	          return false;
	        }
	        return value === accepted;
	    }
	  }
	}
	
	class DecisionInput {
	  constructor(name, inputArrayOinstance, tree, isRoot) {
	    Object.getSet(this, 'name', 'id', 'childCntId', 'inputArray', 'class', 'condition');
	    this.clone = () => this;
	
	    this.tree = () => tree;
	    if (inputArrayOinstance instanceof ValueCondition) {
	      this.condition = inputArrayOinstance.condition;
	      this.isConditional = true;
	      inputArrayOinstance = inputArrayOinstance.payload;
	    }
	    if (inputArrayOinstance !== undefined){
	      this.name = name;
	      this.id = `decision-input-node-${String.random()}`;
	      this.childCntId = `decision-child-ctn-${String.random()}`
	      this.values = tree.values;
	      this.onComplete = tree.onComplete;
	      this.onChange = tree.onChange;
	      this.inputArray = DecisionInputTree.validateInput(inputArrayOinstance, this.values);
	      this.class =  ROOT_CLASS;
	      this.getValue = (index) => this.inputArray[index].value();
	      this.validate = () => DecisionInputTree.validateInput(inputArrayOinstance, this.values);
	    }
	
	    const getWrapper = (wrapperOid) => wrapperOid instanceof LogicWrapper ?
	        wrapperOid : (LogicWrapper.get(wrapperId) || this.root());
	
	    this.branch = (wrapperId, inputs) =>
	            get(wrapperId).branch(String.random(), new DecisionInput(name));
	    this.conditional = (wrapperId, inputs, name, selector) =>
	            get(wrapperId).conditional(String.random(), new DecisionInput(name, relation, formula));
	
	    this.update = tree.update;
	    this.addValues = (values) => {
	      this.inputArray.forEach((input) => values[input.name()] = input.value())
	    }
	
	    this.reachable = () => {
	      const nodeId = this._nodeId;
	      const wrapper = LogicWrapper.get(nodeId);
	      return wrapper.reachable();
	    }
	    this.isValid = () => {
	      let valid = true;
	      this.inputArray.forEach((input) =>
	            valid = valid && input.valid());
	      return valid;
	    }
	    this.isRoot = () => isRoot;
	
	    this.html = (parentCalling) => {
	      if (this.isRoot() && parentCalling !== true) return tree.html();
	      return DecisionInput.template.render(this);
	    }
	    this.treeHtml = (wrapper) => tree.html(wrapper);
	  }
	}
	DecisionInput.template = new $t('input/decision/decision');
	
	
	// properties
	// optional :
	// noSubmission: /[0-9]{1,}/ delay that determins how often a submission will be processed
	// buttonText: determins the text displayed on submit button;
	
	class DecisionInputTree extends LogicTree {
	  constructor(onComplete, props) {
	    const decisionInputs = [];
	    props = props || {};
	    const tree = {};
	
	    tree.buttonText = () => {
	      return props.buttonText || `Create ${root.node.name}`;
	    }
	
	    let disabled;
	    tree.disableButton = (d, elem) => {
	      disabled = d === null || d === true || d === false ? d : disabled;
	      if (elem) {
	        const button = du.find.closest(`button`, elem);
	        if (button) {
	          button.disabled = disabled === null ? !isComplete(root) : disabled;
	        }
	      }
	    }
	
	    function superArgument(onComplete) {
	      const formatPayload = (name, payload) => {
	        decisionInputs.push(new DecisionInput(name, payload, tree, decisionInputs.length === 0));
	        return decisionInputs[decisionInputs.length - 1];
	      }
	      if (onComplete && onComplete._TYPE === 'DecisionInputTree') {
	        onComplete.formatPayload = formatPayload;
	        return onComplete;
	      }
	      return formatPayload;
	    }
	
	    super(superArgument(onComplete));
	    const root = this;
	
	    const onCompletion = [];
	    const onChange = [];
	    const onSubmit = [];
	    tree.html = (wrapper) => {
	      wrapper = wrapper || root;
	      let inputHtml = '';
	      wrapper.forAll((wrapper) => {
	        inputHtml += wrapper.payload().html(true);
	      });
	      const scope = {wrapper, inputHtml, DecisionInputTree, tree};
	      if (wrapper === root) {
	        return DecisionInputTree.template.render(scope);
	      }
	      return inputHtml;
	    };
	
	
	    this.onComplete = (func) => {
	      if ((typeof func) === 'function') onCompletion.push(func);
	    }
	    this.onChange = (func) => {
	      if ((typeof func) === 'function') onChange.push(func);
	    }
	    this.onSubmit = (func) => {
	      if ((typeof func) === 'function') onSubmit.push(func);
	    }
	
	    this.values = () => {
	      const values = {};
	      root.forEach((wrapper) => {
	        wrapper.payload().addValues(values);
	      });
	      return values;
	    }
	    tree.values = root.values;
	    tree.hideButton = props.noSubmission;
	
	    let completionPending = false;
	    this.completed = () => {
	      if (!root.isComplete()) return false;
	      const delay = props.noSubmission || 0;
	      if (!completionPending) {
	        completionPending = true;
	        setTimeout(() => {
	          const values = tree.values();
	          onCompletion.forEach((func) => func(values, this))
	          completionPending = false;
	        }, delay);
	      }
	      return true;
	    }
	
	    let submissionPending = false;
	    this.submit = () => {
	      const delay = props.noSubmission || 0;
	      if (!submissionPending) {
	        submissionPending = true;
	        setTimeout(() => {
	          const values = tree.values();
	          if (!root.isComplete()) return false;
	          onSubmit.forEach((func) => func(values, this))
	          submissionPending = false;
	        }, delay);
	      }
	      return true;
	    }
	
	    let changePending = false;
	    this.changed = (elem) => {
	      const delay = props.noSubmission || 0;
	      if (!changePending) {
	        changePending = true;
	        setTimeout(() => {
	          const values = tree.values();
	          onChange.forEach((func) => func(values, this, elem))
	          changePending = false;
	        }, delay);
	      }
	      return true;
	    }
	
	    this.onComplete(onComplete);
	
	    return this;
	  }
	}
	
	DecisionInputTree.ValueCondition = ValueCondition;
	
	DecisionInputTree.class = 'decision-input-tree';
	DecisionInputTree.buttonClass = 'decision-input-tree-submit';
	
	DecisionInputTree.validate = (wrapper) => {
	  let valid = true;
	  wrapper.forEach((wrapper) => {
	    valid = valid && wrapper.payload().isValid();
	  });
	  return valid;
	}
	
	DecisionInputTree.update = (soft) =>
	  (elem) => {
	    const cnt = du.find.closest('[node-id]', elem);
	    const parent = cnt.parentElement;
	    const nodeId = cnt.getAttribute('node-id');
	    const wrapper = LogicWrapper.get(nodeId);
	    console.log(isComplete(wrapper));
	    if(!soft) {
	      du.find.downAll('.decision-input-cnt', parent).forEach((e) => e.hidden = true)
	      wrapper.forEach((n) => {
	        let selector = `[node-id='${n.nodeId()}']`;
	        elem = du.find.down(selector, parent);
	        if (elem) elem.hidden = false;
	      });
	      wrapper.root().changed();
	      wrapper.root().completed()
	    }
	    wrapper.payload().tree().disableButton(undefined, elem);
	  };
	
	DecisionInputTree.submit = (elem) => {
	  const wrapper = LogicWrapper.get(elem.getAttribute('root-id'));
	  wrapper.submit();
	}
	
	du.on.match('keyup', `.${ROOT_CLASS}`, DecisionInputTree.update(true));
	du.on.match('change', `.${ROOT_CLASS}`, DecisionInputTree.update());
	du.on.match('click', `.${DecisionInputTree.buttonClass}`, DecisionInputTree.submit);
	
	
	DecisionInputTree.DO_NOT_CLONE = true;
	DecisionInputTree.validateInput = (inputArrayOinstance, valuesFunc) => {
	  if (Array.isArray(inputArrayOinstance)) {
	    inputArrayOinstance.forEach((instance) => {
	      instance.childCntId = `decision-child-ctn-${String.random()}`
	    });
	    return inputArrayOinstance;
	  }
	  inputArrayOinstance.childCntId = `decision-child-ctn-${String.random()}`
	  return [inputArrayOinstance];
	}
	
	DecisionInputTree.template = new $t('input/decision/decisionTree');
	
	module.exports = DecisionInputTree;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/pan-zoom.js',
function (require, exports, module) {
	
// Took thiss code from https://stackoverflow.com/a/33929456
	function panZoom(canvas, draw) {
	  let mrx, mry;
	  const eventFuncs = [];
	  const instance = this;
	  let lastMoveTime = new Date().getTime();
	
	  this.on = (eventName) => {
	    if (eventFuncs[eventName] === undefined) eventFuncs[eventName] = [];
	    return (func) => {
	      if ((typeof func) === 'function') {
	        eventFuncs[eventName].push(func);
	      }
	    }
	  }
	  let sleeping = false;
	  let nextUpdateId = 0;
	  this.sleep = () => sleeping = true;
	  this.wake = () => {
	    if (sleeping) {
	      sleeping = false;
	      requestAnimationFrame(() => update(++nextUpdateId));
	    }
	  };
	  this.once = () => {
	    requestAnimationFrame(() => update(++nextUpdateId, true))
	  };
	
	  this.onMove = this.on('move');
	  this.onTranslate = this.on('translated');
	  this.onZoom = this.on('zoom');
	  this.onClick = this.on('click');
	  this.onMousedown = this.on('mousedown');
	  this.onMouseup = this.on('mouseup');
	
	  function eventObject(eventName, event) {
	    let x  =  mouse.rx;
	    let y = mouse.ry;
	    const dt = displayTransform;
	    x -= dt.x;
	    y -= dt.y;
	    // screenX and screen Y are the screen coordinates.
	    screenX = event.pageX;//dt.scale*(x * dt.matrix[0] + y * dt.matrix[2])+dt.cox;
	    screenY = event.pageY;//dt.scale*(x * dt.matrix[1] + y * dt.matrix[3])+dt.coy;
	    return {
	      eventName, screenX, screenY,
	      imageX: mouse.rx,
	      imageY: mouse.ry,
	      dx: mrx,
	      dy: mry,
	    };
	  }
	
	  function runOn(type, event) {
	    const dt = displayTransform;
	    let performingFunction = false;
	    const funcs = eventFuncs[type];
	    const eventObj  = eventObject(type, event);
	    for (let index = 0; !performingFunction && index < funcs.length; index += 1) {
	      performingFunction = funcs[index](eventObj, event);
	    }
	    return performingFunction;
	  }
	
	  var ctx = canvas.getContext("2d");
	  var mouse = {
	      x : 0,
	      y : 0,
	      w : 0,
	      alt : false,
	      shift : false,
	      ctrl : false,
	      buttonLastRaw : 0, // user modified value
	      buttonRaw : 0,
	      over : false,
	      buttons : [1, 2, 4, 6, 5, 3], // masks for setting and clearing button raw bits;
	  };
	  function mouseMove(event) {
	      lastMoveTime = new Date().getTime();
	      mouse.x = event.offsetX;
	      mouse.y = event.offsetY;
	      if (mouse.x === undefined) {
	          mouse.x = event.clientX;
	          mouse.y = event.clientY;
	      }
	      runOn('move', event);
	      mouse.alt = event.altKey;
	      mouse.shift = event.shiftKey;
	      mouse.ctrl = event.ctrlKey;
	      if (event.type === "mousedown") {
	        if (!runOn('mousedown', event))  {
	          event.preventDefault()
	          mouse.buttonRaw |= mouse.buttons[event.which-1];
	        }
	      } else if (event.type === "mouseup") {
	        if (!runOn('mouseup', event)) {
	          mouse.buttonRaw &= mouse.buttons[event.which + 2];
	        }
	      } else if (event.type === "mouseout") {
	          mouse.buttonRaw = 0;
	          mouse.over = false;
	      } else if (event.type === "mouseover") {
	          mouse.over = true;
	      } else if (event.type === "mousewheel") {
	          event.preventDefault()
	          mouse.w = event.wheelDelta;
	      } else if (event.type === "DOMMouseScroll") { // FF you pedantic doffus
	         mouse.w = -event.detail;
	      }
	      instance.wake();
	  }
	
	  function setupMouse(e) {
	      e.addEventListener('mousemove', mouseMove);
	      e.addEventListener('mousedown', mouseMove);
	      e.addEventListener('mouseup', mouseMove);
	      e.addEventListener('mouseout', mouseMove);
	      e.addEventListener('mouseover', mouseMove);
	      e.addEventListener('mousewheel', mouseMove);
	      e.addEventListener('DOMMouseScroll', mouseMove); // fire fox
	
	      e.addEventListener("contextmenu", function (e) {
	          e.preventDefault();
	      }, false);
	  }
	  setupMouse(canvas);
	
	  let transformCount = 0;
	  const round = (val) => Math.round((val*100)/displayTransform.scale) / 100;
	  const print = (...attrs) => {
	    if (transformCount++ % 100 !== 0) return;
	    let str = '';
	    for (let index = 0; index < attrs.length; index += 1) {
	      const attr = attrs[index];
	      str += `${attr}: ${round(displayTransform[attr])} `;
	    }
	    console.log(str);
	  }
	
	  function positionEvents() {
	    const dt = displayTransform;
	    const dxAbs = Math.abs(dt.dx);
	    const dyAbs = Math.abs(dt.dy);
	    const doxAbs = Math.abs(dt.dox);
	    const doyAbs = Math.abs(dt.doy);
	    dt.moving = dt.moving || dxAbs > 1 || dyAbs > 1;
	    dt.scoping = dt.scoping || doxAbs > 1 || doyAbs > 1;
	    if (dt.moving && dxAbs < .1 && dyAbs < .1) {
	      dt.moving = false;
	      runOn('translated', this);
	    }
	    if (dt.scoping && doxAbs < .1 && doyAbs < .1) {
	      dt.scoping = false;
	      runOn('zoom', this);
	    }
	  }
	
	  // terms.
	  // Real space, real, r (prefix) refers to the transformed canvas space.
	  // c (prefix), chase is the value that chases a requiered value
	  var displayTransform = {
	      x:0,
	      y:0,
	      ox:0,
	      oy:0,
	      scale:1,
	      rotate:0,
	      cx:0,  // chase values Hold the actual display
	      cy:0,
	      cox:0,
	      coy:0,
	      cscale:1,
	      crotate:0,
	      dx:0,  // deltat values
	      dy:0,
	      dox:0,
	      doy:0,
	      dscale:1,
	      drotate:0,
	      drag:0.2,  // drag for movements
	      accel:0.7, // acceleration
	      matrix:[0,0,0,0,0,0], // main matrix
	      invMatrix:[0,0,0,0,0,0], // invers matrix;
	      mouseX:0,
	      mouseY:0,
	      ctx:ctx,
	      realPosition: function (x, y) {
	        var screenX = canvas.width / 2;
	        var screenY = canvas.height / 2;
	        x = (screenX * this.invMatrix[0] + screenY * this.invMatrix[2]);
	        y = (screenX * this.invMatrix[1] + screenY * this.invMatrix[3]);
	        return {x,y};
	      },
	      setTransform:function(){
	          var m = this.matrix;
	          var i = 0;
	          const dt = displayTransform;
	          this.ctx.setTransform(m[i++],m[i++],m[i++],m[i++],m[i++],m[i++]);
	      },
	      setHome:function(){
	          this.ctx.setTransform(1,0,0,1,0,0);
	
	      },
	      update:function(){
	          // smooth all movement out. drag and accel control how this moves
	          // acceleration
	          this.dx += (this.x-this.cx)*this.accel;
	          this.dy += (this.y-this.cy)*this.accel;
	          this.dox += (this.ox-this.cox)*this.accel;
	          this.doy += (this.oy-this.coy)*this.accel;
	          this.dscale += (this.scale-this.cscale)*this.accel;
	          this.drotate += (this.rotate-this.crotate)*this.accel;
	          // drag
	          this.dx *= this.drag;
	          this.dy *= this.drag;
	          this.dox *= this.drag;
	          this.doy *= this.drag;
	          this.dscale *= this.drag;
	          this.drotate *= this.drag;
	          // set the chase values. Chase chases the requiered values
	          this.cx += this.dx;
	          this.cy += this.dy;
	          this.cox += this.dox;
	          this.coy += this.doy;
	          this.cscale += this.dscale;
	          this.crotate += this.drotate;
	
	          positionEvents(this);
	
	
	          // create the display matrix
	          this.matrix[0] = Math.cos(this.crotate)*this.cscale;
	          this.matrix[1] = Math.sin(this.crotate)*this.cscale;
	          this.matrix[2] =  - this.matrix[1];
	          this.matrix[3] = this.matrix[0];
	
	          // set the coords relative to the origin
	          this.matrix[4] = -(this.cx * this.matrix[0] + this.cy * this.matrix[2])+this.cox;
	          this.matrix[5] = -(this.cx * this.matrix[1] + this.cy * this.matrix[3])+this.coy;
	
	
	          // create invers matrix
	          var det = (this.matrix[0] * this.matrix[3] - this.matrix[1] * this.matrix[2]);
	          this.invMatrix[0] = this.matrix[3] / det;
	          this.invMatrix[1] =  - this.matrix[1] / det;
	          this.invMatrix[2] =  - this.matrix[2] / det;
	          this.invMatrix[3] = this.matrix[0] / det;
	
	          // check for mouse. Do controls and get real position of mouse.
	          if(mouse !== undefined){  // if there is a mouse get the real cavas coordinates of the mouse
	              let mdx = mouse.x-mouse.oldX; // get the mouse movement
	              let mdy = mouse.y-mouse.oldY;
	              mrx = (mdx * this.invMatrix[0] + mdy * this.invMatrix[2]);
	              mry = (mdx * this.invMatrix[1] + mdy * this.invMatrix[3]);
	              if(mouse.oldX !== undefined && (mouse.buttonRaw & 1)===1){ // check if panning (middle button)
	                  // get the movement in real space
	                  this.x -= mrx;
	                  this.y -= mry;
	              }
	              // do the zoom with mouse wheel
	              if(mouse.w !== undefined && mouse.w !== 0){
	                  this.ox = mouse.x;
	                  this.oy = mouse.y;
	                  this.x = this.mouseX;
	                  this.y = this.mouseY;
	                  /* Special note from answer */
	                  // comment out the following is you change drag and accel
	                  // and the zoom does not feel right (lagging and not
	                  // zooming around the mouse
	                  /*
	                  this.cox = mouse.x;
	                  this.coy = mouse.y;
	                  this.cx = this.mouseX;
	                  this.cy = this.mouseY;
	                  */
	                  if(mouse.w > 0){ // zoom in
	                      this.scale *= 1.1;
	                      mouse.w -= 20;
	                      if(mouse.w < 0){
	                          mouse.w = 0;
	                      }
	                  }
	                  if(mouse.w < 0){ // zoom out
	                      this.scale *= 1/1.1;
	                      mouse.w += 20;
	                      if(mouse.w > 0){
	                          mouse.w = 0;
	                      }
	                  }
	
	              }
	              // get the real mouse position
	              var screenX = (mouse.x - this.cox);
	              var screenY = (mouse.y - this.coy);
	              this.screenX = screenX;
	              this.screenY = screenY;
	              this.mouseX = this.cx + (screenX * this.invMatrix[0] + screenY * this.invMatrix[2]);
	              this.mouseY = this.cy + (screenX * this.invMatrix[1] + screenY * this.invMatrix[3]);
	              mouse.rx = this.mouseX;  // add the coordinates to the mouse. r is for real
	              mouse.ry = this.mouseY;
	              // save old mouse position
	              mouse.oldX = mouse.x;
	              mouse.oldY = mouse.y;
	          }
	
	      }
	  }
	  this.displayTransform = displayTransform;
	
	  const max = .000000000001;
	  const min = max*-1;
	  function hasDelta() {
	    const dt = displayTransform;
	    return !((dt.dx > min && dt.dx < max) &&
	            (dt.dy > min && dt.dy < max) &&
	            (dt.dox > min && dt.dox < max) &&
	            (dt.doy > min && dt.doy < max) &&
	            (dt.drotate > min && dt.drotate < max));
	  }
	
	  // image to show
	  // var img = new Image();
	  // img.src = "https://upload.wikimedia.org/wikipedia/commons/e/e5/Fiat_500_in_Emilia-Romagna.jpg"
	  // set up font
	  ctx.font = "14px verdana";
	  ctx.textAlign = "center";
	  ctx.textBaseline = "middle";
	  // timer for stuff
	  var timer =0;
	  function update(updateId, once){
	    if (nextUpdateId !== updateId) return;
	    nextUpdateId++;
	    timer += 1; // update timere
	    displayTransform.update();
	    displayTransform.setHome();
	    ctx.clearRect(0,0,canvas.width,canvas.height);
	    displayTransform.setTransform();
	    draw(canvas);
	    ctx.fillStyle = "white";
	    if(mouse.buttonRaw === 4){ // right click to return to homw
	         displayTransform.x = 0;
	         displayTransform.y = 0;
	         displayTransform.scale = 1;
	         displayTransform.rotate = 0;
	         displayTransform.ox = 0;
	         displayTransform.oy = 0;
	     }
	
	    if (lastMoveTime < new Date().getTime() - 1000) instance.sleep();
	    if (hasDelta() || sleeping === false) {
	      if (once) sleeping = true;
	      setTimeout(() => requestAnimationFrame(() => update(++nextUpdateId)), 30);
	    } else {
	      sleeping = true;
	    }
	  }
	  update(++nextUpdateId); // start it happening
	
	  this.center = () => {
	    const x = displayTransform.x + canvas.width/2;
	    const y = displayTransform.y + canvas.height/2
	    return {x,y};
	  }
	
	  this.centerOn = function(x, y) {
	    const hype = Math.sqrt(x*x + y*y);
	    const pointRads = Math.atan(y/x) || 0;
	    x = hype*Math.sin(displayTransform.rotate + pointRads);
	    y = hype*Math.cos(-1*(displayTransform.rotate + pointRads));
	
	    displayTransform.scale = 1;
	    displayTransform.cox = 0;
	    displayTransform.coy = 0;
	    displayTransform.dox = 0;
	    displayTransform.doy = 0;
	    displayTransform.dx = 0;
	    displayTransform.dy = 0;
	    displayTransform.ox = 0;
	    displayTransform.oy = 0;
	    displayTransform.x = x - (canvas.width / 2);
	    displayTransform.y = y - (canvas.height / 2);
	    displayTransform.rotate = 0;
	    displayTransform.update();
	    displayTransform.moving = true;
	    displayTransform.zooming = true;
	    this.once();
	  };
	
	  return this;
	}
	
	module.exports = panZoom;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/draw.js',
function (require, exports, module) {
	
const Circle2d = require('./objects/circle');
	const Line2d = require('./objects/line');
	const Vertex2d = require('./objects/vertex');
	const ToleranceMap = require('../../tolerance-map.js');
	const du = require('../../dom-utils.js');
	const tol = .1;
	let vertLocTolMap;
	
	class Draw2d {
	  constructor(canvasOselector, invertY) {
	    const yCoef = invertY ? -1 : 1;
	    let takenLocations;
	    let coloredLocations;
	
	    function canvas() {
	      if (typeof canvasOid === 'string') return du.find(canvasOselector);
	      return canvasOselector;
	    }
	    const ctx = () => canvas().getContext('2d');
	
	    function draw(object, color, width) {
	      if (object === undefined) return;
	      if (Array.isArray(object)) {
	        takenLocations = [];
	        vertLocTolMap = new ToleranceMap({x: tol, y: tol});
	        for (let index = 0; index < object.length; index += 1)
	          draw(object[index], color, width);
	        return;
	      }
	      let constructorId = object.constructor.name;
	      if (constructorId !== 'SnapLocation2d')
	        constructorId = constructorId.replace(/^(Snap).*$/, '$1')
	      switch (constructorId) {
	        case 'Line2d':
	          draw.line(object, color, width);
	          break;
	        case 'Circle2d':
	          draw.circle(object, color, width);
	          break;
	        case 'Plane2d':
	          draw.plane(object, color, width);
	          break;
	        case 'Polygon2d':
	          draw.polygon(object, color, width);
	          break;
	        case 'Square2d':
	          draw.square(object, color, width);
	          break;
	        case 'LineMeasurement2d':
	          draw.measurement(object, color, width);
	          break;
	        case 'Snap':
	          draw.snap(object, color, width);
	          break;
	        case 'SnapLocation2d':
	          draw.snapLocation(object, color, width);
	        break;
	        default:
	          console.error(`Cannot Draw '${object.constructor.name}'`);
	      }
	    }
	
	    draw.canvas = canvas;
	    draw.ctx = ctx;
	    draw.beginPath = () => ctx().beginPath();
	    draw.moveTo = () => ctx().moveTo();
	
	    draw.clear = () => {
	      ctx().save();
	      ctx().setTransform(1, 0, 0, 1, 0, 0);
	      ctx().clearRect(0, 0, canvas().width, canvas().height);
	      ctx().restore();
	    }
	    const colors = [
	      'indianred', 'gray', 'fuchsia', 'lime', 'black', 'lightsalmon', 'red',
	      'maroon', 'yellow', 'olive', 'lightcoral', 'green', 'aqua', 'white',
	      'teal', 'darksalmon', 'blue', 'navy', 'salmon', 'silver', 'purple'
	    ];
	    let colorIndex = 0;
	
	    let rMultiplier = 1;
	    function identifyVertices(line) {
	      vertLocTolMap.add(line.startVertex());
	      vertLocTolMap.add(line.endVertex());
	      const svHits = vertLocTolMap.matches(line.startVertex()).length;
	      const evHits = vertLocTolMap.matches(line.endVertex()).length;
	      const svRadius = Math.pow(.5,  1 + ((svHits - 1) * .75));
	      const evRadius = Math.pow(.5,  1 + ((evHits - 1) * .75));
	
	      const vertId = 13*(line.startVertex().x() + line.endVertex().x() + 13*(line.startVertex().y() + line.endVertex().y()));
	      const ccolor = colors[Math.floor(line.length() + vertId) % colors.length];
	
	      draw.circle(new Circle2d(svRadius * rMultiplier, line.startVertex()), null, ccolor, .01);
	      draw.circle(new Circle2d(evRadius * rMultiplier, line.endVertex()), null, ccolor, .01);
	    }
	
	    const midpointFlag = (point, radians) => {
	      ctx().moveTo(point.x(), yCoef * point.y());
	      const ev = Line2d.startAndTheta(point, radians, 15).endVertex();
	      ctx().lineTo(ev.x(), yCoef * ev.y());
	    }
	    function midpointFlags(line) {
	      midpointFlag(line.midpoint(), Math.toRadians(line.degrees() - 135));
	      midpointFlag(line.midpoint(), Math.toRadians(line.degrees() + 135));
	    }
	
	    draw.line = (line, color, width) => {
	      if (line === undefined) return;
	      color = color ||  'black';
	      width = width || 10;
	      ctx().beginPath();
	      ctx().strokeStyle = color;
	      ctx().lineWidth = width;
	      ctx().moveTo(line.startVertex().x(), yCoef * line.startVertex().y());
	      ctx().lineTo(line.endVertex().x(), yCoef * line.endVertex().y());
	      if (Draw2d.debug.showFlags) midpointFlags(line);
	      ctx().stroke();
	      // identifyVertices(line);
	    }
	
	    draw.plane = (plane, color, width) => {
	      if (plane === undefined) return;
	      color = color ||  'black';
	      width = width || .1;
	      plane.getLines().forEach((line) => draw.line(line, color, width));
	    }
	
	    draw.polygon = (poly, color, width) => {
	      if (poly === undefined) return;
	      color = color ||  'black';
	      width = width || 1;
	      poly.lines().forEach((line) => draw.line(line, color, width));
	      // if ((typeof poly.getTextInfo) === 'function') {
	      //   ctx().save();
	      //   const info = poly.getTextInfo();
	      //   ctx().translate(info.center.x(), yCoef * info.center.y());
	      //   ctx().rotate(info.radians);
	      //   ctx().beginPath();
	      //   ctx().lineWidth = 4;
	      //   ctx().strokeStyle = color;
	      //   ctx().fillStyle =  color;
	      //   const text = info.limit === undefined ? info.text : (info.text || '').substring(0, info.limit);
	      //   ctx().fillText(text, info.x, yCoef * info.y, info.maxWidth);
	      //   ctx().stroke()
	      //   ctx().restore();
	      // }
	    }
	
	    draw.square = (square, color, text) => {
	      ctx().save();
	      ctx().beginPath();
	      ctx().lineWidth = 2;
	      ctx().strokeStyle = 'black';
	      ctx().fillStyle = color;
	
	      const center = square.center();
	      ctx().translate(center.x(), yCoef * center.y());
	      ctx().rotate(square.radians());
	      ctx().rect(square.offsetX(true), square.offsetY(true), square.width(), square.height());
	      ctx().stroke();
	      ctx().fill();
	
	      if (text) {
	        ctx().beginPath();
	        ctx().lineWidth = 4;
	        ctx().strokeStyle = 'black';
	        ctx().fillStyle =  'black';
	        ctx().fillText(text, 0, square.height() / 4, square.width());
	        ctx().stroke()
	      }
	
	      ctx().restore();
	    }
	
	    draw.circle = (circle, lineColor, fillColor, lineWidth) => {
	      const center = circle.center();
	      ctx().beginPath();
	      ctx().lineWidth = Number.isFinite(lineWidth) ? lineWidth : 2;
	      ctx().strokeStyle = lineColor || 'black';
	      ctx().fillStyle = fillColor || 'white';
	      ctx().arc(center.x(),yCoef * center.y(), circle.radius(),0, 2*Math.PI);
	      ctx().stroke();
	      ctx().fill();
	    }
	
	    draw.text = (text, point, props) => {
	      props ||= {};
	      point = new Vertex2d(point);
	      text = '' + text;
	      const ctx = draw.ctx();
	
	      ctx.save();
	      ctx.lineWidth = 0;
	      const textLength = text.length;
	      ctx.translate(point.x(), yCoef * point.y());
	      let radians = props.radians || 0;
	      if (yCoef === -1) radians += Math.PI/2;
	      ctx.rotate(props.radians);
	      ctx.beginPath();
	      ctx.fillStyle = props.fillColor || "white";
	      ctx.strokeStyle = props.fillColor || 'white';
	      ctx.rect((textLength * -3)/14, -4/15, (textLength * 6)/14, 8/15);
	      ctx.fill();
	      ctx.stroke();
	
	      ctx.beginPath();
	      ctx.font = `${props.size || '3px'} ${props.font || 'Arial'}`;
	      ctx.lineWidth = .2;
	      ctx.strokeStyle = props.color || 'black';
	      ctx.fillStyle =  props.color || 'black';
	      ctx.fillText(text, props.x || 0, yCoef * (props.y || 0), props.maxWidth);
	      ctx.stroke()
	      ctx.restore();
	    }
	
	    const blank = 4;
	    const hblank = blank/2;
	    function drawMeasurementLabel(line, measurement) {
	      if (measurement === undefined) return;
	      const ctx = draw.ctx();
	      const midpoint = line.midpoint();
	
	      ctx.save();
	      ctx.lineWidth = 0;
	      const length = measurement.display();
	      const textLength = length.length;
	      ctx.translate(midpoint.x(), yCoef * midpoint.y());
	      ctx.rotate(line.radians());
	      ctx.beginPath();
	      ctx.fillStyle = "white";
	      ctx.strokeStyle = 'white';
	      ctx.rect((textLength * -3)/14, -4/15, (textLength * 6)/14, 8/15);
	      ctx.fill();
	      ctx.stroke();
	
	      ctx.beginPath();
	      ctx.font = '3px Arial';//(Math.abs((Math.log(Math.floor(line.length() * 10)))) || .1) + "px Arial";
	      ctx.lineWidth = .2;
	      ctx.strokeStyle = 'black';
	      ctx.fillStyle =  'black';
	      ctx.fillText(length, 0, 0);
	      ctx.stroke()
	      ctx.restore();
	    }
	
	    draw.measurement = (measurement, color, textWidth) => {
	      const measurementColor = color || 'grey';
	      const measurementLineWidth = '.1';
	      const lines = measurement.I(1, takenLocations);
	      try {
	        const winner = lines.midpointClear();
	        if (winner === undefined) return;
	        draw.beginPath();
	        draw.line(winner.startLine, measurementColor, measurementLineWidth, true);
	        draw.line(winner.endLine, measurementColor, measurementLineWidth, true);
	        draw.line(winner, measurementColor, measurementLineWidth, true);
	        drawMeasurementLabel(winner, measurement);
	      } catch (e) {
	        console.error('Measurement render error:', e);
	      }
	    }
	
	    function snapLocColor(snapLoc) {
	      const locIdentifier = snapLoc.location().replace(/(.{1,}?)[0-9]{1,}(.*)/, '$1$2');
	      switch (locIdentifier) {
	        case "right": return 'red';
	        case "rightcenter": return 'pink';
	        case "left": return '#b57edc';
	        case "leftcenter": return 'lavender';
	        case "back": return 'gray';
	        case "backcenter": return 'yellow';
	        default: return "grey"
	      }
	    }
	
	    draw.snapLocation = (location, color, radius) => {
	      const c = color || snapLocColor(location);
	      draw.circle(location.circle(radius), 'black', c);
	    }
	
	    draw.snap = (snap, color, width) => {
	      draw(snap.object(), color, width);
	      const textInfo = snap.getTextInfo();
	      textInfo.color = color || textInfo.color;
	      draw.text(textInfo.text.substring(0,10), textInfo.center, textInfo);
	      if (Draw2d.debug.showNormals) draw(snap.object().normals());
	    }
	
	    return draw;
	  }
	}
	
	Draw2d.debug = {};
	module.exports = Draw2d;
	
});


RequireJS.addFunction('./public/js/utils/input/styles/measurement.js',
function (require, exports, module) {
	

	
	
	const Input = require('../input');
	const $t = require('../../$t');
	const Measurement = require('../../measurement');
	
	class MeasurementInput extends Input {
	  constructor(props) {
	    let value = new Measurement(props.value, true);
	    props.value = () => value;
	    super(props);
	    props.validation = (val) =>
	        !Number.isNaN(val && val.display ? value : new Measurement(val).value());
	    props.errorMsg = 'Invalid Mathematical Expression';
	    this.value = () => {
	      return value.display();
	    }
	    const parentSetVal = this.setValue;
	    this.setValue = (val) => {
	      let newVal = props.validation(val) ? ((val instanceof Measurement) ?
	                        val : new Measurement(val, true)) : value;
	      const updated = newVal !== value;
	      value = newVal;
	      return updated;
	    }
	  }
	}
	
	MeasurementInput.template = new $t('input/measurement');
	MeasurementInput.html = (instance) => () => MeasurementInput.template.render(instance);
	
	
	module.exports = MeasurementInput;
	
});


RequireJS.addFunction('./public/js/utils/input/styles/select.js',
function (require, exports, module) {
	

	
	
	
	const Input = require('../input');
	const $t = require('../../$t');
	
	class Select extends Input {
	  constructor(props) {
	    super(props);
	    const isArray = Array.isArray(props.list);
	    let value;
	    if (isArray) {
	      value = props.index && props.list[props.index] ?
	      props.list[props.index] : props.list[0];
	      value = props.list.indexOf(props.value) === -1 ? props.list[0] : props.value;
	    } else {
	      const key = Object.keys(props.list)[0];
	      value = props.value || key;
	    }
	    props.value = undefined;
	    this.setValue(value);
	    this.isArray = () => isArray;
	    const parentHidden = this.hidden;
	    this.hidden = () => props.list.length < 2 || parentHidden();
	
	    this.selected = (value) => value === this.value();
	  }
	}
	
	Select.template = new $t('input/select');
	Select.html = (instance) => () => Select.template.render(instance);
	
	module.exports = Select;
	
});


RequireJS.addFunction('./public/js/utils/test/tests/decision-tree.js',
function (require, exports, module) {
	

	// branch structure
	//
	// style
	//   solid
	//     isInset:false
	//     material
	//       mdf
	//         cost
	//         profile
	//       soft maple
	//         cost
	//         profile
	//       walnut
	//         cost
	//         profile
	//       alder
	//         cost
	//         profile
	//   panel
	//     isInset:true
	//     profile
	//       shaker
	//         mdfCore
	//           soft maple
	//         nonMdfCore
	//           soft maple
	//           walnut
	//           alder
	//
	// isInset (type===Inset)
	//   magnet
	
	const Test = require('../test.js').Test;
	const DecisionTree = require('../../decision-tree');
	const states = {};
	
	states[5] = {descriptor: 'style'}
	states[6] = {descriptor: 'solid'}
	states[7] = {descriptor: 'isInset=false'}
	states[8] = {descriptor: 'material'}
	states[9] = {descriptor: 'mdf'}
	states[10] = {descriptor: 'cost'}
	states[11] = {descriptor: 'profile'}
	states[12] = {descriptor: 'soft maple'}
	states[13] = {descriptor: 'cost'}
	states[14] = {descriptor: 'profile'}
	states[15] = {descriptor: 'walnut'}
	states[16] = {descriptor: 'cost'}
	states[17] = {descriptor: 'profile'}
	states[18] = {descriptor: 'alder'}
	states[19] = {descriptor: 'cost'}
	states[20] = {descriptor: 'profile'}
	states[21] = {descriptor: 'panel'}
	states[22] = {descriptor: 'isInset=true'}
	states[23] = {descriptor: 'profile'}
	states[24] = {descriptor: 'shaker'}
	states[25] = {descriptor: 'mdfCore'}
	states[26] = {descriptor: 'soft maple'}
	states[27] = {descriptor: 'nonMdfCore'}
	states[28] = {descriptor: 'soft maple'}
	states[29] = {descriptor: 'walnut'}
	states[30] = {descriptor: 'alder'}
	
	states[32] = {descriptor: 'isInset (type===Inset)'}
	states[33] = {descriptor: 'magnet'}
	
	const dNode = new DecisionTree('root', {_UNIQUE_NAME_GROUP: 'tester'});
	const dNode2 = new DecisionTree('root2', {_UNIQUE_NAME_GROUP: 'tester'});
	const dNode3 = new DecisionTree('root3', {_UNIQUE_NAME_GROUP: 'testerr'});
	const statess = dNode.addStates(states);
	const style = dNode.then(5);
	const solid = style.then(6);
	const material = solid.then([7,8])[1];
	const materials = material.then([9,12,15,18]);
	materials[0].then([10,11]);
	materials[1].then([13,14]);
	materials[2].then([16,17]);
	materials[3].then([19,20]);
	
	
	const panel = style.then(21);
	panel.then(22);
	const profile = panel.then(23);
	const shaker = profile.then(24);
	shaker.then(25).then(26);
	const nonMdfCore = shaker.then(27);
	nonMdfCore.then([28,29,30]);
	
	dNode.then(32).then(33);
	const func = (node) => node.payload().descriptor !== 'cost';
	const subtree = style.subtree({'21': '23', '27': /29|30/, '9': func});
	
	
	Test.add('DecisionTree Subtree',(ts) => {
	  const kept = ['5','6','7','8','9','11','12','13','14','15','16','17',
	                '18','19','20','21','23','24','25','26','27','29','30'];
	  const ignored = ['10','22', '28','32','33','root'];
	  const errors = {
	    '10': 'Function condition did not work',
	    '28': 'Regular expression condition did not work',
	    '22': 'String condition did not work.',
	    '32': 'Subtree is including parents',
	    '33': 'Subtree is including parents',
	    'root': 'Subtree is including parents',
	    'default': 'This should not happen I would check the modification history of this test file.'
	  }
	  let nodeCount = 0;
	  subtree.forEach((node) => {
	    const errorMsg = errors[node.name] || errors.default;
	    ts.assertNotEquals(kept.indexOf(node.name), -1, errorMsg);
	    nodeCount++;
	  });
	  ts.assertEquals(nodeCount, 23, 'Subtree does not include all the nodes it should');
	  ts.success();
	});
	
	Test.add('DecisionTree Leaves', (ts) => {
	  const leaves = subtree.leaves();
	  ts.assertEquals(leaves.length, 11, 'Not plucking all the leaves');
	  ts.assertEquals(dNode.leaves().length, 15, 'Not plucking all the leaves');
	  ts.success();
	});
	
});


RequireJS.addFunction('./public/js/utils/test/tests/imposter.js',
function (require, exports, module) {
	
const Test = require('../test.js').Test;
	const Imposter = require('../../object/imposter');
	
	class JustTryAndCopyMe {
	  constructor() {
	    Object.getSet(this, {one: 1, two: 2, override1: 'unchanged1'});
	    this.three = 3;
	    this.four = 4;
	    this.override2 = 'unchanged2'
	    this.array = [1,2,3,4];
	    this.object = {one: 1, two: 2, three: 3};
	
	    this.equals = () => false;
	  }
	}
	
	Test.add('Imposter: fooled me',(ts) => {
	  const orig = new JustTryAndCopyMe();
	  const imposter = new Imposter(orig, {override1: () => 'changed1', override2: 'changed2'});
	  ts.assertTrue(imposter instanceof JustTryAndCopyMe);
	  ts.assertEquals(orig.one(), imposter.one());
	  ts.assertEquals(orig.two(), imposter.two());
	  ts.assertEquals(orig.three, imposter.three);
	  ts.assertEquals(orig.four, imposter.four);
	
	  ts.assertEquals(orig.one(4), imposter.one());
	  ts.assertEquals(orig.two(3), imposter.two());
	  orig.three = 7;
	  ts.assertEquals(orig.three, imposter.three);
	  orig.four = 8;
	  ts.assertEquals(orig.four, imposter.four);
	
	  ts.assertEquals(imposter.one(2), orig.one());
	  ts.assertEquals(imposter.two(1), orig.two());
	  imposter.three = 5;
	  ts.assertEquals(orig.three, imposter.three);
	  imposter.four = 0;
	  ts.assertEquals(orig.four, imposter.four);
	
	  ts.assertEquals(orig.array, imposter.array);
	  ts.assertEquals(orig.object, imposter.object);
	  orig.array[0] = 44;
	  imposter.object.one = 66;
	  ts.assertEquals(orig.array[0], imposter.array[0]);
	  ts.assertEquals(orig.object.one, imposter.object.one);
	
	  ts.assertFalse(orig === imposter);
	  ts.assertFalse(orig.equals(imposter));
	  ts.assertTrue(imposter.equals(orig));
	
	  // Test initial values
	  ts.assertEquals(imposter.override1(), 'changed1');
	  ts.assertEquals(imposter.override2, 'changed2');
	  ts.assertEquals(orig.override1(), 'unchanged1');
	  ts.assertEquals(orig.override2, 'unchanged2');
	
	  // Test function changes
	  ts.assertEquals(imposter.override1('changed3'), 'changed1');
	  ts.assertEquals(imposter.override2, 'changed2');
	  ts.assertEquals(orig.override1('unchanged3'), 'unchanged3');
	  ts.assertEquals(orig.override2, 'unchanged2');
	
	  // Test field assinments
	  imposter.override2 = 'changed4';
	  ts.assertEquals(imposter.override2, 'changed4');
	  ts.assertEquals(imposter.override1(), 'changed1');
	  orig.override2 = 'unchanged5';
	  ts.assertEquals(orig.override2, 'unchanged5');
	  ts.assertEquals(orig.override1(), 'unchanged3');
	
	  ts.success();
	});
	
});


RequireJS.addFunction('./public/js/utils/test/tests/star-line-map.js',
function (require, exports, module) {
	

	const Test = require('../test.js').Test;
	const EscapeMap = require('../../canvas/two-d/maps/escape');
	const Vertex2d = require('../../canvas/two-d/objects/vertex');
	const Line2d = require('../../canvas/two-d/objects/line');
	const Polygon2d = require('../../canvas/two-d/objects/polygon');
	
	// [new Vertex2d(10,50),new Vertex2d(10,10),new Vertex2d(50,10),new Vertex2d(50,40),new Vertex2d(20,40),new Vertex2d(20,15),new Vertex2d(40,15), new Vertex2d(40,35), new Vertex2d(35,35), new Vertex2d(35,20),new Vertex2d(25,20),new Vertex2d(25,37.5), new Vertex2d(45,37.5),new Vertex2d(45,12.5),new Vertex2d(15,12.5), new Vertex2d(15,45),new Vertex2d(50,45), new Vertex2d(50,50),new Vertex2d(10,50)]
	//
	// [new Vertex2d(20,14),new Vertex2d(15,8),new Vertex2d(24,3),new Vertex2d(20,14)]
	
	const spiral = Polygon2d.fromString('[(10,50),(10,10),(50,10),(50,40),(20,40),(20,15),(40,15), (40,35), (35,35), (35,20),(25,20),(25,37.5), (45,37.5),(45,12.5),(15,12.5), (15,45),(50,45), (50,50)]');
	const triangle = Polygon2d.fromString('[(20,14),(15,8),(24,3),(20,14)]');
	const star = Line2d.fromString('[(14,25),(16.5,20.5),(11,23),(17,23),(12.5,20.5),(14,25)]');
	const innerLines = [new Line2d(new Vertex2d(40,47), new Vertex2d(40,48)),
	                    new Line2d(new Vertex2d(40,25), new Vertex2d(35,25)),
	                    new Line2d(new Vertex2d(40,25), new Vertex2d(35,15))]
	
	// star.forEach(l => l.translate(new Line2d(new Vertex2d(0,0),new Vertex2d(10,12))));
	
	Test.add('StarLineMap: escape',(ts) => {
	  // const escapeMap = new EscapeMap(spiral.lines().concat(triangle.lines()).concat(innerLines));
	  let lines = spiral.lines().concat(triangle.lines()).concat(star).concat(innerLines);
	  const escapeMap = new EscapeMap(lines);
	  const parimeterAns = Polygon2d.fromString(`(10, 50) => (10, 10) => (16.666666666666668, 10) => (15, 8) => (24, 3) => (21.454545454545453, 10) => (50, 10) => (50, 40) => (20, 40) => (20, 15) => (40, 15) => (40, 35) => (35, 35) => (35, 20) => (25, 20) => (25, 37.5) => (45, 37.5) => (45, 12.5) => (20.545454545454547, 12.5) => (20, 14) => (18.75, 12.5) => (15, 12.5) => (15, 21.18181818181818) => (16.5, 20.5) => (15.556603773584905, 22.198113207547173) => (17, 23) => (15.111111111111112, 23) => (15, 23.200000000000003) => (15, 45) => (50, 45) => (50, 50)`);
	  const parimeter = EscapeMap.parimeter(lines);
	  ts.assertTrue(parimeter.equals(parimeterAns), 'Use canvas buddy to isolate issue: /canvas-buddy/html/index.html\n\t\tIt seams like there is an error somewhere in the merging of groups... I would focus your investigation there.');
	  ts.success();
	});
	
	Test.add('Polygon: build', (ts) => {
	  const polyAns = Polygon2d.fromString('[(14,25),(16.5,20.5),(11,23),(17,23),(12.5,20.5)]');
	  for (let index = 0; index < 5; index++) {
	    const star = Line2d.fromString('[(14,25),(16.5,20.5),(11,23),(17,23),(12.5,20.5),(14,25)]');
	    star.shuffle();
	    const poly = Polygon2d.build(star);
	    ts.assertTrue(poly.equals(polyAns));
	  }
	  ts.success();
	});
	
});


RequireJS.addFunction('./public/js/utils/test/tests/logic-tree.js',
function (require, exports, module) {
	

	// breakfast) Branch
	//   food) Multiselect
	//     bacon) Leaf
	//     eggs) Select
	//       2) Select
	//         over easy) Leaf
	//         sunny side up) Leaf
	//         scramble) Leaf
	//         fried) Leaf
	//       3) Select
	//         over easy) Leaf
	//         sunny side up) Leaf
	//         scramble) Leaf
	//         fried) Leaf
	//       6) Select
	//         over easy) Leaf
	//         sunny side up) Leaf
	//         scramble) Leaf
	//         fried) Leaf
	//     toast) Select
	//       white) Leaf
	//       wheat) Leaf
	//       texas) Leaf
	//     cereal) Branch
	//       milk) Leaf
	//       type) Select
	//         raisin brand) Leaf
	//         cheerios) Leaf
	//         life) Leaf
	//   dishes) Branch
	//     plate) Leaf
	//     fork) Leaf
	//     having cereal) Conditional
	//       bowl) Leaf
	//       spoon) Leaf
	
	
	const Test = require('../test.js').Test;
	const LogicTree = require('../../logic-tree');
	
	class ReferenceableFuctions {
	  constructor(id) {
	    id = id._TYPE === undefined ? id : id.id;
	    Object.getSet(this, {id});
	    this.condition = (tree) => {
	      if (id === 1) {
	        return tree.reachable('bacon') || tree.reachable('eggs');
	      } else if (id === 2) {
	        return tree.reachable('cereal');
	      }
	    }
	    this.LOGIC_TYPE = 'Conditional';
	    this.clone = () => new ReferenceableFuctions(id);
	  }
	}
	
	function createTree(connectEggs, optional, shouldCopy, testFuncs) {
	  const tree = new LogicTree(String.random());
	
	  function runTestFunc(name) {
	    if (testFuncs && testFuncs[name]) {
	      testFuncs[name](tree, name);
	    }
	  }
	
	  const branch = tree.branch('breakfast');
	  const food = branch.multiselect('food');
	  food.optional(optional);
	  food.leaf('bacon', {cost: 1});
	  const eggs = food.select('eggs');
	  const two = eggs.select(2, {multiplier: 2});
	  eggs.optional(optional);
	  two.optional(optional);
	  two.leaf('over easy', {cost: 1.8});
	  two.leaf('sunny side up', {cost: 2.6});
	  two.leaf('scramble', {cost: 3.2});
	  two.leaf('fried', {cost: 1.3});
	  runTestFunc('onlyOne');
	  const three = eggs.select(3, {multiplier: 3}).addChildren('2');
	  runTestFunc('now2');
	  const six = eggs.select(6, {multiplier: 6}).addChildren('2');
	  runTestFunc('now3');
	  const toast = food.select('toast');
	  three.optional(optional);
	  six.optional(optional);
	  toast.optional(optional);
	  toast.leaf('white', {cost: 1.01});
	  toast.leaf('wheat', {cost: 1.24});
	  toast.leaf('texas', {cost: 1.17});
	  const cereal = food.branch('cereal');
	  cereal.leaf('milk', {cost: 8.99});
	  const type = cereal.select('type');
	  type.optional(optional);
	  type.leaf('raisin brand', {cost: -0.55});
	  type.leaf('cheerios', {cost: 1.58});
	  type.leaf('life', {cost: 1.23});
	
	  const dishes = branch.branch('dishes');
	  const needPlate = dishes.conditional('need plate', new ReferenceableFuctions(1));
	  needPlate.leaf('plate', {cost: .14});
	  needPlate.leaf('fork', {cost: .07});
	  const havingCereal = dishes.conditional('having cereal', new ReferenceableFuctions(2));
	  havingCereal.leaf('bowl', {cost: .18});
	  havingCereal.leaf('spoon', {cost: .06});
	  runTestFunc('all');
	
	  if (connectEggs) {
	    two.valueSync(three);
	    two.defaultSync(six);
	  }
	  return shouldCopy ? copy(tree) : tree;
	}
	
	function copy(origTree) {
	    const treeJson = origTree.toJson();
	    return Object.fromJson(treeJson);
	}
	
	function testIsComplete(ts) {
	  return (tree, isComplete) => ts.assertTrue(isComplete === tree.isComplete());
	}
	
	function access(index, returnValue, testFuncs, tree) {
	  const func = testFuncs[index];
	  if ((typeof func === 'function')) {
	    func(tree, returnValue);
	  }
	}
	
	function accessProcess(ts, testFuncs, optional, shouldCopy) {
	  let tree = createTree(true, optional, shouldCopy);
	  access('init', tree, testFuncs, tree);
	  access('dontEat2', tree.setChoice('food', null), testFuncs, tree);
	  if (optional)
	    access('dontEat', tree.setChoice('food', {}), testFuncs, tree);
	
	  access('bacon', tree.setChoice('food', {bacon: true}), testFuncs, tree);
	
	  access('toast', tree.setChoice('food', {toast: true}), testFuncs, tree);
	  access('chooseToast', tree.setChoice('toast', 'white'), testFuncs, tree);
	
	  access('chooseCereal', tree.setChoice('type', 'life'), testFuncs, tree);
	  access('cereal', tree.setChoice('food', {cereal: true}), testFuncs, tree);
	
	  access('eggs', tree.setChoice('food', {eggs: true}), testFuncs, tree);
	  access('2', tree.setChoice('eggs', '2'), testFuncs, tree);
	  access('2value', tree.setChoice('2', 'scramble'), testFuncs, tree);
	  if (optional)
	    access('2NoValue', tree.setChoice('2', null), testFuncs, tree);
	  access('2valueAgain', tree.setChoice('2', 'scramble'), testFuncs, tree);
	  access('2default', tree.setDefault('2', 'fried'), testFuncs, tree);
	  access('3', tree.setChoice('eggs', '3'), testFuncs, tree);
	  access('6', tree.setChoice('eggs', '6'), testFuncs, tree);
	
	
	  access('all', tree.setChoice('food', {eggs: true, bacon: true, toast: true, cereal: true}), testFuncs, tree);
	  return tree;
	}
	
	function LogicTest(tree, ts) {
	  const properStructure = "breakfast) Branch\n  food) Multiselect\n    bacon) Leaf\n    eggs) Select\n      2) Select\n        over easy) Leaf\n        sunny side up) Leaf\n        scramble) Leaf\n        fried) Leaf\n      3) Select\n        over easy) Leaf\n        sunny side up) Leaf\n        scramble) Leaf\n        fried) Leaf\n      6) Select\n        over easy) Leaf\n        sunny side up) Leaf\n        scramble) Leaf\n        fried) Leaf\n    toast) Select\n      white) Leaf\n      wheat) Leaf\n      texas) Leaf\n    cereal) Branch\n      milk) Leaf\n      type) Select\n        raisin brand) Leaf\n        cheerios) Leaf\n        life) Leaf\n  dishes) Branch\n    need plate) Conditional\n      plate) Leaf\n      fork) Leaf\n    having cereal) Conditional\n      bowl) Leaf\n      spoon) Leaf\n";
	  ts.assertEquals(tree.structure(), properStructure);
	  ts.success();
	}
	
	function decisionsTest(ts, copy) {
	  function validateDecisions (tree, ...names) {
	    if (tree.decisions().length !== names.length) {
	      console.log('badd!')
	    }
	    const decisions = tree.decisions();
	    ts.assertEquals(decisions.length, names.length);
	    const decisionNames = decisions.map((elem) => elem.name);
	    for (let index = 0; index < names.length; index += 1) {
	      ts.assertNotEquals(decisionNames.indexOf(names[index]) === -1);
	    }
	  }
	
	  const testFuncs = {
	    init: (tree) => validateDecisions(tree, 'food'),
	    dontEat: (tree) => validateDecisions(tree, 'food'),
	
	    bacon: (tree) => validateDecisions(tree, 'food'),
	
	    toast: (tree) => validateDecisions(tree, 'food', 'toast'),
	    chooseToast: (tree) => validateDecisions(tree, 'food', 'toast'),
	
	    chooseCereal: (tree) => validateDecisions(tree, 'food', 'toast'),
	    cereal: (tree) => validateDecisions(tree, 'food', 'having cereal'),
	
	    eggs: (tree) => validateDecisions(tree, 'food', 'eggs'),
	    "2": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "2value": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "2NoValue": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "2valueAgain": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "2default": (tree) => validateDecisions(tree, 'food', 'eggs', '2'),
	    "3": (tree) => validateDecisions(tree, 'food', 'eggs', '3'),
	    "6": (tree) => validateDecisions(tree, 'food', 'eggs', '6'),
	
	    all: (tree) => validateDecisions(tree, 'food', 'eggs', '6', 'having cereal', 'toast')
	  }
	  accessProcess(ts, testFuncs, undefined, copy);
	  ts.success();
	}
	
	function optionalTest(ts, shouldCopy) {
	  const tic = testIsComplete(ts);
	  const testFuncs = {
	    init: (tree) => tic(tree, true),
	    dontEat: (tree) =>  tic(tree, true),
	    dontEat2: (tree) =>  tic(tree, true),
	    bacon: (tree) =>  tic(tree, true),
	    toast: (tree) =>  tic(tree, true),
	    chooseToast: (tree) =>  tic(tree, true),
	    chooseCereal: (tree) =>  tic(tree, true),
	    cereal: (tree) =>  tic(tree, true),
	    eggs: (tree) =>  tic(tree, true),
	    "2": (tree) =>  tic(tree, true),
	    "2value": (tree) =>  tic(tree, true),
	    "2NoValue": (tree) =>  tic(tree, true),
	    "2valueAgain": (tree) =>  tic(tree, true),
	    "2default": (tree) =>  tic(tree, true),
	    "3": (tree) =>  tic(tree, true),
	    "6": (tree) =>  tic(tree, true),
	    all: (tree) =>  tic(tree, true),
	  }
	  accessProcess(ts, testFuncs, true, shouldCopy);
	  ts.success();
	}
	
	function notOptionalTest(ts, shouldCopy) {
	  const tic = testIsComplete(ts);
	  const testFuncs = {
	    init: (tree) => tic(tree, false),
	    dontEat: (tree) =>  tic(tree, false),
	    dontEat2: (tree) =>  tic(tree, false),
	    bacon: (tree) =>  tic(tree, true),
	    toast: (tree) =>  tic(tree, false),
	    chooseToast: (tree) =>  tic(tree, true),
	    chooseCereal: (tree) =>  tic(tree, true),
	    cereal: (tree) =>  tic(tree, true),
	    eggs: (tree) =>  tic(tree, false),
	    "2": (tree) =>  tic(tree, false),
	    "2value": (tree) =>  tic(tree, true),
	    "2NoValue": (tree) =>  tic(tree, false),
	    "2valueAgain": (tree) =>  tic(tree, true),
	    "2default": (tree) =>  tic(tree, true),
	    "3": (tree) =>  tic(tree, true),
	    "6": (tree) =>  tic(tree, true),
	    all: (tree) =>  tic(tree, true),
	  }
	  accessProcess(ts, testFuncs, false, shouldCopy);
	  ts.success();
	}
	
	function instanceCountTest(ts, shouldCopy) {
	  const instanceCountCorrect = (tree, countObj, stage) => {
	    Object.keys(countObj).forEach((name) =>
	      ts.assertEquals(countObj[name], tree.node.instanceCount(name),
	          `@stage=${stage} name=${name} incorrect instance count shouldCopy=${shouldCopy}`)
	    );
	  }
	
	  function instanceCountObj(count, obj, two, three, six) {
	    obj['over easy'] = count;
	    obj['sunny side up'] = count;
	    obj['scramble'] = count;
	    obj['fried'] = count;
	    obj['2'] = two;
	    obj['3'] = three;
	    obj['6'] = six;
	    return obj;
	  }
	  const food = 1;
	  const eggs = 1;
	  const two = 1;
	  const three = 1;
	  const six = 1;
	  const toast = 1
	  const white = 1;
	  const wheat = 1;
	  const texas = 1;
	  const milk = 1;
	  const type = 1;
	  const cheerios = 1;
	  const life = 1;
	  const onlyOneObj = instanceCountObj(1, {food, eggs}, 1, 0, 0);
	  const now2Obj = instanceCountObj(2, {food, eggs}, 1, 1, 0);
	  const now3Obj = instanceCountObj(3, {food, eggs}, 1, 1, 1);
	  const allObj = instanceCountObj(3, {food,eggs,toast,white,wheat,texas,milk,type,cheerios,life}, 1, 1, 1);
	  const testFuncs = {
	    onlyOne: (tree, stage) =>  instanceCountCorrect(tree, onlyOneObj, stage),
	    now2: (tree, stage) =>  instanceCountCorrect(tree, now2Obj, stage),
	    now3: (tree, stage) =>  instanceCountCorrect(tree, now3Obj, stage),
	    all: (tree, stage) =>  instanceCountCorrect(tree, allObj, stage),
	  }
	  createTree(undefined, undefined, shouldCopy, testFuncs)
	  ts.success();
	}
	
	function forPathTest(ts, shouldCopy) {
	    function verifyCost(choices, expectedCost) {
	      const tree = createTree(undefined, undefined, shouldCopy);
	      const keys = Object.keys(choices);
	      keys.forEach((key) => tree.setChoice(key, choices[key]));
	      const data = tree.forPath((wrapper, cost) => {
	        cost = cost || 0;
	        const payload = wrapper.payload();
	        if (payload.cost) cost += payload.cost;
	        if (payload.multiplier) cost *= payload.multiplier;
	        return cost;
	      });
	      let total = 0;
	      data.forEach((cost) => total += cost);
	      ts.assertEquals(Math.round(total * 100) / 100, expectedCost);
	    }
	
	    verifyCost({food: {bacon: true}}, 1.21)
	    verifyCost({food: {bacon: false, eggs: false, cereal:true},
	                type: 'life'}, 10.46);
	    verifyCost({food: {bacon: true, eggs: true},
	                eggs: '2', '2': 'fried'}, 2.51)
	    verifyCost({food: {bacon: true, eggs: false, cereal:true},
	                eggs: '2', '2': 'fried', type: 'life'}, 11.67);
	    verifyCost({food: {bacon: true, eggs: true, cereal:true, toast: true},
	                eggs: '6', '6': 'sunny side up', type: 'life', toast: 'wheat'}, 15.51);
	    ts.success();
	}
	
	function forPathReverseTest(ts, shouldCopy) {
	      function verifyCost(choices, expectedCost) {
	        const tree = createTree(true, undefined, shouldCopy);
	        const keys = Object.keys(choices);
	        keys.forEach((key) => tree.setChoice(key, choices[key]));
	        const data = tree.forPath((wrapper, cost) => {
	          cost = cost || 0;
	          const payload = wrapper.payload();
	          if (payload.cost) cost += payload.cost;
	          if (payload.multiplier) cost *= payload.multiplier;
	          return cost;
	        }, true);
	        let total = 0;
	        data.forEach((cost) => total += cost);
	        ts.assertEquals(Math.round(total * 100) / 100, expectedCost);
	      }
	
	      verifyCost({food: {bacon: true}}, 1.21)
	      verifyCost({food: {bacon: false, eggs: false, cereal:true},
	                  type: 'life'}, 10.46);
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '2', '2': 'fried'}, 3.81)
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '3', '2': 'fried'}, 5.11)
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '6', '2': 'fried'}, 1.21)
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '6', '6': 'scramble'}, 20.41)
	      verifyCost({food: {bacon: true, eggs: false, cereal:true},
	                  eggs: '2', '2': 'fried', type: 'life'}, 11.67);
	      verifyCost({food: {bacon: true, eggs: true, cereal:true, toast: true},
	                  eggs: '6', '6': 'sunny side up', type: 'life', toast: 'wheat'}, 28.51);
	      ts.success();
	}
	
	function leavesTest(ts, shouldCopy) {
	      function verifyCost(choices, expectedCost) {
	        const tree = createTree(undefined, undefined, true);
	        const keys = Object.keys(choices);
	        keys.forEach((key) => tree.setChoice(key, choices[key]));
	        let total = 0;
	        tree.leaves().forEach((wrapper) => {
	          const payload = wrapper.payload();
	          if (payload.cost) total += payload.cost;
	        });
	        ts.assertEquals(Math.round(total * 100) / 100, expectedCost);
	      }
	
	      verifyCost({food: {bacon: true}}, 1.21)
	      verifyCost({food: {bacon: false, eggs: false, cereal:true},
	                  type: 'life'}, 10.46);
	      verifyCost({food: {bacon: true, eggs: true},
	                  eggs: '2', '2': 'fried'}, 2.51)
	      verifyCost({food: {bacon: true, eggs: false, cereal:true},
	                  eggs: '2', '2': 'fried', type: 'life'}, 11.67);
	      verifyCost({food: {bacon: true, eggs: true, cereal:true, toast: true},
	                  eggs: '6', '6': 'sunny side up', type: 'life', toast: 'wheat'}, 15.51);
	      ts.success();
	}
	
	function getNodeByPathTest(ts, shouldCopy) {
	  const tree = createTree(undefined, undefined, shouldCopy)
	
	  const fried2 = tree.root().node.next('food').next('eggs').next('2').next('fried');
	  const fried3 = tree.root().node.next('food').next('eggs').next('3').next('fried');
	  const fried6 = tree.root().node.next('food').next('eggs').next('6').next('fried');
	
	  const friedBy2 = tree.node.getNodeByPath('food', 'eggs', '2', 'fried');
	  const friedBy3 = tree.node.getNodeByPath('food', 'eggs', '3', 'fried');
	  const friedBy6 = tree.node.getNodeByPath('food', 'eggs', '6', 'fried');
	
	  ts.assertEquals(fried2, friedBy2);
	  ts.assertEquals(fried3, friedBy3);
	  ts.assertEquals(fried6, friedBy6);
	
	  ts.assertNotEquals(fried2, friedBy3);
	  ts.assertNotEquals(fried2, friedBy6);
	  ts.assertNotEquals(fried3, friedBy2);
	  ts.assertNotEquals(fried3, friedBy6);
	  ts.assertNotEquals(fried6, friedBy2);
	  ts.assertNotEquals(fried6, friedBy3);
	
	  ts.success();
	}
	
	function removeTest(ts, shouldCopy) {
	    const tree = createTree(null, null, shouldCopy);
	    function checkNodeCounts(tree, nodeCounts) {
	      Object.keys(nodeCounts).forEach((key) =>
	          ts.assertEquals(nodeCounts[key], tree.node.instanceCount(key),
	            `RemoveTest Failed: incorrect instance count for ${key}`));
	    }
	    function nodeCounts(overwrites, eggTypeCount, nuke) {
	      overwrites = overwrites || {};
	      function overVal(id, def) {
	        return overwrites[id] !== undefined ? overwrites[id] :
	                                (nuke !== undefined ? nuke : def);
	      }
	      return {
	        food: overVal("food", 1),
	        eggs: overVal("eggs", 1),
	        '2': overVal("2", 1),
	        '3': overVal("3", 1),
	        '6': overVal("6", 1),
	        toast: overVal("toast", 1),
	        white: overVal("white", 1),
	        wheat: overVal("wheat", 1),
	        texas: overVal("texas", 1),
	        milk: overVal("milk", 1),
	        type: overVal("type", 1),
	        cheerios: overVal("cheerios", 1),
	        life: overVal("life", 1),
	
	        scramble: overVal("scramble", eggTypeCount || 3),
	        fried: overVal("fried", eggTypeCount || 3),
	        "sunny side up": overVal("sunny side up", eggTypeCount || 3),
	        "over easy": overVal("over easy", eggTypeCount || 3)
	      }
	    }
	
	    try {
	      tree.node.addState('food', {hello: 'world'});
	      ts.fail();
	    } catch (e) {}
	
	    checkNodeCounts(tree, nodeCounts());
	    tree.node.getNodeByPath('food', 'eggs', '3', 'fried').remove();
	    checkNodeCounts(tree, nodeCounts({fried: 2}));
	    tree.node.getNodeByPath('food', 'eggs', '3').remove();
	    checkNodeCounts(tree, nodeCounts({'3': 0}, 2))
	    tree.node.getNodeByPath('food', 'eggs', '2').remove();
	    checkNodeCounts(tree, nodeCounts({'3': 0, '2': 0}, 1))
	    tree.node.getNodeByPath('food').remove();
	    checkNodeCounts(tree, nodeCounts(undefined, undefined, 0));
	    ts.assertEquals(tree.node.instanceCount('dishes'), 1);
	
	    const msg = 'hello world';
	    const payload = {msg};
	    tree.node.addState('food', payload);
	    tree.node.then('food');
	    const food = tree.node.getNodeByPath('food');
	    ts.assertEquals(Object.keys(food.payload()).length, 2);
	    ts.assertEquals(food.payload().msg, msg);
	
	    ts.success();
	}
	
	function attachTreeTest(ts) {
	  const orderTree = createTree();
	  const origLeaves = orderTree.node.leaves();
	  let leaveCount = origLeaves.length;
	  const drinkTree = new LogicTree(String.random());
	
	  const type = drinkTree.select('drink type');
	  type.select('alcholic').leaf('beer');
	  type.select('non alcholic').leaf('soda');
	  orderTree.attachTree(drinkTree);
	  let newLeaves = orderTree.node.leaves();
	  ts.assertEquals(leaveCount + 2, newLeaves.length)
	  leaveCount = newLeaves.length;
	
	  const eggs = orderTree.getByPath('food', 'eggs');
	  const nonAlcholic = orderTree.getByPath('drink type', 'non alcholic');
	  nonAlcholic.attachTree(eggs);
	  newLeaves = orderTree.node.leaves();
	  ts.assertEquals(leaveCount + 12, newLeaves.length)
	  leaveCount = newLeaves.length;
	
	  const milk = orderTree.getByPath('food', 'cereal', 'milk');
	  nonAlcholic.attachTree(milk);
	  newLeaves = orderTree.node.leaves();
	  ts.assertEquals(leaveCount + 1, newLeaves.length)
	
	  milk.attachTree(nonAlcholic);
	
	  ts.success();
	}
	
	Test.add('LogicTree structure', (ts) => {
	  LogicTest(createTree(), ts);
	});
	Test.add('LogicTree structure (copy)', (ts) => {
	  LogicTest(createTree(undefined, undefined, true), ts);
	});
	
	Test.add('LogicTree getNodeByPath', (ts) => {
	  getNodeByPathTest(ts);
	});
	Test.add('LogicTree getNodeByPath (copy)', (ts) => {
	  getNodeByPathTest(ts, true);
	});
	
	Test.add('LogicTree remove', (ts) => {
	  removeTest(ts);
	});
	Test.add('LogicTree remove (copy)', (ts) => {
	  removeTest(ts, true);
	});
	
	Test.add('LogicTree decisions', (ts) => {
	  decisionsTest(ts);
	});
	Test.add('LogicTree decisions (copy)', (ts) => {
	  decisionsTest(ts, true);
	});
	
	Test.add('LogicTree isComplete (optional)', (ts) => {
	  optionalTest(ts);
	});
	Test.add('LogicTree isComplete (optional & copy)', (ts) => {
	  optionalTest(ts,true);
	});
	
	Test.add('LogicTree isComplete (!optional)', (ts) => {
	  notOptionalTest(ts);
	});
	Test.add('LogicTree isComplete (!optional & copy)', (ts) => {
	  notOptionalTest(ts, true);
	});
	
	Test.add('LogicTree forPath (forward)', (ts) => {
	  forPathTest(ts);
	});
	Test.add('LogicTree forPath (forward & copy)', (ts) => {
	  forPathTest(ts, true);
	});
	
	Test.add('LogicTree forPath (reverse)', (ts) => {
	  forPathReverseTest(ts);
	});
	Test.add('LogicTree forPath (reverse & copy)', (ts) => {
	  forPathReverseTest(ts, true);
	});
	
	Test.add('LogicTree leaves', (ts) => {
	  leavesTest(ts);
	});
	Test.add('LogicTree leaves (copy)', (ts) => {
	  leavesTest(ts, true);
	});
	
	Test.add('LogicTree instanceCount', (ts) => {
	  instanceCountTest(ts);
	});
	Test.add('LogicTree instanceCount (copy)', (ts) => {
	  instanceCountTest(ts, true);
	});
	
	Test.add('LogicTree attachTree', (ts) => {
	  attachTreeTest(ts);
	});
	Test.add('LogicTree attachTree (copy)', (ts) => {
	  attachTreeTest(ts, true);
	});
	
	Test.add('LogicTree change', (ts) => {
	  let tree = createTree();
	  const food = tree.getByPath('food');
	  const needPlate = tree.getByPath('dishes', 'need plate');
	  food.node.change('needPlate');
	  ts.success();
	});
	
	
	// Test.add('LogicTree ', (ts) => {
	//   function validateDecisions (tree, ...names) {
	//     const decisions = tree.decisions();
	//     ts.assertEquals(decisions.length, names.length);
	//     const decisionNames = decisions.map((elem) => elem.name);
	//     for (let index = 0; index < names.length; index += 1) {
	//       ts.assertNotEquals(decisionNames.indexOf(names[index]) === -1);
	//     }
	//   }
	//
	//   const testFuncs = {
	//     init: (tree) => ,
	//     dontEat: (tree) => ,
	//
	//     bacon: (tree) => ,
	//
	//     toast: (tree) => ,
	//     chooseToast: (tree) => ,
	//
	//     chooseCereal: (tree) => ,
	//     cereal: (tree) => ,
	//
	//     eggs: (tree) => ,
	//     "2": (tree) => ,
	//     "2value": (tree) => ,
	//     "2NoValue": (tree) => ,
	//     "2valueAgain": (tree) => ,
	//     "2default": (tree) => ,
	//     "6": (tree) => ,
	//
	//     all: (tree) =>
	//   }
	//   accessProcess(ts, testFuncs);
	//   ts.success();
	// });
	
});


RequireJS.addFunction('./public/js/utils/test/tests/utils.js',
function (require, exports, module) {
	
const Test = require('../test.js').Test;
	
	Test.add('Array: scale',(ts) => {
	  const original = [1,2,3,4];
	  const arr = Array.from(original);
	  const valScale = arr.scale(3, true);
	  ts.assertTrue(original.equals(arr));
	  ts.assertTrue(valScale.equals([3,6,9,12]));
	  const funcScale = arr.scale((val, index) => index, true);
	  ts.assertTrue(original.equals(arr));
	  ts.assertTrue(funcScale.equals([0,2,6,12]));
	  arr.scale([9,5,3,2]);
	  ts.assertTrue(!original.equals(arr));
	  ts.assertTrue(arr.equals([9,10,9,8]));
	
	  ts.success();
	});
	
	Test.add('Array: add',(ts) => {
	  const original = [1,2,3,4];
	  const arr = Array.from(original);
	  const valScale = arr.add(3, true);
	  ts.assertTrue(original.equals(arr));
	  ts.assertTrue(valScale.equals([4,5,6,7]));
	  const funcScale = arr.add((val, index) => index, true);
	  ts.assertTrue(original.equals(arr));
	  ts.assertTrue(funcScale.equals([1,3,5,7]));
	  arr.add([9,5,3,2]);
	  ts.assertTrue(!original.equals(arr));
	  ts.assertTrue(arr.equals([10,7,6,6]));
	
	  ts.success();
	});
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/vertex.js',
function (require, exports, module) {
	
const approximate10 = require('../../../approximate.js').new(10);
	const ToleranceMap = require('../../../tolerance-map.js');
	const Tolerance = require('../../../tolerance.js');
	const tol = .001;
	const within = Tolerance.within(tol);
	
	
	class Vertex2d {
	  constructor(point) {
	    if (arguments.length === 2) point = {x:arguments[0], y: arguments[1]};
	    if (Array.isArray(point)) point = {x: point[0], y: point[1]};
	    if (point instanceof Vertex2d) return point;
	    let modificationFunction;
	    let id = String.random();
	    this.id = () => id;
	    point = point || {x:0,y:0};
	    Object.getSet(this, {point});
	    this.layer = point.layer;
	    const instance = this;
	    this.move = (center) => {
	      this.point(center);
	      return true;
	    };
	
	    this.translate = (xOffset, yOffset, doNotModify) => {
	      const vertex = doNotModify ? this.copy() : this;
	      vertex.point().x += xOffset;
	      vertex.point().y += yOffset;
	      return vertex;
	    }
	
	    this.rotate = (radians, pivot, doNotModify) => {
	      const vertex = doNotModify ? this.copy() : this;
	      const point = vertex.point();
	      pivot ||= new Vertex2d(0,0);
	      const s = Math.sin(radians);
	      const c = Math.cos(radians);
	      point.x -= pivot.x();
	      point.y -= pivot.y();
	      const newX = point.x * c - point.y * s;
	      const newY = point.x * s + point.y * c;
	      point.x = newX + pivot.x();
	      point.y = newY + pivot.y();
	      return vertex;
	    }
	    this.point = (newPoint) => {
	      newPoint = newPoint instanceof Vertex2d ? newPoint.point() : newPoint;
	      if (newPoint) this.x(newPoint.x);
	      if (newPoint) this.y(newPoint.y);
	      return point;
	    }
	
	    this.modificationFunction = (func) => {
	      if ((typeof func) === 'function') {
	        if ((typeof this.id) !== 'function') Lookup.convert(this);
	        modificationFunction = func;
	      }
	      return modificationFunction;
	    }
	
	    this.equals = (other, tol) => {
	      if (!(other instanceof Vertex2d)) return false;
	      const wi = tol ? Tolerance.within(tol) : within;
	      return wi(other.x(), this.x()) && wi(other.y(), this.y());
	    }
	    this.x = (val) => {
	      if ((typeof val) === 'number') point.x = val;
	      return this.point().x;
	    }
	    this.y = (val) => {
	      if ((typeof val) === 'number') this.point().y = val;
	      return this.point().y;
	    }
	
	    const dummyFunc = () => true;
	    this.forEach = (func, backward) => {
	      let currVert = this;
	      let lastVert;
	      do {
	        lastVert = currVert;
	        func(currVert);
	        currVert = backward ? currVert.prevVertex() : currVert.nextVertex();
	      } while (currVert && currVert !== this);
	      return currVert || lastVert;
	    }
	
	    this.distance = (vertex) => {
	      vertex = (vertex instanceof Vertex2d) ? vertex : new Vertex2d(vertex);
	      const xDiff = vertex.x() - this.x();
	      const yDiff = vertex.y() - this.y();
	      return Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
	    }
	
	    const barelyRound = (value) => Math.round(value * 10000000000000) / 10000000000000;
	    this.toString = () => `(${barelyRound(this.x())}, ${barelyRound(this.y())})`;
	    this.approxToString = () => `(${approximate10(this.x())}, ${approximate10(this.y())})`;
	    const parentToJson = this.toJson;
	
	    this.offset = (x, y) => {
	      if (x instanceof Vertex2d) {
	        y = x.y();
	        x = x.x();
	      }
	      const copy = this.toJson().point;
	      if (y !== undefined) copy.y += y;
	      if (x !== undefined) copy.x += x;
	      return new Vertex2d(copy);
	    }
	
	    this.copy = () => new Vertex2d([this.x(), this.y()]);
	
	    this.differance = (x, y) => {
	      if (x instanceof Vertex2d) {
	        y = x.y();
	        x = x.x();
	      }
	      return new Vertex2d({x: this.x() - x, y: this.y() - y});
	    }
	
	    this.point(point);
	  }
	}
	
	Vertex2d.fromJson = (json) => {
	  return new Vertex2d(json.point);
	}
	
	Vertex2d.minMax = (...vertices) => {
	  if (Array.isArray(vertices[0])) vertices = vertices[0];
	  const max = new Vertex2d(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);
	  const min = new Vertex2d(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
	  for (let index = 0; index < vertices.length; index += 1) {
	    const vert = vertices[index];
	    if (max.x() < vert.x()) max.x(vert.x());
	    if (max.y() < vert.y()) max.y(vert.y());
	    if (min.x() > vert.x()) min.x(vert.x());
	    if (min.y() > vert.y()) min.y(vert.y());
	  }
	  return {min, max, diff: new Vertex2d(max.x() - min.x(), max.y() - min.y())};
	}
	
	Vertex2d.center = (...vertices) => {
	  if (Array.isArray(vertices[0])) vertices = vertices[0];
	  const minMax = Vertex2d.minMax(...vertices);
	  const centerX = minMax.min.x() + (minMax.max.x() - minMax.min.x())/2;
	  const centerY = minMax.min.y() + (minMax.max.y() - minMax.min.y())/2;
	  return new Vertex2d(centerX, centerY);
	}
	
	Vertex2d.weightedCenter = (...vertices) => {
	  if (Array.isArray(vertices[0])) vertices = vertices[0];
	  let x = 0;
	  let y = 0;
	  let count = 0;
	  vertices.forEach((vertex) => {
	    if (Number.isFinite(vertex.x() + vertex.y())) {
	      count++;
	      x += vertex.x();
	      y += vertex.y();
	    }
	  });
	  return new Vertex2d({x: x/count, y: y/count});
	}
	
	// Vertex2d.center = Vertex2d.weightedCenter;
	
	Vertex2d.sort = (a, b) =>
	    a.x() === b.x() ? (a.y() === b.y() ? 0 : (a.y() > b.y() ? -1 : 1)) : (a.x() > b.x() ? -1 : 1);
	
	const ignoreVerySmall = (v) => Math.abs(v) < .000001 ? 0 : v;
	Vertex2d.sortByMax = (verts) => {
	  let max;
	  const center = Vertex2d.center(verts);
	  for (let index = 0; index < verts.length; index++) {
	    let v = verts[index];
	    let curr = {v, distance: v.distance(center)};
	    if (max === undefined || max.distance < curr.distance) {
	      max = curr;
	    }
	  }
	  return verts.sort((v1, v2) => {
	    const d1 = v1.distance(max.v);
	    const d2 = v2.distance(max.v);
	    return d2 - d1;
	  });
	}
	
	Vertex2d.centerOn = (newCenter, vertices) => {
	  newCenter = new Vertex2d(newCenter);
	  const center = Vertex2d.center(...vertices);
	  const diff = newCenter.copy().differance(center);
	  for (let index = 0; index < vertices.length; index++) {
	    const vert = vertices[index];
	    vert.translate(diff.x(), diff.y());
	  }
	}
	
	Vertex2d.scale = (scaleX, scaleY, vertices) => {
	  const center = Vertex2d.center(vertices);
	  Vertex2d.centerOn(new Vertex2d(0,0), vertices);
	  for (let index = 0; index < vertices.length; index++) {
	    const vert = vertices[index];
	    vert.x(vert.x() * 1);
	    vert.y(vert.y() * -1);
	  }
	  Vertex2d.centerOn(center, vertices);
	}
	
	Vertex2d.toleranceMap = (tolerance, vertices) => {
	  tolerance ||= tol;
	  vertices = [];
	  const map = new ToleranceMap({x: tolerance, y: tolerance});
	  for (let index = 0; index < vertices.length; index++) {
	    map.add(vertices[index]);
	  }
	  return map;
	}
	
	Vertex2d.reusable = true;
	new Vertex2d();
	
	module.exports = Vertex2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/polygon.js',
function (require, exports, module) {
	const Vertex2d = require('./vertex');
	const Line2d = require('./line');
	
	class Polygon2d {
	  constructor(initialVertices) {
	    let lines = [];
	    const instance = this;
	    let faceIndecies = [2];
	    let map
	
	    this.vertices = (target, before, after) => {
	      if (lines.length === 0) return [];
	      const fullList = [];
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        fullList.push(line.startVertex());
	      }
	      if (target) {
	        const vertices = [];
	        const index = fullList.indexOf(target);
	        if (index === undefined) return null;
	        vertices = [];
	        for (let i = before; i < before + after + 1; i += 1) vertices.push(fullList[i]);
	        return vertices;
	      } else return fullList;
	    }
	
	    this.reverse = () => {
	      const verts = instance.vertices();
	      for (let index = lines.length - 1; index > -1; index--) {
	        const line = lines[index];
	        const startVert = index === lines.length - 1 ? verts[0] : verts[index + 1];
	        const endVert = verts[index];
	        line.startVertex(startVert);
	        line.endVertex(endVert);
	      }
	      lines = lines.reverse();
	      faceIndecies.forEach((index, i) => {
	          faceIndecies[i] = lines.length - index - 1;
	      });
	    }
	
	    this.mirrorX = () => {
	      const start = this.center().copy();
	      const end = start.translate(0, 10, true);
	      const mirror = new Line2d(start, end);
	      mirror.mirrorX(this.vertices());
	    }
	    this.mirrorY = () => {
	      const start = this.center().copy();
	      const end = start.translate(10, 0, true);
	      const mirror = new Line2d(start, end);
	      const verts = this.vertices();
	      mirror.mirrorPoints(verts);
	    }
	
	    this.verticesAndMidpoints = (target, before, after) => {
	      const verts = this.vertices();
	      const both = [];
	      for (let index = 0; index < verts.length; index++) {
	        const sv = verts[index];
	        const ev = verts[index + 1 === verts.length ? 0 : index + 1];
	        both.push(sv);
	        both.push(Vertex2d.center(sv, ev));
	      }
	      return both;
	    }
	
	    function addNieghborsOfVertexWithinLine(vertex, indicies) {
	      const list = [];
	      for (let index = 0; index < indicies.length; index++) {
	        const i = indicies[index];
	        let found = false;
	        for (let index = 0; !found && index < lines.length; index++) {
	          const line = lines[index];
	          if (line.withinSegmentBounds(vertex)) {
	            found = true;
	            if (i > 0) {
	              list.push(instance.neighbors(line.endVertex(), i - 1)[0]);
	            } else if (i < 0) {
	              list.push(instance.neighbors(line.startVertex(), i + 1)[0]);
	            } else {
	              list.push(vertex);
	            }
	          }
	        }
	        if (!found) list.push(null);
	      }
	      return list;
	    }
	
	    this.neighbors = (vertex,...indicies) => {
	      const verts = this.verticesAndMidpoints();
	      const targetIndex = verts.equalIndexOf(vertex);
	      if (targetIndex !== -1) {
	        const list = [];
	        for (let index = 0; index < indicies.length; index++) {
	          const i = indicies[index];
	          const offsetIndex = Math.mod(targetIndex + i, verts.length);
	          list.push(verts[offsetIndex]);
	        }
	        return list;
	      }
	      return addNieghborsOfVertexWithinLine(vertex, indicies);
	    }
	
	    // TODO: this function is rotating should use degrees not theta.
	    function positionRelitiveToVertex(vertex, moveTo, externalVertex) {
	      const center = instance.center();
	      if (moveTo.theta) {
	        if (externalVertex) {
	          vertex.rotate(moveTo.theta, center);
	          throw new Error('is this used?');
	        }
	        const rotatedPoly = instance.rotate(moveTo.theta, vertex, true);
	        const rotatedCenter = rotatedPoly.center();
	        const offset = rotatedCenter.differance(vertex);
	        return moveTo.center.translate(offset.x(), offset.y(), true);
	      }
	      const offset = center.differance(vertex);
	      return moveTo.center.translate(offset.x(), offset.y(), true);
	    }
	
	    function vertexFunction(midpoint) {
	      const getVertex = midpoint ? (line) => line.midpoint() : (line) => line.startVertex().copy();
	      return (index, moveTo) => {
	        const vertex = getVertex(lines[Math.mod(index, lines.length)]);
	        if (moveTo === undefined) return vertex;
	        return positionRelitiveToVertex(vertex, moveTo);
	      }
	    }
	
	    this.relativeToExternalVertex = (vertex, moveTo) => positionRelitiveToVertex(vertex, moveTo, true);
	    this.vertex = vertexFunction();
	    this.midpoint = vertexFunction(true);
	    this.point = (index, moveTo) => {
	      if (index % 2 === 0) return this.vertex(index/2, moveTo);
	      else return this.midpoint((index - 1)/2, moveTo);
	    }
	
	    this.midpoints = () => {
	      const list = [];
	      for (let index = 0; index < lines.length; index++) {
	        list.push(this.midpoint(index));
	      }
	      return list;
	    }
	
	    this.radians = (rads) => {
	      const currRads = new Line2d(this.center(), this.faces()[0].midpoint()).radians();
	      if (Number.isFinite(rads)) {
	        const radOffset = rads - currRads;
	        this.rotate(radOffset);
	        return rads;
	      }
	      return currRads;
	    }
	    this.angle = (angle) => Math.toDegrees(this.radians(Math.toRadians(angle)));
	
	    this.faceIndecies = (indicies) => {
	      if (indicies) {
	        if (indicies.length > 1) console.warn.subtle(500, 'vertex sorting has not been tested for multple faces');
	        faceIndecies = [0];
	        const i = indicies[0];
	        lines = lines.slice(i).concat(lines.slice(0, i));
	        for (let index = 1; index < lines.length; index++) {
	          const ind = Math.mod(indicies[index] - i, lines.length);
	          if (!Number.isNaN(ind)) faceIndecies.push(ind);
	        }
	      }
	      return faceIndecies;
	    }
	    this.faces = () => this.lines().filter((l, i) => faceIndecies.indexOf(i) !== -1);
	    this.normals = () => {
	      let normals = [];
	      let center = this.center();
	      for (let index = 0; index < faceIndecies.length; index++) {
	        const line = lines[faceIndecies[index]];
	        if (line)
	          normals.push(new Line2d(center.copy(), line.midpoint()));
	      }
	      return normals;
	    }
	
	    this.lines = () => lines;
	    this.startLine = () => lines[0];
	    this.endLine = () => lines[lines.length - 1];
	    this.valid = () => lines.length > 2;
	
	    this.lineMap = (force) => {
	      if (!force && map !== undefined) return map;
	      if (lines.length === 0) return {};
	      map = {};
	      let lastEnd;
	      if (!lines[0].startVertex().equals(lines[lines.length - 1].endVertex())) throw new Error('Broken Polygon');
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        if (lastEnd && !line.startVertex().equals(lastEnd)) throw new Error('Broken Polygon');
	        lastEnd = line.endVertex();
	        map[line.toString()] = line;
	      }
	      return map;
	    }
	
	    this.equals = (other) => {
	      if (!(other instanceof Polygon2d)) return false;
	      const verts = this.vertices();
	      const otherVerts = other.vertices();
	      if (verts.length !== otherVerts.length) return false;
	      let otherIndex = undefined;
	      let direction;
	      for (let index = 0; index < verts.length * 2; index += 1) {
	        const vIndex = index % verts.length;
	        if (otherIndex === undefined) {
	          if (index > verts.length) {
	            return false
	          } if(verts[index].equals(otherVerts[0])) {
	            otherIndex = otherVerts.length * 2;
	          }
	        } else if (otherIndex === otherVerts.length * 2) {
	          if (verts[vIndex].equals(otherVerts[1])) direction = 1;
	          else if(verts[vIndex].equals(otherVerts[otherVerts.length - 1])) direction = -1;
	          else return false;
	          otherIndex += direction * 2;
	        } else if (!verts[vIndex].equals(otherVerts[otherIndex % otherVerts.length])) {
	          return false;
	        } else {
	          otherIndex += direction;
	        }
	      }
	      return true;
	    }
	
	    function getLine(line) {
	      const lineMap = this.lineMap();
	      return lineMap[line.toString()] || lineMap[line.toNegitiveString()];
	    }
	
	    this.toDrawString = () => {
	      return Line2d.toDrawString(instance.lines()) + '\n' + Line2d.toDrawString(instance.normals(), 'red');
	    }
	
	    this.getLines = (startVertex, endVertex, reverse) => {
	      const inc = reverse ? -1 : 1;
	      const subSection = [];
	      let completed = false;
	      const doubleLen = lines.length * 2;
	      for (let steps = 0; steps < doubleLen; steps += 1) {
	        const index =  (!reverse ? steps : (doubleLen - steps - 1)) % lines.length;
	        const curr = lines[index];
	        if (subSection.length === 0) {
	          if (startVertex.equals(!reverse ? curr.startVertex() : curr.endVertex())) {
	            subSection.push(!reverse ? curr : curr.negitive());
	            if (endVertex.equals(reverse ? curr.startVertex() : curr.endVertex())) {
	              completed = true;
	              break;
	            }
	          }
	        } else {
	          subSection.push(!reverse ? curr : curr.negitive());
	          if (endVertex.equals(reverse ? curr.startVertex() : curr.endVertex())) {
	            completed = true;
	            break;
	          }
	        }
	      }
	      if (completed) return subSection;
	    }
	
	    this.translate = (xDiff, yDiff) => {
	      for (let index = 0; index < lines.length; index++) {
	        lines[index].startVertex().translate(xDiff, yDiff);
	      }
	    }
	
	    this.center = (center) => {
	      const curr = Vertex2d.center(...this.vertices());
	      if (center !== undefined) {
	        const diff = center.differance(curr);
	        this.translate(diff.x(), diff.y());
	      }
	      return Vertex2d.center(...this.vertices());
	    }
	
	    this.rotate = (theta, pivot, doNotModify) => {
	      pivot ||= this.center();
	      const poly = doNotModify ? this.copy() : this;
	      if (doNotModify) return this.copy().rotate(theta, pivot);
	      for (let index = 0; index < lines.length; index++) {
	        lines[index].startVertex().rotate(theta, pivot);
	      }
	      return this;
	    }
	
	    this.centerOn = (newCenter) => {
	      if (newCenter) {
	        newCenter = new Vertex2d(newCenter);
	        const center = this.center();
	        const diff = newCenter.copy().differance(center);
	        this.translate(diff.x(), diff.y());
	      }
	    }
	
	    this.addVertices = (list) => {
	      if (list === undefined) return;
	      const verts = [];
	      const endLine = this.endLine();
	      for (let index = 0; index < list.length + 1; index += 1) {
	        if (index < list.length) verts[index] = new Vertex2d(list[index]);
	        if (index > 0) {
	          const startVertex = verts[index - 1];
	          const endVertex = verts[index] || this.startLine().startVertex();
	          const line = new Line2d(startVertex, endVertex);
	          lines.push(line);
	        }
	      }
	      if (verts.length > 0 && lines.length > 0) {
	        if (endLine) endline.endVertex(verts[0]);
	      }
	      // this.removeLoops();
	      this.lineMap(true);
	    }
	
	    this.addBest = (lineList) => {
	      if (lineList.length > 100) throw new Error('This algorythum is slow: you should either find a way to speed it up or use a different method');
	      const lastLine = lines[lines.length - 2];
	      const endVert = lastLine.endVertex();
	      lineList.sort(Line2d.distanceSort(endVert));
	      const nextLine = lineList[0].acquiescent(lastLine);
	      const connectLine = new Line2d(endVert, nextLine.startVertex());
	      endVert.translate(connectLine.run()/2, connectLine.rise()/2);
	      lines.splice(lines.length - 1, 1);
	      const newLastLine = new Line2d(endVert, nextLine.endVertex());
	      const newConnectLine = new Line2d(nextLine.endVertex(), lines[0].startVertex());
	      lines.push(newLastLine);
	      if (!newConnectLine.isPoint()) lines.push(newConnectLine);
	      lineList.splice(0,1);
	    }
	
	    this.path = (offset) => {
	      offset ||= 0;
	      let path = '';
	      const verts = this.vertices();
	      for (let index = 0; index < verts.length; index++) {
	        const i = Math.mod(index + offset, verts.length);
	        path += `${verts[i].toString()} => `
	      }
	      return path.substring(0, path.length - 4);
	    }
	
	    this.toString = this.path;
	    this.area = () => {
	      let total = 0;
	      let verts = this.vertices();
	      for (var i = 0, l = verts.length; i < l; i++) {
	        var addX = verts[i].x();
	        var addY = verts[i == verts.length - 1 ? 0 : i + 1].y();
	        var subX = verts[i == verts.length - 1 ? 0 : i + 1].x();
	        var subY = verts[i].y();
	
	        total += (addX * addY * 0.5);
	        total -= (subX * subY * 0.5);
	      }
	
	      return Math.abs(total);
	    }
	
	    this.clockWise = () => {
	      let sum = 0;
	      for (let index = 0; index < lines.length; index++) {
	        const l = lines[index];
	        sum += (l.endVertex().x() - l.startVertex().x()) * (l.endVertex().y() + l.startVertex().y());
	      }
	      return sum >= 0;
	    }
	
	    function ensure(antiClockWise) {
	      if (instance.clockWise() === !antiClockWise) return;
	      instance.reverse();
	    }
	    this.ensureClockWise = () => ensure();
	    this.ensureAntiClockWise = () => ensure(true);
	
	    this.removeLoops = () => {
	      const map = {}
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        const key = line.toString();
	        const negKey = line.toNegitiveString();
	        if (map[key]) {
	          lines.splice(map[key].index, index - map[key].index + 1);
	        } else if (map[negKey]) {
	          lines.splice(map[negKey].index, index - map[negKey].index + 1);
	        } else {
	          map[key] = {line, index};
	        }
	      }
	    }
	
	    this.copy = () => {
	      const copy = new Polygon2d(this.vertices().map((v) => v.copy()));
	      copy.faceIndecies(this.faceIndecies());
	      return copy;
	    }
	
	    this.addVertices(initialVertices);
	  }
	}
	
	Polygon2d.centerOn = (newCenter, polys) => {
	  newCenter = new Vertex2d(newCenter);
	  const center = Polygon2d.center(...polys);
	  const diff = newCenter.copy().differance(center);
	  for (let index = 0; index < polys.length; index++) {
	    const poly = polys[index];
	    poly.translate(diff.x(), diff.y());
	  }
	}
	
	Polygon2d.build = (lines) => {
	  const start = lines[0].startVertex().copy();
	  const end = lines[0].endVertex().copy();
	  lines.splice(0, 1);
	  const poly = new Polygon2d([start, end]);
	  while (lines.length > 0) {
	    poly.addBest(lines);
	  }
	  return poly;
	}
	
	Polygon2d.fromLines = (lines) => {
	  if (lines === undefined || lines.length === 0) return null;
	  let lastLine = lines[0];
	  const verts = [lastLine.startVertex()];
	  for (let index = 1; index < lines.length; index++) {
	    let line = lines[index].acquiescent(lastLine);
	    if (!line.startVertex().equals(verts[verts.length - 1])) {
	      verts.push(line.startVertex());
	    }
	    if (!line.endVertex().equals(verts[verts.length - 1])) {
	      if (index !== lines.length - 1 || !line.endVertex().equals(verts[0]))
	        verts.push(line.endVertex());
	    }
	    lastLine = line;
	  }
	  return new Polygon2d(verts);
	}
	
	Polygon2d.minMax = (...polys) => {
	  const centers = [];
	  const max = new Vertex2d(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);
	  const min = new Vertex2d(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
	  for (let index = 0; index < polys.length; index += 1) {
	    const verts = polys[index].vertices();
	    for (let vIndex = 0; vIndex < verts.length; vIndex++) {
	      const vert = verts[vIndex];
	      if (max.x() < vert.x()) max.x(vert.x());
	      if (max.y() < vert.y()) max.y(vert.y());
	      if (min.x() > vert.x()) min.x(vert.x());
	      if (min.y() > vert.y()) min.y(vert.y());
	    }
	  }
	  return {min, max};
	}
	
	Polygon2d.center = (...polys) => {
	  const minMax = Polygon2d.minMax(...polys);
	  return Vertex2d.center(minMax.min, minMax.max);
	}
	
	Polygon2d.lines = (...polys) => {
	  if (Array.isArray(polys[0])) polys = polys[0];
	  let lines = [];
	  for (let index = 0; index < polys.length; index += 1) {
	    lines = lines.concat(polys[index].lines());
	  }
	  // return lines;
	  const consolidated = Line2d.consolidate(...lines);
	  if (consolidated.length !== Line2d.consolidate(...consolidated).length) {
	    console.error.subtle('Line Consolidation malfunction');
	  }
	  return consolidated;
	}
	
	
	
	const vertRegStr = "\\(([0-9]*(\\.[0-9]*|))\\s*,\\s*([0-9]*(\\.[0-9]*|))\\)";
	const vertReg = new RegExp(vertRegStr);
	const vertRegG = new RegExp(vertRegStr, 'g');
	
	Polygon2d.fromString = (str) => {
	  const vertStrs = str.match(vertRegG);
	  const verts = vertStrs.map((str) => {
	    const match = str.match(vertReg);
	    return new Vertex2d(Number.parseFloat(match[1]), Number.parseFloat(match[3]));
	  });
	  return new Polygon2d(verts);
	}
	
	const tol = .1;
	Polygon2d.toParimeter = (lines, recurseObj) => {
	  if (lines.length < 2) throw new Error('Not enough lines to create a parimeter');
	  let lineMap, splitMap, parimeter;
	  if (recurseObj) {
	    lineMap = recurseObj.lineMap;
	    splitMap = recurseObj.splitMap;
	    parimeter = recurseObj.parimeter;
	  } else {
	    lineMap = Line2d.toleranceMap(tol, true, lines);
	    const center = Vertex2d.center(Line2d.vertices(lines));
	    const isolate = Line2d.isolateFurthestLine(center, lines);
	    splitMap = Vertex2d.toleranceMap();
	    // splitMap.add(isolate.line.startVertex());
	    parimeter = [isolate.line];
	  }
	  parimeter.slice(1).forEach((l) => {
	    if (splitMap.matches(l.startVertex()).length === 0)
	      throw new Error('wtf');
	  });
	  if (parimeter.length > lines.length) return null;
	  const sv = parimeter[0].startVertex();
	  const ev = parimeter[parimeter.length - 1].endVertex();
	  const alreadyVisitedStart = splitMap.matches(sv).length !== 0;
	  const alreadyVisitedEnd = splitMap.matches(ev).length !== 0;
	  if (alreadyVisitedEnd || alreadyVisitedStart) return null;
	  const madeItAround = parimeter.length > 1 && sv.equals(ev);
	  if (madeItAround) return Polygon2d.fromLines(parimeter);
	
	  const startLine = parimeter[0];
	  const partialParimeters = []
	  const lastLine = parimeter[parimeter.length - 1];
	  let matches = lineMap.matches(lastLine.negitive());
	  if (matches.length < 2) {
	    if (parimeter.length === 1) {
	      lines.remove(lastLine);
	      return Polygon2d.toParimeter(lines);
	    } else return null;
	  }
	    // throw new Error('A parimeter must exist between lines for function to work');
	  for (let index = 0; index < matches.length; index++) {
	    if (splitMap.matches(matches[index].endVertex()).length === 0) {
	      const newParim = Array.from(parimeter).concat(matches[index]);
	      const newSplitMap = splitMap.clone();
	      newSplitMap.add(matches[index].startVertex());
	      partialParimeters.push({parimeter: newParim, splitMap: newSplitMap, lineMap});
	    }
	  }
	
	  let biggest = null;
	  for (let index = 0; index < partialParimeters.length; index ++) {
	    const recObj = partialParimeters[index];
	    const searchResult = Polygon2d.toParimeter(lines, recObj);
	    if (biggest === null || (searchResult !== null && biggest.area() < searchResult.area()))
	      biggest = searchResult;
	  }
	  if (recurseObj === undefined)
	    biggest = biggest.clockWise() ? biggest : new Polygon2d(biggest.vertices().reverse());
	  return biggest;
	}
	
	
	new Polygon2d();
	module.exports = Polygon2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/line.js',
function (require, exports, module) {
	
const Vertex2d = require('./vertex');
	const Circle2d = require('./circle');
	const ToleranceMap = require('../../../tolerance-map.js');
	const Tolerance = require('../../../tolerance.js');
	const tol = .01;
	const withinTol = Tolerance.within(tol);
	
	class Line2d {
	  constructor(startVertex, endVertex) {
	    startVertex = new Vertex2d(startVertex);
	    endVertex = new Vertex2d(endVertex);
	    const measureTo = [];
	    const instance = this;
	    Object.getSet(this, {startVertex, endVertex});
	
	    this.startVertex = (newVertex) => {
	      if (newVertex instanceof Vertex2d) {
	        startVertex = newVertex;
	      }
	      return startVertex;
	    }
	    this.endVertex = (newVertex) => {
	      if (newVertex instanceof Vertex2d) {
	        endVertex = newVertex;
	      }
	      return endVertex;
	    }
	
	    this.mirrorPoints = (points) => {
	      for (let index = 0; index < points.length; index++) {
	        const point = points[index];
	        const perpLine = this.perpendicular(1000, point);
	        const closestPoint = this.closestPointOnLine(perpLine.endVertex());
	        const intersectLine = new Line2d(point, closestPoint);
	        const dist = intersectLine.length() * 2;
	        const rads = intersectLine.radians();
	        const mirrored = Line2d.startAndTheta(point, rads, dist).endVertex();
	        point.point(mirrored.point());
	      }
	    }
	
	    this.mirrorX = (points) => {
	      const endVertex = this.startVertex().translate(0, 10, true);
	      const mirror = new Line2d(this.startVertex(), endVertex);
	      mirror.mirrorPoints([this.startVertex(), this.endVertex()]);
	    }
	    this.mirrorY = (points) => {
	      const endVertex = this.startVertex().translate(10, 0, true);
	      const mirror = new Line2d(this.startVertex(), endVertex);
	      mirror.mirrorPoints([this.startVertex(), this.endVertex()]);
	    }
	
	    this.rise = () => endVertex.y() - startVertex.y();
	    this.run = () =>  endVertex.x() - startVertex.x();
	
	    function changeLength(value) {
	      const circle = new Circle2d(value, instance.startVertex());
	      const points = circle.intersections(instance);
	      const dist0 = instance.endVertex().distance(points[0]);
	      const dist1 = instance.endVertex().distance(points[1]);
	      if (dist1 < dist0) {
	        instance.endVertex().point(points[1]);
	      } else {
	        instance.endVertex(points[0]);
	      }
	    }
	
	    this.isVertical = () => this.slope() > 1000;
	    this.isHorizontal = () => Math.abs(this.slope()) < .001;
	
	    this.withinDirectionalBounds = (point, limit) => {
	      point = new Vertex2d(point);
	      const withinLimit = limit === undefined || (limit > point.y() && limit > point.x());
	      const rise = this.rise();
	      const run = this.run();
	      if (withinLimit && this.withinSegmentBounds(point)) return true;
	      const offsetPoint = Line2d.startAndTheta(point, this.radians(), .0000001).endVertex();
	      if (this.startVertex().distance(point) > this.startVertex().distance(offsetPoint)) return false;
	      return withinLimit;
	    }
	
	    this.withinSegmentBounds = (pointOline) => {
	      let isWithin = false;
	      let path = -1;
	      if (pointOline instanceof Line2d) {
	        const l = pointOline
	        const slopeEqual = withinTol(this.slope(), l.slope());
	        const c = l.midpoint();
	        const xBounded = c.x() < this.maxX() + tol && c.x() > this.minX() - tol;
	        const yBounded = c.y() < this.maxY() + tol && c.y() > this.minY() - tol;
	        if (slopeEqual && xBounded && yBounded) {
	          isWithin = true;
	          path = 0
	        } else {
	          path = 1;
	          isWithin = this.withinSegmentBounds(l.startVertex()) || this.withinSegmentBounds(l.endVertex()) ||
	                l.withinSegmentBounds(this.startVertex()) || l.withinSegmentBounds(this.endVertex());
	        }
	      } else {
	        path = 2;
	        let point = new Vertex2d(pointOline);
	        isWithin = this.minX() - tol < point.x() && this.minY() - tol < point.y() &&
	          this.maxX() + tol > point.x() && this.maxY() + tol > point.y();
	      }
	      if (isWithin) {
	        console.log.subtle(500, 'is it within?');
	      }
	      return isWithin;
	    }
	
	
	    function reconsileLength (newLength) {
	      const moveVertex = instance.endVertex();
	      const nextLine = moveVertex.nextLine()
	      if (nextLine === undefined) changeLength(newLength);
	
	      const vertex1 = nextLine.endVertex();
	      const circle1 = new Circle2d(nextLine.length(), vertex1);
	      const vertex2 = instance.startVertex();
	      const circle2 = new Circle2d(newLength, vertex2);
	      const intersections = circle1.intersections(circle2);
	
	      const useFirst = (intersections.length !== 0 && intersections.length === 1) ||
	                moveVertex.distance(intersections[0]) < moveVertex.distance(intersections[1]);
	      if (intersections.length === 0) {
	        changeLength(newLength);
	      } else if (useFirst) {
	        moveVertex.point(intersections[0]);
	      } else {
	        moveVertex.point(intersections[1]);
	      }
	    }
	
	    this.translate = (line) => {
	      const xOffset = line.endVertex().x() - line.startVertex().x();
	      const yOffset = line.endVertex().y() - line.startVertex().y();
	      this.startVertex().translate(xOffset, yOffset);
	      this.endVertex().translate(xOffset, yOffset);
	    }
	
	    this.length = (value) => {
	      value = Number.parseFloat(value);
	      if (!Number.isNaN(value) && value !== 0) {
	        const sv = this.startVertex();
	        const x = value * Math.cos(this.radians()) + sv.x();
	        const y = value * Math.sin(this.radians()) + sv.y();
	        this.endVertex().point({x,y});
	      }
	      const a = this.endVertex().x() - this.startVertex().x();
	      const b = this.endVertex().y() - this.startVertex().y();
	      return Math.sqrt(a*a + b*b);
	    }
	
	    function getSlope(v1, v2) {
	      return Line2d.getSlope(v1.x(), v1.y(), v2.x(), v2.y());
	    }
	
	    function getB(x, y, slope) {
	      if (slope === 0) return y;
	      else if (Math.abs(slope) === Infinity) {
	        if (instance.startVertex().x() === 0) return 0;
	        else return Infinity;
	      }
	      else return y - slope * x;
	    }
	
	    function newX(m1, m2, b1, b2) {
	      return (b2 - b1) / (m1 - m2);
	    }
	
	    function getY(x, slope, b) {return slope*x + b}
	    function getX(y, slope, b) {return  (y - b)/slope}
	
	    this.midpoint = () => {
	      const x = (this.endVertex().x() + this.startVertex().x())/2;
	      const y = (this.endVertex().y() + this.startVertex().y())/2;
	      return new Vertex2d({x,y});
	    }
	
	    this.bisector = (other, dist) => {
	      const intersection = this.findIntersection(other);
	      if (!intersection) return null;
	      const negAcquiesed = other.acquiescent(this).negitive();
	      const radians = (this.radians() + negAcquiesed.radians()) / 2;
	      const bisector = Line2d.startAndTheta(intersection, radians, dist);
	      const bev = bisector.endVertex();
	      const startDist = this.startVertex().distance(intersection);
	      const endDist = this.endVertex().distance(intersection);
	      const furthestVertId = startDist > endDist ? 'startVertex' : 'endVertex';
	
	      const negBisector = Line2d.startAndTheta(intersection, radians + Math.PI, dist);
	      const dist1 = bisector.endVertex().distance(this[furthestVertId]()) +
	                    bisector.endVertex().distance(negAcquiesed[furthestVertId]());
	      const dist2 = negBisector.endVertex().distance(this[furthestVertId]()) +
	                    negBisector.endVertex().distance(negAcquiesed[furthestVertId]());
	      return dist1 < dist2 ? bisector : negBisector;
	    }
	
	    this.closestEnds = (other) => {
	      const tsv = this.startVertex();
	      const osv = other.startVertex();
	      const tev = this.endVertex();
	      const oev = other.endVertex();
	
	      const ss = tsv.distance(osv);
	      const se = tsv.distance(oev);
	      const ee = tev.distance(oev);
	      const es = tev.distance(osv);
	
	      if (ss <= se && ss <= ee && ss <= es) return [tsv, osv];
	      if (se <= ee && se <= es) return [tsv, oev];
	      if (ee <= es) return [tev, oev];
	      else return [tev, osv]
	    }
	
	    // Always returns left side of intersection path
	    this.thetaBetween = (other) => {
	      if (!(other instanceof Line2d)) throw new Error('Cannot calculate thetaBetween if arg1 is not an instanceof Line2d');
	      let theta;
	      let theta1 = this.radians();
	      let closestEnds = this.closestEnds(other);
	      if (closestEnds.indexOf(this.startVertex()) !== -1) {
	        theta1 += Math.PI;
	      }
	      let theta2 = other.radians();
	      if (closestEnds.indexOf(other.startVertex()) !== -1) {
	        theta2 += Math.PI;
	      }
	
	      if (theta1 > theta2) {
	        theta = theta2 - theta1 + Math.PI * 2;
	      } else {
	        theta = theta2 - theta1;
	      }
	      return theta % (2 * Math.PI)
	    }
	
	    this.yIntercept = () => getB(this.startVertex().x(), this.startVertex().y(), this.slope());
	    this.slope = () => getSlope(this.startVertex(), this.endVertex());
	    this.y = (x) => {
	      if (x === undefined) x = this.startVertex().x();
	      const slope = this.slope();
	      if (slope === Infinity) return Infinity;
	      if (slope === 0) return this.startVertex().y();
	      return  (this.slope()*x + this.yIntercept());
	    }
	
	    this.x = (y) => {
	      if (y === undefined) y = this.startVertex().y();
	      const slope = this.slope();
	      if (slope === Infinity) return this.startVertex().x();
	      if (slope === 0) {
	        return Infinity;
	      }
	      return (y - this.yIntercept())/slope;
	    }
	
	    //TODO: fix!!!!
	    this.liesOn = (vertices) => {
	      const liesOn = [];
	      for (let index = 0; index < vertices.length; index += 1) {
	        const v = vertices[index];
	        const y = this.y(v.x());
	        if ((withinTol(y, v.y()) || Math.abs(y) === Infinity) && this.withinSegmentBounds(v)) {
	          liesOn.push(v);
	        }
	      }
	      liesOn.sort(Vertex2d.sort);
	      return liesOn;
	    }
	
	    this.isOn = (vertex) => {
	      const y = this.y(vertex.x());
	      return (y === vertex.y() || Math.abs(y) === Infinity) && this.withinSegmentBounds(vertex);
	    }
	
	    this.measureTo = (verts) => {
	      if (Array.isArray(verts)) {
	        verts = this.liesOn(verts);
	        measureTo.concatInPlace(verts);
	      }
	      return measureTo;
	    }
	
	    this.maxDem = () => this.y() > this.x() ? this.y() : this.x();
	    this.minDem = () => this.y() < this.x() ? this.y() : this.x();
	
	    this.closestPointOnLine = (vertex, segment) => {
	      vertex = (vertex instanceof Vertex2d) ? vertex : new Vertex2d(vertex);
	      const perpLine = this.perpendicular(undefined, vertex, true);
	      const perpSlope = perpLine.slope();
	      const slope = this.slope();
	      let x, y;
	      if (!Number.isFinite(slope)) {
	        x = this.startVertex().x();
	        y = vertex.y();
	      } else if (!Number.isFinite(perpSlope)) {
	        x = vertex.x();
	        y = this.startVertex().y();
	      } else {
	        x = newX(slope, perpSlope, this.yIntercept(), perpLine.yIntercept());
	        y = this.y(x);
	      }
	      const closestPoint = new Vertex2d({x, y});
	      if (!segment || this.withinSegmentBounds(closestPoint)) return closestPoint;
	      return false;
	    }
	
	    this.closestVertex = (vertex) => {
	      const sv = this.startVertex()
	      const ev = this.endVertex()
	      return sv.distance(vertex) < ev.distance(vertex) ? sv : ev;
	    }
	    this.furthestVertex = (vertex) => {
	      const sv = this.startVertex()
	      const ev = this.endVertex()
	      return sv.distance(vertex) > ev.distance(vertex) ? sv : ev;
	    }
	
	    const leftRightTol = .000001;
	    function rightLeftInfo(vertex) {
	      const closestPoint = instance.closestPointOnLine(vertex);
	      const perp = instance.perpendicular(vertex.distance(closestPoint)/2, closestPoint, true);
	      const distStart = vertex.distance(perp.startVertex());
	      const distEnd = vertex.distance(perp.endVertex());
	      return {distStart, distEnd, inconclusive: Math.abs(distStart - distEnd) < leftRightTol};
	    }
	    function isRight(info) {
	      return !info.inconclusive && info.distStart < info.distEnd;
	    }
	    this.isRight = (vertex) => isRight(rightLeftInfo(vertex));
	    this.isLeft = (vertex) => {
	      const info = rightLeftInfo(vertex);
	      return !info.inconclusive && info.distStart > info.distEnd;
	    }
	    this.direction = (vertOline) => {
	      if (vertOline instanceof Vertex2d) {
	        const info = rightLeftInfo(vertOline);
	        return info.inconclusive ? 'on' : (isRight(info) ? 'right' : 'left');
	      } else if (vertOline instanceof Line2d) {
	        const startDir = this.direction(vertOline.startVertex());
	        const endDir = this.direction(vertOline.endVertex());
	        if (startDir === 'on' || endDir === 'on' || startDir !== endDir) return 'across';
	        return startDir;
	      }
	    }
	
	    this.inverseX = (y) => this.slope()*y + this.yIntercept();
	    this.inverseY = (x) => (x-this.yIntercept())/this.slope();
	    this.perpendicular = (distance, vertex, center) => {
	      distance ||= this.length();
	      const rotated = this.copy().rotate(Math.PI12);
	      const mp = vertex || rotated.midpoint();
	      if (center) {
	        distance = Math.abs(distance);
	        const left = Line2d.startAndTheta(mp, rotated.negitive().radians(), distance/2);
	        const right = Line2d.startAndTheta(mp, rotated.radians(), distance/2);
	        // return new Line2d(right.endVertex(), left.endVertex());
	        return new Line2d(left.endVertex(), right.endVertex());
	        // return right.combine(left);
	      }
	      return Line2d.startAndTheta(mp, rotated.radians(), distance);
	    }
	
	    this.rotate = (radians, pivot) => {
	      pivot ||= this.midpoint();
	
	      const sv = this.startVertex();
	      const spl = new Line2d(pivot, sv);
	      const sRadOffset = radians + spl.radians();
	      const sfl = Line2d.startAndTheta(pivot, sRadOffset, spl.length());
	      sv.point(sfl.endVertex());
	
	      const ev = this.endVertex();
	      const epl = new Line2d(pivot, ev);
	      const eRadOffset = radians + epl.radians();
	      const efl = Line2d.startAndTheta(pivot, eRadOffset, epl.length());
	      ev.point(efl.endVertex());
	      return this;
	    }
	
	    this.vertical = () => this.slope() === Infinity;
	
	
	    const consideredInfinity = 1000000000;
	    const NaNfinity = (x,y) => Number.NaNfinity(x,y) ||
	                                Math.abs(x) > consideredInfinity ||
	                                Math.abs(y) > consideredInfinity;
	    this.findIntersection = (line) => {
	      if (this.slope() === 0 && line.slope() === 0) {
	        if (this.yIntercept() === line.yIntercept()) return Infinity;
	        return false;
	      }
	
	      if (this.vertical() && line.vertical()) {
	        if (this.startVertex().x() === line.startVertex().x()) return Infinity;
	        return false;
	      }
	
	      if (withinTol(line.radians(), this.radians()) &&
	              withinTol(line.yIntercept(), this.yIntercept())) {
	        return Vertex2d.center(line.startVertex(), this.startVertex(), line.endVertex(), this.endVertex());
	      }
	      const slope = this.slope();
	      const lineSlope = line.slope();
	      let x, y;
	      if (!Number.isFinite(slope)) {
	        x = this.startVertex().x();
	        y = line.y(x);
	      } else if (!Number.isFinite(lineSlope)) {
	        x = line.startVertex().x();
	        y = this.y(x);
	      } else if (slope === 0) {
	        y = this.startVertex().y();
	        x = line.x(y);
	      } else if (lineSlope === 0) {
	        y = line.startVertex().y();
	        x = this.x(y);
	      } else {
	        x = newX(slope, lineSlope, this.yIntercept(), line.yIntercept());
	        y = this.y(x);
	      }
	      if (NaNfinity(x,y)) return false;
	      if (this.toString() === '"(9, 10) => (9.000000000000005, -90)"' && this.toString() === '(20, 40) => (20, 15)') {
	        console.log('wtf');
	      }
	      // if (!Line2d.withinLineBounds(new Vertex2d(x,y), this, line)) return false;
	
	      return new Vertex2d({x,y});
	    }
	
	    this.findDirectionalIntersection = (line, limit) => {
	      const intersection = this.findIntersection(line);
	      if (intersection && this.withinDirectionalBounds(intersection, limit)) return intersection;
	      return false;
	    }
	
	    this.findSegmentIntersection = (line, both) => {
	      const intersection = this.findIntersection(line);
	      if (!intersection) return false;
	      if (!both && this.withinSegmentBounds(intersection)) {
	        return intersection;
	      }
	      if (this.withinSegmentBounds(intersection) && line.withinSegmentBounds(intersection)) {
	        return intersection;
	      }
	      return false;
	    }
	
	    this.distance = (other) => {
	      if (other instanceof Vertex2d) {
	        const point =  this.closestPointOnLine(other, true);
	        if (point) return point.distance(other);
	        const dist1 = startVertex.distance(other);
	        const dist2 = endVertex.distance(other);
	        return dist1 > dist2 ? dist2 : dist1;
	      }
	      if (other instanceof Line2d) {
	        if (this.findSegmentIntersection(other, true)) return 0;
	        const dist1 = this.distance(other.startVertex());
	        const dist2 = this.distance(other.endVertex());
	        const dist3 = other.distance(this.startVertex());
	        const dist4 = other.distance(this.endVertex());
	        return Math.min(...[dist1,dist2,dist3,dist4].filter((d) => Number.isFinite(d)));
	      }
	    }
	
	    this.minX = () => this.startVertex().x() < this.endVertex().x() ?
	                        this.startVertex().x() : this.endVertex().x();
	    this.minY = () => this.startVertex().y() < this.endVertex().y() ?
	                        this.startVertex().y() : this.endVertex().y();
	    this.maxX = () => this.startVertex().x() > this.endVertex().x() ?
	                        this.startVertex().x() : this.endVertex().x();
	    this.maxY = () => this.startVertex().y() > this.endVertex().y() ?
	                        this.startVertex().y() : this.endVertex().y();
	    this.withinLineBounds = (vertex) => {
	      if (this.slope() > consideredInfinity)
	        return vertex.x() > this.startVertex().x() - tol && vertex.x() < this.startVertex().x() + tol;
	      if (this.slope() === 0)
	        return vertex.y() > this.startVertex().y() - tol && vertex.y() < this.startVertex().y() + tol;
	      return true;
	    }
	    this.angle = () => {
	      return Math.toDegrees(this.radians());
	    }
	    this.radians = () => {
	      const deltaX = this.endVertex().x() - this.startVertex().x();
	      const deltaY = this.endVertex().y() - this.startVertex().y();
	      return Math.atan2(deltaY, deltaX);
	    }
	    this.degrees = () => Math.toDegrees(this.radians());
	
	    // Positive returns right side.
	    this.parrelle = (distance, midpoint, length) => {
	      if (distance === 0) return this.copy();
	      if ((typeof distance) !== 'number') throw new Error('distance (arg1) must be of type number && a non-zero value');
	      length ||= this.length();
	      midpoint ||= this.midpoint();
	      const perpLine = this.perpendicular(distance * 2, midpoint, true);
	      let targetPoint = perpLine.startVertex();
	      if (distance < 0) targetPoint = perpLine.endVertex();
	      const radians = this.radians();
	      const halfLine1 = Line2d.startAndTheta(targetPoint, radians, length/2);
	      const halfLine2 = Line2d.startAndTheta(targetPoint, radians, length/-2);
	      const parrelle = halfLine1.combine(halfLine2);
	      return Math.abs(parrelle.radians() - this.radians()) < Math.PI12 ? parrelle : parrelle.negitive();
	    }
	
	    this.isParrelle = (other) => {
	      const posRads = Math.mod(this.radians(), 2*Math.PI);
	      const negRads = Math.mod(this.radians() + Math.PI, 2*Math.PI);
	      const otherRads = Math.mod(other.radians(), 2*Math.PI);
	      return withinTol(posRads, otherRads) || withinTol(negRads, otherRads);
	    }
	
	    this.radianDifference = (other) => {
	      const posRads = Math.mod(this.radians(), 2*Math.PI);
	      const negRads = Math.mod(this.radians() + Math.PI, 2*Math.PI);
	      const otherRads = Math.mod(other.radians(), 2*Math.PI);
	      const positiveDiff = Math.abs(otherRads - posRads);
	      const negitiveDiff = Math.abs(otherRads - negRads);
	      return positiveDiff > negitiveDiff ? positiveDiff : negitiveDiff;
	    }
	
	    this.equals = (other) => {
	      if (!(other instanceof Line2d)) return false;
	      if (other === this) return true;
	      const forwardEq = this.startVertex().equals(other.startVertex()) && this.endVertex().equals(other.endVertex());
	      const backwardEq = this.startVertex().equals(other.endVertex()) && this.endVertex().equals(other.startVertex());
	      return forwardEq || backwardEq;
	    }
	
	
	    const withinPointTol = Tolerance.within(.1);
	    this.isPoint = () => withinPointTol(this.length(), 0);
	    this.clean = (other) => {
	      if (!(other instanceof Line2d)) return;
	      if (other.startVertex().equals(other.endVertex())) return this;
	      if (this.startVertex().equals(this.endVertex())) return other;
	      if (this.toString() === other.toString() || this.toString() === other.toNegitiveString()) return this;
	      if (this.isPoint()) return other;
	      if (other.isPoint()) return this;
	    }
	
	    this.copy = () => new Line2d(this.startVertex().copy(), this.endVertex().copy());
	
	    this.combine = (other) => {
	      if (!(other instanceof Line2d)) return;
	      const clean = this.clean(other);
	      if (clean) return clean;
	      if (!withinTol(this.slope(), other.slope())) return;
	      const otherNeg = other.negitive();
	      const outputWithinTol = withinTol(this.y(other.x()), other.y(other.x())) &&
	                    withinTol(this.x(other.y()), other.x(other.y()));
	      if (!outputWithinTol) return;
	      const v1 = this.startVertex();
	      const v2 = this.endVertex();
	      const ov1 = other.startVertex();
	      const ov2 = other.endVertex();
	      if (!this.withinSegmentBounds(other)) {
	        const dist = this.distance(other);
	        if (dist < tol) {
	          console.warn('distance is incorrect:', dist);
	          this.withinSegmentBounds(other);
	        }
	        return;
	      }
	      // Fix sort method
	      const vs = Vertex2d.sortByMax([v1, v2, ov1, ov2]);
	      const combined = new Line2d(vs[0], vs[vs.length - 1]);
	      return withinTol(this.radians(), combined.radians()) ? combined : combined.negitive();
	    }
	
	    this.isEndpoint = (vertex) => this.startVertex().equals(vertex) || this.endVertex().equals(vertex);
	    this.sortVerticies = (vertices) =>
	      vertices.sort((v1,v2) => this.startVertex().distance(v1) - this.startVertex().distance(v2))
	
	    this.slice = (lines) => {
	      if (this.isPoint()) return null;
	      const intersections = {};
	      for (let index = 0; index < lines.length; index++) {
	        if (!lines[index].equals(this)) {
	          const intersect = this.findSegmentIntersection(lines[index], true);
	          if (intersect && !this.isEndpoint(intersect)) {
	            intersections[intersect.toString()] = intersect;
	          }
	        }
	      }
	
	      const list = Object.values(intersections);
	      this.sortVerticies(list);
	      if (list.length === 0) return null;
	      const fractured = [];
	      let prevVert = this.startVertex().copy();
	      for (let index = 0; index < list.length; index++) {
	        const currVert = list[index];
	        const line = new Line2d(prevVert, currVert);
	        if (!line.isPoint()) {
	          fractured.push(line);
	          prevVert = currVert;
	        } else {
	          console.log('point?');
	        }
	      }
	      const lastLine = new Line2d(prevVert, this.endVertex().copy());
	      if (!lastLine.isPoint()) fractured.push(lastLine);
	      return fractured;
	    }
	
	    this.trimmed = (distance, both) => {
	      if ((typeof distance) !== 'number' || distance === 0) throw new Error('distance (arg1) must be of type number && a non-zero value');
	      const trimBack = distance < 0;
	      distance = Math.abs(distance);
	      const halfLen = this.length() / 2;
	      const halfNewLen = halfLen - distance;
	      const midPoint = this.midpoint();
	      const frontRads = this.radians();
	      const backRads = frontRads + Math.PI;
	      let xOffsetFront, yOffsetFront, xOffsetBack, yOffsetBack;
	      if (both) {
	        xOffsetFront = halfNewLen * Math.cos(frontRads);
	        yOffsetFront = halfNewLen * Math.sin(frontRads);
	        xOffsetBack = halfNewLen * Math.cos(backRads);
	        yOffsetBack = halfNewLen * Math.sin(backRads);
	      } else if (trimBack) {
	        xOffsetFront = halfLen * Math.cos(frontRads);
	        yOffsetFront = halfLen * Math.sin(frontRads);
	        xOffsetBack = halfNewLen * Math.cos(backRads);
	        yOffsetBack = halfNewLen * Math.sin(backRads);
	      } else {
	        xOffsetFront = halfNewLen * Math.cos(frontRads);
	        yOffsetFront = halfNewLen * Math.sin(frontRads);
	        xOffsetBack = halfLen * Math.cos(backRads);
	        yOffsetBack = halfLen * Math.sin(backRads);
	      }
	      const sv = this.startVertex();
	      const ev = this.endVertex();
	      const startVertex = {x: midPoint.x() - xOffsetBack, y: midPoint.y() - yOffsetBack};
	      const endVertex = {x: midPoint.x() - xOffsetFront, y: midPoint.y() - yOffsetFront};
	      const line = new Line2d(startVertex, endVertex);
	      return withinTol(line.radians(), this.radians()) ? line : line.negitive();
	    }
	
	    this.move = (center) => {
	      const mouseLocation = new Vertex2d(center);
	      const perpLine = this.perpendicular(undefined, mouseLocation);
	      const interX = this.findIntersection(perpLine);
	      const diffLine = new Line2d(interX, mouseLocation);
	      const rads = diffLine.radians();
	      const xDiff = Math.cos(rads);
	      const yDiff = Math.sin(rads);
	      const sv = this.startVertex();
	      const newStart = {x: sv.x() + xDiff, y: sv.y() + yDiff};
	      const ev = this.endVertex();
	      const newEnd = {x: ev.x() + xDiff, y: ev.y() + yDiff};
	      this.startVertex().point().x = newStart.x;
	      this.startVertex().point().y = newStart.y;
	      this.endVertex().point().x = newEnd.x;
	      this.endVertex().point().y = newEnd.y;
	    };
	
	    this.acquiescent = (trendSetter) => {
	      if (!(trendSetter instanceof Line2d)) return this;
	      const shouldReverse = trendSetter.endVertex().distance(this.endVertex()) <
	                            trendSetter.endVertex().distance(this.startVertex());
	      if (shouldReverse) return this.negitive();
	      return this;
	    }
	
	    this.negitive = () => new Line2d(this.endVertex(), this.startVertex());
	    this.toString = () => `${this.startVertex().toString()} => ${this.endVertex().toString()}`;
	    this.toInfoString = () => `slope: ${this.slope()}\n` +
	                        `angle: ${this.angle()}\n` +
	                        `segment: ${this.toString()}`;
	    this.toNegitiveString = () => `${this.endVertex().toString()} => ${this.startVertex().toString()}`;
	    this.approxToString = () => `${this.startVertex().approxToString()} => ${this.endVertex().approxToString()}`;
	  }
	}
	Line2d.reusable = true;
	Line2d.startAndTheta = (startVertex, theta, dist) => {
	  dist ||= 100;
	  startVertex = new Vertex2d(startVertex);
	  const end = {
	    x: startVertex.x() + dist * Math.cos(theta),
	    y: startVertex.y() +dist*Math.sin(theta)
	  };
	  return new Line2d(startVertex.point(), end);
	}
	Line2d.instance = (startV, endV, group) => {
	  const line = Lookup.instance(Line2d.name);
	  line.lookupGroup(group);
	  line.startVertex(new Vertex2d(startV)).lookupGroup(group);
	  line.endVertex(new Vertex2d(endV)).lookupGroup(group);
	  return line;
	}
	
	Line2d.trendLine = (...points) => {
	  const center = Vertex2d.center(...points);
	  let maxArr = [];
	  for (let index = 0; index < points.length; index += 1) {
	    const obj = {};
	    obj.point = new Vertex2d(points[index]);
	    obj.distance = obj.point.distance(center);
	    if (maxArr[0] === undefined || maxArr[0].distance < obj.distance) {
	      maxArr = [obj].concat(maxArr);
	    } else if (maxArr[1] === undefined || maxArr[1].distance < obj.distance) {
	      maxArr = [maxArr[0], obj].concat(maxArr);
	    }
	  }
	  const line = new Line2d(maxArr[0].point, maxArr[1].point);
	  console.log(`trendLine: ${points}\n\t${line}\n\t${center}` );
	  return line;
	}
	
	const distanceObj = (line, trendLine) => ({
	  line: line.acquiescent(trendLine),
	  distance: line.distance(vertex),
	  deltaRad: trendLine.radianDifference(line.radians())
	});
	
	Line2d.vertices = (lines) => {
	  const verts = {};
	  for (let index = 0; index < lines.length; index += 1) {
	    const line = lines[index];
	    const sv = line.startVertex();
	    const ev = line.endVertex();
	    verts[sv.id()] = sv;
	    verts[ev.id()] = ev;
	  }
	  return Object.values(verts);
	}
	
	Line2d.consolidate = (...lines) => {
	  // TODO: this should be absSlope...
	  const tolMap = new ToleranceMap({'slope': tol});
	  const lineMap = {};
	  for (let index = 0; index < lines.length; index += 1) {
	    if (!lines[index].isPoint()) {
	      if (Number.isNaN(lines[index].slope())) {
	        console.log('here');
	        lines[index].slope();
	      }
	      tolMap.add(lines[index]);
	    }
	  }
	  let minList = [];
	  const combinedKeys = {};
	  for (let index = 0; index < lines.length; index += 1) {
	    const line = lines[index];
	    const matches = tolMap.matches(line);
	    const mapId = tolMap.tolerance().boundries(line);
	    if (!combinedKeys[mapId]) {
	      combinedKeys[mapId] = true;
	      let lastIndex;
	      for (let tIndex = 0; tIndex < matches.length; tIndex += 1) {
	        let target = matches[tIndex];
	        let found = false;
	        for (let mIndex = tIndex + 1; mIndex < matches.length; mIndex += 1) {
	          const combined = target.combine(matches[mIndex]);
	          if (combined) {
	            found = true;;
	            const m = matches[mIndex];
	            matches.splice(mIndex, 1);
	            matches[tIndex] = combined;
	            target = combined;
	            mIndex = tIndex;
	          }
	        }
	        if (found) tIndex--;
	      }
	      minList = minList.concat(matches);
	    }
	  }
	
	  const strMap = {};
	  minList = minList.filter((l) => {
	    const str = l.toString();
	    if (strMap[str]) return false;
	    return strMap[str] = true;
	  });
	  return minList;
	}
	
	const within = Tolerance.within(.00001);
	Line2d.favored = (trendLine,lines) => {
	  if (lines.length < 2) return lines[0].acquiescent(trendLine);
	  const best = distanceObj(lines[0], trendLine);
	  for (let index = 1; index < lines.length; index++) {
	    const curr = distanceObj(line[index], trendLine);
	    const closer = within(curr.distance, best.distance) || curr.distance < best.distance;
	    const straighter = within(curr.deltaRad, best.deltaRad) || curr.deltaRad < best.deltaRad;
	    if (straighter && closer) best = curr;
	  }
	  return best.line;
	}
	
	Line2d.withinLineBounds = (vertex, ...lines) => {
	  for (let index = 0; index < lines.length; index++) {
	    if (!lines[index].withinLineBounds(vertex)) return false;
	  }
	  return true;
	}
	
	const distLine = (line, vertex, index) => {
	  return {line, distance: line.distance(vertex), index};
	}
	Line2d.isolateFurthestLine = (vertex, lines) => {
	  let retLines = [];
	  let max = distLine(lines[0], vertex, index);
	  for (let index = 1; index < lines.length; index++) {
	    let curr = distLine(lines[index], vertex, index);
	    if (curr.distance > max.distance) {
	      retLines = retLines.slice(0, max.index)
	                  .concat([max.line]).concat(retLines.slice(max.index));
	      max = curr;
	    } else retLines.push(curr.line);
	  }
	  return {line: max.line, lines: retLines};
	}
	
	Line2d.getSlope = function(x1, y1, x2, y2) {
	  const slope = (y2 - y1) / (x2 - x1);
	  if (Number.NaNfinity(slope) || slope > 10000 || slope < -10000) return Infinity;
	  if (slope > -0.00001 && slope < 0.00001) return 0;
	  return slope;
	}
	
	Line2d.toleranceMap = (tol, startEndBoth, lines) => {
	  tol ||= .01;
	  lines ||= [];
	  const tolAttrs = {};
	  const both = startEndBoth !== true && startEndBoth !== false;
	  if (both || startEndBoth === true) {
	    tolAttrs['startVertex.x'] = tol;
	    tolAttrs['startVertex.y'] = tol;
	  }
	  if (both || startEndBoth === false) {
	    tolAttrs['endVertex.x'] = tol;
	    tolAttrs['endVertex.y'] = tol;
	  }
	  const map = new ToleranceMap(tolAttrs);
	  for (let index = 0; index < lines.length; index++) {
	    map.add(lines[index]);
	    if (!both) map.add(lines[index].negitive());
	  }
	  return map;
	}
	
	Line2d.sliceAll = (lines) => {
	  const fractured = [];
	  for (let index = 0; index < lines.length; index++) {
	    const sliced = lines[index].slice(lines);
	    if (sliced) fractured.concatInPlace(sliced);
	    else fractured.push(lines[index]);
	  }
	  return fractured;
	}
	
	Line2d.toDrawString = (lines, ...colors) => {
	  let str = '';
	  lines.forEach((l,i) => {
	    color = colors[i%colors.length] || '';
	    str += `${color}[${l.startVertex().toString()},${l.endVertex().toString()}],`;
	  });
	  return str.substr(0, str.length - 1);
	}
	
	Line2d.toApproxDrawString = (lines, ...colors) => {
	  let str = '';
	  lines.forEach((l,i) => {
	    color = colors[i%colors.length] || '';
	    str += `${color}[${l.startVertex().approxToString()},${l.endVertex().approxToString()}],`;
	  });
	  return str.substr(0, str.length - 1);
	}
	
	Line2d.toString = (lines) => {
	  let str = '';
	  for (let index = 0; index < lines.length; index++) {
	    str += `[${lines[index].startVertex().toString()}, ${lines[index].endVertex().toString()}],`;
	  }
	  return str.substring(0, str.length - 1);
	}
	
	const pathReg = /\[.*?\]/g;
	const vertRegStr = "\\(([0-9]*(\\.[0-9]*|)),\\s*([0-9]*(\\.[0-9]*|))\\)";
	const vertReg = new RegExp(vertRegStr);
	const vertRegG = new RegExp(vertRegStr, 'g');
	
	function sectionFromString(str, lines) {
	  const vertStrs = str.match(vertRegG);
	  let prevVert;
	  const verts = vertStrs.map((str) => {
	    const match = str.match(vertReg);
	    const currVert = new Vertex2d(Number.parseFloat(match[1]), Number.parseFloat(match[3]));
	    if (prevVert) lines.push(new Line2d(prevVert, currVert));
	    prevVert = currVert;
	  });
	  return prevVert;
	}
	
	Line2d.fromString = (str) => {
	  const lines = [];
	  const sections = str.match(pathReg) || [str];
	  let prevVert;
	  for (let index = 0; index < sections.length; index++) {
	    prevVert = sectionFromString(sections[index], lines);
	  }
	  return lines;
	}
	
	Line2d.mirror = (lines) => {
	  return Vertex2d.mirror(Line2d.vertices(lines));
	}
	
	Line2d.distanceSort = (target) => (l1,l2) => {
	  const ds1 = target.distance(l1.startVertex());
	  const ds2 = target.distance(l2.startVertex());
	  const de1 = target.distance(l1.endVertex());
	  const de2 = target.distance(l2.endVertex());
	  return (ds1 < de1 ? ds1 : de1) - (ds2 < de2 ? ds2 : de2);
	}
	
	new Line2d();
	
	module.exports = Line2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/line-measurement.js',
function (require, exports, module) {
	
const Circle2d = require('circle');
	const Vertex2d = require('vertex');
	const Line2d = require('line');
	const Lookup = require('../../../object/lookup');
	const Measurement = require('../../../measurement.js');
	const approximate = require('../../../approximate.js');
	const ToleranceMap = require('../../../tolerance-map.js');
	
	class LineMeasurement2d {
	  constructor(line, center, layer, modificationFunction) {
	    const offset = 3;
	    this.line = () => line;
	
	    function modifyMeasurment(offsetLine, line, buffer, takenLocations) {
	      const startLength = line.startLine.length();
	      line.startLine.length(startLength + buffer);
	      line.endLine.length(startLength + buffer);
	      line.translate(offsetLine);
	      let notTaken = true;
	      const point = line.midpoint();
	      for (let index = 0; index < takenLocations.length; index++) {
	        const locationInfo = takenLocations[index];
	        const takenPoint = locationInfo.point;
	        const biggestBuffer = locationInfo.buffer < buffer ? locationInfo.buffer : buffer;
	        if (takenPoint.distance(point) < biggestBuffer) {
	          if (takenPoint.length === length) return;
	          notTaken = false;
	        }
	      }
	      return notTaken === true ? point : undefined;
	    }
	
	    function notTaken(obj) {
	      return (buffer) => {
	        buffer ||= 7.5;
	        const closer = obj.closerLine();
	        const further = obj.furtherLine();
	        const cStartL = further.startLine
	        const cEndL = further.endLine
	        const offsetLine = cStartL.copy();
	        offsetLine.length(buffer);
	        const length = approximate(further.length());
	        do {
	          const point = modifyMeasurment(offsetLine, further, buffer, obj.takenLocations);
	          if (point) {
	            obj.takenLocations.push({point, buffer, length});
	            return further;
	          }
	        } while (buffer < 1000);
	      }
	    }
	    this.I = (l, takenLocations) => {
	      takenLocations ||= [];
	      l = l || layer || 1;
	      const termDist = (l + 1) * offset;
	      const measureDist = l * offset;
	      const startLine = line.perpendicular(termDist * 2, line.startVertex(), true);
	      const endLine = line.perpendicular(termDist * 2, line.endVertex(), true);
	      const startCircle = new Circle2d(measureDist, line.startVertex());
	      const endCircle = new Circle2d(measureDist, line.endVertex());
	      const startTerminationCircle = new Circle2d(termDist - 2.5, line.startVertex());
	      const endTerminationCircle = new Circle2d(termDist - 2.5, line.endVertex());
	      const startVertices = startCircle.intersections(startLine);
	      const endVertices = endCircle.intersections(endLine);
	      let l1, l2;
	      if (startVertices.length > 0 && endVertices.length > 0) {
	        const startTerminationVertices = startTerminationCircle.intersections(startLine);
	        const endTerminationVertices = endTerminationCircle.intersections(endLine);
	        let startTerminationLine, endTerminationLine, measurementLine;
	
	        l1 = new Line2d(startVertices[1], endVertices[1]);
	        l1.startLine = new Line2d(line.startVertex(), startTerminationVertices[1]);
	        l1.endLine = new Line2d(line.endVertex(), endTerminationVertices[1]);
	
	        l2 = new Line2d(startVertices[0], endVertices[0]);
	        l2.startLine = new Line2d(line.startVertex(), startTerminationVertices[0]);
	        l2.endLine = new Line2d(line.endVertex(), endTerminationVertices[0]);
	        const furtherLine = (point) => LineMeasurement2d.furtherLine(l1, l2, point || center);
	        const closerLine = (point) => LineMeasurement2d.furtherLine(l1, l2, point || center, true);
	        const obj = {furtherLine, closerLine, takenLocations};
	        obj.midpointClear = notTaken(obj);
	        return obj;
	      } else {
	        throw new Error('No Intersection???');
	        return {};
	      }
	    }
	
	    this.copy = (modFunc) => new LineMeasurement2d(line, modFunc);
	    this.modificationFunction = (func) => {
	      if ((typeof func) === 'function') {
	        if ((typeof this.id) !== 'function') Lookup.convert(this);
	        modificationFunction = func;
	      }
	      return modificationFunction;
	    }
	
	    this.toString = () => `|--${this.line()}--|`;
	    this.display = () => new Measurement(line.length()).display();
	
	    this.modify = (value) => modificationFunction(new Measurement(value, true).decimal());
	
	    this.modificationFunction(modificationFunction);
	  }
	}
	
	function measurementLevel(line) {
	  if ((typeof line.length) !== 'function')
	    console.log(line);
	
	  return Math.log(line.length()*line.length())*2;
	}
	
	const lengthSortFunc = (center) => (l1, l2) => {
	  const lengthDiff = l1.length() - l2.length();
	  if (lengthDiff !== 0)
	    return lengthDiff;
	  return center.distance(l2.midpoint()) - center.distance(l1.midpoint());
	}
	LineMeasurement2d.measurements = (lines) => {
	  const verts = Line2d.vertices(lines);
	  const center = Vertex2d.center(...verts);
	  lines.sort(lengthSortFunc(center));
	  // lines.sort(lengthSortFunc(center));
	  const measurements = [];
	  const lengthMap = new ToleranceMap({length: .00001});
	  for (let tIndex = 0; tIndex < lines.length; tIndex += 1) {
	    const tarVerts = lines[tIndex].liesOn(verts);
	    if (tarVerts.length > 2) {
	      for (let index = 1; index < tarVerts.length; index += 1) {
	        const sv = tarVerts[index - 1];
	        const ev = tarVerts[index];
	        const line = new Line2d(sv,ev);
	        lengthMap.add(line);
	      }
	    }
	    if (tarVerts.length > 1) {
	      const sv = tarVerts[0];
	      const ev = tarVerts[tarVerts.length - 1];
	      const line = new Line2d(sv,ev);
	      lengthMap.add(line);
	    }
	  }
	
	
	  const lengths = Object.keys(lengthMap.map());
	  const slopeMap = new ToleranceMap({length: .00001, slope: .1});
	  for (index = 0; index < lengths.length; index += 1) {
	    let lines = lengthMap.map()[lengths[index]];
	    //TODO: possibly restrict the measurements that display....
	    for(let li = 0; li < lines.length; li++) {
	      const line = lines[li];
	      const perpLine = line.perpendicular();
	      if (slopeMap.matches(perpLine).length === 0) {
	        slopeMap.add(perpLine);
	      } else {
	        lines.splice(li, 1);
	        li--;
	      }
	    }
	    measurements.concatInPlace(lines);
	  }
	
	  for (let index = 0; index < measurements.length; index++)
	    if (approximate.abs(measurements[index].length()) !== 0)
	      measurements[index] = new LineMeasurement2d(measurements[index], center, measurementLevel(measurements[index]));
	    else
	      measurements.splice(index--, 1);
	
	  return measurements;
	}
	
	LineMeasurement2d.furtherLine = (l1, l2, point, closer) =>
	    point === undefined ? (closer ? l1 : l2) :
	    (l1.midpoint().distance(point) > l2.midpoint().distance(point) ?
	      (closer ? l2 : l1) :
	      (closer ? l1 : l2));
	
	module.exports = LineMeasurement2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/corner.js',
function (require, exports, module) {
	//
	// const Vertex2d = require('vertex');
	//
	// class Corner {
	//   constructor(center, height, width, radians) {
	//     width = width === undefined ? 121.92 : width;
	//     height = height === undefined ? 60.96 : height;
	//     radians = radians === undefined ? 0 : radians;
	//     const instance = this;
	//     Object.getSet(this, {center: new Vertex2d(center), height, width, radians});
	//     if ((typeof center) === 'function') this.center = center;
	//     const startPoint = new Vertex2d(null);
	//
	//     const getterHeight = this.height;
	//     this.height = (v) => {
	//       notify(getterHeight(), v);
	//       return getterHeight(v);
	//     }
	//     const getterWidth = this.width;
	//     this.width = (v) => notify(getterWidth(), v) || getterWidth(v);
	//
	//     const changeFuncs = [];
	//     this.onChange = (func) => {
	//       if ((typeof func) === 'function') {
	//         changeFuncs.push(func);
	//       }
	//     }
	//
	//     let lastNotificationId = 0;
	//     function notify(currentValue, newValue) {
	//       if (changeFuncs.length === 0 || (typeof newValue) !== 'number') return;
	//       if (newValue !== currentValue) {
	//         const id = ++lastNotificationId;
	//         setTimeout(() => {
	//           if (id === lastNotificationId)
	//             for (let i = 0; i < changeFuncs.length; i++) changeFuncs[i](instance);
	//         }, 100);
	//       }
	//     }
	//
	//     this.radians = (newValue) => {
	//       if (newValue !== undefined && !Number.isNaN(Number.parseFloat(newValue))) {
	//         notify(radians, newValue);
	//         radians = newValue;
	//       }
	//       return radians;
	//     };
	//     this.startPoint = () => {
	//       startPoint.point({x: this.center().x() - width / 2, y: this.center().y() - height / 2});
	//       return startPoint;
	//     }
	//     this.angle = (value) => {
	//       if (value !== undefined) this.radians(Math.toRadians(value));
	//       return Math.toDegrees(this.radians());
	//     }
	//
	//     // this.x = (val) => notify(this.center().x(), val) || this.center().x(val);
	//     // this.y = (val) => notify(this.center().y(), val) || this.center().y(val);
	//     this.x = (val) => {
	//       if (val !== undefined) this.center().x(val);
	//       return this.center().x();
	//     }
	//     this.y = (val) => {
	//       if (val !== undefined) this.center().y(val);
	//       return this.center().y();
	//     }
	//     this.minDem = () => this.width() > this.height() ? this.width() : this.height();
	//     this.maxDem = () => this.width() > this.height() ? this.width() : this.height();
	//
	//     this.shorterSideLength = () => this.height() < this.width() ? this.height() : this.width();
	//     this.move = (position, theta) => {
	//       const center = position.center instanceof Vertex2d ? position.center.point() : position.center;
	//       if (position.maxX !== undefined) center.x = position.maxX - this.offsetX();
	//       if (position.maxY !== undefined) center.y = position.maxY - this.offsetY();
	//       if (position.minX !== undefined) center.x = position.minX + this.offsetX();
	//       if (position.minY !== undefined) center.y = position.minY + this.offsetY();
	//       this.radians(position.theta);
	//       this.center().point(center);
	//       return true;
	//     };
	//
	//     function centerMethod(widthMultiplier, heightMultiplier, position) {
	//       const center = instance.center();
	//       const rads = instance.radians();
	//       const offsetX = instance.width() * widthMultiplier * Math.cos(rads) -
	//                         instance.height() * heightMultiplier * Math.sin(rads);
	//       const offsetY = instance.height() * heightMultiplier * Math.cos(rads) +
	//                         instance.width() * widthMultiplier * Math.sin(rads);
	//
	//       if (position !== undefined) {
	//         const posCenter = new Vertex2d(position.center);
	//         return new Vertex2d({x: posCenter.x() + offsetX, y: posCenter.y() + offsetY});
	//       }
	//       const backLeftLocation = {
	//             x: instance.center().x() - offsetX ,
	//             y: instance.center().y() - offsetY
	//       };
	//       return new Vertex2d(backLeftLocation);
	//     }
	//
	//
	//     this.frontCenter = (position) => centerMethod(0, -.5, position);
	//     this.backCenter = (position) => centerMethod(0, .5, position);
	//     this.leftCenter = (position) => centerMethod(.5, 0, position);
	//     this.rightCenter = (position) => centerMethod(-.5, 0, position);
	//
	//     this.backLeft = (position) => centerMethod(.5, .5, position);
	//     this.backRight = (position) => centerMethod(-.5, .5, position);
	//     this.frontLeft = (position) =>  centerMethod(.5, -.5, position);
	//     this.frontRight = (position) => centerMethod(-.5, -.5, position);
	//
	//     this.offsetX = (negitive) => negitive ? this.width() / -2 : this.width() / 2;
	//     this.offsetY = (negitive) => negitive ? this.height() / -2 : this.height() / 2;
	//
	//     this.toString = () => `[${this.frontLeft()} - ${this.frontRight()}]\n[${this.backLeft()} - ${this.backRight()}]`
	//   }
	// }
	//
	// new Square2d();
	//
	// module.exports = Square2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/circle.js',
function (require, exports, module) {
	
const Vertex2d = require('./vertex');
	
	class Circle2d {
	  constructor(radius, center) {
	    center = new Vertex2d(center);
	    Object.getSet(this, {radius, center});
	    // ( x - h )^2 + ( y - k )^2 = r^2
	    const instance = this;
	    // Stole the root code from: https://stackoverflow.com/a/37225895
	    function lineIntersects (line, bounded) {
	      const p1 = line.startVertex();
	      const p2 = line.endVertex();
	        var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
	        v1 = {};
	        v2 = {};
	        v1.x = p2.x() - p1.x();
	        v1.y = p2.y() - p1.y();
	        v2.x = p1.x() - instance.center().x();
	        v2.y = p1.y() - instance.center().y();
	        b = (v1.x * v2.x + v1.y * v2.y);
	        c = 2 * (v1.x * v1.x + v1.y * v1.y);
	        b *= -2;
	        d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - instance.radius() * instance.radius()));
	        if(isNaN(d)){ // no intercept
	            return [];
	        }
	        u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line
	        u2 = (b + d) / c;
	        retP1 = {};   // return points
	        retP2 = {}
	        ret = []; // return array
	        if(!bounded || (u1 <= 1 && u1 >= 0)){  // add point if on the line segment
	            retP1.x = p1.x() + v1.x * u1;
	            retP1.y = p1.y() + v1.y * u1;
	            ret[0] = retP1;
	        }
	        if(!bounded || (u2 <= 1 && u2 >= 0)){  // second add point if on the line segment
	            retP2.x = p1.x() + v1.x * u2;
	            retP2.y = p1.y() + v1.y * u2;
	            ret[ret.length] = retP2;
	        }
	        return ret;
	    }
	
	    function circleIntersects(circle) {
	      return Circle2d.intersectionOfTwo(instance, circle);
	    }
	
	    this.toString = () => `(${this.radius()}${this.center()}----)`;
	
	    this.intersections = (input) => {
	      if (input === undefined)
	        console.log('here');
	      if (input instanceof Circle2d) return circleIntersects(input);
	      if (input.constructor.name === 'Line2d') return lineIntersects(input);
	      throw new Error(`Cannot find intersections for ${input.constructor.name}`);
	    }
	  }
	}
	
	// Ripped off from: https://stackoverflow.com/a/12221389
	Circle2d.intersectionOfTwo = (circle0, circle1) => {
	    const x0 = circle0.center().x();
	    const y0 = circle0.center().y();
	    const r0 = circle0.radius();
	
	    const x1 = circle1.center().x();
	    const y1 = circle1.center().y();
	    const r1 = circle1.radius();
	    var a, dx, dy, d, h, rx, ry;
	    var x2, y2;
	
	    /* dx and dy are the vertical and horizontal distances between
	     * the circle centers.
	     */
	    dx = x1 - x0;
	    dy = y1 - y0;
	
	    /* Determine the straight-line distance between the centers. */
	    d = Math.sqrt((dy*dy) + (dx*dx));
	
	    /* Check for solvability. */
	    if (d > (r0 + r1)) {
	        /* no solution. circles do not intersect. */
	        return [];
	    }
	    if (d < Math.abs(r0 - r1)) {
	        /* no solution. one circle is contained in the other */
	        return [];
	    }
	
	    /* 'point 2' is the point where the line through the circle
	     * intersection points crosses the line between the circle
	     * centers.
	     */
	
	    /* Determine the distance from point 0 to point 2. */
	    a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;
	
	    /* Determine the coordinates of point 2. */
	    x2 = x0 + (dx * a/d);
	    y2 = y0 + (dy * a/d);
	
	    /* Determine the distance from point 2 to either of the
	     * intersection points.
	     */
	    h = Math.sqrt((r0*r0) - (a*a));
	
	    /* Now determine the offsets of the intersection points from
	     * point 2.
	     */
	    rx = -dy * (h/d);
	    ry = dx * (h/d);
	
	    /* Determine the absolute intersection points. */
	    var xi = x2 + rx;
	    var xi_prime = x2 - rx;
	    var yi = y2 + ry;
	    var yi_prime = y2 - ry;
	
	    const list = [];
	    return [{x: xi, y: yi}, {x: xi_prime, y: yi_prime}];
	}
	
	Circle2d.reusable = true;
	Circle2d.instance = (radius, center) => {
	  const inst = Lookup.instance(Circle2d.name);
	  inst.radius(radius);
	  inst.center(center);
	  return inst;
	}
	new Circle2d();
	
	module.exports = Circle2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/three-view.js',
function (require, exports, module) {
	
const Polygon3D = require('../../../../../../services/cabinet/app-src/three-d/objects/polygon.js');
	const Vector3D = require('../../../../../../services/cabinet/app-src/three-d/objects/vector.js');
	const EscapeMap = require('../maps/escape.js');
	const Polygon2d = require('../objects/polygon');
	const Line2d = require('../objects/line');
	const Vertex2d = require('../objects/vertex');
	
	const defaultNormals = {front: new Vector3D(0,0,-1), right: new Vector3D(-1,0,0), top: new Vector3D(0,-1,0)};
	
	class ThreeView {
	  constructor(polygons, normals, gap) {
	    normals ||= defaultNormals;
	    gap ||= 10;
	
	    this.normals = {};
	    this.normals.front = () => normals.front;
	    this.normals.right = () => normals.right;
	    this.normals.top = () => normals.top;
	
	    const frontView = Polygon3D.viewFromVector(polygons, normals.front);
	    const rightView = Polygon3D.viewFromVector(polygons, normals.right);
	    const topview = Polygon3D.viewFromVector(polygons, normals.top);
	
	    const axis = {};
	    axis.front = Polygon3D.mostInformation(frontView);
	    axis.right = Polygon3D.mostInformation(rightView);
	    axis.top = Polygon3D.mostInformation(topview);
	
	    // Orient properly
	    if (axis.front.indexOf('y') === 0) axis.front.reverse();
	    if (axis.top.indexOf(axis.front[0]) !== 0) axis.top.reverse();
	    if (axis.right.indexOf(axis.front[1]) !== 1) axis.right.reverse();
	
	    const to2D = (mi) => (p) => p.to2D(mi[0],mi[1]);
	    const front2D = frontView.map(to2D(axis.front));
	    const right2D = rightView.map(to2D(axis.right));
	    const top2D = topview.map(to2D(axis.top));
	
	    console.log(Line2d.toDrawString(Polygon2d.lines(top2D)))
	
	    Polygon2d.centerOn({x:0,y:0}, front2D);
	
	    const frontMinMax = Polygon2d.minMax(...front2D);
	    const rightMinMax = Polygon2d.minMax(...right2D);
	    const topMinMax = Polygon2d.minMax(...top2D);
	    const rightCenterOffset = frontMinMax.max.x() + gap + (rightMinMax.max.x() - rightMinMax.min.x())/2;
	    const topCenterOffset = frontMinMax.max.y() + gap + (topMinMax.max.y() - topMinMax.min.y())/2;
	
	    Polygon2d.centerOn({x:rightCenterOffset, y:0}, right2D);
	    Polygon2d.centerOn({x:0,y:topCenterOffset}, top2D);
	
	    const front = Polygon2d.lines(front2D);
	    const right = Polygon2d.lines(right2D);
	    const top = Polygon2d.lines(top2D);
	    // Line2d.mirror(top);
	    Vertex2d.scale(1, -1, Line2d.vertices(top));
	
	    let parimeter;
	    this.parimeter = () => {
	      if (!parimeter) {
	        parimeter = {};
	        parimeter.front = EscapeMap.parimeter(this.front());
	        parimeter.right = EscapeMap.parimeter(this.right());
	        parimeter.top = EscapeMap.parimeter(this.top());
	        parimeter.front.ensureClockWise();
	        parimeter.right.ensureClockWise();
	        parimeter.top.ensureClockWise();
	
	      }
	      return {
	        front: () => parimeter.front.copy(),
	        right: () => parimeter.right.copy(),
	        top: () => parimeter.top.copy(),
	        allLines: () => parimeter.front.lines().concat(parimeter.right.lines().concat(parimeter.top.lines()))
	      };
	    }
	
	    this.axis = () => axis;
	    this.front = () => front;
	    this.right = () => right;
	    this.top = () => top;
	    this.toDrawString = () => {
	      let str = '';
	      str += '//Front\n' + Line2d.toDrawString(front);
	      str += '\n//Right\n' + Line2d.toDrawString(right);
	      str += '\n//Top\n' + Line2d.toDrawString(top);
	      return str;
	    }
	  }
	}
	
	module.exports = ThreeView;
	
});


RequireJS.addFunction('./public/js/utils/input/styles/select/relation.js',
function (require, exports, module) {
	

	
	const StringMathEvaluator = require('../../../string-math-evaluator.js');
	const Select = require('../select.js');
	
	class RelationInput {
	  constructor(name, searchFunc) {
	    if (RelationInput.relationsObjs[name] !== undefined) throw new Error('Relation Inputs must have a unique name.');
	    this.eval = function(list, value) {
	      let minDiff = Number.MAX_SAFE_INTEGER;
	      let winner;
	
	      if (!Array.isArray(list)) return undefined;
	      for(let index = 0; index < list.length; index += 1) {
	        const evalVal = this.constructor.evaluator.eval(list[index]);
	        const diff =  searchFunc(value, evalVal);
	        if (diff >= 0 && diff < minDiff) {
	          minDiff = diff;
	          winner = index;
	        }
	      }
	      return winner;
	    };
	    RelationInput.relationsObjs[RelationInput.toPascalCase(name)] = this;
	    RelationInput.relations.push(name);
	    RelationInput.relations
	        .sort((a, b) => a.length > b.length ? 1 : -1);
	  }
	}
	
	RelationInput.relationsObjs = {};
	RelationInput.relations = [];
	RelationInput.toPascalCase = (str) => new String(str).replace(/ /g, '_').toUpperCase();
	
	RelationInput.evaluator = new StringMathEvaluator(Math);
	RelationInput.eval = (name, list, value) => {
	  const relation = RelationInput.relationsObjs[RelationInput.toPascalCase(name)];
	  return relation ? relation.eval(list, value) : undefined;
	}
	
	new RelationInput('Equal', (a, b) => a !== b ? -1 : 0);
	new RelationInput('Greater Than', (a, b) => a >= b ? -1 : b - a);
	new RelationInput('Greater Than Or Equal', (a, b) => a > b ? -1 : b - a);
	new RelationInput('Less Than', (a, b) => a <= b ? -1 : a - b);
	new RelationInput('Less Than Or Equal', (a, b) => a < b ? -1 : a - b);
	
	RelationInput.selector = new Select({name: 'relation',
	                            value: 'Equal',
	                            list: RelationInput.relations,
	                            label: 'Auto Select Relation'});
	
	module.exports = RelationInput;
	
	
	
	
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/square.js',
function (require, exports, module) {
	
const Vertex2d = require('vertex');
	
	class Square2d {
	  constructor(center, height, width, radians) {
	    width = width === undefined ? 121.92 : width;
	    height = height === undefined ? 60.96 : height;
	    radians = radians === undefined ? 0 : radians;
	    const id = String.random();
	    const instance = this;
	    Object.getSet(this, {center: new Vertex2d(center), height, width, radians});
	    if ((typeof center) === 'function') this.center = center;
	    const startPoint = new Vertex2d(null);
	
	
	    this.radians = (newValue) => {
	      if (newValue !== undefined && !Number.isNaN(Number.parseFloat(newValue))) {
	        radians = newValue;
	      }
	      return radians;
	    };
	    this.startPoint = () => {
	      startPoint.point({x: this.center().x() - width / 2, y: this.center().y() - height / 2});
	      return startPoint;
	    }
	    this.angle = (value) => {
	      if (value !== undefined) this.radians(Math.toRadians(value));
	      return Math.toDegrees(this.radians());
	    }
	
	    this.x = (val) => {
	      if (val !== undefined) this.center().x(val);
	      return this.center().x();
	    }
	    this.y = (val) => {
	      if (val !== undefined) this.center().y(val);
	      return this.center().y();
	    }
	    this.minDem = () => this.width() > this.height() ? this.width() : this.height();
	    this.maxDem = () => this.width() > this.height() ? this.width() : this.height();
	
	    this.shorterSideLength = () => this.height() < this.width() ? this.height() : this.width();
	    this.move = (position) => {
	      const center = position.center instanceof Vertex2d ? position.center.point() : position.center;
	      if (position.maxX !== undefined) center.x = position.maxX - this.offsetX();
	      if (position.maxY !== undefined) center.y = position.maxY - this.offsetY();
	      if (position.minX !== undefined) center.x = position.minX + this.offsetX();
	      if (position.minY !== undefined) center.y = position.minY + this.offsetY();
	      this.radians(position.theta);
	      this.center().point(center);
	      return true;
	    };
	
	    this.offsetX = (negitive) => negitive ? this.width() / -2 : this.width() / 2;
	    this.offsetY = (negitive) => negitive ? this.height() / -2 : this.height() / 2;
	
	    this.toString = () => `Square2d(${id}): ${this.width()} X ${this.height()}] @ ${this.center()}`
	  }
	}
	
	new Square2d();
	
	module.exports = Square2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/snap.js',
function (require, exports, module) {
	
const Vertex2d = require('vertex');
	const Line2d = require('line');
	const SnapLocation2d = require('snap-location');
	const HoverObject2d = require('../hover-map').HoverObject2d;
	const Tolerance = require('../../../tolerance.js');
	const Lookup = require('../../../object/lookup.js');
	const withinTol = Tolerance.within(.1);
	
	class Snap2d extends Lookup {
	  constructor(parent, object, tolerance) {
	    super();
	    name = 'booyacka';
	    Object.getSet(this, {object, tolerance}, 'layoutId');
	    if (parent === undefined) return;
	    const instance = this;
	    const id = String.random();
	    let start = new Vertex2d();
	    let end = new Vertex2d();
	    let layout = parent.layout();
	
	    this.dl = () => 24 * 2.54;
	    this.dr = () => 24 * 2.54;
	    this.dol = () => 12;
	    this.dor = () => 12;
	    this.toString = () => `SNAP ${this.id()}(${tolerance}):${this.object()}`
	    this.position = {};
	    this.id = () => id;
	    this.parent = () => parent;
	    this.x = parent.x;
	    this.y = parent.y;
	    this.width = parent.width;
	    this.height = parent.height;
	    this.center = parent.center;
	    this.angle = parent.angle;
	    this.rotate = parent.rotate;
	
	    this.radians = (newValue) => {
	      if (newValue !== undefined ) {
	        const constraint = this.constraint();
	        if (constraint === 'fixed') return;
	        const radians = parent.radians();
	        const snapAnchor = constraint.snapLoc;
	        const originalPosition = snapAnchor && snapAnchor.center();
	        const radianDifference = newValue - radians;
	        if (newValue !== parent.radians())
	          console.log('rads', Math.toRadians(newValue), '=>', parent.radians())
	        this.parent().rotate(radianDifference);
	        // notify(radians, newValue);
	        if (snapAnchor) this.parent.center(snapAnchor.at({center: originalPosition}));
	
	      }
	      return parent.radians();
	    };
	
	    const changeFuncs = [];
	    this.onChange = (func) => {
	      if ((typeof func) === 'function') {
	        changeFuncs.push(func);
	      }
	    }
	
	    let lastNotificationId = 0;
	    function notify(currentValue, newValue) {
	      if (changeFuncs.length === 0 || (typeof newValue) !== 'number') return;
	      if (newValue !== currentValue) {
	        const id = ++lastNotificationId;
	        setTimeout(() => {
	          if (id === lastNotificationId)
	            for (let i = 0; i < changeFuncs.length; i++) changeFuncs[i](instance);
	        }, 100);
	      }
	    }
	
	    // this.minDem = () => this.width() > this.height() ? this.width() : this.height();
	    // this.maxDem = () => this.width() > this.height() ? this.width() : this.height();
	
	    this.view = () => {
	      switch (this) {
	        case parent.topview(): return 'topview';
	        case parent.bottomview(): return 'bottomview';
	        case parent.leftview(): return 'leftview';
	        case parent.rightview(): return 'rightview';
	        case parent.frontview(): return 'frontview';
	        case parent.backview(): return 'backview';
	        default: return null;
	      }
	    }
	
	    this.forEachConnectedObject = (func, objMap) => {
	      objMap = objMap || {};
	      objMap[this.id()] = this;
	      const locs = this.snapLocations.paired();
	      for (let index = 0; index < locs.length; index += 1) {
	        const loc = locs[index];
	        const connSnap = loc.pairedWith();
	        if (connSnap instanceof SnapLocation2d) {
	          const connObj = connSnap.parent();
	          if (connObj && objMap[connOb.id()] === undefined) {
	            objMap[connObj.id()] = connObj;
	            connSnap.parent().forEachConnectedObject(undefined, objMap);
	          }
	        }
	      }
	      if ((typeof func) === 'function') {
	        const objs = Object.values(objMap);
	        for (let index = 0; index < objs.length; index += 1) {
	          func(objs[index]);
	        }
	      } else return objMap;
	    };
	
	    this.forEachConnectedSnap = (func, pairedMap) => {
	      pairedMap ||= {};
	      const locs = this.snapLocations.paired();
	      for (let index = 0; index < locs.length; index += 1) {
	        const loc = locs[index];
	        pairedMap[loc.toString()]  = loc;
	        const connSnap = loc.pairedWith();
	        if (connSnap instanceof SnapLocation2d) {
	          const snapStr = connSnap.toString();
	          if (pairedMap[snapStr] === undefined) {
	            pairedMap[snapStr] = connSnap;
	            connSnap.parent().forEachConnectedSnap(undefined, pairedMap);
	          }
	        }
	      }
	
	      if ((typeof func) === 'function') {
	        const snaps = Object.values(pairedMap);
	        for (let index = 0; index < snaps.length; index += 1) {
	          func(snaps[index]);
	        }
	      } else return pairedMap;
	    }
	
	    this.constraints = () => {
	      let constraints = [];
	      this.forEachConnectedSnap((snapLoc) => {
	        const possible = snapLoc.pairedWith();
	        if (!(possible instanceof SnapLocation2d)) constraints.push(snapLoc);
	      });
	      return constraints;
	    };
	
	    this.constraint = () => {
	      let constraints = this.constraints();
	      if (constraints.length === 0) return 'free';
	      const wallMap = {};
	      let anchor;
	      for (let index = 0; index < constraints.length; index++) {
	        const snapLoc = constraints[index];
	        const constraint = snapLoc.pairedWith();
	        if (constraint instanceof Line2d && !wallMap[constraint.toString()]) {
	          wallMap[constraint.toString()] = {wall: constraint, snapLoc};
	          if (Object.keys(wallMap).length === 2 || anchor) return 'fixed';
	        } else if (constraint instanceof Vertex2d) {
	          if (anchor || Object.keys(wallMap).length === 1) return 'fixed';
	          anchor = {vertex: constraint, snapLoc};
	        }
	      }
	      if (anchor) return anchor;
	      const walls = Object.values(wallMap);
	      return walls.length === 1 ? walls[0] : 'free';
	    }
	
	    const snapLocations = [];
	    this.addLocation = (snapLoc) => {
	      if (snapLoc instanceof SnapLocation2d && this.position[snapLoc.location()] === undefined) {
	        const index = snapLocations.length;
	        snapLocations.push(snapLoc);
	        snapLoc.prev = () => snapLocations[Math.mod(index - 1, snapLocations.length)];
	        snapLoc.next = () => snapLocations[Math.mod(index + 1, snapLocations.length)];
	        this.position[snapLoc.location()] = snapLoc.at;
	      }
	    }
	    function getSnapLocations(func) {
	      const locs = [];
	      for (let index = 0; index < snapLocations.length; index += 1) {
	        const loc = snapLocations[index];
	        if ((typeof func) === 'function') {
	          if (func(loc)) locs.push(loc);
	        } else locs.push(loc);
	      }
	      return locs;
	    }
	
	    const backReg = /^back[0-9]{1,}$/;
	    const rightCenterReg = /^right[0-9]{1,}center$/;
	    const leftCenterReg = /^left[0-9]{1,}center$/;
	    const backCenterReg = /^back[0-9]{1,}center$/;
	    const centerReg = /^[a-z]{1,}[0-9]{1,}center$/;
	    this.snapLocations = getSnapLocations;
	    this.snapLocations.notPaired = () => getSnapLocations((loc) => loc.pairedWith() === null);
	    this.snapLocations.paired = () => getSnapLocations((loc) => loc.pairedWith() !== null);
	    this.snapLocations.wallPairable = () => getSnapLocations((loc) => loc.location().match(backReg));
	    this.snapLocations.rightCenter = () => getSnapLocations((loc) => loc.location().match(rightCenterReg));
	    this.snapLocations.leftCenter = () => getSnapLocations((loc) => loc.location().match(leftCenterReg));
	    this.snapLocations.backCenter = () => getSnapLocations((loc) => loc.location().match(backCenterReg));
	    this.snapLocations.center = () => getSnapLocations((loc) => loc.location().match(centerReg));
	    this.snapLocations.byLocation = (name) => getSnapLocations((loc) => loc.location() === name);
	    this.snapLocations.at = (vertex) => {
	      for (let index = 0; index < snapLocations.length; index++)
	        if (snapLocations[index].center().equals(vertex)) return snapLocations[index];
	      return null;
	    }
	    this.snapLocations.resetCourting = () => {
	      for (let index = 0; index < snapLocations.length; index++) {
	        if (snapLocations[index] instanceof SnapLocation2d)
	          snapLocations[index].courting(null);
	      }
	    }
	
	    this.connected = () => this.snapLocations.paired().length > 0;
	
	    // this.snapLocations.rotate = backCenter.rotate;
	    function resetVertices() {
	      for (let index = 0; index < snapLocations.length; index += 1) {
	        const snapLoc = snapLocations[index];
	        instance.position[snapLoc.location()]();
	      }
	    }
	
	    this.maxRadius = () => {
	      return Math.sqrt(this.width() * this.width() + this.height()*this.height());
	      // This is more accurate but expensive.
	      // const center = this.center();
	      // let maxDist = 0;
	      // for (let index = 0; index < snapLocations.length; index++) {
	      //   const loc = snapLocations[index].center();
	      //   const currDist = center.distance(loc);
	      //   if (currDist > maxDist) {
	      //     maxDist = currDist;
	      //   }
	      // }
	      // return maxDist;
	    }
	
	    this.minRadius = () => {
	      const center = this.center();
	      let minDist = Number.MAX_SAFE_INTEGER;
	      for (let index = 0; index < snapLocations.length; index++) {
	        const loc = snapLocations[index].center();
	        const currDist = center.distance(loc);
	        if (currDist < minDist) {
	          minDist = currDist;
	        }
	      }
	      return minDist;
	    }
	
	    const hoveringNear = new HoverObject2d(this.object().center, () => this.maxRadius() + 10).hovering;
	    const hoveringObject = new HoverObject2d(this.object().center, () => this.minRadius() * 1.3).hovering;
	    this.hovering = (vertex) => {
	      const isNear = hoveringNear(vertex);
	      if (!isNear) return;
	      for (let index = 0; index < snapLocations.length; index++) {
	        const hoveringSnap = snapLocations[index].hovering(vertex);
	        if (hoveringSnap) return snapLocations[index];
	      }
	      return hoveringObject(vertex) && this;
	    }
	
	    this.hoveringSnap = (vertex, excluded) => {
	      if (this === excluded || Array.exists(excluded, this)) return false;
	      const isNear = hoveringNear(vertex);
	      if (!isNear) return;
	      for (let index = 0; index < snapLocations.length; index++) {
	        const hoveringSnap = snapLocations[index].hovering(vertex);
	        if (hoveringSnap) return snapLocations[index];
	      }
	      return false;
	    }
	
	    this.otherHoveringSnap = (vertex) =>
	      parent.layout().snapAt(vertex, this);
	
	    function calculateMaxAndMin(closestVertex, furthestVertex, wall, position, axis) {
	      const maxAttr = `max${axis.toUpperCase()}`;
	      const minAttr = `min${axis.toUpperCase()}`;
	      if (closestVertex[axis]() === furthestVertex[axis]()) {
	        const perpLine = wall.perpendicular(10, null, true);
	        const externalVertex = !layout.within(perpLine.startVertex()) ?
	                perpLine.endVertex() : perpLine.startVertex();
	        if (externalVertex[axis]() < closestVertex[axis]()) position[maxAttr] = closestVertex[axis]();
	        else position[minAttr] = closestVertex[axis]();
	      } else if (closestVertex[axis]() < furthestVertex[axis]()) position[minAttr] = closestVertex[axis]();
	      else position[maxAttr] = closestVertex[axis]();
	    }
	
	    function sameSlopeAsWall(wall, v1, v2, v3) {
	      const wallSlope = wall.slope();
	      const p1 = v1.point();
	      const p2 = v2.point()
	      const p3 = v3.point()
	      return withinTol(wallSlope, Line2d.getSlope(p1.x, p1.y, p2.x, p2.y)) ||
	              withinTol(wallSlope, Line2d.getSlope(p2.x, p2.y, p3.x, p3.y));
	    }
	
	    function findBestWallSnapLoc(center, wall, wallPairables, theta) {
	      let best;
	      const currentCenter = instance.parent().center();
	      for (let index = 0; index < wallPairables.length; index++) {
	        const snapLoc = wallPairables[index];
	        const neighbors = instance.object().neighbors(snapLoc.center(), -1, 1);
	        if (theta === 180)
	          console.log('rotated');
	        if (sameSlopeAsWall(wall, neighbors[0], snapLoc.center(), neighbors[1])) {
	          const centerVertex = snapLoc.at({center, theta});
	          const moveIsWithin = layout.within(centerVertex);
	          if (moveIsWithin) {
	            const dist = centerVertex.distance(currentCenter);
	            if (best === undefined || best.dist > dist) {
	              const absTheta = parent.radians() - theta;
	              best = {center: centerVertex, theta: absTheta, wall, pairWith: snapLoc};
	            }
	          }
	        }
	      }
	      return best;
	    }
	
	    function findWallSnapLocation(center) {
	      const centerWithin = layout.within(center);
	      let wallObj;
	      layout.walls().forEach((wall) => {
	        const point = wall.closestPointOnLine(center, true);
	        if (point) {
	          const wallDist = point.distance(center);
	          const isCloser = (!centerWithin || wallDist < tolerance*2) &&
	                          (wallObj === undefined || wallObj.distance > wallDist);
	          if (isCloser) {
	            wallObj = {point, distance: wallDist, wall};
	          }
	        }
	      });
	      if (wallObj) {
	        const wall = wallObj.wall;
	        const point = wallObj.point;
	        const wallPairables = instance.snapLocations.wallPairable();
	        return findBestWallSnapLoc(point, wall, wallPairables, 0) ||
	                    findBestWallSnapLoc(point, wall, wallPairables, Math.PI);
	      }
	    }
	
	    const neighborSelectFunc = (cursorCenter, neighborSeperation) => (min, index) =>
	      min.distance(cursorCenter);// + (index === 1 ? neighborSeperation / 2 : 0);
	
	    function findClosestNeighbor(otherMidpoint, radians, targetMidpoint, otherLoc, cursorCenter) {
	      const obj = instance.object();
	      const tempPoly = obj.copy();
	      const objVerts = obj.verticesAndMidpoints();
	      const targetIndex = objVerts.equalIndexOf(targetMidpoint.center());
	
	      if (targetIndex === undefined) {
	        console.log('wtf');
	      }
	
	      tempPoly.rotate(radians);
	      const newCenter = tempPoly.point(targetIndex, {center: otherMidpoint.center()});
	      tempPoly.centerOn(newCenter);
	      const neighbors = tempPoly.neighbors(otherMidpoint.center(), -1, 0, 1);
	      const neighborSeperation = neighbors[0].distance(neighbors[2]);
	      const neighbor = neighbors.min(null, neighborSelectFunc(cursorCenter, neighborSeperation));
	      const neighborIndex = tempPoly.verticesAndMidpoints().equalIndexOf(neighbor);
	      const locCount = instance.snapLocations().length;
	
	      const originalPosition = objVerts[neighborIndex + locCount % locCount];
	      if (originalPosition === undefined) { // Vertex
	        console.log('wtff');
	      }
	      const targetLoc = instance.snapLocations.at(originalPosition);
	      if (!targetLoc) {
	        // console.log(targetLoc.location());
	        return;
	      }
	
	      const dist = neighbor.distance(cursorCenter);
	      const centerDist = tempPoly.center().distance(otherMidpoint.parent().object().center());
	      return {targetLoc, dist, radians, targetMidpoint, otherMidpoint, centerDist};
	    }
	
	    function closestSnap(otherMidpoint, otherLoc, snapList, cursorCenter) {
	      let closest = null;
	      const c = cursorCenter;
	      const om = otherMidpoint;
	      const ol = otherLoc;
	      const otherParent = otherMidpoint.parent();
	      for (let index = 0; index < snapList.length; index++) {
	        const snapLoc = snapList[index];
	        if (snapLoc.parent() !== otherParent) {
	          try {
	            const targetMidpoint = snapList[index];
	            const tm = targetMidpoint;
	            const radDiff = otherMidpoint.forwardRadians() - targetMidpoint.forwardRadians();
	            const parrelle = findClosestNeighbor(om, radDiff, tm, ol, c);
	            const antiParrelle = findClosestNeighbor(om, radDiff - Math.PI, tm, ol, c);
	            const furthestCenter =
	            parrelle.centerDist > antiParrelle.centerDist ? parrelle : antiParrelle;
	            furthestCenter.otherLoc = otherLoc;
	            if (furthestCenter.radians === 0) return furthestCenter;
	            if (!closest || closest.dist < furthestCenter.dist) {
	              closest = furthestCenter;
	            }
	          } catch (e) {
	            console.warn('dont know if/how this needs fixed');
	          }
	        }
	      }
	      return closest;
	    }
	
	
	    function closestBackSnapInfo(otherLoc, cursorCenter) {
	      const snapList = instance.snapLocations.center();
	      let midpoint = otherLoc.neighbor(1);
	      let snapInfo1 = closestSnap(midpoint, otherLoc, snapList, cursorCenter);
	      if (snapInfo1.radians === 0) return snapInfo1;
	      midpoint = otherLoc.neighbor(-1);
	      let snapInfo2 = closestSnap(midpoint, otherLoc, snapList, cursorCenter);
	      if (snapInfo2.radians === 0) return snapInfo2;
	      if (snapInfo1.radians === Math.PI) return snapInfo1;
	      if (snapInfo2.radians === Math.PI) return snapInfo2;
	      const rotation1isSmallest = snapInfo2.radians > snapInfo1.radians;
	      return rotation1isSmallest ? snapInfo1 : snapInfo2;
	    }
	
	    function closestCenterSnap(otherLoc, cursorCenter) {
	      const snapList = instance.snapLocations.center();
	    }
	
	    let lastClosestSnapLocation;
	    const distanceFunc = (center) => (snapLoc) => snapLoc.center().distance(center);// +
	//          (lastClosestSnapLocation === snapLoc ? -10 : 0);
	    function findClosestSnapLoc (center) {
	      const objects = parent.layout().activeObjects();
	      const instObj = instance.object();
	      const instCenter = instObj.center();
	      let closest = null;
	      for (let index = 0; index < objects.length; index++) {
	        const object = objects[index];
	        // TODO: these should be the same object but they are not.... its convoluted.
	        if (object.id() !== parent.id()) {
	          const otherSnap = object.snap2d.top();
	          const combinedRadius = otherSnap.maxRadius() + instance.maxRadius();
	          const center2centerDist = otherSnap.object().center().distance(instCenter);
	          if (center2centerDist - 1 < combinedRadius) {
	            console.log('hit!');
	            const snapLocs = otherSnap.snapLocations();
	            closest = snapLocs.min(closest, distanceFunc(center));
	          }
	        }
	      }
	      lastClosestSnapLocation = closest;
	      return closest;
	    }
	
	    function snapMove(snapInfo) {
	      if (snapInfo) {
	        snapInfo.targetLoc.move(snapInfo.otherLoc.center(), null);
	        instance.rotate(snapInfo.radians, snapInfo.otherLoc.center());
	        snapInfo.targetLoc.courting(snapInfo.otherLoc);
	      }
	    }
	
	    function findObjectSnapLocation(center) {
	      const start = new Date().getTime();
	      const closestOtherLoc = findClosestSnapLoc(center);
	      console.log('took:', new Date().getTime() - start);
	      if (closestOtherLoc === null) return;
	      let snapList, midpointOffset;
	      if (closestOtherLoc.isLeft) {
	        if (!closestOtherLoc.isCenter) midpointOffset = -1;
	        snapList = instance.snapLocations.rightCenter();
	      } else if (closestOtherLoc.isRight) {
	        if (!closestOtherLoc.isCenter) midpointOffset = 1;
	        snapList = instance.snapLocations.leftCenter();
	      } else if (closestOtherLoc.isBack && ! closestOtherLoc.isCenter) {
	        const snapInfo = closestBackSnapInfo(closestOtherLoc, center);
	        snapMove(snapInfo);
	        return;
	      } else {
	        snapList = instance.snapLocations.backCenter();
	      }
	      if (snapList) {
	        let midpoint = midpointOffset ? closestOtherLoc.neighbor(midpointOffset) : closestOtherLoc;
	        const snapInfo = closestSnap(midpoint, closestOtherLoc, snapList, center);
	        snapMove(snapInfo);
	      }
	    }
	
	    let lastValidMove;
	    this.makeMove = (position, force) => {
	      this.snapLocations.resetCourting();
	      this.parent().center(position.center);
	      if (position.theta !== undefined) instance.radians(position.theta);
	      if (!force) {
	        let validMove = true;
	        if (!validMove) {
	          if (lastValidMove) {
	            console.log('Invalid Move');
	            return this.makeMove(lastValidMove, true); // No move was made return undefined
	          }
	        } else lastValidMove = position;
	        lastValidMove = position;
	      }
	    }
	
	    function clearIdentifiedConstraints() {
	      Snap2d.identifiedConstraints = null;
	    }
	    this.clearIdentifiedConstraints = clearIdentifiedConstraints;
	
	    this.move = (center) => {
	      clearIdentifiedConstraints.subtle(2000);
	      let constraint = this.constraint();
	      if (constraint.wall) {
	        const snapCenter = constraint.wall.closestPointOnLine(center, true) ||
	          constraint.wall.closestVertex(center);
	        const vertCenter = constraint.snapLoc.at({center: snapCenter});
	        return this.moveConnected(vertCenter);
	      } else if (constraint.vertex) {
	        console.log('vertex constraint');
	        return;
	      } else if (constraint === 'fixed') {
	        Snap2d.identifiedConstraints = this.constraints();
	        return;
	      }
	      const pairedSnapLocs = this.snapLocations.paired();
	      const centerWithin = layout.within(center);
	      let closest = {};
	      const runData = {start: new Date().getTime()};
	      const wallSnapLocation = findWallSnapLocation(center);
	      runData.wall = new Date().getTime();
	      if (wallSnapLocation !== undefined) {
	        this.makeMove(wallSnapLocation);
	        wallSnapLocation.pairWith.courting(wallSnapLocation.wall);
	        this.moveConnected(null, wallSnapLocation.theta, true);
	      } else if (centerWithin) {
	        if (this.connected()) {
	          this.moveConnected(center);
	        } else {
	          this.makeMove({center});
	          runData.move = new Date().getTime();
	          findObjectSnapLocation(center);
	          runData.object = new Date().getTime();
	          console.log(`wall: ${runData.wall - runData.start}
	move: ${runData.move - runData.wall}
	objec: ${runData.object - runData.move}
	total: ${runData.object - runData.start}`);
	        }
	      }
	    }
	
	    function moveConnectedObjects(moveId, theta) {
	      const pairedLocs = instance.snapLocations.paired();
	      for (let index = 0; index < pairedLocs.length; index += 1) {
	        const loc = pairedLocs[index];
	        const paired = loc.pairedWith();
	        if (paired instanceof SnapLocation2d) {
	          const tarVertexLoc = paired.at({center: loc.center()});
	          paired.parent().moveConnected(tarVertexLoc, theta, moveId);
	        }
	      }
	    }
	
	    let moveCounter = 0;
	    let lastMove;
	    this.moveConnected = (center, theta, moveId) => {
	      const alreadyMoved = moveId === false;
	      moveId ||= moveCounter++;
	      if (moveId === lastMove) return;
	      lastMove = moveId;
	      if (!alreadyMoved) {
	        if (theta) instance.rotate(theta, moveId);
	        if (center) instance.makeMove({center});
	      }
	      moveConnectedObjects(moveId, theta);
	    }
	  }
	}
	
	Snap2d.get = {};
	Snap2d.registar = (clazz) => {
	  const instance = new clazz();
	  if (instance instanceof Snap2d) {
	    const name = clazz.prototype.constructor.name.replace(/^Snap/, '').toCamel();
	    if (Snap2d.get[name] === undefined)
	      Snap2d.get[name] = (parent, tolerance) => new clazz(parent, tolerance);
	    else throw new Error(`Double registering Snap2d: ${name}`);
	  }
	}
	
	Snap2d.identfied = (snapLoc) => Snap2d.identifiedConstraints &&
	        Snap2d.identifiedConstraints.indexOf(snapLoc) !== -1;
	
	Snap2d.fromJson = (json) => {
	  const layout = Layout2d.get(json.layoutId);
	  const object = Object.fromJson(json.object);
	  const snapObj = new Snap2d(layout, object, json.tolerance);
	  snapObj.id(json.id);
	  return snapObj;
	}
	
	new Snap2d();
	
	module.exports = Snap2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/plane.js',
function (require, exports, module) {
	
class Plane2d {
	  constructor(vertices) {
	    this.getLines = () => {
	      const lines = [];
	      for (let index = 0; index < vertices.length; index += 1) {
	        lines.push(new Line2d(vertices[index], vertices[(index + 1) % vertices.length]));
	      }
	      return lines;
	    }
	  }
	}
	
	Plane2d.getPlanes = (planes) => {
	  const ps = [];
	  planes.forEach((p) => ps.push(new Plane2d(p)));
	  return ps;
	}
	
	Plane2d.consolidatePolygons = (polygons) => {
	  const consolidated = {top: {}, left: {}, front: {}};
	  function group(g, poly) {
	
	    map.xy[index].push({x: v.pos.x, y: v.pos.y, level: v.pos.z});
	    map.xz[index].push({x: v.pos.x, y: v.pos.z, level: v.pos.y});
	    map.yz[index].push({x: v.pos.y, y: v.pos.z, level: v.pos.x});
	  }
	  const map = {xy: [], xz: [], yz: []};
	  polygons.forEach((p, index) => {
	    map.xy.push([]);
	    map.xz.push([]);
	    map.yz.push([]);
	    p.vertices.forEach((v) => {
	      map.xy[index].push({x: v.pos.x, y: v.pos.y, level: v.pos.z});
	      map.xz[index].push({x: v.pos.x, y: v.pos.z, level: v.pos.y});
	      map.yz[index].push({x: v.pos.y, y: v.pos.z, level: v.pos.x});
	    });
	  });
	  return map;
	}
	
	new Plane2d();
	module.exports = Plane2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/snap-location.js',
function (require, exports, module) {
	
const Vertex2d = require('vertex');
	const Line2d = require('line');
	const Circle2d = require('circle');
	const HoverObject2d = require('../hover-map').HoverObject2d;
	
	class SnapLocation2d {
	  constructor(parent, location, centerFunction) {
	    Object.getSet(this, {location});
	    let pairedWith = null;
	    let courting;
	    const instance = this;
	
	    this.center = () => centerFunction();
	
	    // If position is defined and a Vertex2d:
	    //        returns the position of parents center iff this location was at position
	    // else
	    //        returns current postion based off of the parents current center
	
	    this.at = (position) => {
	      return centerFunction(position);
	    }
	    this.centerFunction = (lf) => {
	      if ((typeof lf) === 'function') centerFunction = lf;
	      return lf;
	    }
	    this.circle = (radius) => new Circle2d(radius || 2, centerFunction());
	    this.eval = () => this.parent().position[location]();
	    this.parent = () => parent;
	    this.pairedWith = () => pairedWith;
	    this.disconnect = () => {
	      if (pairedWith === null) return false;
	      const wasPaired = pairedWith;
	      pairedWith = null;
	      if (wasPaired instanceof SnapLocation2d) wasPaired.disconnect();
	      instance.parent().clearIdentifiedConstraints();
	      return true;
	    }
	    this.pairWith = (otherSnapLoc) => {
	      otherSnapLoc ||= courting;
	      const alreadyPaired = otherSnapLoc === pairedWith;
	      if (!alreadyPaired && otherSnapLoc) {
	        pairedWith = otherSnapLoc;
	        courting = null;
	        if (otherSnapLoc instanceof SnapLocation2d) otherSnapLoc.pairWith(this);
	      }
	    }
	
	    // TODO: location should be immutible and so should these;
	    this.isRight = this.location().indexOf('right') === 0;
	    this.isLeft = this.location().indexOf('left') === 0;
	    this.isBack = this.location().indexOf('back') === 0;
	    this.isCenter = this.location().match(/center$/) !== null;
	
	    this.courting = (otherSnapLoc) => {
	      if (courting === otherSnapLoc) return courting;
	      if (!pairedWith) {
	        if (otherSnapLoc) {
	          courting = otherSnapLoc;
	          if (otherSnapLoc instanceof SnapLocation2d)
	            otherSnapLoc.courting(this);
	        } else if (otherSnapLoc === null && courting) {
	          const tempLocation = courting;
	          courting = null;
	          if (tempLocation instanceof SnapLocation2d)
	            tempLocation.courting(null);
	        }
	      } else if (otherSnapLoc) {
	        throw new Error('You cannot court a location when alreadyPaired');
	      }
	      return courting;
	    }
	
	    this.neighbors = (...indicies) => {
	      const vertexNeighbors = parent.object().neighbors(this.center(), ...indicies);
	      return vertexNeighbors.map((vert) => parent.snapLocations.at(vert));
	    }
	
	    this.neighbor = (index) => this.neighbors(index)[0];
	
	    this.slope = (offsetIndex) => {
	      const neighbor = parent.object().neighbors(this.center(), offsetIndex)[0];
	      const nCenter = neighbor.point();
	      const center = this.center().point();
	      if (offsetIndex < 0)
	        return Line2d.getSlope(nCenter.x, nCenter.y, center.x, center.y);
	      return Line2d.getSlope(center.x, center.y, nCenter.x, nCenter.y);
	    }
	
	    this.forwardSlope = () => this.slope(1);
	    this.reverseSlope =  () => this.slope(-1);
	    this.forwardRadians = () => Math.atan(this.slope(1));
	    this.reverseRadians = () => Math.atan(this.slope(-1));
	
	
	    this.snapToLocation = (otherSnapLoc) => {
	      const center = otherSnapLoc.center();
	      const otherRads = otherSnapLoc.forwardRadians();
	      const rads = instance.forwardRadians();
	      const changeInTheta = otherRads - rads;
	      const position1 = {center: center, theta: changeInTheta};
	      const position2 = {center: center, theta: changeInTheta - Math.PI};
	      const newPosition1 = instance.parent().position[location](position1);
	      const newPosition2 = instance.parent().position[location](position2);
	      const otherObjectCenter = otherSnapLoc.parent().object().center()
	      const dist1 = newPosition1.distance(otherObjectCenter);
	      const dist2 = newPosition2.distance(otherObjectCenter);
	      const objTheta = instance.parent().radians();
	      const theta = objTheta - changeInTheta;
	      if (dist1 > dist2) {
	        instance.parent().makeMove({center: newPosition1, theta});
	      } else {
	        instance.parent().makeMove({center: newPosition2, theta: theta - Math.PI});
	      }
	    }
	
	    function snapToObject(vertex) {
	      const otherSnapLoc = parent.otherHoveringSnap(vertex);
	      if (!otherSnapLoc) return false;
	      instance.courting(otherSnapLoc);
	      instance.snapToLocation(otherSnapLoc);
	      return true;
	    }
	
	    this.move = (vertex, moveId) => {
	      if (parent.connected()) return parent.moveConnected(this.at({center: vertex}));
	      const shouldNotSnap = (typeof moveId) === 'number' || moveId === null;
	      vertex = new Vertex2d(vertex);
	      if (shouldNotSnap || !snapToObject(vertex)) {
	        const thisNewCenterLoc = this.parent().position[location]({center: vertex});
	        this.parent().makeMove({center: thisNewCenterLoc});
	      }
	    }
	
	    this.rotateAround = (theta) => {
	      const startPosition = {center: this.center()};
	      this.parent().moveConnected(null, theta);
	      const newCenter = this.at(startPosition);
	      this.parent().moveConnected(newCenter);
	    }
	
	    this.setRadians = (radians) => {
	      const startPosition = {center: this.center()};
	      const theta = radians - parent.radians();
	      this.parent().moveConnected(null, theta);
	      const newCenter = this.at(startPosition);
	      this.parent().moveConnected(newCenter);
	    }
	
	    this.notPaired = () => pairedWith === null;
	
	    this.hovering = new HoverObject2d(() => this.center(), 12).hovering;
	
	    this.instString = () => `${parent.id()}:${location}`;
	    this.toString = () => pairedWith  instanceof SnapLocation2d ?
	                  `${this.instString()}=>${pairedWith && pairedWith.instString()}` :
	                  `${this.instString()}=>${pairedWith}`;
	    this.toJson = () => {
	      const pw = pairedWith;
	      if (pw === undefined) return;
	      const json = [{
	        location, objectId: parent.parent().id()
	      }];
	      json[1] = pw instanceof SnapLocation2d ?
	                  {location: pw.location(), objectId: pw.parent().parent().id()} :
	                  pw.constructor.name;
	      const thisStr = this.toString();
	      const pairStr = pw.toString();
	      json.view = parent.view();
	      json.UNIQUE_ID = thisStr < pairStr ? thisStr : pairStr;;
	      return json;
	    }
	  }
	}
	
	SnapLocation2d.fromJson = (json) => {
	  console.log('jsoned it up!')
	}
	
	let activeLocations = [];
	SnapLocation2d.active = (locs) => {
	  if (Array.isArray(locs)) activeLocations = activeLocations.concat(locs);
	  return activeLocations;
	}
	SnapLocation2d.clear = () => activeLocations = [];
	
	function fromToPoint(snapLoc, xDiffFunc, yDiffFunc) {
	  return (position) => {
	    const xDiff = xDiffFunc();
	    const yDiff = yDiffFunc();
	    const vertex = snapLoc.center();
	    if (xDiff === 0 && yDiff === 0) {
	      if (position) return snapLoc.parent().parent().center().clone();
	      vertex.point(snapLoc.parent().parent().center().clone());
	      return snapLoc;
	    }
	    const center = snapLoc.parent().parent().center();
	    const direction = xDiff >= 0 ? 1 : -1;
	    const hypeLen = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
	    let rads = Math.atan(yDiff/xDiff);
	    if (position) {
	      rads += position.theta === undefined ? snapLoc.parent().radians() : position.theta;
	      const newPoint = position.center;
	      return new Vertex2d({
	        x: newPoint.x() - direction * (hypeLen * Math.cos(rads)),
	        y: newPoint.y() - direction * (hypeLen * Math.sin(rads))
	      });
	    } else {
	      rads += snapLoc.parent().radians();
	      vertex.point({
	        x: center.x() + direction * (hypeLen * Math.cos(rads)),
	        y: center.y() + direction * (hypeLen * Math.sin(rads))
	      });
	      return snapLoc;
	    }
	  }
	}
	SnapLocation2d.fromToPoint = fromToPoint;
	
	const f = (snapLoc, attr, attrM, props) => () => {
	  let val = snapLoc.parent()[attr]() * attrM;
	  let keys = Object.keys(props || {});
	  for (let index = 0; index < keys.length; index += 1) {
	    const key = keys[index];
	    val += snapLoc.parent()[key]() * props[key];
	  }
	  return val;
	};
	
	SnapLocation2d.locationFunction = f;
	
	module.exports = SnapLocation2d;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/maps/star-line-map.js',
function (require, exports, module) {
	
const Vertex2d = require('../objects/vertex');
	const Line2d = require('../objects/line');
	const ExtremeSector = require('./star-sectors/extreme');
	
	
	
	class StarLineMap {
	  constructor(type, sectorCount, center) {
	    type = type.toLowerCase();
	    let sectors;
	    let compiled;
	    const lines = [];
	    const instance = this;
	    sectorCount ||= 1000;
	
	    this.center = () => center ||= Vertex2d.center(...Line2d.vertices(lines));
	
	    function getSector(t) {
	      const args = Array.from(arguments).slice(1);
	      t ||= type;
	      switch (t) {
	        case 'extreme':
	          return new ExtremeSector(...args);
	        default:
	          throw new Error(`Unknown sector type '${t}'`);
	      }
	    }
	
	    function buildSectors(type, center, count) {
	      count ||= sectorCount;
	      sectors = [];
	      center ||= instance.center();
	      const thetaDiff = 2*Math.PI / count;
	      for (let index = 0; index < count; index++) {
	        const sector = getSector(type, center, thetaDiff * (index));
	        sectors.push(sector);
	        for (let sIndex = 0; sIndex < lines.length; sIndex++) {
	          sector.add(lines[sIndex]);
	        }
	      }
	    }
	
	    this.isSupported = (obj) => obj instanceof Line2d;
	
	    this.add = (obj) => {
	      if (!this.isSupported(obj)) throw new Error(`obj of type ${obj.constructor.name} is not supported`);
	      lines.push(obj);
	    }
	
	    this.addAll = (lines) => {
	      for(let index = 0; index < lines.length; index++)this.add(lines[index]);
	    }
	
	    this.filter = (type, center, count) => {
	      buildSectors(type, center, count);
	      const extremes = {};
	      for (let index = 0; index < sectors.length; index++) {
	        sectors[index].filter(extremes);
	      }
	      return Object.values(extremes);
	    }
	
	    this.sectorLines = () => buildSectors() || sectors.map((s) => s.line());
	    this.toDrawString = (sectorCount) => {
	      buildSectors(null, sectorCount || 24);
	      const center = this.center();
	      let str = `//center ${center.approxToString()}`;
	      str += '\n//lines\n' + Line2d.toDrawString(lines, 'black');
	      str += '\n\n//Sectors\n';
	      sectors.forEach(s => str += s.toDrawString(String.nextColor()));
	      return str;
	    }
	  }
	}
	
	
	module.exports = StarLineMap;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/maps/escape.js',
function (require, exports, module) {
	
const Line2d = require('../objects/line');
	const Vertex2d = require('../objects/vertex');
	const Polygon2d = require('../objects/polygon');
	const Tolerance = require('../../../tolerance.js');
	const ToleranceMap = require('../../../tolerance-map.js');
	const tol = .0015;
	const withinTol = Tolerance.within(tol);
	const nonZero = (val) => !withinTol(val, 0);
	
	class EscapeGroup {
	  constructor(line) {
	    let canEscape;
	    const lineMap = {};
	    const id = String.random();
	    lineMap[line.toString()] = line;
	    let reference, type;
	
	    this.id = () => id;
	    this.type = (val) => {
	      if (val !== undefined) type = val;
	      return type;
	    }
	    this.reference = (other) => {
	      if (other instanceof EscapeGroup && other !== this)
	        reference = other;
	      return reference;
	    }
	    this.lines = () => Object.values(lineMap);
	    this.canEscape = (ce, type) => {
	      if (ce === true || ce === false) {
	        if ((canEscape === true && ce === false) || (canEscape === false && ce === true))
	          console.warn('Conflicting escape values???');
	      }
	      this.type(type);
	      if (ce === true) canEscape = true;
	      return canEscape;
	    }
	    this.connect = (other) => {
	      if (other === this) return;
	      const lines = other.lines();
	      for (let index = 0; index < lines.length; index++) {
	        const line = lines[index];
	        lineMap[line.toString()] = line;
	      }
	
	      if (this.canEscape() !== true)
	        this.canEscape(other.canEscape());
	    }
	  }
	}
	
	class Escape {
	  constructor(line) {
	    let escapeGroupRight = new EscapeGroup(line);
	    let escapeGroupLeft = new EscapeGroup(line);
	    let groupIdMap = {}
	    groupIdMap[escapeGroupRight.id()] = true;
	    groupIdMap[escapeGroupLeft.id()] = true;
	    const updateReference = {
	      left: () => {
	        let reference = escapeGroupLeft.reference();
	        if (reference) {
	          if (groupIdMap[reference.id()]) {
	            reference = new EscapeGroup(line);
	            reference.connect(escapeGroupLeft);
	          }
	          groupIdMap[reference.id()] = true;
	          escapeGroupLeft = reference;
	          updateReference.left();
	        }
	      },
	      right: () => {
	        let reference = escapeGroupRight.reference();
	        if (reference) {
	          if (groupIdMap[reference.id()]) {
	            reference = new EscapeGroup(line);
	            reference.connect(escapeGroupRight);
	          }
	          groupIdMap[reference.id()] = true;
	          escapeGroupRight = reference;
	          updateReference.right();
	        }
	      }
	    }
	    this.updateReference = () => updateReference.left() || updateReference.right();
	    this.right = (ce, type) => {
	      updateReference.right();
	      return escapeGroupRight.canEscape(ce, type);
	    }
	    this.left = (ce, type) => {
	      updateReference.left();
	      return escapeGroupLeft.canEscape(ce, type);
	    }
	
	    this.right.connected = (other) => {
	      escapeGroupRight.canEscape();
	      updateReference.right();
	      escapeGroupRight.connect(other);
	      other.reference(escapeGroupRight);
	    }
	    this.left.connected = (other) => {
	      escapeGroupLeft.canEscape();
	      updateReference.left();
	      escapeGroupLeft.connect(other);
	      other.reference(escapeGroupLeft);
	    }
	
	    this.right.group = () => this.updateReference() || escapeGroupRight;
	    this.left.group = () => this.updateReference() || escapeGroupLeft;
	    this.right.type = (type) => escapeGroupRight.type(type);
	    this.left.type = (type) => escapeGroupLeft.type(type);
	  }
	}
	
	class EscapeMap {
	  constructor(lines, perpindicularDistance) {
	    perpindicularDistance ||= .05;
	    const instance = this;
	    let escapeObj;
	
	    function escapeLines(lines, perpDist) {
	      const getState = (lineOstr) =>
	        escapeObj.states[lineOstr instanceof Line2d ? lineOstr.toString() : lineOstr];
	
	      function recursiveEscape(obj) {
	        const closests = Object.values(obj.closest);
	        for (let cIndex = 0; cIndex < closests.length; cIndex++) {
	          setEscapes(obj, closests[cIndex]);
	        }
	      }
	
	      function setEscape(obj, closest, dir) {
	        const dirObj = closest[dir];
	        if (dirObj.line) {
	          const dirState = getState(dirObj.line);
	          let dirOfEndpoint = dirObj.line.direction(dirObj.runner.startVertex());
	          let escapeBretheran = dirOfEndpoint === 'right' ? dirState.escape.right.group() : dirState.escape.left.group();
	          obj.escape[dir].connected(escapeBretheran);
	          dirState.escape.updateReference();
	          if (obj.escape[dir]()) dirObj.successful = true;
	        }
	      }
	
	      const targetLine = new Line2d(new Vertex2d(45, 37.5),
	                                  new Vertex2d(45, 12.5))
	      function setEscapes(obj, closest) {
	        if (obj.escape.right() === true) obj.escape.left(false);
	        else if (obj.escape.left() === true) obj.escape.right(false);
	        if (obj.line.equals(targetLine)) {
	          console.log('gotcha');
	        }
	        setEscape(obj, closest, 'right');
	        setEscape(obj, closest, 'left');
	        return obj;
	      }
	
	      const toDrawString = (key) => () => {
	        const state = escapeObj.states[key];
	        const sRight = state.closest.startVertex.right;
	        const sLeft = state.closest.startVertex.left;
	        const eRight = state.closest.endVertex.right;
	        const eLeft = state.closest.endVertex.left;
	        Line2d.toDrawString([state.line,sRight, eRight,sLeft,eLeft],
	                              'green', 'red', 'red', 'blue', 'blue');
	      }
	      const initEscape = (line, index) => {
	        if (getState(line) !== undefined) return;
	        const key = line.toString();
	        escapeObj.states[key] = {index, line, closest: {}, runners: {},
	                escape: new Escape(line),
	                toDrawString: toDrawString(key)};
	      };
	
	      const isClosest = (origin, curr, prospective, originToEndDist) => {
	        if (!(prospective instanceof Vertex2d)) return false;
	        if ((typeof prospective.distance) !== 'function') {
	          console.log('here')
	        }
	        const prospectDist = prospective.distance(origin) - originToEndDist;
	        // const validDistance = prospectDist > 0 || withinTol(prospectDist, 0);
	        // if (!validDistance) return false;
	        if (!curr) return true;
	        const currDist = curr.distance(origin) - originToEndDist;
	        return Math.abs(currDist) > Math.abs(prospectDist);
	      }
	
	      const intersectsPoint = (target, line1, line2) => {
	        const intersection = line1.findDirectionalIntersection(line2);
	        return intersection instanceof Vertex2d &&
	                  (target.equals(intersection, .1) ||
	                   intersection.distance(line2.startVertex()) >
	                   target.distance(line2.startVertex()));
	      }
	
	      function runners(line, targetFuncName, startPointFuncName, radians) {
	        const state = getState(line);
	        const vertex = line[targetFuncName]();
	        const perp = line.perpendicular(perpDist, line[startPointFuncName](), true);
	        const originToEndDist = line.midpoint().distance(line.startVertex());
	        const rightOrigin = perp.startVertex();
	        const right = Line2d.startAndTheta(rightOrigin, radians, 1000000000);
	        const rightPerp = line.perpendicular(-10000000);
	        const leftOrigin = perp.endVertex();
	        const left = Line2d.startAndTheta(leftOrigin, radians, 100000000);
	        const leftPerp = line.perpendicular(10000000);
	        const center = Line2d.startAndTheta(line[startPointFuncName](), radians, 100000000);
	        state.runners[radians] = {right, left};
	        state.closest[targetFuncName] = {right: {}, left:{}};
	        let closest = state.closest[targetFuncName];
	        let escapedLeft = true;
	        let escapedRight = true;
	        let escapedLeftPerp = true;
	        let escapedRightPerp = true;
	        for (let index = 0; index < lines.length; index++) {
	          const other = lines[index];
	          if (intersectsPoint(vertex, other, center)) {
	            const leftIntersection = left.findDirectionalIntersection(other);
	            if (other.withinSegmentBounds(leftIntersection)) {
	              if (isClosest(leftOrigin, closest.left.intersection, leftIntersection, originToEndDist)) {
	                escapedLeft = false;
	                const escapeLine = new Line2d(left.startVertex(), leftIntersection);
	                closest.left = {intersection: leftIntersection, line: other, escapeLine, runner: left};
	              }
	            }
	            const rightIntersection = right.findDirectionalIntersection(other);
	            if (other.withinSegmentBounds(rightIntersection)) {
	              if (isClosest(rightOrigin, closest.right.intersection, rightIntersection, originToEndDist)) {
	                escapedRight = false;
	                const escapeLine = new Line2d(right.startVertex(), rightIntersection);
	                closest.right = {intersection: rightIntersection, line: other, escapeLine, runner: right};
	              }
	            }
	          }
	          const rightPerpIntersection = rightPerp.findDirectionalIntersection(other);
	          if (other.withinSegmentBounds(rightPerpIntersection) && nonZero(line.distance(rightPerpIntersection)))
	            escapedRightPerp = false;
	          const leftPerpIntersection = leftPerp.findDirectionalIntersection(other);
	          if (other.withinSegmentBounds(leftPerpIntersection) && nonZero(line.distance(leftPerpIntersection)))
	            escapedLeftPerp = false;
	        }
	
	        if (escapedRight || escapedRightPerp)
	          state.escape.right(true, 'independent');
	        if (escapedLeft || escapedLeftPerp)
	          state.escape.left(true, 'independent');
	        if (escapedRight || escapedLeft) state.type = 'independent';
	      }
	
	      function runAll(lines) {
	        escapeObj = {states: {}, runners: {right: [], left: []}};
	        for (let index = 0; index < lines.length; index++) {
	          const line = lines[index];
	          initEscape(line, index);
	          runners(line, 'startVertex', 'endVertex', line.radians() - Math.PI);
	          runners(line, 'endVertex', 'startVertex', line.radians());
	        }
	      }
	
	      runAll(lines);
	
	      const indStates = instance.states.independent();
	      const indLines = indStates.map(s => s.line);
	      for (let index = indStates.length - 1; index > -1; index--) {
	        const state = indStates[index];
	        const indLine = state.line;
	        const sliced = indLine.slice(indLines);
	        if (sliced) {
	          lines.splice(state.index, 1);
	          for (let sIndex = 0; sIndex < sliced.length; sIndex++) {
	            lines.push(sliced[sIndex]);
	          }
	        }
	      }
	
	      // runAll(lines);
	      //
	      // const values = Object.values(escapeObj.states);
	      // for (let index = 0; index < values.length; index++) {
	      //   recursiveEscape(values[index]);
	      // }
	      return escapeObj;
	    }
	
	    this.states = () => escapeObj.states;
	    this.states.independent = () => Object.values(escapeObj.states)
	                                .filter(obj => obj.type === 'independent');
	    this.independent = () => this.states.independent().map(obj => obj.line);
	
	
	    this.dependent = () => Object.values(escapeObj.states)
	                                .filter(obj => (obj.escape.left() || obj.escape.right()) && obj.type !== 'independent')
	                                .map(obj => obj.line);
	    this.escaped = () => Object.values(escapeObj.states)
	                                .filter(obj => obj.escape.left() || obj.escape.right())
	                                .map(obj => obj.line);
	
	    this.groups = () => {
	      const parents = {};
	      Object.values(escapeObj.states).forEach((obj) => {
	        if (parents[obj.escape.right.group().id()] === undefined)
	          parents[obj.escape.right.group().id()] = obj.escape.right.group();
	        if (parents[obj.escape.left.group().id()] === undefined)
	          parents[obj.escape.left.group().id()] = obj.escape.left.group();
	      })
	      return Object.values(parents);
	    }
	
	    this.escapeAttempts = (successOfailure) => {
	      const lines = [];
	      const add = (obj) =>
	            (successOfailure === undefined || (successOfailure && obj.successful) || (!successOfailure && !obj.successful)) &&
	            obj.intersection && lines.push(obj.escapeLine);
	      const lateBloomers = Object.values(escapeObj.states).filter(obj => obj.type !== 'independent');
	      for (let index = 0; index < lateBloomers.length; index++) {
	        const target = lateBloomers[index];
	        const closests = Object.values(target.closest);
	        for (let cIndex = 0; cIndex < closests.length; cIndex++) {
	          add(closests[cIndex].right);
	          add(closests[cIndex].left);
	        }
	      }
	      return lines;
	    }
	
	
	
	    this.toDrawString = () => {
	      let str = Line2d.toDrawString(lines);
	      str += '\n\n//Independed Escapers\n' + Line2d.toDrawString(this.independent(), 'green');
	      str += '\n\n//Dependent Escapers\n' + Line2d.toDrawString(this.dependent(), 'lightgreen');
	      // str += '\n\n//Successful Escapes\n' + Line2d.toDrawString(this.escapeAttempts(true), 'blue');
	      // str += '\n\n//Attempted Escapes\n' + Line2d.toDrawString(this.escapeAttempts(false), 'red');
	      return str;
	    }
	
	    this.groupDrawString = () => {
	      const groups = this.groups();
	      let str = '';
	      for (let index = 0; index < groups.length; index++) {
	        const group = groups[index];
	        const lines = group.lines();
	        str += `\n\n//Group ${index} (${lines.length})\n//${Line2d.toDrawString(lines, 'red')}`;
	      }
	      return str;
	    }
	
	    escapeLines(lines, perpindicularDistance);
	  }
	}
	
	EscapeMap.parimeter = (lines) => {
	  const escapeObj = new EscapeMap(lines);
	  // TODO: need a better/more complete algorythum.
	  const escaped = escapeObj.independent();
	  const breakdown = Line2d.sliceAll(escaped);
	  const breakdownMap = new EscapeMap(breakdown);
	  const parimeter = Line2d.consolidate(...breakdownMap.escaped());
	  const poly = Polygon2d.build(parimeter);
	  return poly;
	}
	
	module.exports = EscapeMap;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/maps/star-sectors/extreme.js',
function (require, exports, module) {
	
const Line2d = require('../../objects/line');
	const Tolerance = require('../../../../tolerance.js');
	const ToleranceMap = require('../../../../tolerance-map.js');
	const tol = .0001;
	const withinTol = Tolerance.within(tol);
	
	
	class ExtremeSector {
	  constructor(center, theta) {
	    const intersectionMap = new ToleranceMap({'line.slope': tol})
	    center = center.copy();
	    const limits = {start: {
	        dist: 0
	      },middle: {
	        dist: 0
	      },end: {
	        dist: 0
	      }
	    }
	
	    const sectorLine = Line2d.startAndTheta(center, theta);
	    // sectorLine.translate(new Line2d(sectorLine.midpoint(), sectorLine.startVertex()));
	    this.line = () => sectorLine;
	
	    function newLimit(vertex, line, limitObj) {
	      const dist = center.distance(vertex);
	      if (dist > limitObj.dist) {
	        limitObj.dist = dist;
	        limitObj.line = line;
	      }
	    }
	
	    this.filter = (extremes) => {
	      extremes ||= {};
	      const add = (line) => line && extremes[line.toString()] === undefined &&
	                            (extremes[line.toString()] = line);
	      add(limits.start.line);
	      add(limits.middle.line);
	      add(limits.end.line);
	      return extremes;
	    }
	
	    this.toDrawString = (color) => {
	      const sectionStr = Line2d.toDrawString([sectorLine], color);
	      const extremes = Object.values(this.extremes());
	      const linesStrs = Line2d.toDrawString(extremes, color);
	      return `// ${Math.toDegrees(theta)}\n${sectionStr}\n${linesStrs}\n`;
	    }
	
	    //Maybe useful to remove consolidatable lines.
	    function additionFilter(matches, elem) {
	      matches.push(elem);
	      const lineToMatch = {};
	      let lines = [];
	      for (let index = 0; index < matches.length; index++) {
	        const match = matches[index];
	        lines.push(match.line);
	        lineToMatch[match.line.toString()] = match;
	      }
	      lines = Line2d.consolidate(...lines);
	      const consolidated = [];
	      for (let index = 0; index < lines.length; index++) {
	        const line = lines[index];
	        let match = lineToMatch[line.toString()];
	        if (!match) match = {line, intersection: sectorLine.findDirectionalIntersection(line)}
	        consolidated.push(match);
	      }
	      return consolidated;
	    }
	
	    this.add = (line) => {
	      const intersection = sectorLine.findDirectionalIntersection(line);
	      if (intersection && line.withinSegmentBounds(intersection)) {
	        const sv = line.startVertex(); const mv = line.midpoint(); const ev = line.endVertex();
	        // intersectionMap.filter({line, intersection},  additionFilter);
	        newLimit(sv, line, limits.start);
	        newLimit(mv, line, limits.middle);
	        newLimit(ev, line, limits.end);
	      }
	    }
	  }
	}
	
	module.exports = ExtremeSector;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/snap/polygon.js',
function (require, exports, module) {
	const Snap2d = require('../snap');
	const Line2d = require('../line');
	const Square2d = require('../square');
	const Polygon2d = require('../polygon');
	const SnapLocation2d = require('../snap-location');
	const Vertex2d = require('../vertex');
	const ToleranceMap = require('../../../../tolerance-map.js');
	
	class SnapPolygon extends Snap2d {
	  constructor(parent, polygon, tolerance) {
	    if (!(polygon instanceof Polygon2d) || !polygon.valid()) throw new Error('PolygonSnap requires a valid polygon to intialize');
	    super(parent, polygon, tolerance);
	    let locationCount = 0;
	    polygon.centerOn(parent.center());
	    if (parent === undefined) return this;
	    const instance = this;
	    let longestFaceIndex;
	
	    const setOpeningLine = (index) => {
	      const line = polygon.lines()[index];
	      if (longestFaceIndex === undefined || instance.longestFaceLine().length() < line.length()) {
	        longestFaceIndex = index;
	      }
	    }
	
	    this.longestFaceLine = () => {
	      const rotated = this.object();
	      const lines = rotated.lines();
	      if (longestFaceIndex) return lines[index];
	      const longest = lines[0];
	      for (let index = 1; index < lines.length; index++) {
	        const line = lines[index];
	        if (longest.length < line) longest = line;
	      }
	      return longest;
	    }
	
	    this.polygon = () => polygon;
	
	    this.object = () => {
	      polygon.center(this.center());
	      const thetaDiff = polygon.radians() - this.radians();
	      const rotated = polygon.rotate(this.radians(), null, true);
	      return rotated;
	    }
	
	    const midpointMap = new ToleranceMap({x: .1, y:.1});
	    const vertexFunc = (index) => (position) => instance.object().vertex(index, position);
	    const midpointFunc = (index) => (position) => instance.object().midpoint(index, position);
	    function addLine(index, name, targetName) {
	      const locFunc = vertexFunc(index + 1);
	      const snapLoc = new SnapLocation2d(instance, name + locationCount++,  locFunc,  targetName);
	      instance.addLocation(snapLoc);
	      const mpFunc = midpointFunc(index + (name === 'right' ? 1 : 0));
	      const mpLoc = mpFunc();
	      if(midpointMap.matches(mpLoc).length === 0) {
	        midpointMap.add(mpLoc);
	        const snapLocMidpoint = new SnapLocation2d(instance, `${name}${locationCount++}center`,  mpFunc,  `${targetName}Center`);
	        instance.addLocation(snapLocMidpoint);
	      }
	
	      snapLoc.at();
	    }
	
	    const backs = [];
	    function queBack (index) {backs.push(index)};
	
	    function addBacks(index) {
	      for (let index = 0; index < backs.length; index++) {
	        const i = backs[index];
	        addLine(i, `back${i}`, 'back');
	      }
	    }
	
	    function addVertex(index, prevIsFace, targetIsFace, nextIsFace) {
	      if (prevIsFace && !targetIsFace && nextIsFace){
	        queBack(index);
	      } else if (targetIsFace && !nextIsFace) {
	        addLine(index, 'right', 'left');
	        setOpeningLine(index);
	      } else if (!targetIsFace && nextIsFace) {
	        addLine(index, 'left', 'right');
	      } else if (targetIsFace) {
	        setOpeningLine(index);
	        return;
	      } else {
	        queBack(index);
	      }
	    }
	
	    function build() {
	      const faces = instance.object().faces();
	      const lines = instance.object().lines();
	      let prevPrevIsFace = faces.equalIndexOf(lines[lines.length -2]) !== -1;
	      let prevIsFace = faces.equalIndexOf(lines[lines.length - 1]) !== -1;
	      for (let index = 0; index < lines.length; index++) {
	        const line = lines[index];
	        const currIsFace = faces.equalIndexOf(line) !== -1;
	        const currIndex = index === 0 ? lines.length - 1 : index - 1;
	        addVertex(currIndex, prevPrevIsFace, prevIsFace, currIsFace);
	        prevPrevIsFace = prevIsFace;
	        prevIsFace = currIsFace;
	      }
	      addBacks();
	    }
	
	    this.getTextInfo = () => {
	      const lfl = this.longestFaceLine();
	      const dist = instance.height() / 4;
	      const radians = lfl.radians();
	      const textLine = lfl.perpendicular(dist/2);
	      return {
	        text: instance.parent().name() || 'pooop',
	        center: textLine.endVertex(),
	        radians,
	        x: 0,
	        y: 0,
	        size: instance.height() / 4,
	        maxWidth: lfl ? lfl.length() : instance.width(),
	        limit: 10
	      }};
	
	    build();
	  }
	}
	
	module.exports = SnapPolygon;
	
});


RequireJS.addFunction('./public/js/utils/canvas/two-d/objects/snap/square.js',
function (require, exports, module) {
	const Snap2d = require('../snap');
	const Square2d = require('../square');
	const Polygon2d = require('../polygon');
	const SnapLocation2d = require('../snap-location');
	const Vertex2d = require('../vertex');
	
	class SnapSquare extends Snap2d {
	  constructor(parent, tolerance) {
	    const polygon = new Polygon2d();
	    polygon.getTextInfo = () => ({
	      text: this.parent().name() || 'kazzooi',
	      center: this.center(),
	      radians: this.radians(),
	      x: this.x(),
	      y: this.y() / 4,
	      maxWidth: this.width(),
	      limit: 10
	    });
	    // super(parent, new Square2d(parent.center), tolerance);
	    super(parent, polygon, tolerance);
	    if (parent === undefined) return this;
	    this.addLocation(SnapSquare.backCenter(this));
	    this.addLocation(SnapSquare.backRight(this));
	    this.addLocation(SnapSquare.rightCenter(this));
	    this.addLocation(SnapSquare.frontRight(this));
	    this.addLocation(SnapSquare.frontLeft(this));
	    this.addLocation(SnapSquare.leftCenter(this));
	    this.addLocation(SnapSquare.backLeft(this));
	    const vertices = this.snapLocations().map((snap) =>
	      snap.center());
	    polygon.addVertices(vertices);
	  }
	}
	
	const fromToPoint = SnapLocation2d.fromToPoint;
	const wFunc = (snapLoc, multiplier) => SnapLocation2d.locationFunction(snapLoc, 'width', multiplier);
	const hFunc = (snapLoc, multiplier) => SnapLocation2d.locationFunction(snapLoc, 'height', multiplier);
	
	SnapSquare.backCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "backCenter",
	      () => fromToPoint(snapLoc, wFunc(snapLoc, 0), hFunc(snapLoc, -.5)));
	  return snapLoc;
	}
	SnapSquare.frontCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontCenter",
	      () => fromToPoint(snapLoc, wFunc(snapLoc, 0), () => hFunc(snapLoc, .5)));
	  snapLoc.at();
	  return snapLoc;
	}
	SnapSquare.leftCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "leftCenter",
	      () => fromToPoint(snapLoc, wFunc(snapLoc, -.5), hFunc(snapLoc, 0)));
	  return snapLoc;
	}
	SnapSquare.rightCenter = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "rightCenter",
	      () => fromToPoint(snapLoc, wFunc(snapLoc, .5), hFunc(snapLoc, 0)));
	  return snapLoc;
	}
	
	SnapSquare.backLeft = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "backLeft",
	      () => fromToPoint(snapLoc, wFunc(snapLoc, -.5), hFunc(snapLoc, -.5)));
	  return snapLoc;
	}
	SnapSquare.backRight = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "backRight",
	      () => fromToPoint(snapLoc, wFunc(snapLoc, .5), hFunc(snapLoc, -.5)));
	  return snapLoc;
	}
	
	SnapSquare.frontRight = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontRight",
	      () => fromToPoint(snapLoc, wFunc(snapLoc, .5), hFunc(snapLoc, .5)));
	  return snapLoc;
	}
	SnapSquare.frontLeft = (parent) => {
	  const snapLoc = new SnapLocation2d(parent, "frontLeft",
	      () => fromToPoint(snapLoc, wFunc(snapLoc, -.5), hFunc(snapLoc, .5)));
	  return snapLoc;
	}
	
	module.exports = SnapSquare;
	
});


RequireJS.addFunction('./services/cabinet/generated/html-templates.js',
function (require, exports, module) {
	
exports['101748844'] = (get, $t) => 
			`<span class='pad ` +
			$t.clean(get("class")) +
			`' index='` +
			$t.clean(get("$index")) +
			`'> ` +
			$t.clean(get("input").html()) +
			` </span>`
	
	exports['115117775'] = (get, $t) => 
			`<div ` +
			$t.clean(get("hideAll")(get("properties")) ? 'hidden' : '') +
			`> <div class="property-container close" radio-id='666'> <div class='` +
			$t.clean(get("key") ? "expand-header" : "") +
			`'> ` +
			$t.clean(get("key")) +
			` </div> <div id='config-expand-list-` +
			$t.clean(get("childIdMap")[get("key")]) +
			`' hidden> ` +
			$t.clean(get("childIdMap")[get("key")]) +
			` </div> </div> </div>`
	
	exports['184800797'] = (get, $t) => 
			`<option value='` +
			$t.clean(get("section").prototype.constructor.name) +
			`' ` +
			$t.clean(get("opening").coverType() === get("section").name ? 'selected' : '') +
			`> ` +
			$t.clean(get("section").name.toSentance().replace('Section', '')) +
			` </option>`
	
	exports['550500469'] = (get, $t) => 
			`<span > <input list='auto-fill-list-` +
			$t.clean(get("input").id() +
			get("willFailCheckClassnameConstruction")()) +
			` expand-list-` +
			$t.clean(get("type")()) +
			`-input' id='` +
			$t.clean(get("input").id()) +
			`' placeholder='` +
			$t.clean(get("input").placeholder) +
			`' type='text'> <datalist id="auto-fill-list-` +
			$t.clean(get("input").id()) +
			`"> ` +
			$t.clean( new $t('-1921787246').render(get("input").autofill(), 'option', get)) +
			` </datalist> </span>`
	
	exports['714657883'] = (get, $t) => 
			`<div >` +
			$t.clean(get("groupHtml")(get("group"))) +
			`</div>`
	
	exports['800055541'] = (get, $t) => 
			`<div class='divison-section-cnt' index='` +
			$t.clean(get("$index")) +
			`'> ` +
			$t.clean(get("OpenSectionDisplay").html(get("opening").sectionProperties())) +
			` </div>`
	
	exports['987967094'] = (get, $t) => 
			`<span > <label>` +
			$t.clean(get("property").name()) +
			`</label> <input class='transparent' type='radio' name='UNIT2' prop-radio-update='` +
			$t.clean(get("property").id()) +
			`' value="` +
			$t.clean(get("property").name()) +
			`" ` +
			$t.clean(get("property").value() === true ? 'checked' : '') +
			`> </span>`
	
	exports['990870856'] = (get, $t) => 
			`<div class='inline' > <h3>` +
			$t.clean(get("assem").objId) +
			`</h3> <div> ` +
			$t.clean(get("getFeatureDisplay")(get("assem"))) +
			` </div> </div>`
	
	exports['1036581066'] = (get, $t) => 
			`<div class='tab' > ` +
			$t.clean(get("property").name()) +
			` (` +
			$t.clean(get("property").code()) +
			`) </div>`
	
	exports['1410278299'] = (get, $t) => 
			`<span > <label>` +
			$t.clean(get("property").name()) +
			`</label> <input type='radio' name='` +
			$t.clean(get("key")) +
			`' prop-radio-update='` +
			$t.clean(get("property").id()) +
			`' ` +
			$t.clean(get("property").value() === true ? 'checked' : '') +
			`> </span>`
	
	exports['1417643187'] = (get, $t) => 
			`<li name='` +
			$t.clean(get("property").name()) +
			`'> ` +
			$t.clean(get("property").name()) +
			` </li>`
	
	exports['1447370576'] = (get, $t) => 
			`<div class="expandable-list-body" key='` +
			$t.clean(get("key")) +
			`'> <div class="expand-item"> <button class='expandable-item-rm-btn' ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'>X</button> <div class="expand-header ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> ` +
			$t.clean(get("getHeader")(get("item"), get("key"))) +
			` </div> <div class="expand-body ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> ` +
			$t.clean(get("getBody") && get("getBody")(get("item"), get("key"))) +
			` </div> </div> </div>`
	
	exports['1630257666'] = (get, $t) => 
			`<div part-id='` +
			$t.clean(get("part").id()) +
			`' part-code='` +
			$t.clean(get("part").partCode()) +
			`' class='model-state ` +
			$t.clean(get("tdm").isTarget("part-id", get("part").id()) ? "active " : "") +
			`' ` +
			$t.clean(get("partList").length === 1 ? 'hidden' : '') +
			`> <label type='part-id' part-id='` +
			$t.clean(get("part").id()) +
			`' part-code='` +
			$t.clean(get("part").partCode()) +
			`'> ` +
			$t.clean(get("part").partCode()) +
			`-` +
			$t.clean(get("$index") +
			1) +
			` </label> <input type='checkbox' class='part-id-checkbox' part-id='` +
			$t.clean(get("part").id()) +
			`' part-code='` +
			$t.clean(get("part").partCode()) +
			`' ` +
			$t.clean(!get("tdm").hidePartId(get("part").id()) ? 'checked' : '') +
			`> </div>`
	
	exports['1835219150'] = (get, $t) => 
			`<option value='` +
			$t.clean(get("isArray")() ? get("value") : get("key")) +
			`' ` +
			$t.clean(get("selected")(get("isArray")() ? get("value") : get("key")) ? 'selected' : '') +
			`> ` +
			$t.clean(get("value")) +
			` </option>`
	
	exports['1927703609'] = (get, $t) => 
			`<div > ` +
			$t.clean(get("recurse")(get("key"), get("group"))) +
			` </div>`
	
	exports['2055573719'] = (get, $t) => 
			`<div > ` +
			$t.clean(get("CostManager").headHtml(get("child"))) +
			` ` +
			$t.clean(get("CostManager").bodyHtml(get("child"))) +
			` </div>`
	
	exports['auto-save'] = (get, $t) => 
			`<div> <button type="button" class='auto-save-btn' name="button">Auto Save</button> <span class='status'></span> </div> `
	
	exports['expandable/input-repeat'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('550500469').render(get("inputs")(), 'input', get)) +
			` <button ex-list-id='` +
			$t.clean(get("id")()) +
			`' class='expandable-list-add-btn' ` +
			$t.clean(get("hideAddBtn") ? 'hidden' : '') +
			`> Add ` +
			$t.clean(get("listElemLable")()) +
			` here </button> <div class='error' id='` +
			$t.clean(get("ERROR_CNT_ID")) +
			`'></div> </div> `
	
	exports['-1921787246'] = (get, $t) => 
			`<option value="` +
			$t.clean(get("option")) +
			`" ></option>`
	
	exports['expandable/list'] = (get, $t) => 
			` <div class="expandable-list ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> ` +
			$t.clean( new $t('1447370576').render(get("list")(), 'key, item', get)) +
			` <div class='expand-input-cnt' hidden has-input-tree='` +
			$t.clean(get("hasInputTree")()) +
			`'>` +
			$t.clean(get("inputHtml")()) +
			`</div> <div class='input-open-cnt'><button>Add ` +
			$t.clean(get("listElemLable")()) +
			`</button></div> </div> `
	
	exports['expandable/pill'] = (get, $t) => 
			` <div class="expandable-list ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> <div class="expand-list-cnt ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> ` +
			$t.clean( new $t('-2108278621').render(get("list")(), 'key, item', get)) +
			` <div class='input-open-cnt'><button>Add ` +
			$t.clean(get("listElemLable")()) +
			`</button></div> </div> <div> <div class='expand-input-cnt' hidden>` +
			$t.clean(get("inputHtml")()) +
			`</div> <br> <div class='error' id='` +
			$t.clean(get("ERROR_CNT_ID")()) +
			`'></div> </div> <div class='expand-tab'> <div class="expand-body ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'></div> </div> </div> `
	
	exports['-2108278621'] = (get, $t) => 
			`<div key='` +
			$t.clean(get("key")) +
			`'> <div class="expand-item"> <div class='expand-rm-btn-cnt'> <button class='expandable-item-rm-btn' ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'>X</button> </div> <div class="expand-header ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> ` +
			$t.clean(get("getHeader")(get("item"), get("key"))) +
			` </div> </div> </div>`
	
	exports['expandable/top-add-list'] = (get, $t) => 
			` <div class="expandable-list ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> <div class='expand-input-cnt' hidden has-input-tree='` +
			$t.clean(get("hasInputTree")()) +
			`'>` +
			$t.clean(get("inputHtml")()) +
			`</div> <div class='input-open-cnt'><button>Add ` +
			$t.clean(get("listElemLable")()) +
			`</button></div> ` +
			$t.clean( new $t('1447370576').render(get("list")(), 'key, item', get)) +
			` </div> `
	
	exports['expandable/sidebar'] = (get, $t) => 
			` <div class="expandable-list ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> <div class="expand-list-cnt ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`'> ` +
			$t.clean( new $t('-688234735').render(get("list")(), 'key, item', get)) +
			` <div class='expand-input-cnt' hidden>` +
			$t.clean(get("inputHtml")()) +
			`</div> <div class='input-open-cnt'><button>Add ` +
			$t.clean(get("listElemLable")()) +
			`</button></div> </div> <div> </div> <div class="expand-body ` +
			$t.clean(get("type")()) +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> Hello World! </div> </div> `
	
	exports['-688234735'] = (get, $t) => 
			`<div class="expandable-list-body" key='` +
			$t.clean(get("key")) +
			`'> <div class="expand-item"> <div class='expand-rm-btn-cnt'> <button class='expandable-item-rm-btn' ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'>X</button> </div> <div class="expand-header ` +
			$t.clean(get("type")()) +
			` ` +
			$t.clean(get("activeKey")() === get("key") ? ' active' : '') +
			`" ex-list-id='` +
			$t.clean(get("id")()) +
			`' key='` +
			$t.clean(get("key")) +
			`'> ` +
			$t.clean(get("getHeader")(get("item"), get("key"))) +
			` </div> </div> </div>`
	
	exports['input/decision/decision'] = (get, $t) => 
			` <span class='decision-input-cnt' node-id='` +
			$t.clean(get("_nodeId")) +
			`' ` +
			$t.clean(get("reachable")() ? '' : 'hidden') +
			`> <span id='` +
			$t.clean(get("id")) +
			`'> ` +
			$t.clean( new $t('101748844').render(get("inputArray"), 'input', get)) +
			` </span> </span> `
	
	exports['input/input'] = (get, $t) => 
			`<` +
			$t.clean(get("inline")() ? 'span' : 'div') +
			` class='input-cnt'` +
			$t.clean(get("hidden")() ? ' hidden' : '') +
			`> <label>` +
			$t.clean(get("label")()) +
			`</label> <input class='` +
			$t.clean(get("class")()) +
			`' list='input-list-` +
			$t.clean(get("id")()) +
			`' id='` +
			$t.clean(get("id")()) +
			`' placeholder='` +
			$t.clean(get("placeholder")()) +
			`' type='` +
			$t.clean(get("type")()) +
			`' name='` +
			$t.clean(get("name")()) +
			`' ` +
			$t.clean(get("attrString")()) +
			`> <datalist id="input-list-` +
			$t.clean(get("id")()) +
			`"> ` +
			$t.clean( new $t('-994603408').render(get("list")(), 'item', get)) +
			` </datalist> <div class='error' id='` +
			$t.clean(get("errorMsgId")()) +
			`' hidden>` +
			$t.clean(get("errorMsg")()) +
			`</div> </` +
			$t.clean(get("inline")() ? 'span' : 'div') +
			`> `
	
	exports['-994603408'] = (get, $t) => 
			`<option value="` +
			$t.clean(get("item")) +
			`" ></option>`
	
	exports['input/decision/decisionTree'] = (get, $t) => 
			`<div class='` +
			$t.clean(get("DecisionInputTree").class) +
			`' root-id='` +
			$t.clean(get("wrapper").nodeId()) +
			`'> ` +
			$t.clean(get("inputHtml")) +
			` <button class='` +
			$t.clean(get("DecisionInputTree").buttonClass) +
			`' root-id='` +
			$t.clean(get("wrapper").nodeId()) +
			`' ` +
			$t.clean(get("tree").hideButton ? 'hidden' : '') +
			`> ` +
			$t.clean(get("tree").buttonText()) +
			` </button> </div> `
	
	exports['input/measurement'] = (get, $t) => 
			`<div class='fit input-cnt'` +
			$t.clean(get("hidden")() ? ' hidden' : '') +
			`> <label>` +
			$t.clean(get("label")()) +
			`</label> <input class='measurement-input ` +
			$t.clean(get("class")()) +
			`' id='` +
			$t.clean(get("id")()) +
			`' value='` +
			$t.clean(get("value")() ? get("value")() : "") +
			`' placeholder='` +
			$t.clean(get("placeholder")()) +
			`' type='` +
			$t.clean(get("type")()) +
			`' name='` +
			$t.clean(get("name")()) +
			`'> <div class='error' id='` +
			$t.clean(get("errorMsgId")()) +
			`' hidden>` +
			$t.clean(get("errorMsg")()) +
			`</div> </div> `
	
	exports['input/data-list'] = (get, $t) => 
			`` +
			$t.clean( new $t('-994603408').render(get("list")(), 'item', get)) +
			` `
	
	exports['input/select'] = (get, $t) => 
			`<` +
			$t.clean(get("inline")() ? 'span' : 'div') +
			` class='input-cnt'` +
			$t.clean(get("hidden")() ? ' hidden' : '') +
			`> <label>` +
			$t.clean(get("label")()) +
			`</label> <select class='` +
			$t.clean(get("class")()) +
			`' id='` +
			$t.clean(get("id")()) +
			`' name='` +
			$t.clean(get("name")()) +
			`' value='` +
			$t.clean(get("value")()) +
			`'> ` +
			$t.clean( new $t('1835219150').render(get("list")(), 'key, value', get)) +
			` </select> <div class='error' id='` +
			$t.clean(get("errorMsgId")()) +
			`' hidden>` +
			$t.clean(get("errorMsg")()) +
			`</div> </` +
			$t.clean(get("inline")() ? 'span' : 'div') +
			`> `
	
	exports['2d/controls'] = (get, $t) => 
			`<div class='orientation-arrows' id='` +
			$t.clean(get("navId")()) +
			`' l-id='` +
			$t.clean(get("id")()) +
			`'> <table class='orientation-arrows-table controls-2d' cellspacing="0" cellpadding="0"> <tbody> <tr><td></td> <td dir='u'>&#8679;</td> <td></td></tr> <tr><td dir='l'>&#8635;</td> <td dir='c'>` +
			$t.clean(get("space")()) +
			`&#` +
			$t.clean(get("centerCode")()) +
			`;` +
			$t.clean(get("space")()) +
			`</td> <td dir='r'>&#8634;</td></tr> <tr><td></td> <td dir='d'>&#8681;</td> <td></td></tr> </tbody> </table> </div> `
	
	exports['2d/pop-up/door-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <table> <tr> <td><label>Height</label></td> <td><input class='value-2d' key='height' value='` +
			$t.clean(get("display")(get("target").height())) +
			`'></td> </tr> <tr> <td><label>Width</label></td> <td><input class='value-2d' key='width' value='` +
			$t.clean(get("display")(get("target").width())) +
			`'></td> </tr> <tr> <td><label>Distance From Floor</label></td> <td><input class='value-2d' key='fromFloor' value='` +
			$t.clean(get("display")(get("target").fromFloor())) +
			`'></td> </tr> <tr> <td> <button class='hinge-btn transparent'>Hinge</button> </td> <td><button class='remove-btn-2d transparent'>Remove</button></td> </tr> </table> </div> `
	
	exports['2d/pop-up/corner-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <table> <tr> <td><label>X</label></td> <td><input class='value-2d' key='x' value='` +
			$t.clean(get("display")(get("target").x())) +
			`'></td> </tr> <tr> <td><label>Y</label></td> <td><input class='value-2d' key='y' value='` +
			$t.clean(get("display")(get("target").y())) +
			`'></td> </tr> <tr> <td><label>Angle</label></td> <td><input class='value-2d' key='angle' value='` +
			$t.clean(get("target").angle()) +
			`' convert='false'></td> </tr> <tr> <td><label>Show Angle</label></td> <td><input class='value-2d' key='showAngle' type='checkbox' convert='false' ` +
			$t.clean(get("target").showAngle ? 'checked' : '') +
			`></td> </tr> <tr> <td colspan="2"><button class='remove-btn-2d transparent'>Remove</button></td> </tr> </table> </div> `
	
	exports['2d/pop-up/layout-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <label>Ceiling Height</label> <input class='value-2d' type="text" key="ceilingHeight" convert='false' value="` +
			$t.clean(get("display")(get("target").ceilingHeight())) +
			`"> </div> `
	
	exports['2d/pop-up/line-measurement-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> ` +
			$t.clean( new $t('987967094').render(get("UNITS"), 'property', get)) +
			` <br> <input type='text' class='measurement-mod transparent' value='` +
			$t.clean(get("target").display()) +
			`'> </div> `
	
	exports['2d/pop-up/snap-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").parent().constructor.name) +
			`' id='` +
			$t.clean(get("target").parent().id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <label>Name</label> <input class='value-2d' member='object' type="text" key="name" value="` +
			$t.clean(get("target").parent().name()) +
			`"> <br><br> <label>Width</label> <input class='value-2d' member='cabinet' type="text" key="width" value="` +
			$t.clean(get("display")(get("target").width())) +
			`"> <br> <label>Depth</label> <input class='value-2d' member='cabinet' type="text" key="thickness" value="` +
			$t.clean(get("display")(get("target").height())) +
			`"> <br> <label>Angle</label> <input class='value-2d' member='snap' type="text" convert='false' key="angle" value="` +
			$t.clean(get("target").angle()) +
			`"> <br> <label>X</label> <input class='value-2d' member='snap' type="text" key="x" value="` +
			$t.clean(get("display")(get("target").x())) +
			`"> <br> <label>Y</label> <input class='value-2d' member='snap' type="text" key="y" value="` +
			$t.clean(get("display")(get("target").y())) +
			`"> <br> <label>From Floor</label> <input class='value-2d' member='bridge' type="text" key="fromFloor" cascade='fromCeiling' value="` +
			$t.clean(get("display")(get("target").parent().fromFloor())) +
			`"> <br> <label>From Ceiling</label> <input class='value-2d' member='bridge' type="text" key="fromCeiling" cascade='fromFloor' value="` +
			$t.clean(get("display")(get("target").parent().fromCeiling())) +
			`"> <br> <button class='remove-btn-2d transparent'>Remove</button> </div> `
	
	exports['2d/pop-up/snap-location-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").parent().constructor.name) +
			`' id='` +
			$t.clean(get("target").parent().id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <div class='which-radio-cnt'` +
			$t.clean(get("scope").snapPartner() ? '' : ' hidden') +
			`> <label>Both</label> <input type="radio" name="which" checked value='Both'> <div class='tab'> <label>` +
			$t.clean(get("name1")()) +
			`</label> <input type="radio" name="which" value="` +
			$t.clean(get("name1")()) +
			`"> <br> <label>` +
			$t.clean(get("name2")()) +
			`</label> <input type="radio" name="which" value="` +
			$t.clean(get("name2")()) +
			`"> </div> <br> </div> <label>` +
			$t.clean(get("scope").partner() ? 'Rotate' : 'Angle') +
			`</label> <input member='snap-loc' type="text" convert='false' name="angle" value="` +
			$t.clean(get("angle")()) +
			`"> <br> <label>X</label> <input member='snap-loc' type="text" name="x" value="` +
			$t.clean(get("display")(get("target").center().x())) +
			`"> <br> <label>Y</label> <input member='snap-loc' type="text" name="y" value="` +
			$t.clean(get("display")(get("target").center().y())) +
			`"> <br> <button class='remove-btn-2d transparent'>Remove</button> <span class='fix-cnt right'` +
			$t.clean(!get("scope").snapPartner() ? '' : ' hidden') +
			`> <label>Fix</label> <input member='snap-loc' type="checkbox" name="fix" value=""> </span> </div> `
	
	exports['2d/pop-up/wall-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <button class='add-door-btn-2d transparent'>Add Door</button> <button class='add-window-btn-2d transparent'>Add Window</button> <button class='add-vertex-btn-2d transparent'>Add Vertex</button> <button class='add-object-btn-2d transparent'>Add Object</button> <button class='remove-btn-2d transparent'>Remove</button> </div> `
	
	exports['2d/pop-up/window-2d'] = (get, $t) => 
			`<div type-2d='` +
			$t.clean(get("target").constructor.name) +
			`' id='` +
			$t.clean(get("target").id()) +
			`' x='` +
			$t.clean(get("lastImagePoint").x) +
			`' y='` +
			$t.clean(get("lastImagePoint").y) +
			`'> <table> <tr> <td><label>Height</label></td> <td><input class='value-2d' key='height' value='` +
			$t.clean(get("display")(get("target").height())) +
			`'></td> </tr> <tr> <td><label>Width</label></td> <td><input class='value-2d' key='width' value='` +
			$t.clean(get("display")(get("target").width())) +
			`'></td> </tr> <tr> <td><label>Distance From Floor</label></td> <td><input class='value-2d' key='fromFloor' value='` +
			$t.clean(get("display")(get("target").fromFloor())) +
			`'></td> </tr> <tr> <td colspan="2"><button class='remove-btn-2d'>Remove</button></td> </tr> </table> </div> `
	
	exports['cabinet/body'] = (get, $t) => 
			`<div> <div class='center'> <div class='left'> <label>Show Left</label> <select class="show-left-select"> ` +
			$t.clean( new $t('-970877277').render(get("showTypes"), 'showType', get)) +
			` </select> </div> <div class='property-id-container center inline-flex'>` +
			$t.clean(get("selectHtml")) +
			`</div> <div class='right'> <select class="show-right-select"> ` +
			$t.clean( new $t('-970877277').render(get("showTypes"), 'showType', get)) +
			` </select> <label>Show Right</label> </div> </div> <br> <div class='center'> <button class='save-cabinet-btn' index='` +
			$t.clean(get("$index")) +
			`'>Save</button> </div> ` +
			$t.clean( new $t('800055541').render(get("cabinet").openings, 'opening', get)) +
			` </div> `
	
	exports['-970877277'] = (get, $t) => 
			`<option >` +
			$t.clean(get("showType").name) +
			`</option>`
	
	exports['cabinet/head'] = (get, $t) => 
			`<div class='cabinet-header' cabinet-id='` +
			$t.clean(get("cabinet").id()) +
			`'> ` +
			$t.clean(get("$index")) +
			`) <input class='cabinet-id-input' name='name' prop-update='` +
			$t.clean(get("$index")) +
			`.name' index='` +
			$t.clean(get("$index")) +
			`' display-id='` +
			$t.clean(get("displayId")) +
			`' value='` +
			$t.clean(get("cabinet").name()) +
			`'> Size: <div class='cabinet-dem-cnt' cabinet-id='` +
			$t.clean(get("cabinet").id()) +
			`'> <label>W:</label> <input class='cabinet-id-input dem' prop-update='` +
			$t.clean(get("$index")) +
			`.width' name='width' display-id='` +
			$t.clean(get("displayId")) +
			`' value='` +
			$t.clean(get("displayValue")(get("cabinet").width())) +
			`'> <label>H:</label> <input class='cabinet-id-input dem' prop-update='` +
			$t.clean(get("$index")) +
			`.length' name='length' display-id='` +
			$t.clean(get("displayId")) +
			`' value='` +
			$t.clean(get("displayValue")(get("cabinet").length())) +
			`'> <label>D:</label> <input class='cabinet-id-input dem' prop-update='` +
			$t.clean(get("$index")) +
			`.thickness' name='thickness' display-id='` +
			$t.clean(get("displayId")) +
			`' value='` +
			$t.clean(get("displayValue")(get("cabinet").thickness())) +
			`'> </div> </div> `
	
	exports['display-manager'] = (get, $t) => 
			`<div class='display-manager' id='` +
			$t.clean(get("id")) +
			`'> ` +
			$t.clean( new $t('-533097724').render(get("list"), 'item', get)) +
			` </div> `
	
	exports['-533097724'] = (get, $t) => 
			`<span class='display-manager-item'> <button class='display-manager-input` +
			$t.clean(get("$index") === 0 ? " active" : "") +
			`' type='button' display-id='` +
			$t.clean(get("item").id) +
			`' link='` +
			$t.clean(get("link")) +
			`'>` +
			$t.clean(get("item").name) +
			`</button> </span>`
	
	exports['divide/body'] = (get, $t) => 
			`<h2>` +
			$t.clean(get("list").activeKey()) +
			`</h2> val: ` +
			$t.clean(get("list").value()('selected')) +
			` `
	
	exports['divide/head'] = (get, $t) => 
			`<div> <div class='open-divider-select` +
			$t.clean(get("sections").length === 0 ? '' : ' hidden') +
			`'> S </div> </div> `
	
	exports['divider-controls'] = (get, $t) => 
			`<div> <label>Dividers:</label> <input class='division-pattern-input' type='text' name='pattern' opening-id='` +
			$t.clean(get("opening").id()) +
			`' value='` +
			$t.clean(get("opening").pattern().str) +
			`'> <span class="open-orientation-radio-cnt"> <label for='open-orientation-horiz-` +
			$t.clean(get("opening").id()) +
			`'>Horizontal:</label> <input type='radio' name='orientation-` +
			$t.clean(get("opening").id()) +
			`' value='horizontal' open-id='` +
			$t.clean(get("opening").id()) +
			`' id='open-orientation-horiz-` +
			$t.clean(get("opening").id()) +
			`' class='open-orientation-radio' ` +
			$t.clean(get("opening").value('vertical') ? '' : 'checked') +
			`> <label for='open-orientation-vert-` +
			$t.clean(get("opening").id()) +
			`'>Vertical:</label> <input type='radio' name='orientation-` +
			$t.clean(get("opening").id()) +
			`' value='vertical' open-id='` +
			$t.clean(get("opening").id()) +
			`' id='open-orientation-vert-` +
			$t.clean(get("opening").id()) +
			`' class='open-orientation-radio' ` +
			$t.clean(get("opening").value('vertical') ? 'checked' : '') +
			`> </span> <div class='open-pattern-input-cnt' opening-id='` +
			$t.clean(get("opening").id()) +
			`' ` +
			$t.clean(get("opening").pattern().equals ? 'hidden' : '') +
			`> ` +
			$t.clean(get("patternInputHtml")) +
			` </div> </div> `
	
	exports['feature'] = (get, $t) => 
			`<h3>Feature Display</h3> `
	
	exports['group/body'] = (get, $t) => 
			`<div class='group-cnt'> <div class='group-header' cab-style='Inset' ` +
			$t.clean(get("group").propertyConfig.isInset() ? '' : 'hidden') +
			`> <h2>Inset <b class='group-key'>` +
			$t.clean(get("group").propertyConfig('Inset').__KEY) +
			`</b></h2> </div> <div class='group-header' cab-style='Overlay' ` +
			$t.clean(!get("group").propertyConfig.isInset() && !get("group").propertyConfig.isReveal() ? '' : 'hidden') +
			`> <h2>Overlay <b class='group-key'>` +
			$t.clean(get("group").propertyConfig('Overlay').__KEY) +
			`</b></h2> </div> <div class='group-header' cab-style='Reveal' ` +
			$t.clean(get("group").propertyConfig.isReveal() ? '' : 'hidden') +
			`> <h2>Reveal <b class='group-key'>` +
			$t.clean(get("group").propertyConfig('Reveal').__KEY) +
			`</b></h2> </div> ` +
			$t.clean(get("propertyHtml")()) +
			` <div class='cabinet-cnt' group-id='` +
			$t.clean(get("group").id()) +
			`'></div> </div> `
	
	exports['group/head'] = (get, $t) => 
			`<div group-display-id='` +
			$t.clean(get("groupDisplay").id()) +
			`'> <div class='expand-header group-display-header active' group-id='` +
			$t.clean(get("group").id()) +
			`'> ` +
			$t.clean(get("$index")) +
			`<input class='group-input' group-id='` +
			$t.clean(get("group").id()) +
			`' value='` +
			$t.clean(get("group").name()) +
			`' prop-update='name'> </div> <div class='group-display-body'>` +
			$t.clean(get("body")) +
			`</div> </div> <br> `
	
	exports['index'] = (get, $t) => 
			`<html lang="en" dir="ltr"> <head> <meta charset="utf-8"> <style> /* #two-d-model { width: 500px; height:500px;} */ div { font-size:x-small; } </style> <script type="text/javascript" src='/cabinet/js/index.js'></script> <link rel="stylesheet" href="/styles/expandable-list.css"> <link rel="stylesheet" href="/cabinet/styles/estimate.css"> <script src="/js/utility-filter.js" run-type='auto'></script> <title>Estimate</title> </head> <body> <button id='menu-btn'>&#8801;</button> <div id='menu' hidden></div> <div id='login'><div id='login-cnt' class='center-all'></div></div> <div id='display-ctn'> <div id='app' name='Orders' ` +
			$t.clean(get("id") !== 'home' ? "link='/cabinet/home'" : '') +
			` hidden> <div id='order-cnt'></div> <div id='model-cnt'> <div id='display-menu'></div> <div id='model-display-cnt'> <canvas id="two-d-model"></canvas> <div id="three-d-model" class="viewer small"> <div class='inline left'> <div id='three-d-orientation-controls'></div> <span id="model-controller"></span> </div> </div> </div> </div> </div> <div name='Property Manager' ` +
			$t.clean(get("id") !== 'home' ? "link='/cabinet/property'" : '') +
			` id='property-manager-cnt' hidden> <div class='center'> <button id='property-manager-save-all'>Save All</button> </div> <div id='property-manager'></div> </div> <div id='cost-manager' "link='/cabinet/cost'" name='Cost Manager' ` +
			$t.clean(get("id") !== 'cost' ? "link='/cabinet/cost'" : '') +
			` hidden></div> <div id='template-manager' name='Template Manager' ` +
			$t.clean(get("id") !== 'template' ? "link='/cabinet/template'" : '') +
			` hidden>Temp Man</div> <div id='pattern-manager' name='Pattern Manager' ` +
			$t.clean(get("id") !== 'home' ? "link='/cabinet/pattern'" : '') +
			` hidden>Pat Man</div> </div> <div id='property-select-cnt'></div> </body> </html> `
	
	exports['login/confirmation-message'] = (get, $t) => 
			`<h3> Check your email for confirmation. </h3> <button id='resend-activation'>Resend</button> `
	
	exports['login/create-account'] = (get, $t) => 
			`<h3>Create An Account</h3> <input type='text' placeholder="email" name='email' value='` +
			$t.clean(get("email")) +
			`'> <input type='password' placeholder="password" name='password' value='` +
			$t.clean(get("password")) +
			`'> <br><br> <button id='register'>Register</button> <br><br> <a href='#' user-state='RESET_PASSWORD'>Reset Passord</a> | <a href='#' user-state='LOGIN'>Login</a> `
	
	exports['login/reset-password'] = (get, $t) => 
			`<h3>Reset Password</h3> <input type='text' placeholder="email" name='email' value='` +
			$t.clean(get("email")) +
			`'> <input type='password' placeholder="password" name='password' value='` +
			$t.clean(get("password")) +
			`'> <br><br> <button id='reset-password'>Reset</button> <br><br> <a href='#' user-state='LOGIN'>Login</a> | <a href='#' user-state='CREATE_ACCOUNT'>Create An Account</a> `
	
	exports['login/login'] = (get, $t) => 
			`<h3>Login</h3> <input type='text' placeholder="email" name='email' value='` +
			$t.clean(get("email")) +
			`'> <input type='password' placeholder="password" name='password' value='` +
			$t.clean(get("password")) +
			`'> <br><br> <button id='login-btn'>Login</button> <br><br> <a href='#' user-state='RESET_PASSWORD'>Reset Passord</a> | <a href='#' user-state='CREATE_ACCOUNT'>Create An Account</a> `
	
	exports['managers/cost/body'] = (get, $t) => 
			`<div hidden> <div> <span> ` +
			$t.clean(get("CostManager").nodeInputHtml()) +
			` <button>Add Cost</button> <button>Add Node</button> </span> <span> Cost Display </span> </div> ` +
			$t.clean( new $t('2055573719').render(get("node").children(), 'child', get)) +
			` </div> `
	
	exports['managers/abstract-manager'] = (get, $t) => 
			`<div> <div class="center"> <h2 id='` +
			$t.clean(get("headerId")) +
			`'> ` +
			$t.clean(get("header")) +
			` <button class='manager-save-btn' id='` +
			$t.clean(get("saveBtnId")) +
			`'>Save</button> </h2> </div> <div id="` +
			$t.clean(get("bodyId")) +
			`"></div> </div> `
	
	exports['managers/cost/head'] = (get, $t) => 
			`<div class='expand-header' node-id='` +
			$t.clean(get("node").nodeId()) +
			`'> <b> ` +
			$t.clean(get("node").payload().name()) +
			` - ` +
			$t.clean(get("node").payload().type()) +
			` </b> <ul> ` +
			$t.clean( new $t('1417643187').render(get("node").payload().requiredProperties, 'property', get)) +
			` </ul> </div> `
	
	exports['managers/cost/main'] = (get, $t) => 
			`<div> <div class="center"> <h2 id='cost-manager-header'> Cost Tree Manager </h2> </div> ` +
			$t.clean( new $t('-496477131').render(get("root")().children(), 'child', get)) +
			` <button id='cost-manager-save-btn'>Save</button> </div> `
	
	exports['-496477131'] = (get, $t) => 
			`<div class='expandable-list cost-tree' radio-id='poo'> ` +
			$t.clean(get("headHtml")(get("child"))) +
			` ` +
			$t.clean(get("bodyHtml")(get("child"))) +
			` </div>`
	
	exports['managers/cost/property-select'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('-1569738859').render(get("groups"), 'group, properties', get)) +
			` </div> `
	
	exports['-1569738859'] = (get, $t) => 
			`<div > <b>` +
			$t.clean(get("group")) +
			` (` +
			$t.clean(get("abbriviation")(get("group"))) +
			`)</b> ` +
			$t.clean( new $t('1036581066').render(get("properties"), 'property', get)) +
			` </div>`
	
	exports['managers/cost/types/labor'] = (get, $t) => 
			`<div cost-id='` +
			$t.clean(get("cost").id()) +
			`'> <b>Labor</b> <span` +
			$t.clean(get("cost").length() === undefined ? ' hidden' : '') +
			`> <input value='` +
			$t.clean(get("cost").length()) +
			`'> </span> <span` +
			$t.clean(get("cost").width() === undefined ? ' hidden' : '') +
			`> <label>X</label> <input value='` +
			$t.clean(get("cost").width()) +
			`'> </span> <span` +
			$t.clean(get("cost").depth() === undefined ? ' hidden' : '') +
			`> <label>X</label> <input value='` +
			$t.clean(get("cost").depth()) +
			`'> </span> <br> <div> <label>Cost</label> <input value='` +
			$t.clean(get("cost").cost()) +
			`'> <label>Per ` +
			$t.clean(get("cost").unitCost('name')) +
			` = ` +
			$t.clean(get("cost").unitCost('value')) +
			`</label> </div> </div> `
	
	exports['managers/cost/types/material'] = (get, $t) => 
			`<div cost-id='` +
			$t.clean(get("cost").id()) +
			`'> <b>Material</b> <span` +
			$t.clean(get("cost").length() === undefined ? ' hidden' : '') +
			`> <input value='` +
			$t.clean(get("cost").length()) +
			`'> </span> <span` +
			$t.clean(get("cost").width() === undefined ? ' hidden' : '') +
			`> <label>X</label> <input value='` +
			$t.clean(get("cost").width()) +
			`'> </span> <span` +
			$t.clean(get("cost").depth() === undefined ? ' hidden' : '') +
			`> <label>X</label> <input value='` +
			$t.clean(get("cost").depth()) +
			`'> </span> <br> <div> <label>Cost</label> <input value='` +
			$t.clean(get("cost").cost()) +
			`'> <label>Per ` +
			$t.clean(get("cost").unitCost('name')) +
			` = ` +
			$t.clean(get("cost").unitCost('value')) +
			`</label> </div> </div> `
	
	exports['managers/property/body'] = (get, $t) => 
			`<div> No Need </div> `
	
	exports['managers/property/header'] = (get, $t) => 
			`<div> <b>` +
			$t.clean(get("instance").name) +
			` (` +
			$t.clean(get("instance").constructor.code) +
			`) - ` +
			$t.clean(get("instance").value) +
			`</b> </div> `
	
	exports['managers/template/body'] = (get, $t) => 
			`<div class='template-body' template-id=` +
			$t.clean(get("template").id()) +
			`> <div class='inline-flex full-width'> <h4 class='nowrap'>` +
			$t.clean(get("template").type()) +
			`</h4> <div class='full-width'> <button class='copy-template right'>Copy</button> <button class='paste-template right'>Paste</button> </div> </div> <label>Automatic Toekick</label> <input type="checkbox" name="autoToeKick" ` +
			$t.clean(get("template").autoToeKick() ? 'checked' : '') +
			`> <br> <label>Height from floor:</label> <input class='cabinet-input dem' type="text" name="fromFloor" value="` +
			$t.clean(get("template").fromFloor()) +
			`"> <input class='cabinet-input' type="text" name="fromFloorValue" disabled> <br> <div class='inline-flex'> <label>Demensions: </label> <span> <input class='cabinet-input dem' type="text" name="width" value="` +
			$t.clean(get("toDisplay")(get("template").width())) +
			`"> X <input class='cabinet-input dem' type="text" name="height" value="` +
			$t.clean(get("toDisplay")(get("template").height())) +
			`"> X <input class='cabinet-input dem' type="text" name="thickness" value="` +
			$t.clean(get("toDisplay")(get("template").thickness())) +
			`"> <br> <input class='cabinet-input' type="text" name="widthValue" disabled> X <input class='cabinet-input' type="text" name="heightValue" disabled> X <input class='cabinet-input' type="text" name="thicknessValue" disabled> </span> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Values</div> <div hidden class="` +
			$t.clean(get("containerClasses").values) +
			`"></div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Subassemblies</div> <div hidden class="` +
			$t.clean(get("containerClasses").subassemblies) +
			`">2</div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Joints</div> <div hidden class="` +
			$t.clean(get("containerClasses").joints) +
			`">3</div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Divider Joint</div> <div hidden class="` +
			$t.clean(get("containerClasses").dividerJoint) +
			`"> ` +
			$t.clean(get("dividerJointInput").html()) +
			` </div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>Openings</div> <div hidden class="` +
			$t.clean(get("containerClasses").openings) +
			`">5</div> </div> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='cabinet-template-input-cnt'> <div class='expand-header'>View Shape</div> <div hidden> <div template-id='` +
			$t.clean(get("template").id()) +
			`' class='layout-shape-display'> <canvas class="top-sketch" width="200" height="200"></canvas> <canvas class="front-sketch" width="200" height="200"></canvas> </div> </div> </div> </div> `
	
	exports['managers/template/head'] = (get, $t) => 
			`<div> <b>` +
			$t.clean(get("template").type()) +
			`</b> </div> `
	
	exports['managers/template/joints/body'] = (get, $t) => 
			`<div> <b> Sorry, I havent made a way to auto configure joints. So you'll have to help me out. </b> <div class='tab'> <b>Center Axis</b> <div class='tab'> Tells me what direction to offset the center of the Male part. </div> <br> <b>Demension Axis</b> <div class='tab'> Tells me what demension to expand by the given depth.(Prerotation) </div> </div> </div> ` +
			$t.clean(get("jointInput").html()) +
			` <input type="text" name="value" disabled > <input type="checkbox" name="convert" checked> `
	
	exports['managers/template/joints/head'] = (get, $t) => 
			`<b> <input class='template-input' value='` +
			$t.clean(get("obj").malePartCode) +
			`' attr='joints' placeholder='Male Part Code' name='malePartCode'> => <input class='template-input' value='` +
			$t.clean(get("obj").femalePartCode) +
			`' attr='joints' placeholder='Female Part Code' name='femalePartCode'> </b> `
	
	exports['managers/template/main'] = (get, $t) => 
			`<div template-manager=` +
			$t.clean(get("id")()) +
			`> <div class='section-properties'> <br> <label>Inset</label> <input class='style-selector' type="radio" name="style" value="Inset" ` +
			$t.clean(get("sectionState").style === 'Inset' ? 'checked' : '') +
			`> <label>overlay</label> <input class='style-selector' type="radio" name="style" value="Overlay" ` +
			$t.clean(get("sectionState").style === 'Overlay' ? 'checked' : '') +
			`> <label>Reveal</label> <input class='style-selector' type="radio" name="style" value="Reveal" ` +
			$t.clean(get("sectionState").style === 'Reveal' ? 'checked' : '') +
			`> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <label>Door</label> <input type="radio" name='sectionType' value="DoorSection"> <label>Drawer</label> <input type="radio" name='sectionType' value="DrawerSection"> <label>Duel Door</label> <input type="radio" name='sectionType' value="DualDoorSection"> <label>False Front</label> <input type="radio" name='sectionType' value="FalseFrontSection"> <label>Open</label> <input type="radio" name='sectionType' value=""> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <label>Divider Count</label> <input id='template-divider-count-input' type="number" name="count" min='0' max='3' value=0> <label>Vertical</label> <input type="checkbox" name="vertical"> <label>Test</label> <input type="checkbox" name="testDividers"> </div> <div id='` +
			$t.clean(get("parentId")()) +
			`'></div> <div class='center center-vert' id='opening-sketch-cnt'></div> </div> `
	
	exports['managers/template/openings/body'] = (get, $t) => 
			`<div> <h4>Opening Border Part Codes</h4> <div class='tab border-part-code-cnt'> ` +
			$t.clean(get("select").html()) +
			` <input class='opening-part-code-input' attr='openings' name='partCode' value="` +
			$t.clean(get("obj")[get("select").value()]) +
			`"> </div> <h4>Opening Border Locations</h4> <div class='tab'> Definition Type: <div class='tab'> <label>Default</label> <input class='opening-type-selector' type='radio' name="definitionType-` +
			$t.clean(get("obj").id) +
			`" value='Default' ` +
			$t.clean(get("obj")._Type === undefined ? 'checked' : '') +
			`> <label>Manual</label> <input class='opening-type-selector' type='radio' name="definitionType-` +
			$t.clean(get("obj").id) +
			`" value='location' ` +
			$t.clean(get("obj")._Type === 'location' ? 'checked' : '') +
			`> <label>Slice (L/R)</label> <input class='opening-type-selector' type='radio' name="definitionType-` +
			$t.clean(get("obj").id) +
			`" value='slice' ` +
			$t.clean(get("obj")._Type === 'slice' ? 'checked' : '') +
			`> </div> <div class='border-location-cnt' ` +
			$t.clean(get("obj")._Type === 'location' ? '' : 'hidden') +
			`> <label>Inner</label> <input type="radio" name="innerOouter-` +
			$t.clean(get("obj").id) +
			`" value="true" ` +
			$t.clean(get("state").innerOouter === 'true' ? 'checked' : '') +
			`> <label>Outer</label> <input type="radio" name="innerOouter-` +
			$t.clean(get("obj").id) +
			`" value="false" ` +
			$t.clean(get("state").innerOouter === 'false' ? 'checked' : '') +
			`> <br><br> <label>Vertex:</label> <br> ` +
			$t.clean( new $t('-182533851').render('0..4', 'i', get)) +
			` <br><br> <label>X</label> <input type="radio" name="xOyOz-` +
			$t.clean(get("obj").id) +
			`" value="x" ` +
			$t.clean(get("state").xOyOz === 'x' ? 'checked' : '') +
			`> <label>Y</label> <input type="radio" name="xOyOz-` +
			$t.clean(get("obj").id) +
			`" value="y" ` +
			$t.clean(get("state").xOyOz === 'y' ? 'checked' : '') +
			`> <label>Z</label> <input type="radio" name="xOyOz-` +
			$t.clean(get("obj").id) +
			`" value="z" ` +
			$t.clean(get("state").xOyOz === 'z' ? 'checked' : '') +
			`> <br><br> <input type='text' name='opening-coordinate-value' value=''> </div> <div class='border-slice-cnt' ` +
			$t.clean(get("obj")._Type === 'slice' ? '' : 'hidden') +
			`> Left Side Depth <input type='text' name='leftDepth' value='` +
			$t.clean(get("leftDepth")) +
			`'> <br> Right Side Depth <input type='text' name='rightDepth' value='` +
			$t.clean(get("rightDepth")) +
			`'> </div> <div class='opening-location-value-cnt'></div> <div class='opening-location-description-cnt'></div> </div> </div> `
	
	exports['-182533851'] = (get, $t) => 
			`<span class='border-location-cnt'> <label>` +
			$t.clean(get("i")) +
			`</label> <input type="radio" name="index-` +
			$t.clean(get("obj").id) +
			`" value="` +
			$t.clean(get("i")) +
			`" ` +
			$t.clean(get("state").index === get("i") ? 'checked' : '') +
			`> </span>`
	
	exports['managers/template/openings/head'] = (get, $t) => 
			`<div class='inline-flex' opening-id='` +
			$t.clean(get("obj").id) +
			`'> Openings </div> `
	
	exports['managers/template/openings/points'] = (get, $t) => 
			`<table> <tr> <td` +
			$t.clean(get("target")(4) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").outer[0])) +
			`</td> <td></td> <td></td> <td` +
			$t.clean(get("target")(5) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").outer[1])) +
			`</td> </tr> <tr> <td></td> <td` +
			$t.clean(get("target")(0) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").inner[0])) +
			`</td> <td` +
			$t.clean(get("target")(1) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").inner[1])) +
			`</td> <td></td> </tr> <tr> <td></td> <td` +
			$t.clean(get("target")(3) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").inner[3])) +
			`</td> <td` +
			$t.clean(get("target")(2) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").inner[2])) +
			`</td> <td></td> </tr> <tr> <td` +
			$t.clean(get("target")(7) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").outer[3])) +
			`</td> <td></td> <td></td> <td` +
			$t.clean(get("target")(6) ? ' class="bold"' : '') +
			`>` +
			$t.clean(get("display")(get("coords").outer[2])) +
			`</td> </tr> </table> `
	
	exports['managers/template/subassemblies/body'] = (get, $t) => 
			`<div template-attr='subassembles'> <div> <label>All</label> <input class='template-include' type='radio' name='is-` +
			$t.clean(get("obj").id) +
			`' value='All' ` +
			$t.clean(get("obj").include === 'All' ? 'checked' : '') +
			`> <label>Overlay</label> <input class='template-include' type='radio' name='is-` +
			$t.clean(get("obj").id) +
			`' value='Overlay' ` +
			$t.clean(get("obj").include === 'Overlay' ? 'checked' : '') +
			`> <label>Reveal</label> <input class='template-include' type='radio' name='is-` +
			$t.clean(get("obj").id) +
			`' value='Reveal' ` +
			$t.clean(get("obj").include === 'Reveal' ? 'checked' : '') +
			`> <label>Inset</label> <input class='template-include' type='radio' name='is-` +
			$t.clean(get("obj").id) +
			`' value='Inset' ` +
			$t.clean(get("obj").include === 'Inset' ? 'checked' : '') +
			`> </div> <label>Name</label> <input class='template-input' attr='subassemblies' name="name" value="` +
			$t.clean(get("obj").name) +
			`"> <br> <div class='sub-demensions-cnt inline-flex'> ` +
			$t.clean(get("demensionXyzSelect").html()) +
			` <input class='template-input' attr='subassemblies' name='demensions' value='` +
			$t.clean(get("getEqn")(get("demensionXyzSelect"), get("obj").demensions)) +
			`'> <input disabled class='measurement-input' name='value'> <input type="checkbox" name="convert" checked> </div> <br> <div class='sub-center-cnt inline-flex'> ` +
			$t.clean(get("centerXyzSelect").html()) +
			` <input class='template-input' attr='subassemblies' name='center' value='` +
			$t.clean(get("getEqn")(get("centerXyzSelect"), get("obj").center)) +
			`'> <input disabled class='measurement-input' name='value'> <input type="checkbox" name="convert" checked> </div> <br> <div class='sub-center-cnt inline-flex'> ` +
			$t.clean(get("rotationXyzSelect").html()) +
			` <input class='template-input' attr='subassemblies' name='rotation' value='` +
			$t.clean(get("getEqn")(get("rotationXyzSelect"), get("obj").rotation)) +
			`'> <input disabled class='measurement-input' name='value'> </div> </div> `
	
	exports['managers/template/subassemblies/head'] = (get, $t) => 
			`<label>Part Code</label> <input class='template-input' attr='subassemblies' name='code' value="` +
			$t.clean(get("obj").code) +
			`"> ` +
			$t.clean(get("typeInput").html()) +
			` `
	
	exports['managers/template/values/head'] = (get, $t) => 
			`<div template-attr='values'> <input class='template-input' attr='values' type='text' name='name' value='` +
			$t.clean(get("obj").key) +
			`' placeholder="Variable Name"> <input class='measurement-input' type='text' name='value' value='` +
			$t.clean(get("obj").eqn) +
			`' placeholder="Value" disabled> <input type="checkbox" name="convert" checked> <br> <input class='template-input full-width' attr='values' type='text' name='eqn' value='` +
			$t.clean(get("obj").eqn) +
			`' placeholder="Equation"> </div> `
	
	exports['model-controller'] = (get, $t) => 
			`<div class='` +
			$t.clean(get("group").level < 2 ? '' : 'model-selector indent') +
			`' ` +
			$t.clean(get("group").level < 2 ? '' : 'hidden') +
			`> <div class='model-state ` +
			$t.clean(get("tdm").isTarget("prefix", get("group").prefix) ? "active " : "") +
			` ` +
			$t.clean(get("label") ? "prefix-switch" : "") +
			`'> <label type='prefix'>` +
			$t.clean(get("label")) +
			`</label> <input type='checkbox' class='prefix-checkbox' prefix='` +
			$t.clean(get("group").prefix) +
			`' ` +
			$t.clean(!get("tdm").hidePrefix(get("label")) ? 'checked' : '') +
			` ` +
			$t.clean(get("group").level === 0 ? 'hidden' : '') +
			`> <div class='model-container'> ` +
			$t.clean( new $t('-1234745150').render(get("group").parts, 'partName, partList', get)) +
			` </div> ` +
			$t.clean( new $t('model-controller').render(get("group").groups, 'label, group', get)) +
			` </div> </div> `
	
	exports['-1234745150'] = (get, $t) => 
			`<div class='model-state ` +
			$t.clean(get("group").level < 1 ? '' : 'model-label indent') +
			` ` +
			$t.clean(get("tdm").isTarget("part-name", get("partName")) ? " active" : "") +
			`' ` +
			$t.clean(get("group").level < 1 ? '' : 'hidden') +
			`> <label type='part-name' part-name='` +
			$t.clean(get("partName")) +
			`'> ` +
			$t.clean(get("partName")) +
			`` +
			$t.clean(get("partList").length === 1 ? '(' +
			get("partList")[0].partCode() +
			')' : '') +
			` </label> <input type='checkbox' class='part-name-checkbox' part-name='` +
			$t.clean(get("partName")) +
			`' ` +
			$t.clean(!get("tdm").hidePartName(get("partName")) ? 'checked' : '') +
			`> <div class='indent'> ` +
			$t.clean( new $t('1630257666').render(get("partList"), 'part', get)) +
			` </div> </div>`
	
	exports['opening'] = (get, $t) => 
			`<div class='opening-cnt' opening-id='` +
			$t.clean(get("opening").id()) +
			`'> <div class='divider-controls'> ` +
			$t.clean(get("OpenSectionDisplay").dividerHtml(get("opening"))) +
			` </div> </div> <label>Section Type:</label> <select class='section-selection'> <option>Open</option> ` +
			$t.clean( new $t('184800797').render(get("sections"), 'section', get)) +
			` </select> <div id='` +
			$t.clean(get("openDispId")) +
			`'> </div> `
	
	exports['order/body'] = (get, $t) => 
			`<div order-id='` +
			$t.clean(get("order").id()) +
			`'> <b>` +
			$t.clean(get("order").name()) +
			`</b> <ul id='order-nav' class='center toggle-display-list'> <li class='toggle-display-item active' display-id='builder-display-` +
			$t.clean(get("order").id()) +
			`'>Builder</li> <li class='toggle-display-item' display-id='information-display-` +
			$t.clean(get("order").id()) +
			`'>Information</li> </ul> <div id='builder-display-` +
			$t.clean(get("order").id()) +
			`'> <b>` +
			$t.clean(get("order").name()) +
			`</b> <button class='save-order-btn' index='` +
			$t.clean(get("$index")) +
			`'>Save</button> <div id='room-pills'>RoomPills!</div> </div> <div id='information-display-` +
			$t.clean(get("order").id()) +
			`' hidden> <utility-filter id='uf-info-` +
			$t.clean(get("order").id()) +
			`' edit='true'> [ {"ID":1,"NAME":"Linktype","LEGAL_NAME":"Telephone and Data Systems, Inc.","LOGO_URI":"http://dummyimage.com/349x31.jpg/dddddd/000000","OWNER_ID":988}, {"ID":2,"NAME":"Eare","LEGAL_NAME":"Zymeworks Inc.","LOGO_URI":null,"OWNER_ID":933}, {"ID":3,"NAME":"Ainyx","LEGAL_NAME":"Pacira Pharmaceuticals, Inc.","LOGO_URI":null,"OWNER_ID":960}, {"ID":4,"NAME":"Photobean","LEGAL_NAME":"ArQule, Inc.","LOGO_URI":null,"OWNER_ID":443}, {"ID":5,"NAME":"Zoombeat","LEGAL_NAME":"Domtar Corporation","LOGO_URI":"http://dummyimage.com/83x401.bmp/5fa2dd/ffffff","OWNER_ID":739}] </utility-filter> </div> </div> `
	
	exports['order/builder/body'] = (get, $t) => 
			`<div order-id='` +
			$t.clean(get("order").id()) +
			`'> <b>` +
			$t.clean(get("order").name) +
			`</b> <button class='save-order-btn' index='` +
			$t.clean(get("$index")) +
			`'>Save</button> <div id='room-pills'>RoomPills!</div> </div> `
	
	exports['order/builder/head'] = (get, $t) => 
			`<h3 class='margin-zero'> ` +
			$t.clean(get("order").name) +
			` </h3> `
	
	exports['order/head'] = (get, $t) => 
			`<h3 class='margin-zero'> ` +
			$t.clean(get("order").name()) +
			` </h3> `
	
	exports['order/information/body'] = (get, $t) => 
			`<utility-filter hidden> [ {"ID":1,"NAME":"Linktype","LEGAL_NAME":"Telephone and Data Systems, Inc.","LOGO_URI":"http://dummyimage.com/349x31.jpg/dddddd/000000","OWNER_ID":988}, {"ID":2,"NAME":"Eare","LEGAL_NAME":"Zymeworks Inc.","LOGO_URI":null,"OWNER_ID":933}, {"ID":3,"NAME":"Ainyx","LEGAL_NAME":"Pacira Pharmaceuticals, Inc.","LOGO_URI":null,"OWNER_ID":960}, {"ID":4,"NAME":"Photobean","LEGAL_NAME":"ArQule, Inc.","LOGO_URI":null,"OWNER_ID":443}, {"ID":5,"NAME":"Zoombeat","LEGAL_NAME":"Domtar Corporation","LOGO_URI":"http://dummyimage.com/83x401.bmp/5fa2dd/ffffff","OWNER_ID":739}] </utility-filter> `
	
	exports['order/information/head'] = (get, $t) => 
			`<b>Information</b> `
	
	exports['order-redirect'] = (get, $t) => 
			`<!DOCTYPE html> <html lang="en" dir="ltr"> <head> <meta charset="utf-8"> <title>` +
			$t.clean(get("order").name()) +
			`</title> <data hidden>` +
			$t.clean(get("JSON").stringify(get("order").toJson())) +
			`</data> <script> let stop = false; let urlElem, countdownElem, buttonElem; function postOrder() { const xhr = new XMLHttpRequest(); const url = urlElem.value; const body = 'heyoooo'; xhr.open('post', url, true); xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest'); xhr.setRequestHeader('Access-Control-Allow-Origin', '*'); xhr.setRequestHeader('Content-Type', 'application/json'); xhr.onreadystatechange = function () { if (this.readyState != 4) return; if (this.status == 200) { console.log('success'); } else { console.error('failure'); } } xhr.send(JSON.stringify(body)); return xhr; } window.addEventListener('click', () => { stop = true; urlElem.parentElement.hidden = false; countdownElem.parentElement.hidden = true; }); let count = 15; const countdown = () => { if (count === 0) return postOrder(); if (!stop) { countdownElem.innerText = count--; setTimeout(countdown, 1000); } } window.onload = () => { urlElem = document.getElementById('url-input'); countdownElem = document.getElementById('load-countdown'); buttonElem = document.getElementById('load-btn'); buttonElem.addEventListener('click', postOrder); countdown(); } </script> </head> <body> <div> <h3> Loading '` +
			$t.clean(get("order").name()) +
			`' using url: ` +
			$t.clean(get("url")) +
			` </h3> <h3 id='load-countdown'></h3> <h4> Click anywhare to stop/change url</h4> </div> <div hidden> <input id='url-input' type="text" name="url" value="` +
			$t.clean(get("url")) +
			`"> <button id='load-btn'>Load</button> </div> </body> </html> `
	
	exports['order'] = (get, $t) => 
			`<!DOCTYPE html> <html lang="en" dir="ltr"> <head> <meta charset="utf-8"> <script type="text/javascript" src='/cabinet/js/index.js'></script> <link rel="stylesheet" href="/styles/expandable-list.css"> <link rel="stylesheet" href="/cabinet/styles/estimate.css"> <script src="/js/utility-filter.js" run-type='auto'></script> <title>CComp</title> </head> <body> <div id='order-select-cnt'> <span id='order-selector-cnt' hidden></span> <button type="button" class='auto-save-btn' name="button">Choose Save Location</button> <span id='save-time-cnt'></span> </div> <div class='expandable-list' id='single-order-cnt'> <div class='center'> <input id='order-name-input' class='header-input' size='20' type="text" name="order-name"> <input id='order-version-input' class='header-input' size='20' type="text" name="order-version"> </div> <div id='main-display-menu' class='display-manager center'></div> <div id='display-cnt'> <div id='order-display-cnt'> <div id='order-cnt'> <div id='order-name-save-cnt'></div> <div id='room-cnt'></div> </div> <div id='model-cnt'> <div id='display-menu'></div> <div id='model-display-cnt'> <div id="two-d-model"> <canvas id="two-d-model-canvas"></canvas> <div class='orientation-controls'></div> </div> <div id="three-d-model" class="viewer small"> <div class='inline left'> <div class='orientation-controls'></div> <span id="model-controller"></span> </div> </div> </div> </div> </div> <div id='information-display'> <utility-filter id='uf-order-info' edit='true'> [] </utility-filter> </div> </div> </div> </body> </html> `
	
	exports['orientation-arrows'] = (get, $t) => 
			`<div class='orientation-arrows' id='` +
			$t.clean(get("navId")()) +
			`' l-id='` +
			$t.clean(get("id")()) +
			`'> <table class='orientation-arrows-table orient-arrows' cellspacing="0" cellpadding="0"> <tr><td></td> <td dir='u'>&#8679;</td> <td></td></tr> <tr><td dir='l'>&#8678;</td> <td dir='c'>` +
			$t.clean(get("space")()) +
			`&#8865;` +
			$t.clean(get("space")()) +
			`</td> <td dir='r'>&#8680;</td></tr> <tr><td></td> <td dir='d'>&#8681;</td> <td></td></tr> </table> </div> `
	
	exports['properties/config-body'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('-302479018').render(get("properties"), 'property', get)) +
			` <button class='save-change' properties-id='` +
			$t.clean(get("properties")._ID) +
			`' ` +
			$t.clean(get("changed")(get("properties")._ID) ? '' : 'hidden') +
			`> Save </button> </div> `
	
	exports['-302479018'] = (get, $t) => 
			`<div class='property-cnt' > <label>` +
			$t.clean(get("property").name()) +
			`</label> <span ` +
			$t.clean(get("property").measurementId() ? '' : 'hidden') +
			`> <input type="text" prop-value-update='` +
			$t.clean(get("property").id()) +
			`' value="` +
			$t.clean(get("property").display()) +
			`" measurement-id='` +
			$t.clean(get("property").measurementId()) +
			`'> </span> <span ` +
			$t.clean((typeof (get("property").value())) === 'boolean' ? '' : 'hidden') +
			`> <input type="checkbox" prop-boolean-update='` +
			$t.clean(get("property").id()) +
			`' ` +
			$t.clean(get("property").value() === true ? 'checked' : '') +
			`> </span> </div>`
	
	exports['properties/config-body0'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('-179269626').render(get("properties"), 'property', get)) +
			` <button class='save-change' properties-id='` +
			$t.clean(get("properties")._ID) +
			`' ` +
			$t.clean(get("changed")(get("properties")._ID) ? '' : 'hidden') +
			`> Save </button> </div> `
	
	exports['-179269626'] = (get, $t) => 
			`<div class='property-cnt' > <label>` +
			$t.clean(get("property").name()) +
			`</label> <input type="text" prop-value-update='` +
			$t.clean(get("property").id()) +
			`' value="` +
			$t.clean(get("property").display()) +
			`" measurement-id='` +
			$t.clean(get("property").measurementId()) +
			`'> </div>`
	
	exports['properties/config-head'] = (get, $t) => 
			`` +
			$t.clean(get("name")) +
			` `
	
	exports['properties/config-head0'] = (get, $t) => 
			`` +
			$t.clean(get("name")) +
			` `
	
	exports['properties/properties'] = (get, $t) => 
			`<div class='center'> <div class='center'> <label>UNIT :&nbsp;&nbsp;&nbsp;&nbsp;</label> ` +
			$t.clean( new $t('-766481261').render(get("Properties").UNITS, 'property', get)) +
			` </div> ` +
			$t.clean( new $t('115117775').render(get("values"), 'key, properties', get)) +
			` </div> `
	
	exports['-766481261'] = (get, $t) => 
			`<span > <label>` +
			$t.clean(get("property").name()) +
			`</label> <input type='radio' name='UNIT' prop-radio-update='` +
			$t.clean(get("property").id()) +
			`' value="` +
			$t.clean(get("property").name()) +
			`" ` +
			$t.clean(get("property").value() === true ? 'checked' : '') +
			`> </span>`
	
	exports['properties/properties0'] = (get, $t) => 
			`<div class='center'> <div class='` +
			$t.clean(get("key") ? "property-container close" : "") +
			`' radio-id='` +
			$t.clean(get("radioId")) +
			`' ` +
			$t.clean(get("noChildren")() ? 'hidden' : '') +
			`> <div class='` +
			$t.clean(get("key") ? "expand-header" : "") +
			`'> ` +
			$t.clean(get("label")) +
			` </div> <div` +
			$t.clean(get("key") ? ' hidden' : '') +
			`> <div` +
			$t.clean(get("branch") ? ' hidden' : '') +
			`> <div id='config-expand-list-` +
			$t.clean(get("id")) +
			`'></div> ` +
			$t.clean( new $t('1927703609').render(get("groups"), 'key, group', get)) +
			` </div> </div> </div> </div> `
	
	exports['properties/property-menu'] = (get, $t) => 
			` <div class='cabinet-style-selector-cnt'>` +
			$t.clean(get("styleSelector")()) +
			`</div> Property MeNu `
	
	exports['properties/radio'] = (get, $t) => 
			`<div class='center'> <label>` +
			$t.clean(get("key")) +
			`:&nbsp;&nbsp;&nbsp;&nbsp;</label> ` +
			$t.clean( new $t('1410278299').render(get("values"), 'property', get)) +
			` </div> `
	
	exports['properties/unit'] = (get, $t) => 
			`<div> <label>Standard</label> <input type='radio' name='unit' ` +
			$t.clean(get("unit").value() === 'Imperial (US)' ? 'checked' : '') +
			` value='Imperial (US)'> <label>Metric</label> <input type='radio' name='unit' ` +
			$t.clean(get("unit").value() === 'Metric' ? 'checked' : '') +
			` value='Metric'> </div> `
	
	exports['room/body'] = (get, $t) => 
			`<div> ` +
			$t.clean( new $t('714657883').render(get("room").groups, 'group', get)) +
			` <div> <button class='group-add-btn' room-id='` +
			$t.clean(get("room").id()) +
			`'>Add Group</button> </div> </div> `
	
	exports['room/head'] = (get, $t) => 
			`<b>` +
			$t.clean(get("room").name()) +
			`</b> `
	
	exports['sections/divider'] = (get, $t) => 
			`<h2>Divider: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['sections/door'] = (get, $t) => 
			`<h2>DoorSection(` +
			$t.clean(get("list").activeKey()) +
			`):</h2> <br><br> <div> ` +
			$t.clean( new $t('990870856').render(get("assemblies"), 'assem', get)) +
			` </div> `
	
	exports['sections/drawer'] = (get, $t) => 
			`<h2>Drawer: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['sections/dual-door'] = (get, $t) => 
			`<h2>Dual Door: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['sections/false-front'] = (get, $t) => 
			`<h2>False Front: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['sections/open'] = (get, $t) => 
			`<h2>Open: ` +
			$t.clean(get("list").activeKey()) +
			`</h2> <div class='section-feature-ctn'> ` +
			$t.clean(get("featureDisplay")) +
			` </div> `
	
	exports['three-view'] = (get, $t) => 
			`<div class='three-view-cnt' id='` +
			$t.clean(get("id")()) +
			`'> <div class='three-view-three-d-cnt'> <div class='inline left'> <div class='orientation-controls' id='three-d-orientation-controls'></div> <span id="model-controller"></span> </div> </div> <div class='three-view-two-d-cnt'> <div class='three-view-canvases-cnt inline-flex' id='` +
			$t.clean(get("id")()) +
			`-cnt'> <div class='part-input-cnt center-vert'> <input type="text" name="partSelector" list='part-list'> <datalist id='part-list'></datalist> </div> <div class='center-vert'>Part Code: <b id='three-view-part-code-` +
			$t.clean(get("id")()) +
			`'></b></div> <span class='three-view-canvas-cnt'> <b>Three View Drawing</b> <button class='three-view-draw-string-btn'>Copy Draw String</button> <canvas id="three-view" width="` +
			$t.clean(get("maxDem")()) +
			`" height="` +
			$t.clean(get("maxDem")()) +
			`"></canvas> </span> </div> </div> </div> `
	
});


RequireJS.addFunction('./services/cabinet/public/json/cabinets.json',
function (require, exports, module) {
	module.exports = {
	  "base": {
	  "_TYPE": "CabinetTemplate",
	
	  "ID_ATTRIBUTE": "id",
	  "type": "base",
	  "values": [
	    {
	      "key": "brh",
	      "eqn": "tkb.w + BACK.t + brr"
	    },
	    {
	      "key": "innerWidth",
	      "eqn": "c.w - pwt34 * 2"
	    },
	    {
	      "key": "innerWidthCenter",
	      "eqn": "innerWidth + pwt34"
	    }
	  ],
	  "subassemblies": [
	    {
	      "name": "ToeKickBacker",
	      "type": "Panel",
	      "code": "tkb",
	      "center": [
	        "c.w / 2",
	        "w / 2",
	        "-1*(tkd + (t / 2))"
	      ],
	      "demensions": [
	        "tkh",
	        "innerWidth",
	        "tkbw"
	      ],
	      "rotation": [
	        0,
	        0,
	        90
	      ]
	    },
	    {
	      "name": "Panel.Right",
	      "type": "Divider",
	      "code": "R",
	      "center": [
	        "c.w - (R.t / 2)",
	        "R.l / 2",
	        "(w / -2)"
	      ],
	      "demensions": [
	        "c.t",
	        "c.l",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        90,
	        0
	      ]
	    },
	    {
	      "name": "Panel.Left",
	      "type": "Divider",
	      "code": "L",
	      "center": [
	        "(L.t / 2)",
	        "L.l / 2",
	        " (w/-2)"
	      ],
	      "demensions": [
	        "c.t",
	        "c.l",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        90,
	        0
	      ]
	    },
	    {
	      "name": "Back",
	      "type": "Panel",
	      "code": "BACK",
	      "center": [
	        " w / 2 + R.t",
	        "(BACK.h / 2) + tkh",
	        " -1*(c.t - (t / 2))"
	      ],
	      "demensions": [
	        "innerWidth",
	        "c.l - tkh",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        0,
	        "0"
	      ]
	    },
	    {
	      "name": "Bottom",
	      "type": "Divider",
	      "code": "B",
	      "center": [
	        "c.w / 2",
	        "tkh + (t/2)",
	        "w / -2"
	      ],
	      "demensions": [
	        "c.t - BACK.t",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        90,
	        0
	      ]
	    },
	    {
	      "name": "Top",
	      "type": "Divider",
	      "code": "T",
	      "center": [
	        "c.w / 2",
	        "c.h - pwt34/2",
	        "(w / -2)"
	      ],
	      "demensions": [
	        "(c.t - BACK.t) * .2",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        90,
	        0
	      ]
	    },
	    {
	      "name": "Top",
	      "type": "Panel",
	      "code": "pt2",
	      "center": [
	        "c.w / 2",
	        "c.h - pwt34/2",
	        "-1*(c.t - BACK.t - (w / 2))"
	      ],
	      "demensions": [
	        "(c.t - BACK.t) * .2",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        90,
	        0
	      ]
	    }
	  ],
	  "joints": [
	    {
	      "malePartCode": "T",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "T",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "pt2",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "pt2",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "BACK",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": "0.9525",
	      "demensionAxis": "x",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "BACK",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": "0.9525",
	      "demensionAxis": "x",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "B",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "B",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "B",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "x",
	      "centerAxis": "+y"
	    }
	  ],
	  "dividerJoint": {
	    "type": "Dado",
	    "maleOffset": 0.9525
	  },
	  "shape": "square",
	  "width": 45.72,
	  "height": "baseh",
	  "thickness": "based",
	  "fromFloor": 0,
	  "openings": [
	    {
	      "top": "T",
	      "bottom": "B",
	      "left": "L",
	      "right": "R",
	      "back": "BACK"
	    }
	  ]
	},
	  "corner-wall": {
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "corner-wall",
	    "values": [
	      {
	        "key": "bo",
	        "eqn": "4*2.54"
	      },
	      {
	        "key": "fwr",
	        "eqn": "c.w - lw"
	      },
	      {
	        "key": "fwl",
	        "eqn": "c.t - rw"
	      },
	      {
	        "key": "lw",
	        "eqn": "30.48"
	      },
	      {
	        "key": "rw",
	        "eqn": "30.48"
	      },
	      {
	        "key": "cnrD",
	        "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)"
	      },
	      {
	        "key": "pbw",
	        "eqn": "Math.sqrt((bo+BACK.t)*(bo+BACK.t)*2)"
	      },
	      {
	        "key": "backhyp",
	        "eqn": "Math.sqrt((R.t*R.t)*2)"
	      },
	      {
	        "key": "frontLeftTheta",
	        "eqn": "Math.atan(fwl/fwr)"
	      },
	      {
	        "key": "frontHype",
	        "eqn": "Math.sqrt(fwr*fwr + fwl*fwl)"
	      },
	      {
	        "key": "cutWidth",
	        "eqn": "frontHype * 2"
	      },
	      {
	        "key": "frontHypeCenterD",
	        "eqn": "fwl/2"
	      },
	      {
	        "key": "frontHypeCenterX",
	        "eqn": "fwr/2"
	      },
	      {
	        "key": "cutCenterX",
	        "eqn": "frontHypeCenterX - frontHype * Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "cutCenterD",
	        "eqn": "frontHypeCenterD - frontHype * Math.cos(frontLeftTheta)"
	      },
	      {
	        "key": "backCutterDem",
	        "eqn": "bo*2*Math.sin(Math.toRadians(BACK.r.y))"
	      },
	      {
	        "key": "topInnerLimit",
	        "eqn": "c.h - tid - T.t"
	      },
	      {
	        "key": "topOuterLimit",
	        "eqn": "T.c.y + T.t/2"
	      },
	      {
	        "key": "bottomInnerLimit",
	        "eqn": "bid + B.t"
	      },
	      {
	        "key": "bottomOuterLimit",
	        "eqn": "B.c.y - B.t/2"
	      },
	      {
	        "key": "leftInnerLimit",
	        "eqn": "R.t"
	      },
	      {
	        "key": "leftOuterLimit",
	        "eqn": "0"
	      },
	      {
	        "key": "leftCutTheta",
	        "eqn": "Math.PI - frontLeftTheta - Math.PI12"
	      },
	      {
	        "key": "leftCutT",
	        "eqn": "R.t * Math.sin(leftCutTheta)/ Math.sin(Math.PI12 - leftCutTheta)"
	      },
	      {
	        "key": "rightCutTheta",
	        "eqn": "frontLeftTheta"
	      },
	      {
	        "key": "rightCutX",
	        "eqn": "L.t * Math.sin(rightCutTheta)/ Math.sin(Math.PI12 - rightCutTheta)"
	      },
	      {
	        "key": "rightInnerLimit",
	        "eqn": "fwr - leftCutT"
	      },
	      {
	        "key": "rightOuterLimit",
	        "eqn": "fwr"
	      },
	      {
	        "key": "frontDepthMin",
	        "eqn": 0
	      },
	      {
	        "key": "frontDepthMax",
	        "eqn": "fwl"
	      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - (bo - BACK.t)/2 * Math.sin(Math.PI12)",
	          "c.h/2",
	          "-(c.t - (bo - BACK.t)/2 * Math.sin(Math.PI12))"
	        ],
	        "demensions": [
	          "pbw",
	          "c.h",
	          "pwt14"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Panel.Back",
	        "code": "BACK"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "c.w + bo/4*Math.sin(Math.PI/2)",
	          "c.h/2",
	          "-(c.t + bo/4*Math.sin(Math.PI/2))"
	        ],
	        "demensions": [
	          "bo*2",
	          "c.h",
	          "bo*2"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Cutter.Back",
	        "code": "cb"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "R.w/2",
	          "c.h / 2",
	          "R.t/-2"
	        ],
	        "demensions": [
	          "c.w",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "0",
	          0
	        ],
	        "name": "Panel.Left",
	        "code": "R"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t/2",
	          "c.h/2",
	          "L.w/-2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Right",
	        "code": "L"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pbl.w / 2 + R.t ",
	          "c.h/2",
	          "-(c.t - t / 2)"
	        ],
	        "demensions": [
	          "c.w - bo",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.Back.Left",
	        "code": "pbl"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbr.c.x + cpbl.t",
	          "pbr.c.y",
	          "pbr.c.z"
	        ],
	        "demensions": [
	          "pbr.d.x",
	          "pbr.d.y",
	          "pbr.d.z"
	        ],
	        "rotation": [
	          "pbr.r.x",
	          "pbr.r.y",
	          "pbr.r.z"
	        ],
	        "name": "Cutter.Back.Left",
	        "code": "cpbl"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - pbl.t/2",
	          "c.h/2",
	          "-(pbr.w/2 + L.t)"
	        ],
	        "demensions": [
	          "c.t - bo",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Back.Right",
	        "code": "pbr"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbl.c.x",
	          "pbl.c.y",
	          "pbl.c.z - cpbr.t"
	        ],
	        "demensions": [
	          "pbl.d.x",
	          "pbl.d.y",
	          "pbl.d.z"
	        ],
	        "rotation": [
	          "pbl.r.x",
	          "pbl.r.y",
	          "pbl.r.z"
	        ],
	        "name": "Cutter.Back.Right",
	        "code": "cpbr"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "c.w / 2",
	          "c.h - tid - T.t / 2",
	          "c.t / -2"
	        ],
	        "demensions": [
	          "c.w - pbl.t - R.t",
	          "c.t - pbr.t - L.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Top",
	        "code": "T"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "c.w / 2",
	          "bid + B.t / 2",
	          "c.t / -2"
	        ],
	        "demensions": [
	          "c.w - pbl.t - R.t",
	          "c.t - pbr.t - L.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Bottom",
	        "code": "B"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "cutCenterX",
	          "c.h/2",
	          "-cutCenterD"
	        ],
	        "demensions": [
	          "frontHype * 2",
	          "frontHype*2",
	          "c.h"
	        ],
	        "rotation": [
	          "90",
	          "Math.toDegrees(Math.PI - frontLeftTheta)",
	          0
	        ],
	        "name": "Cutter.Front",
	        "code": "cut"
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "B",
	        "type": "Butt"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "pbl",
	        "type": "Butt"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "pbr",
	        "type": "Butt"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "y",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "pbr",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "pbl",
	        "maleOffset": "pbl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "y",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "pbr",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "pbl",
	        "maleOffset": "pbl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbr",
	        "femalePartCode": "R",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbl",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "BACK",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "B"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "L"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "R"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "B"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbl"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbr"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbl",
	        "femalePartCode": "BACK"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbr",
	        "femalePartCode": "BACK"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": "33"
	    },
	    "shape": "corner",
	    "width": "walld*2",
	    "height": "wallh",
	    "thickness": "walld*2",
	    "fromFloor": "walle",
	    "openings": [
	      {
	        "_Type": "location",
	        "rotation": {
	          "x": 0,
	          "z": 0,
	          "y": "270+ Math.toDegrees(frontLeftTheta)"
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "leftInnerLimit",
	              "y": "topInnerLimit",
	              "z": "-(frontDepthMax - rightCutX)"
	            },
	            {
	              "x": "rightInnerLimit",
	              "y": "topInnerLimit",
	              "z": "-(frontDepthMin + R.t)"
	            },
	            {
	              "x": "rightInnerLimit",
	              "y": "bottomInnerLimit",
	              "z": "-(frontDepthMin + R.t)"
	            },
	            {
	              "x": "leftInnerLimit",
	              "y": "bottomInnerLimit",
	              "z": "-(frontDepthMax - rightCutX)"
	            }
	          ],
	          "outer": [
	            {
	              "x": "leftOuterLimit",
	              "y": "topOuterLimit",
	              "z": "-frontDepthMax"
	            },
	            {
	              "x": "rightOuterLimit",
	              "y": "topOuterLimit",
	              "z": "-frontDepthMin"
	            },
	            {
	              "x": "rightOuterLimit",
	              "y": "bottomOuterLimit",
	              "z": "-frontDepthMin"
	            },
	            {
	              "x": "leftOuterLimit",
	              "y": "bottomOuterLimit",
	              "z": "-frontDepthMax"
	            }
	          ]
	        },
	        "state": {
	          "innerOouter": true,
	          "index": 0,
	          "xOyOz": "z"
	        }
	      }
	    ]
	  },
	  "corner-base": {
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "corner-base",
	    "values": [
	      {
	        "key": "bo",
	        "eqn": "4*2.54"
	      },
	      {
	        "key": "fwl",
	        "eqn": "c.w - lw"
	      },
	      {
	        "key": "fwr",
	        "eqn": "c.t - rw"
	      },
	      {
	        "key": "lw",
	        "eqn": "based"
	      },
	      {
	        "key": "rw",
	        "eqn": "based"
	      },
	      {
	        "key": "cnrD",
	        "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)"
	      },
	      {
	        "key": "pbw",
	        "eqn": "Math.sqrt((bo+BACK.t)*(bo+BACK.t)*2)"
	      },
	      {
	        "key": "backhyp",
	        "eqn": "Math.sqrt((R.t*R.t)*2)"
	      },
	      {
	        "key": "frontLeftTheta",
	        "eqn": "Math.atan(fwl/fwr)"
	      },
	      {
	        "key": "frontRightTheta",
	        "eqn": "Math.PI/2  - frontLeftTheta"
	      },
	      {
	        "key": "frontHype",
	        "eqn": "Math.sqrt(fwl*fwl + fwr*fwr)"
	      },
	      {
	        "key": "cutWidth",
	        "eqn": "frontHype * 2"
	      },
	      {
	        "key": "frontHypeCenterD",
	        "eqn": "fwr/2"
	      },
	      {
	        "key": "frontHypeCenterX",
	        "eqn": "fwl/2"
	      },
	      {
	        "key": "cutCenterX",
	        "eqn": "frontHypeCenterX - frontHype * Math.sin(frontRightTheta)"
	      },
	      {
	        "key": "cutCenterD",
	        "eqn": "frontHypeCenterD - frontHype * Math.cos(frontRightTheta)"
	      },
	      {
	        "key": "backCutterDem",
	        "eqn": "bo*2*Math.sin(Math.toRadians(BACK.r.y))"
	      },
	      {
	        "key": "topInnerLimit",
	        "eqn": "T.c.y - T.t/2"
	      },
	      {
	        "key": "topOuterLimit",
	        "eqn": "T.c.y + T.t/2"
	      },
	      {
	        "key": "bottomInnerLimit",
	        "eqn": "B.c.y + B.t/2"
	      },
	      {
	        "key": "bottomOuterLimit",
	        "eqn": "B.c.y - B.t/2"
	      },
	      {
	        "key": "leftInnerLimit",
	        "eqn": "R.t"
	      },
	      {
	        "key": "leftOuterLimit",
	        "eqn": "0"
	      },
	      {
	        "key": "leftCutTheta",
	        "eqn": "Math.PI - frontRightTheta - Math.PI12"
	      },
	      {
	        "key": "leftCutT",
	        "eqn": "R.t * Math.sin(leftCutTheta)/ Math.sin(Math.PI12 - leftCutTheta)"
	      },
	      {
	        "key": "rightCutTheta",
	        "eqn": "frontRightTheta"
	      },
	      {
	        "key": "rightCutX",
	        "eqn": "L.t * Math.sin(rightCutTheta)/ Math.sin(Math.PI12 - rightCutTheta)"
	      },
	      {
	        "key": "rightInnerLimit",
	        "eqn": "fwl - leftCutT"
	      },
	      {
	        "key": "rightOuterLimit",
	        "eqn": "fwl"
	      },
	      {
	        "key": "frontDepthMin",
	        "eqn": 0
	      },
	      {
	        "key": "frontDepthMax",
	        "eqn": "fwr"
	      },
	      {
	        "key": "tkLeftT",
	        "eqn": ".5/Math.sin(frontRightTheta)"
	      },
	      {
	        "key": "tkRightT",
	        "eqn": ".5/Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "tkLeftD",
	        "eqn": "frontHypeCenterX + (tkd + tkb.t/2)*Math.sin(frontRightTheta)"
	      },
	      {
	        "key": "tkRightD",
	        "eqn": "frontHypeCenterD + (tkd + tkb.t/2)*Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "toeKickBackerLen",
	        "eqn": "2*Math.sqrt((triX+tkb.t/2)*(triX+tkb.t/2)+(triY+tkb.t\\2)*(triY+tkb.t\\2))"
	      },
	      {
	        "key": "triX",
	        "eqn": "frontDepthMax +  (tkd + tkb.t/2)/Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "triY",
	        "eqn": "rightInnerLimit + (tkd + tkb.t/2)/Math.sin(frontLeftTheta)"
	      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - (bo - BACK.t)/2 * Math.sin(Math.PI12)",
	          "c.h/2",
	          "-(c.t - (bo - BACK.t)/2 * Math.sin(Math.PI12))"
	        ],
	        "demensions": [
	          "pbw",
	          "c.h",
	          "pwt14"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Panel.Back",
	        "code": "BACK"
	      },
	      {
	        "name": "ToeKickBacker",
	        "type": "Panel",
	        "code": "tkb",
	        "center": [
	          "tkLeftD",
	          "tkb.w / 2",
	          "-1 *(tkRightD)"
	        ],
	        "demensions": [
	          "tkh",
	          "toeKickBackerLen",
	          "tkbw"
	        ],
	        "rotation": [
	          "90+Math.toDegrees(frontLeftTheta)",
	          "0",
	          90
	        ]
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "c.w + bo/4*Math.sin(Math.PI/2)",
	          "c.h/2",
	          "-(c.t + bo/4*Math.sin(Math.PI/2))"
	        ],
	        "demensions": [
	          "bo*2",
	          "c.h",
	          "bo*2"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Cutter.Back",
	        "code": "cb"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "R.w/2",
	          "c.h / 2",
	          "R.t/-2"
	        ],
	        "demensions": [
	          "c.w",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "0",
	          0
	        ],
	        "name": "Panel.Right",
	        "code": "R"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "L.c.x - toeKickBackerLen/2",
	          "L.c.y",
	          "L.c.z"
	        ],
	        "demensions": [
	          "toeKickBackerLen",
	          "L.d.y + 1",
	          "toeKickBackerLen"
	        ],
	        "rotation": [
	          "L.r.x",
	          "L.r.y",
	          "L.r.z"
	        ],
	        "name": "CutterTBLeft",
	        "code": "ctbl"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbl.c.x",
	          "pbl.c.y",
	          "pbl.c.z - toeKickBackerLen/2"
	        ],
	        "demensions": [
	          "toeKickBackerLen",
	          "pbl.d.y + 1",
	          "toeKickBackerLen"
	        ],
	        "rotation": [
	          "pbl.r.x",
	          "pbl.r.y",
	          "pbl.r.z"
	        ],
	        "name": "CutterTBLeft2",
	        "code": "ctbl2"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbr.c.x + toeKickBackerLen/2",
	          "pbr.c.y",
	          "pbr.c.z"
	        ],
	        "demensions": [
	          "toeKickBackerLen",
	          "pbr.d.y + 1",
	          "toeKickBackerLen"
	        ],
	        "rotation": [
	          "pbr.r.x",
	          "pbr.r.y",
	          "pbr.r.z"
	        ],
	        "name": "CutterTBRight",
	        "code": "ctbr"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "R.c.x",
	          "R.c.y",
	          "R.c.z + toeKickBackerLen/2"
	        ],
	        "demensions": [
	          "toeKickBackerLen",
	          "R.d.y + 1",
	          "toeKickBackerLen"
	        ],
	        "rotation": [
	          "R.r.x",
	          "R.r.y",
	          "R.r.z"
	        ],
	        "name": "CutterTBRight2",
	        "code": "ctbr2"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t/2",
	          "c.h/2",
	          "L.w/-2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Left",
	        "code": "L"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pbl.w / 2 + R.t ",
	          "c.h/2",
	          "-(c.t - t / 2)"
	        ],
	        "demensions": [
	          "c.w - bo",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.Back.Left",
	        "code": "pbl"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbr.c.x + cpbl.t",
	          "pbr.c.y",
	          "pbr.c.z"
	        ],
	        "demensions": [
	          "pbr.d.x",
	          "pbr.d.y",
	          "pbr.d.z"
	        ],
	        "rotation": [
	          "pbr.r.x",
	          "pbr.r.y",
	          "pbr.r.z"
	        ],
	        "name": "Cutter.Back.Left",
	        "code": "cpbl"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - pbl.t/2",
	          "c.h/2",
	          "-(pbr.w/2 + L.t)"
	        ],
	        "demensions": [
	          "c.t - bo",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Back.Right",
	        "code": "pbr"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbl.c.x",
	          "pbl.c.y",
	          "pbl.c.z - cpbr.t"
	        ],
	        "demensions": [
	          "pbl.d.x",
	          "pbl.d.y",
	          "pbl.d.z"
	        ],
	        "rotation": [
	          "pbl.r.x",
	          "pbl.r.y",
	          "pbl.r.z"
	        ],
	        "name": "Cutter.Back.Right",
	        "code": "cpbr"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "c.w / 2",
	          "c.h - T.t / 2",
	          "c.t / -2"
	        ],
	        "demensions": [
	          "c.w - pbl.t - R.t",
	          "c.t - pbr.t - L.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Top",
	        "code": "T"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "c.w / 2",
	          "tkh + B.t / 2",
	          "c.t / -2"
	        ],
	        "demensions": [
	          "c.w - pbl.t - R.t",
	          "c.t - pbr.t - L.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Bottom",
	        "code": "B"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "cutCenterX",
	          "c.h/2",
	          "-cutCenterD"
	        ],
	        "demensions": [
	          "frontHype * 2",
	          "frontHype*2",
	          "c.h"
	        ],
	        "rotation": [
	          "90",
	          "Math.toDegrees(Math.PI - frontRightTheta)",
	          0
	        ],
	        "name": "Cutter.Front",
	        "code": "cut"
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "B",
	        "type": "Butt"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "pbl",
	        "type": "Butt"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "pbr",
	        "type": "Butt"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "y",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "pbr",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "pbl",
	        "maleOffset": "pbl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "y",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "pbr",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "pbl",
	        "maleOffset": "pbl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbr",
	        "femalePartCode": "R",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbl",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "BACK",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "B"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "L"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "R"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "B"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbl"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbr"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbl",
	        "femalePartCode": "BACK"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbr",
	        "femalePartCode": "BACK"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "tkb",
	        "femalePartCode": "B",
	        "maleOffset": "B.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+y"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "tkb",
	        "femalePartCode": "L"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "tkb",
	        "femalePartCode": "R"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "ctbl",
	        "femalePartCode": "tkb"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "ctbr",
	        "femalePartCode": "tkb"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "ctbl2",
	        "femalePartCode": "tkb"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "ctbr2",
	        "femalePartCode": "tkb"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": "33"
	    },
	    "shape": "corner",
	    "width": "based*1.5",
	    "height": "baseh",
	    "thickness": "based*1.5",
	    "fromFloor": 0,
	    "openings": [
	      {
	        "_Type": "location",
	        "rotation": {
	          "x": 0,
	          "z": 0,
	          "y": "270+ Math.toDegrees(frontRightTheta)"
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "leftInnerLimit",
	              "y": "topInnerLimit",
	              "z": "-(frontDepthMax - rightCutX)"
	            },
	            {
	              "x": "rightInnerLimit",
	              "y": "topInnerLimit",
	              "z": "-(frontDepthMin + R.t)"
	            },
	            {
	              "x": "rightInnerLimit",
	              "y": "bottomInnerLimit",
	              "z": "-(frontDepthMin + R.t)"
	            },
	            {
	              "x": "leftInnerLimit",
	              "y": "bottomInnerLimit",
	              "z": "-(frontDepthMax - rightCutX)"
	            }
	          ],
	          "outer": [
	            {
	              "x": "leftOuterLimit",
	              "y": "topOuterLimit",
	              "z": "-frontDepthMax"
	            },
	            {
	              "x": "rightOuterLimit",
	              "y": "topOuterLimit",
	              "z": "-frontDepthMin"
	            },
	            {
	              "x": "rightOuterLimit",
	              "y": "bottomOuterLimit",
	              "z": "-frontDepthMin"
	            },
	            {
	              "x": "leftOuterLimit",
	              "y": "bottomOuterLimit",
	              "z": "-frontDepthMax"
	            }
	          ]
	        },
	        "state": {
	          "innerOouter": true,
	          "index": 0,
	          "xOyOz": "z"
	        }
	      }
	    ]
	  },
	  "corner-ut": {
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "corner-ut",
	    "values": [
	      {
	        "key": "bo",
	        "eqn": "4*2.54"
	      },
	      {
	        "key": "fwl",
	        "eqn": "c.w - lw"
	      },
	      {
	        "key": "fwr",
	        "eqn": "c.t - rw"
	      },
	      {
	        "key": "lw",
	        "eqn": "based"
	      },
	      {
	        "key": "rw",
	        "eqn": "based"
	      },
	      {
	        "key": "cnrD",
	        "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)"
	      },
	      {
	        "key": "pbw",
	        "eqn": "Math.sqrt((bo+BACK.t)*(bo+BACK.t)*2)"
	      },
	      {
	        "key": "backhyp",
	        "eqn": "Math.sqrt((R.t*R.t)*2)"
	      },
	      {
	        "key": "frontLeftTheta",
	        "eqn": "Math.atan(fwl/fwr)"
	      },
	      {
	        "key": "frontRightTheta",
	        "eqn": "Math.PI/2  - frontLeftTheta"
	      },
	      {
	        "key": "frontHype",
	        "eqn": "Math.sqrt(fwl*fwl + fwr*fwr)"
	      },
	      {
	        "key": "cutWidth",
	        "eqn": "frontHype * 2"
	      },
	      {
	        "key": "frontHypeCenterD",
	        "eqn": "fwr/2"
	      },
	      {
	        "key": "frontHypeCenterX",
	        "eqn": "fwl/2"
	      },
	      {
	        "key": "cutCenterX",
	        "eqn": "frontHypeCenterX - frontHype * Math.sin(frontRightTheta)"
	      },
	      {
	        "key": "cutCenterD",
	        "eqn": "frontHypeCenterD - frontHype * Math.cos(frontRightTheta)"
	      },
	      {
	        "key": "backCutterDem",
	        "eqn": "bo*2*Math.sin(Math.toRadians(BACK.r.y))"
	      },
	      {
	        "key": "topInnerLimit",
	        "eqn": "T.c.y - T.t/2"
	      },
	      {
	        "key": "topOuterLimit",
	        "eqn": "T.c.y + T.t/2"
	      },
	      {
	        "key": "bottomInnerLimit",
	        "eqn": "B.c.y + B.t/2"
	      },
	      {
	        "key": "bottomOuterLimit",
	        "eqn": "B.c.y - B.t/2"
	      },
	      {
	        "key": "leftInnerLimit",
	        "eqn": "R.t"
	      },
	      {
	        "key": "leftOuterLimit",
	        "eqn": "0"
	      },
	      {
	        "key": "leftCutTheta",
	        "eqn": "Math.PI - frontRightTheta - Math.PI12"
	      },
	      {
	        "key": "leftCutT",
	        "eqn": "R.t * Math.sin(leftCutTheta)/ Math.sin(Math.PI12 - leftCutTheta)"
	      },
	      {
	        "key": "rightCutTheta",
	        "eqn": "frontRightTheta"
	      },
	      {
	        "key": "rightCutX",
	        "eqn": "L.t * Math.sin(rightCutTheta)/ Math.sin(Math.PI12 - rightCutTheta)"
	      },
	      {
	        "key": "rightInnerLimit",
	        "eqn": "fwl - leftCutT"
	      },
	      {
	        "key": "rightOuterLimit",
	        "eqn": "fwl"
	      },
	      {
	        "key": "frontDepthMin",
	        "eqn": 0
	      },
	      {
	        "key": "frontDepthMax",
	        "eqn": "fwr"
	      },
	      {
	        "key": "tkLeftT",
	        "eqn": ".5/Math.sin(frontRightTheta)"
	      },
	      {
	        "key": "tkRightT",
	        "eqn": ".5/Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "tkLeftD",
	        "eqn": "frontHypeCenterX + (tkd + tkb.t/2)*Math.sin(frontRightTheta)"
	      },
	      {
	        "key": "tkRightD",
	        "eqn": "frontHypeCenterD + (tkd + tkb.t/2)*Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "toeKickBackerLen",
	        "eqn": "2*Math.sqrt((triX+tkb.t/2)*(triX+tkb.t/2)+(triY+tkb.t\\2)*(triY+tkb.t\\2))"
	      },
	      {
	        "key": "triX",
	        "eqn": "frontDepthMax +  (tkd + tkb.t/2)/Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "triY",
	        "eqn": "rightInnerLimit + (tkd + tkb.t/2)/Math.sin(frontLeftTheta)"
	      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - (bo - BACK.t)/2 * Math.sin(Math.PI12)",
	          "c.h/2",
	          "-(c.t - (bo - BACK.t)/2 * Math.sin(Math.PI12))"
	        ],
	        "demensions": [
	          "pbw",
	          "c.h",
	          "pwt14"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Panel.Back",
	        "code": "BACK"
	      },
	      {
	        "name": "ToeKickBacker",
	        "type": "Panel",
	        "code": "tkb",
	        "center": [
	          "tkLeftD",
	          "w / 2",
	          "-1 *(tkRightD)"
	        ],
	        "demensions": [
	          "tkh",
	          "toeKickBackerLen",
	          "tkbw"
	        ],
	        "rotation": [
	          "90+Math.toDegrees(frontLeftTheta)",
	          "0",
	          90
	        ]
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "c.w + bo/4*Math.sin(Math.PI/2)",
	          "c.h/2",
	          "-(c.t + bo/4*Math.sin(Math.PI/2))"
	        ],
	        "demensions": [
	          "bo*2",
	          "c.h",
	          "bo*2"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Cutter.Back",
	        "code": "cb"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "R.w/2",
	          "c.h / 2",
	          "R.t/-2"
	        ],
	        "demensions": [
	          "c.w",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "0",
	          0
	        ],
	        "name": "Panel.Right",
	        "code": "R"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "L.c.x - toeKickBackerLen/2",
	          "L.c.y",
	          "L.c.z"
	        ],
	        "demensions": [
	          "toeKickBackerLen",
	          "L.d.y + 1",
	          "toeKickBackerLen"
	        ],
	        "rotation": [
	          "L.r.x",
	          "L.r.y",
	          "L.r.z"
	        ],
	        "name": "CutterTBLeft",
	        "code": "ctbl"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbl.c.x",
	          "pbl.c.y",
	          "pbl.c.z - toeKickBackerLen/2"
	        ],
	        "demensions": [
	          "toeKickBackerLen",
	          "pbl.d.y + 1",
	          "toeKickBackerLen"
	        ],
	        "rotation": [
	          "pbl.r.x",
	          "pbl.r.y",
	          "pbl.r.z"
	        ],
	        "name": "CutterTBLeft2",
	        "code": "ctbl2"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbr.c.x + toeKickBackerLen/2",
	          "pbr.c.y",
	          "pbr.c.z"
	        ],
	        "demensions": [
	          "toeKickBackerLen",
	          "pbr.d.y + 1",
	          "toeKickBackerLen"
	        ],
	        "rotation": [
	          "pbr.r.x",
	          "pbr.r.y",
	          "pbr.r.z"
	        ],
	        "name": "CutterTBRight",
	        "code": "ctbr"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "R.c.x",
	          "R.c.y",
	          "R.c.z + toeKickBackerLen/2"
	        ],
	        "demensions": [
	          "toeKickBackerLen",
	          "R.d.y + 1",
	          "toeKickBackerLen"
	        ],
	        "rotation": [
	          "R.r.x",
	          "R.r.y",
	          "R.r.z"
	        ],
	        "name": "CutterTBRight2",
	        "code": "ctbr2"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t/2",
	          "c.h/2",
	          "L.w/-2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Left",
	        "code": "L"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "pbl.w / 2 + R.t ",
	          "c.h/2",
	          "-(c.t - t / 2)"
	        ],
	        "demensions": [
	          "c.w - bo",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.Back.Left",
	        "code": "pbl"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbr.c.x + cpbl.t",
	          "pbr.c.y",
	          "pbr.c.z"
	        ],
	        "demensions": [
	          "pbr.d.x",
	          "pbr.d.y",
	          "pbr.d.z"
	        ],
	        "rotation": [
	          "pbr.r.x",
	          "pbr.r.y",
	          "pbr.r.z"
	        ],
	        "name": "Cutter.Back.Left",
	        "code": "cpbl"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - pbl.t/2",
	          "c.h/2",
	          "-(pbr.w/2 + L.t)"
	        ],
	        "demensions": [
	          "c.t - bo",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Back.Right",
	        "code": "pbr"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "pbl.c.x",
	          "pbl.c.y",
	          "pbl.c.z - cpbr.t"
	        ],
	        "demensions": [
	          "pbl.d.x",
	          "pbl.d.y",
	          "pbl.d.z"
	        ],
	        "rotation": [
	          "pbl.r.x",
	          "pbl.r.y",
	          "pbl.r.z"
	        ],
	        "name": "Cutter.Back.Right",
	        "code": "cpbr"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "c.w / 2",
	          "c.h -  tid - T.t / 2",
	          "c.t / -2"
	        ],
	        "demensions": [
	          "c.w - pbl.t - R.t",
	          "c.t - pbr.t - L.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Top",
	        "code": "T"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "c.w / 2",
	          "tkh + B.t / 2",
	          "c.t / -2"
	        ],
	        "demensions": [
	          "c.w - pbl.t - R.t",
	          "c.t - pbr.t - L.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Bottom",
	        "code": "B"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "cutCenterX",
	          "c.h/2",
	          "-cutCenterD"
	        ],
	        "demensions": [
	          "frontHype * 2",
	          "frontHype*2",
	          "c.h"
	        ],
	        "rotation": [
	          "90",
	          "Math.toDegrees(Math.PI - frontRightTheta)",
	          0
	        ],
	        "name": "Cutter.Front",
	        "code": "cut"
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "B",
	        "type": "Butt"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "pbl",
	        "type": "Butt"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "pbr",
	        "type": "Butt"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "y",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "pbr",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "B",
	        "femalePartCode": "pbl",
	        "maleOffset": "pbl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "y",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "pbr",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "T",
	        "femalePartCode": "pbl",
	        "maleOffset": "pbl.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbr",
	        "femalePartCode": "R",
	        "maleOffset": "pbr.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-z"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "pbl",
	        "femalePartCode": "L",
	        "maleOffset": "L.t / 2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "BACK",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "B"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "L"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cut",
	        "femalePartCode": "R"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "B"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbl"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "pbr"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbl",
	        "femalePartCode": "BACK"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbr",
	        "femalePartCode": "BACK"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "tkb",
	        "femalePartCode": "B",
	        "maleOffset": "B.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+y"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "tkb",
	        "femalePartCode": "L",
	        "maleOffset": ".1",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "tkb",
	        "femalePartCode": "R"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "ctbl",
	        "femalePartCode": "tkb"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "ctbr",
	        "femalePartCode": "tkb"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "ctbl2",
	        "femalePartCode": "tkb"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "ctbr2",
	        "femalePartCode": "tkb"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": "33"
	    },
	    "shape": "corner",
	    "width": "based*1.5",
	    "height": "maxHeight(c.w,c.t,ceilh)",
	    "thickness": "based*1.5",
	    "fromFloor": 0,
	    "openings": [
	      {
	        "_Type": "location",
	        "rotation": {
	          "x": 0,
	          "z": 0,
	          "y": "270+ Math.toDegrees(frontRightTheta)"
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "leftInnerLimit",
	              "y": "topInnerLimit",
	              "z": "-(frontDepthMax - rightCutX)"
	            },
	            {
	              "x": "rightInnerLimit",
	              "y": "topInnerLimit",
	              "z": "-(frontDepthMin + R.t)"
	            },
	            {
	              "x": "rightInnerLimit",
	              "y": "bottomInnerLimit",
	              "z": "-(frontDepthMin + R.t)"
	            },
	            {
	              "x": "leftInnerLimit",
	              "y": "bottomInnerLimit",
	              "z": "-(frontDepthMax - rightCutX)"
	            }
	          ],
	          "outer": [
	            {
	              "x": "leftOuterLimit",
	              "y": "topOuterLimit",
	              "z": "-frontDepthMax"
	            },
	            {
	              "x": "rightOuterLimit",
	              "y": "topOuterLimit",
	              "z": "-frontDepthMin"
	            },
	            {
	              "x": "rightOuterLimit",
	              "y": "bottomOuterLimit",
	              "z": "-frontDepthMin"
	            },
	            {
	              "x": "leftOuterLimit",
	              "y": "bottomOuterLimit",
	              "z": "-frontDepthMax"
	            }
	          ]
	        },
	        "state": {
	          "innerOouter": true,
	          "index": 0,
	          "xOyOz": "z"
	        }
	      }
	    ]
	  },
	  "ut": {
	  "_TYPE": "CabinetTemplate",
	
	  "ID_ATTRIBUTE": "id",
	  "type": "ut",
	  "values": [
	    {
	      "key": "brh",
	      "eqn": "tkb.w + BACK.t + brr"
	    },
	    {
	      "key": "innerWidth",
	      "eqn": "c.w - pwt34 * 2"
	    },
	    {
	      "key": "innerWidthCenter",
	      "eqn": "innerWidth + pwt34"
	    },
	    {
	      "key": "insetTop",
	      "eqn": "4*2.54"
	    }
	  ],
	  "subassemblies": [
	    {
	      "name": "ToeKickBacker",
	      "type": "Panel",
	      "code": "tkb",
	      "center": [
	        "c.w / 2",
	        "w / 2",
	        "-(tkd + (t / 2))"
	      ],
	      "demensions": [
	        "tkh",
	        "innerWidth",
	        "tkbw"
	      ],
	      "rotation": [
	        0,
	        0,
	        90
	      ]
	    },
	    {
	      "name": "Right",
	      "type": "Divider",
	      "code": "R",
	      "center": [
	        "c.w - (R.t / 2)",
	        "l / 2",
	        "w / -2"
	      ],
	      "demensions": [
	        "c.t",
	        "c.l",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        90,
	        0
	      ]
	    },
	    {
	      "name": "Left",
	      "type": "Divider",
	      "code": "L",
	      "center": [
	        "(t / 2)",
	        " l / 2",
	        "w/-2"
	      ],
	      "demensions": [
	        "c.t",
	        "c.l",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        90,
	        0
	      ]
	    },
	    {
	      "name": "Back",
	      "type": "Panel",
	      "code": "BACK",
	      "center": [
	        "l / 2 + L.t",
	        " (w / 2) + tkb.w",
	        "-(c.t - (t / 2))"
	      ],
	      "demensions": [
	        "c.l - tkb.w - T.t - insetTop",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        0,
	        90
	      ]
	    },
	    {
	      "name": "Bottom",
	      "type": "Divider",
	      "code": "B",
	      "center": [
	        "c.w / 2",
	        "tkh + (t/2)",
	        "w / -2"
	      ],
	      "demensions": [
	        "c.t - BACK.t",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        90,
	        0
	      ]
	    },
	    {
	      "name": "Top",
	      "type": "Divider",
	      "code": "T",
	      "center": [
	        "c.w / 2",
	        "c.h - pwt34/2 - insetTop",
	        "w / -2"
	      ],
	      "demensions": [
	        "c.t",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        90,
	        0
	      ]
	    },
	    {
	      "type": "Panel",
	      "center": [
	        "L.t + innerWidth/2",
	        "c.h - insetTop/2",
	        "tf.t/-2"
	      ],
	      "demensions": [
	        "insetTop",
	        "innerWidth",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        "0",
	        "90"
	      ],
	      "name": "Panel.Top.Filler",
	      "code": "tf"
	    }
	  ],
	  "joints": [
	    {
	      "malePartCode": "T",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "T",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "BACK",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "BACK",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "B",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "B",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "B",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "x",
	      "centerAxis": "+y"
	    },
	    {
	      "type": "Dado",
	      "malePartCode": "BACK",
	      "femalePartCode": "T",
	      "maleOffset": "T.t/2",
	      "demensionAxis": "x",
	      "centerAxis": "+y"
	    }
	  ],
	  "dividerJoint": {
	    "type": "Dado",
	    "maleOffset": 0.9525
	  },
	  "shape": "square",
	  "width": 60.96,
	  "height": "maxHeight(c.w,c.t,ceilh)",
	  "thickness": "based",
	  "fromFloor": 0,
	  "openings": [
	    {
	      "top": "T",
	      "bottom": "B",
	      "left": "L",
	      "right": "R",
	      "back": "BACK"
	    }
	  ]
	},
	  "wall": {
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "wall",
	    "values": [],
	    "subassemblies": [
	      {
	        "type": "Divider",
	        "center": [
	          "c.w - R.t/2",
	          "c.h / 2",
	          "R.w / -2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Right",
	        "code": "R"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t/2",
	          "c.h/2",
	          "L.w/-2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Left",
	        "code": "L"
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "L.t + BACK.w/2",
	          "BACK.h/2 + B.t",
	          "-(c.t - BACK.t /2)"
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "c.h - B.t -T.t",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.back",
	        "code": "BACK"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t + T.w / 2",
	          "c.h - tid - T.t/2",
	          "T.l/-2 "
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "c.t ",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Top",
	        "code": "T"
	      },
	      {
	        "type": "Divider",
	        "center": [
	          "B.w /2 + L.t",
	          "bid + B.t/2",
	          "B.h / -2"
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "c.t",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panal.Bottom",
	        "code": "B"
	      }
	    ],
	    "joints": [
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "T",
	        "maleOffset": "T.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+y"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "B",
	        "maleOffset": "B.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "-y"
	      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "L",
	        "maleOffset": "L.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": "33"
	    },
	    "shape": "square",
	    "width": 45.72,
	    "height": "wallh",
	    "thickness": "walld",
	    "fromFloor": "walle",
	    "openings": [
	      {
	        "top": "T",
	        "bottom": "B",
	        "left": "L",
	        "right": "R",
	        "back": "BACK"
	      }
	    ]
	  },
	  "corner-base-blind": {
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "corner-base-blind",
	    "values": [
	      {
	        "key": "brh",
	        "eqn": "tkb.w + BACK.t + brr"
	      },
	      {
	        "key": "innerWidth",
	        "eqn": "c.w - pwt34 * 2"
	      },
	      {
	        "key": "innerWidthCenter",
	        "eqn": "innerWidth + pwt34"
	      },
	      {
	        "key": "blindDepth",
	        "eqn": "24*2.54"
	      },
	      {
	        "key": "innerHeight",
	        "eqn": "c.h - tkh - B.t"
	      }
	    ],
	    "subassemblies": [
	      {
	        "name": "ToeKickBacker",
	        "type": "Panel",
	        "code": "tkb",
	        "center": [
	          "c.w / 2",
	          "w / 2",
	          "-(tkd + (t / 2))"
	        ],
	        "demensions": [
	          "tkh",
	          "innerWidth",
	          "tkbw"
	        ],
	        "rotation": [
	          0,
	          0,
	          90
	        ]
	      },
	      {
	        "name": "Right",
	        "type": "Divider",
	        "code": "R",
	        "center": [
	          "c.w - (R.t / 2)",
	          "l / 2",
	          "w / -2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Left",
	        "type": "Divider",
	        "code": "L",
	        "center": [
	          "(t / 2)",
	          " l / 2",
	          "w/-2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Back",
	        "type": "Panel",
	        "code": "BACK",
	        "center": [
	          "l / 2 + L.t",
	          " (w / 2) + tkb.w",
	          "-(c.t - (t / 2))"
	        ],
	        "demensions": [
	          "c.l - tkb.w",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          90
	        ]
	      },
	      {
	        "name": "Bottom",
	        "type": "Divider",
	        "code": "B",
	        "center": [
	          "c.w / 2",
	          "tkh + (t/2)",
	          "w / -2"
	        ],
	        "demensions": [
	          "c.t - BACK.t",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Top",
	        "type": "Divider",
	        "code": "T",
	        "center": [
	          "c.w / 2",
	          "c.h - pwt34/2",
	          "w / -2"
	        ],
	        "demensions": [
	          "(c.t - BACK.t) * .2",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Top2",
	        "type": "Panel",
	        "code": "pt2",
	        "center": [
	          "c.w / 2",
	          "c.h - pwt34/2",
	          "-(c.t - BACK.t - (w / 2))"
	        ],
	        "demensions": [
	          "(c.t - BACK.t) * .2",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          90,
	          0
	        ]
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "blindDepth + 2*2.54 - bms.w/2",
	          "tkh + B.t + bms.h/2",
	          "bms.t/-2"
	        ],
	        "demensions": [
	          "6*2.54",
	          "innerHeight",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.Blind.MiddleSupport",
	        "code": "bms"
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "T",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "T",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "pt2",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "pt2",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "B",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "B",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "B",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "x",
	        "centerAxis": "+y"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": 0.9525
	    },
	    "shape": "square",
	    "width": 121.92,
	    "height": "baseh",
	    "thickness": "based",
	    "fromFloor": 0,
	    "openings": [
	      {
	        "_Type": "location",
	        "rotation": {
	          "x": 0,
	          "z": 0,
	          "y": 0
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "bms.c.x + bms.d.x/2",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x + bms.d.x/2",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            }
	          ],
	          "outer": [
	            {
	              "x": "bms.c.x + bms.d.x/2 - R.t",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x + bms.d.x/2 - R.t",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            }
	          ]
	        },
	        "state": {
	          "innerOouter": true,
	          "index": 0,
	          "xOyOz": "z"
	        }
	      },
	      {
	        "_Type": "location",
	        "zRotation": 0,
	        "inner": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "outer": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "R.t",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x - bms.d.x/2",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x - bms.d.x/2",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "R.t",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            }
	          ],
	          "outer": [
	            {
	              "x": "0",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x - bms.d.x/2 + L.t",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x - bms.d.x/2 + L.t",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "0",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            }
	          ]
	        }
	      }
	    ]
	  },
	  "corner-wall-blind": {
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "corner-wall-blind",
	    "values": [
	      {
	        "key": "brh",
	        "eqn": "tkb.w + BACK.t + brr"
	      },
	      {
	        "key": "innerWidth",
	        "eqn": "c.w - pwt34 * 2"
	      },
	      {
	        "key": "innerWidthCenter",
	        "eqn": "innerWidth + pwt34"
	      },
	      {
	        "key": "blindDepth",
	        "eqn": "12*2.54"
	      },
	      {
	        "key": "innerHeight",
	        "eqn": "c.h - tkh - B.t"
	      }
	    ],
	    "subassemblies": [
	      {
	        "name": "ToeKickBacker",
	        "type": "Panel",
	        "code": "tkb",
	        "center": [
	          "c.w / 2",
	          "w / 2",
	          "-(tkd + (t / 2))"
	        ],
	        "demensions": [
	          "tkh",
	          "innerWidth",
	          "tkbw"
	        ],
	        "rotation": [
	          0,
	          0,
	          90
	        ]
	      },
	      {
	        "name": "Right",
	        "type": "Divider",
	        "code": "R",
	        "center": [
	          "c.w - (R.t / 2)",
	          "l / 2",
	          "w / -2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Left",
	        "type": "Divider",
	        "code": "L",
	        "center": [
	          "(t / 2)",
	          " l / 2",
	          "w/-2"
	        ],
	        "demensions": [
	          "c.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Back",
	        "type": "Panel",
	        "code": "BACK",
	        "center": [
	          "l / 2 + L.t",
	          " (w / 2) + tkb.w",
	          "-(c.t - (t / 2))"
	        ],
	        "demensions": [
	          "c.l - tkb.w",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          90
	        ]
	      },
	      {
	        "name": "Bottom",
	        "type": "Divider",
	        "code": "B",
	        "center": [
	          "c.w / 2",
	          "tkh + (t/2)",
	          "w / -2"
	        ],
	        "demensions": [
	          "c.t - BACK.t",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Top",
	        "type": "Divider",
	        "code": "T",
	        "center": [
	          "c.w / 2",
	          "c.h - pwt34/2",
	          "w / -2"
	        ],
	        "demensions": [
	          "(c.t - BACK.t) * .2",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Top2",
	        "type": "Panel",
	        "code": "pt2",
	        "center": [
	          "c.w / 2",
	          "c.h - pwt34/2",
	          "-(c.t - BACK.t - (w / 2))"
	        ],
	        "demensions": [
	          "(c.t - BACK.t) * .2",
	          "innerWidth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          90,
	          0
	        ]
	      },
	      {
	        "type": "Panel",
	        "center": [
	          "blindDepth",
	          "tkh + B.t + bms.h/2",
	          "bms.t/-2"
	        ],
	        "demensions": [
	          "3*2.54",
	          "innerHeight",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.Blind.MiddleSupport",
	        "code": "bms"
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "T",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "T",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "pt2",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "pt2",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "B",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "B",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "B",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "x",
	        "centerAxis": "+y"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": 0.9525
	    },
	    "shape": "square",
	    "width": 60.96,
	    "height": "wallh",
	    "thickness": "walld",
	    "fromFloor": 0,
	    "openings": [
	      {
	        "_Type": "location",
	        "rotation": {
	          "x": 0,
	          "z": 0,
	          "y": 0
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "bms.c.x + bms.d.x/2",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x + bms.d.x/2",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            }
	          ],
	          "outer": [
	            {
	              "x": "bms.c.x + bms.d.x/2 - R.t",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x + bms.d.x/2 - R.t",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            }
	          ]
	        },
	        "state": {
	          "innerOouter": true,
	          "index": 0,
	          "xOyOz": "z"
	        }
	      },
	      {
	        "_Type": "location",
	        "zRotation": 0,
	        "inner": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "outer": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "R.t",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x - bms.d.x/2",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x - bms.d.x/2",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "R.t",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            }
	          ],
	          "outer": [
	            {
	              "x": "0",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x - bms.d.x/2 + L.t",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "bms.c.x - bms.d.x/2 + L.t",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "0",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            }
	          ]
	        }
	      }
	    ]
	  },
	  "corner-base-triangle":{
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "corner-base-triangle",
	    "values": [
	      {
	        "key": "bo",
	        "eqn": "4*2.54"      },
	      {
	        "key": "cnrD",
	        "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)"      },
	      {
	        "key": "pbw",
	        "eqn": "Math.sqrt((bo+BACK.t)*(bo+BACK.t)*2)"      },
	      {
	        "key": "innerWidth",
	        "eqn": "c.w - R.t"      },
	      {
	        "key": "innerWidthCenter",
	        "eqn": "innerWidth + pwt34"      },
	      {
	        "key": "frontHype",
	        "eqn": "Math.sqrt(c.w*c.w+c.t*c.t)"      },
	      {
	        "key": "frontCenterX",
	        "eqn": "frontHype/2 * Math.cos(frontLeftTheta)"      },
	      {
	        "key": "frontCenterZ",
	        "eqn": "-frontHype/2 * Math.cos(frontRightTheta)"      },
	      {
	        "key": "frontLeftTheta",
	        "eqn": "Math.atan(c.t/c.w)"      },
	      {
	        "key": "frontRightTheta",
	        "eqn": "Math.PI/2  - frontLeftTheta"      },
	      {
	        "key": "toeKickBackerLen",
	        "eqn": "Math.sqrt((c.w-tkLeftD-tkLeftT-R.t)*(c.w-tkLeftD-tkLeftT-R.t)+(c.t-tkRightD-tkRightT-L.t)*(c.t-tkRightD-tkRightT-L.t))"      },
	      {
	        "key": "innerDepth",
	        "eqn": "c.t - L.t"      },
	      {
	        "key": "tkLeftT",
	        "eqn": "(tkb.t/2)*Math.sin(frontLeftTheta)"      },
	      {
	        "key": "tkRightT",
	        "eqn": "(tkb.t/2)*Math.sin(frontRightTheta)"      },
	      {
	        "key": "tkLeftD",
	        "eqn": "tkd*Math.sin(frontLeftTheta)"      },
	      {
	        "key": "tkRightD",
	        "eqn": "tkd*Math.sin(frontRightTheta)"      },
	      {
	        "key": "triX",
	        "eqn": "frontCenterX + tkLeftD + tkLeftT"      },
	      {
	        "key": "triY",
	        "eqn": "frontCenterZ - tkRightD - tkRightT"      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - (bo - BACK.t)/2 * Math.sin(Math.PI12)",
	          "c.h/2",
	          "-(c.t - (bo - BACK.t)/2 * Math.sin(Math.PI12))"
	        ],
	        "demensions": [
	          "pbw",
	          "c.h",
	          "pwt14"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Panel.Back",
	        "code": "BACK"      },
	      {
	        "type": "Cutter",
	        "center": [
	          "c.w + bo/4*Math.sin(Math.PI/2)",
	          "c.h/2",
	          "-(c.t + bo/4*Math.sin(Math.PI/2))"
	        ],
	        "demensions": [
	          "bo*2",
	          "c.h",
	          "bo*2"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Cutter.Back",
	        "code": "cb"      },
	      {
	        "type": "Cutter",
	        "center": [
	          "R.c.x + R.t",
	          "R.c.y",
	          "R.c.z - cpbr.t"
	        ],
	        "demensions": [
	          "R.d.x",
	          "R.d.y",
	          "R.d.z"
	        ],
	        "rotation": [
	          "R.r.x",
	          "R.r.y",
	          "R.r.z"
	        ],
	        "name": "Cutter.Back.Right",
	        "code": "cpbr"      },
	      {
	        "type": "Cutter",
	        "center": [
	          "L.c.x + cpbl.t",
	          "L.c.y",
	          "L.c.z - L.t"
	        ],
	        "demensions": [
	          "L.d.x",
	          "L.d.y",
	          "L.d.z"
	        ],
	        "rotation": [
	          "L.r.x",
	          "L.r.y",
	          "L.r.z"
	        ],
	        "name": "Cutter.Back.Left",
	        "code": "cpbl"      },
	      {
	        "name": "ToeKickBacker",
	        "type": "Panel",
	        "code": "tkb",
	        "center": [
	          "triX",
	          "w / 2",
	          "triY"
	        ],
	        "demensions": [
	          "tkh",
	          "toeKickBackerLen",
	          "tkbw"
	        ],
	        "rotation": [
	          "90+Math.toDegrees(frontRightTheta)",
	          "0",
	          90
	        ]      },
	      {
	        "name": "Panel.Right",
	        "type": "Divider",
	        "code": "R",
	        "center": [
	          "c.w - (R.t / 2)",
	          "R.l / 2",
	          "(w / -2)"
	        ],
	        "demensions": [
	          "c.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          90,
	          0
	        ]      },
	      {
	        "name": "Panel.Left",
	        "type": "Divider",
	        "code": "L",
	        "center": [
	          "L.w/2",
	          "L.l / 2",
	          "-(c.t - L.t/2)"
	        ],
	        "demensions": [
	          "c.w - R.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "0",
	          0
	        ]      },
	      {
	        "name": "Bottom",
	        "type": "Divider",
	        "code": "B",
	        "center": [
	          "B.w / 2",
	          "tkh + (t/2)",
	          "B.h / -2"
	        ],
	        "demensions": [
	          "innerWidth",
	          "innerDepth",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ]      },
	      {
	        "name": "Top",
	        "type": "Divider",
	        "code": "T",
	        "center": [
	          "T.w / 2",
	          "c.h - pwt34/2",
	          "T.h /-2"
	        ],
	        "demensions": [
	          "innerWidth",
	          "innerDepth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          "0",
	          0
	        ]      },
	      {
	        "type": "Cutter",
	        "center": [
	          "frontCenterX - fc.t/2*Math.sin(frontLeftTheta)",
	          "c.h/2",
	          "frontCenterZ + fc.t/2*Math.sin(frontRightTheta)"
	        ],
	        "demensions": [
	          "frontHype",
	          "c.h",
	          "frontHype"
	        ],
	        "rotation": [
	          0,
	          "Math.toDegrees(frontRightTheta)",
	          0
	        ],
	        "include": "All",
	        "name": "frontCutter",
	        "code": "fc"      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "T",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": "0.9525",
	        "demensionAxis": "y",
	        "centerAxis": "+x"      },
	      {
	        "malePartCode": "T",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": "0.9525",
	        "demensionAxis": "x",
	        "centerAxis": "-z"      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "R",
	        "type": "Butt",
	        "maleOffset": "0.9525"      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "L",
	        "type": "Butt",
	        "maleOffset": "0.9525"      },
	      {
	        "malePartCode": "B",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"      },
	      {
	        "malePartCode": "B",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"      },
	      {
	        "malePartCode": "tkb",
	        "femalePartCode": "B",
	        "type": "Dado",
	        "maleOffset": "0.9525",
	        "demensionAxis": "x",
	        "centerAxis": "+y"      },
	      {
	        "type": "Butt",
	        "malePartCode": "fc",
	        "femalePartCode": "T"      },
	      {
	        "type": "Butt",
	        "malePartCode": "fc",
	        "femalePartCode": "R"      },
	      {
	        "type": "Butt",
	        "malePartCode": "fc",
	        "femalePartCode": "L"      },
	      {
	        "type": "Butt",
	        "malePartCode": "fc",
	        "femalePartCode": "B"      },
	      {
	        "type": "Butt",
	        "malePartCode": "BACK",
	        "femalePartCode": "T"      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "B",
	        "type": "Butt"      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbr",
	        "femalePartCode": "BACK"      },
	      {
	        "type": "Butt",
	        "malePartCode": "BACK",
	        "femalePartCode": "R"      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbl",
	        "femalePartCode": "L"      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbr",
	        "femalePartCode": "BACK"      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbl",
	        "femalePartCode": "BACK"      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "R"      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "L"      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "T"      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "B"      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": 0.9525
	    },
	    "shape": "square",
	    "width": "based",
	    "height": "baseh",
	    "thickness": "based",
	    "fromFloor": 0,
	    "openings": [
	      {
	        "top": "T",
	        "bottom": "B",
	        "left": "L",
	        "right": "R",
	        "back": "BACK",
	        "_Type": "location",
	        "zRotation": 0,
	        "inner": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "outer": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "R.t",
	              "y": "T.c.y - T.t/2",
	              "z": "L.c.z + L.t/2"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "T.c.y - T.t/2",
	              "z": "R.t/-2"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "B.c.y + B.t/2",
	              "z": "R.t/-2"
	            },
	            {
	              "x": "R.t",
	              "y": "B.c.y + B.t/2",
	              "z": "L.c.z + L.t/2"
	            }
	          ],
	          "outer": [
	            {
	              "x": "0",
	              "y": "c.h",
	              "z": "L.c.z - L.t/2"
	            },
	            {
	              "x": "c.w",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "0",
	              "y": "B.c.y - B.t/2",
	              "z": "L.c.z - L.t/2"
	            }
	          ]
	        }      }
	    ]
	  },
	  "corner-wall-triangle": {
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "corner-wall-triangle",
	    "values": [
	      {
	        "key": "bo",
	        "eqn": "4*2.54"
	      },
	      {
	        "key": "cnrD",
	        "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)"
	      },
	      {
	        "key": "pbw",
	        "eqn": "Math.sqrt((bo+BACK.t)*(bo+BACK.t)*2)"
	      },
	      {
	        "key": "innerWidth",
	        "eqn": "c.w - R.t"
	      },
	      {
	        "key": "innerWidthCenter",
	        "eqn": "innerWidth + pwt34"
	      },
	      {
	        "key": "frontHype",
	        "eqn": "Math.sqrt(c.w*c.w+c.t*c.t)"
	      },
	      {
	        "key": "frontCenterX",
	        "eqn": "frontHype/2 * Math.cos(frontLeftTheta)"
	      },
	      {
	        "key": "frontCenterZ",
	        "eqn": "-frontHype/2 * Math.cos(frontRightTheta)"
	      },
	      {
	        "key": "frontLeftTheta",
	        "eqn": "Math.atan(c.t/c.w)"
	      },
	      {
	        "key": "frontRightTheta",
	        "eqn": "Math.PI/2  - frontLeftTheta"
	      },
	      {
	        "key": "toeKickBackerLen",
	        "eqn": "Math.sqrt((c.w-tkLeftD-tkLeftT-R.t)*(c.w-tkLeftD-tkLeftT-R.t)+(c.t-tkRightD-tkRightT-L.t)*(c.t-tkRightD-tkRightT-L.t))"
	      },
	      {
	        "key": "innerDepth",
	        "eqn": "c.t - L.t"
	      },
	      {
	        "key": "tkLeftT",
	        "eqn": ".5/Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "tkRightT",
	        "eqn": ".5/Math.sin(frontRightTheta)"
	      },
	      {
	        "key": "tkLeftD",
	        "eqn": "tkd/Math.sin(frontLeftTheta)"
	      },
	      {
	        "key": "tkRightD",
	        "eqn": "tkd/Math.sin(frontRightTheta)"
	      },
	      {
	        "key": "triX",
	        "eqn": "frontCenterX + tkLeftD + tkLeftT"
	      },
	      {
	        "key": "triY",
	        "eqn": "frontCenterZ - tkRightD - tkRightT"
	      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Panel",
	        "center": [
	          "c.w - (bo - BACK.t)/2 * Math.sin(Math.PI12)",
	          "c.h/2",
	          "-(c.t - (bo - BACK.t)/2 * Math.sin(Math.PI12))"
	        ],
	        "demensions": [
	          "pbw",
	          "c.h",
	          "pwt14"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Panel.Back",
	        "code": "BACK"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "c.w + bo/4*Math.sin(Math.PI/2)",
	          "c.h/2",
	          "-(c.t + bo/4*Math.sin(Math.PI/2))"
	        ],
	        "demensions": [
	          "bo*2",
	          "c.h",
	          "bo*2"
	        ],
	        "rotation": [
	          0,
	          "135",
	          0
	        ],
	        "name": "Cutter.Back",
	        "code": "cb"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "R.c.x + R.t",
	          "R.c.y",
	          "R.c.z - cpbr.t"
	        ],
	        "demensions": [
	          "R.d.x",
	          "R.d.y",
	          "R.d.z"
	        ],
	        "rotation": [
	          "R.r.x",
	          "R.r.y",
	          "R.r.z"
	        ],
	        "name": "Cutter.Back.Right",
	        "code": "cpbr"
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "L.c.x + cpbl.t",
	          "L.c.y",
	          "L.c.z - L.t"
	        ],
	        "demensions": [
	          "L.d.x",
	          "L.d.y",
	          "L.d.z"
	        ],
	        "rotation": [
	          "L.r.x",
	          "L.r.y",
	          "L.r.z"
	        ],
	        "name": "Cutter.Back.Left",
	        "code": "cpbl"
	      },
	      {
	        "name": "Panel.Right",
	        "type": "Divider",
	        "code": "R",
	        "center": [
	          "c.w - (R.t / 2)",
	          "R.l / 2",
	          "(w / -2)"
	        ],
	        "demensions": [
	          "c.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          90,
	          0
	        ]
	      },
	      {
	        "name": "Panel.Left",
	        "type": "Divider",
	        "code": "L",
	        "center": [
	          "L.w/2",
	          "L.l / 2",
	          "-(c.t - L.t/2)"
	        ],
	        "demensions": [
	          "c.w - R.t",
	          "c.l",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "0",
	          0
	        ]
	      },
	      {
	        "name": "Bottom",
	        "type": "Divider",
	        "code": "B",
	        "center": [
	          "B.w / 2",
	          "bid + (t/2)",
	          "B.h / -2"
	        ],
	        "demensions": [
	          "innerWidth",
	          "innerDepth",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ]
	      },
	      {
	        "name": "Top",
	        "type": "Divider",
	        "code": "T",
	        "center": [
	          "T.w / 2",
	          "c.h - tid - pwt34/2",
	          "T.h /-2"
	        ],
	        "demensions": [
	          "innerWidth",
	          "innerDepth",
	          "pwt34"
	        ],
	        "rotation": [
	          90,
	          "0",
	          0
	        ]
	      },
	      {
	        "type": "Cutter",
	        "center": [
	          "frontCenterX - fc.t/2*Math.sin(frontLeftTheta)",
	          "c.h/2",
	          "frontCenterZ + fc.t/2*Math.sin(frontRightTheta)"
	        ],
	        "demensions": [
	          "frontHype",
	          "c.h",
	          "frontHype"
	        ],
	        "rotation": [
	          0,
	          "Math.toDegrees(frontRightTheta)",
	          0
	        ],
	        "include": "All",
	        "name": "frontCutter",
	        "code": "fc"
	      }
	    ],
	    "joints": [
	      {
	        "malePartCode": "T",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": "0.9525",
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "malePartCode": "T",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": "0.9525",
	        "demensionAxis": "x",
	        "centerAxis": "-z"
	      },
	      {
	        "malePartCode": "B",
	        "femalePartCode": "R",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "-x"
	      },
	      {
	        "malePartCode": "B",
	        "femalePartCode": "L",
	        "type": "Dado",
	        "maleOffset": 0.9525,
	        "demensionAxis": "y",
	        "centerAxis": "+x"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "fc",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "fc",
	        "femalePartCode": "R"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "fc",
	        "femalePartCode": "L"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "fc",
	        "femalePartCode": "B"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "BACK",
	        "femalePartCode": "T"
	      },
	      {
	        "malePartCode": "BACK",
	        "femalePartCode": "B",
	        "type": "Butt"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbr",
	        "femalePartCode": "BACK"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "BACK",
	        "femalePartCode": "R"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbl",
	        "femalePartCode": "L"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbr",
	        "femalePartCode": "BACK"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cpbl",
	        "femalePartCode": "BACK"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "R"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "L"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "T"
	      },
	      {
	        "type": "Butt",
	        "malePartCode": "cb",
	        "femalePartCode": "B"
	      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": 0.9525
	    },
	    "shape": "square",
	    "width": "based",
	    "height": "baseh",
	    "thickness": "based",
	    "fromFloor": 0,
	    "openings": [
	      {
	        "top": "T",
	        "bottom": "B",
	        "left": "L",
	        "right": "R",
	        "back": "BACK",
	        "_Type": "location",
	        "zRotation": 0,
	        "inner": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "outer": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "R.t",
	              "y": "T.c.y - T.t/2",
	              "z": "L.c.z + L.t/2"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "T.c.y - T.t/2",
	              "z": "R.t/-2"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "B.c.y + B.t/2",
	              "z": "R.t/-2"
	            },
	            {
	              "x": "R.t",
	              "y": "B.c.y + B.t/2",
	              "z": "L.c.z + L.t/2"
	            }
	          ],
	          "outer": [
	            {
	              "x": "0",
	              "y": "c.h",
	              "z": "L.c.z - L.t/2"
	            },
	            {
	              "x": "c.w",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "0",
	              "y": "B.c.y - B.t/2",
	              "z": "L.c.z - L.t/2"
	            }
	          ]
	        }
	      }
	    ]
	  },
	  "corner-ut-triangle": {
	  "_TYPE": "CabinetTemplate",
	
	  "ID_ATTRIBUTE": "id",
	  "type": "corner-ut-triangle",
	  "values": [
	    {
	      "key": "bo",
	      "eqn": "4*2.54"
	    },
	    {
	      "key": "cnrD",
	      "eqn": "Math.sqrt(pbw*pbw/2 - bo*bo)"
	    },
	    {
	      "key": "pbw",
	      "eqn": "Math.sqrt((bo+BACK.t)*(bo+BACK.t)*2)"
	    },
	    {
	      "key": "innerWidth",
	      "eqn": "c.w - R.t"
	    },
	    {
	      "key": "innerWidthCenter",
	      "eqn": "innerWidth + pwt34"
	    },
	    {
	      "key": "frontHype",
	      "eqn": "Math.sqrt(c.w*c.w+c.t*c.t)"
	    },
	    {
	      "key": "frontCenterX",
	      "eqn": "frontHype/2 * Math.cos(frontLeftTheta)"
	    },
	    {
	      "key": "frontCenterZ",
	      "eqn": "-frontHype/2 * Math.cos(frontRightTheta)"
	    },
	    {
	      "key": "frontLeftTheta",
	      "eqn": "Math.atan(c.t/c.w)"
	    },
	    {
	      "key": "frontRightTheta",
	      "eqn": "Math.PI/2  - frontLeftTheta"
	    },
	    {
	      "key": "toeKickBackerLen",
	      "eqn": "Math.sqrt((c.w-tkLeftD-tkLeftT-R.t)*(c.w-tkLeftD-tkLeftT-R.t)+(c.t-tkRightD-tkRightT-L.t)*(c.t-tkRightD-tkRightT-L.t)) * .5"
	    },
	    {
	      "key": "innerDepth",
	      "eqn": "c.t - L.t"
	    },
	    {
	      "key": "tkLeftT",
	      "eqn": "(tkb.t/2)*Math.sin(frontLeftTheta)"
	    },
	    {
	      "key": "tkRightT",
	      "eqn": "(tkb.t/2)*Math.sin(frontRightTheta)"
	    },
	    {
	      "key": "tkLeftD",
	      "eqn": "tkd*Math.sin(frontLeftTheta)"
	    },
	    {
	      "key": "tkRightD",
	      "eqn": "tkd*Math.sin(frontRightTheta)"
	    },
	    {
	      "key": "triX",
	      "eqn": "frontCenterX + tkLeftD + tkLeftT"
	    },
	    {
	      "key": "triY",
	      "eqn": "frontCenterZ - tkRightD - tkRightT"
	    }
	  ],
	  "subassemblies": [
	    {
	      "type": "Panel",
	      "center": [
	        "c.w - (bo - BACK.t)/2 * Math.sin(Math.PI12)",
	        "c.h/2",
	        "-(c.t - (bo - BACK.t)/2 * Math.sin(Math.PI12))"
	      ],
	      "demensions": [
	        "pbw",
	        "c.h",
	        "pwt14"
	      ],
	      "rotation": [
	        0,
	        "135",
	        0
	      ],
	      "name": "Panel.Back",
	      "code": "BACK"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "c.w + bo/4*Math.sin(Math.PI/2)",
	        "c.h/2",
	        "-(c.t + bo/4*Math.sin(Math.PI/2))"
	      ],
	      "demensions": [
	        "bo*2",
	        "c.h",
	        "bo*2"
	      ],
	      "rotation": [
	        0,
	        "135",
	        0
	      ],
	      "name": "Cutter.Back",
	      "code": "cb"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "R.c.x + R.t",
	        "R.c.y",
	        "R.c.z - cpbr.t"
	      ],
	      "demensions": [
	        "R.d.x",
	        "R.d.y",
	        "R.d.z"
	      ],
	      "rotation": [
	        "R.r.x",
	        "R.r.y",
	        "R.r.z"
	      ],
	      "name": "Cutter.Back.Right",
	      "code": "cpbr"
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "L.c.x + cpbl.t",
	        "L.c.y",
	        "L.c.z - L.t"
	      ],
	      "demensions": [
	        "L.d.x",
	        "L.d.y",
	        "L.d.z"
	      ],
	      "rotation": [
	        "L.r.x",
	        "L.r.y",
	        "L.r.z"
	      ],
	      "name": "Cutter.Back.Left",
	      "code": "cpbl"
	    },
	    {
	      "name": "ToeKickBacker",
	      "type": "Panel",
	      "code": "tkb",
	      "center": [
	        "triX",
	        "w / 2",
	        "triY"
	      ],
	      "demensions": [
	        "tkh",
	        "toeKickBackerLen",
	        "tkbw"
	      ],
	      "rotation": [
	        "90+Math.toDegrees(frontRightTheta)",
	        "0",
	        90
	      ]
	    },
	    {
	      "name": "Panel.Right",
	      "type": "Divider",
	      "code": "R",
	      "center": [
	        "c.w - (R.t / 2)",
	        "R.l / 2",
	        "(w / -2)"
	      ],
	      "demensions": [
	        "c.t",
	        "c.l",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        90,
	        0
	      ]
	    },
	    {
	      "name": "Panel.Left",
	      "type": "Divider",
	      "code": "L",
	      "center": [
	        "L.w/2",
	        "L.l / 2",
	        "-(c.t - L.t/2)"
	      ],
	      "demensions": [
	        "c.w - R.t",
	        "c.l",
	        "pwt34"
	      ],
	      "rotation": [
	        0,
	        "0",
	        0
	      ]
	    },
	    {
	      "name": "Bottom",
	      "type": "Divider",
	      "code": "B",
	      "center": [
	        "B.w / 2",
	        "tkh + (t/2)",
	        "B.h / -2"
	      ],
	      "demensions": [
	        "innerWidth",
	        "innerDepth",
	        "pwt34"
	      ],
	      "rotation": [
	        "90",
	        "0",
	        0
	      ]
	    },
	    {
	      "name": "Top",
	      "type": "Divider",
	      "code": "T",
	      "center": [
	        "T.w / 2",
	        "c.h - tid - pwt34/2",
	        "T.h /-2"
	      ],
	      "demensions": [
	        "innerWidth",
	        "innerDepth",
	        "pwt34"
	      ],
	      "rotation": [
	        90,
	        "0",
	        0
	      ]
	    },
	    {
	      "type": "Cutter",
	      "center": [
	        "frontCenterX - fc.t/2*Math.sin(frontLeftTheta)",
	        "c.h/2",
	        "frontCenterZ + fc.t/2*Math.sin(frontRightTheta)"
	      ],
	      "demensions": [
	        "frontHype",
	        "c.h",
	        "frontHype"
	      ],
	      "rotation": [
	        0,
	        "Math.toDegrees(frontRightTheta)",
	        0
	      ],
	      "include": "All",
	      "name": "frontCutter",
	      "code": "fc"
	    }
	  ],
	  "joints": [
	    {
	      "malePartCode": "T",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": "0.9525",
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "T",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": "0.9525",
	      "demensionAxis": "x",
	      "centerAxis": "-z"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "R",
	      "type": "Butt",
	      "maleOffset": "0.9525"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "L",
	      "type": "Butt",
	      "maleOffset": "0.9525"
	    },
	    {
	      "malePartCode": "B",
	      "femalePartCode": "R",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "-x"
	    },
	    {
	      "malePartCode": "B",
	      "femalePartCode": "L",
	      "type": "Dado",
	      "maleOffset": 0.9525,
	      "demensionAxis": "y",
	      "centerAxis": "+x"
	    },
	    {
	      "malePartCode": "tkb",
	      "femalePartCode": "B",
	      "type": "Dado",
	      "maleOffset": "0.9525",
	      "demensionAxis": "x",
	      "centerAxis": "+y"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "fc",
	      "femalePartCode": "T"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "fc",
	      "femalePartCode": "R"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "fc",
	      "femalePartCode": "L"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "fc",
	      "femalePartCode": "B"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "BACK",
	      "femalePartCode": "T"
	    },
	    {
	      "malePartCode": "BACK",
	      "femalePartCode": "B",
	      "type": "Butt"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cpbr",
	      "femalePartCode": "BACK"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "BACK",
	      "femalePartCode": "R"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cpbl",
	      "femalePartCode": "L"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cpbr",
	      "femalePartCode": "BACK"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cpbl",
	      "femalePartCode": "BACK"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "R"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "L"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "T"
	    },
	    {
	      "type": "Butt",
	      "malePartCode": "cb",
	      "femalePartCode": "B"
	    }
	  ],
	  "dividerJoint": {
	    "type": "Dado",
	    "maleOffset": 0.9525
	  },
	  "shape": "square",
	  "width": "based",
	  "height": "maxHeight(c.w,c.t,ceilh)",
	  "thickness": "based",
	  "fromFloor": 0,
	  "openings": [
	    {
	      "top": "T",
	      "bottom": "B",
	      "left": "L",
	      "right": "R",
	      "back": "BACK",
	      "_Type": "location",
	      "zRotation": 0,
	      "inner": {
	        "top": {
	          "left": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	          },
	          "right": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	          }
	        },
	        "bottom": {
	          "right": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	          },
	          "left": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	          }
	        }
	      },
	      "outer": {
	        "top": {
	          "left": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	          },
	          "right": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	          }
	        },
	        "bottom": {
	          "right": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	          },
	          "left": {
	            "x": 0,
	            "y": 0,
	            "z": 0
	          }
	        }
	      },
	      "coordinates": {
	        "inner": [
	          {
	            "x": "R.t",
	            "y": "T.c.y - T.t/2",
	            "z": "L.c.z + L.t/2"
	          },
	          {
	            "x": "c.w - L.t",
	            "y": "T.c.y - T.t/2",
	            "z": "R.t/-2"
	          },
	          {
	            "x": "c.w - L.t",
	            "y": "B.c.y + B.t/2",
	            "z": "R.t/-2"
	          },
	          {
	            "x": "R.t",
	            "y": "B.c.y + B.t/2",
	            "z": "L.c.z + L.t/2"
	          }
	        ],
	        "outer": [
	          {
	            "x": "0",
	            "y": "c.h",
	            "z": "L.c.z - L.t/2"
	          },
	          {
	            "x": "c.w",
	            "y": "c.h",
	            "z": "0"
	          },
	          {
	            "x": "c.w",
	            "y": "B.c.y - B.t/2",
	            "z": "0"
	          },
	          {
	            "x": "0",
	            "y": "B.c.y - B.t/2",
	            "z": "L.c.z - L.t/2"
	          }
	        ]
	      }
	    }
	  ]
	},
	  "transition-wall": {
	    "_TYPE": "CabinetTemplate",
	    "autoToeKick": false,
	    "ID_ATTRIBUTE": "id",
	    "type": "transition-wall",
	    "values": [
	      {
	        "key": "cwl",
	        "eqn": "12*2.54"      },
	      {
	        "key": "cwr",
	        "eqn": "24*2.54"      },
	      {
	
	        "key": "maxSide",
	        "eqn": "Math.max(cwl,cwr)"
	      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Divider",
	        "center": [
	          "c.w - R.t/2",
	          "c.h / 2",
	          "R.w / -2"
	        ],
	        "demensions": [
	          "maxSide",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Right",
	        "code": "R"      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t/2",
	          "c.h/2",
	          "R.c.z - R.w/2 + L.w/2"
	        ],
	        "demensions": [
	          "maxSide",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Left",
	        "code": "L"      },
	      {
	        "type": "Panel",
	        "center": [
	          "L.t + BACK.w/2",
	          "BACK.h/2 + B.t",
	          "L.c.z -L.w/2 + BACK.t /2"
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "c.h - B.t -T.t",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.back",
	        "code": "BACK"      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t + T.w / 2",
	          "c.h - tid - T.t/2",
	          "T.l/-2 "
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "Math.max(cwl,  cwr)",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Top",
	        "code": "T",
	        "include": "All"      },
	      {
	        "type": "Divider",
	        "center": [
	          "B.w /2 + L.t",
	          "bid + B.t/2",
	          "B.h / -2"
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "T.h",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panal.Bottom",
	        "code": "B"      }
	    ],
	    "joints": [
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "T",
	        "maleOffset": "T.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+y"      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "B",
	        "maleOffset": "B.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "-y"      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "L",
	        "maleOffset": "L.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": "33"
	    },
	    "shape": "square",
	    "width": 45.72,
	    "height": "wallh",
	    "thickness": "walld",
	    "fromFloor": 0,
	    "openings": [
	      {
	        "top": "T",
	        "bottom": "B",
	        "left": "L",
	        "right": "R",
	        "back": "BACK",
	        "_Type": "slice",
	        "zRotation": 0,
	        "inner": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "outer": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "L.c.x-L.t",
	              "y": "L.c.y + L.h/2",
	              "z": "L.c.z + L.w/2"
	            },
	            {
	              "x": "L.c.y + L.h",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "R.t",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            }
	          ],
	          "outer": [
	            {
	              "x": "0",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "0",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            }
	          ]
	        },
	
	        "leftDepth": "cwl",
	        "rightDepth": "cwr"
	      }
	    ]
	  },
	  "transition-base": {
	    "_TYPE": "CabinetTemplate",
	
	    "ID_ATTRIBUTE": "id",
	    "type": "transition-base",
	    "values": [
	      {
	        "key": "cwl",
	        "eqn": "12*2.54"      },
	      {
	        "key": "cwr",
	        "eqn": "24*2.54"      },
	      {
	        "key": "maxSide",
	        "eqn": "Math.max(cwl,cwr)"      }
	    ],
	    "subassemblies": [
	      {
	        "type": "Divider",
	        "center": [
	          "c.w - R.t/2",
	          "c.h / 2",
	          "R.w / -2"
	        ],
	        "demensions": [
	          "maxSide",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Right",
	        "code": "R"      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t/2",
	          "c.h/2",
	          "R.c.z - R.w/2 + L.w/2"
	        ],
	        "demensions": [
	          "maxSide",
	          "c.h",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          "90",
	          0
	        ],
	        "name": "Panel.Left",
	        "code": "L"      },
	      {
	        "type": "Panel",
	        "center": [
	          "L.t + BACK.w/2",
	          "BACK.h/2 + B.t",
	          "L.c.z -L.w/2 + BACK.t /2"
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "c.h - B.t -T.t",
	          "pwt34"
	        ],
	        "rotation": [
	          0,
	          0,
	          0
	        ],
	        "name": "Panel.back",
	        "code": "BACK"      },
	      {
	        "type": "Divider",
	        "center": [
	          "L.t + T.w / 2",
	          "c.h - T.t/2",
	          "T.l/-2 "
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "Math.max(cwl,  cwr)",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panel.Top",
	        "code": "T",
	        "include": "All"      },
	      {
	        "type": "Divider",
	        "center": [
	          "B.w /2 + L.t",
	          "tkh + B.t/2",
	          "B.h / -2"
	        ],
	        "demensions": [
	          "c.w - L.t - R.t",
	          "T.h",
	          "pwt34"
	        ],
	        "rotation": [
	          "90",
	          "0",
	          0
	        ],
	        "name": "Panal.Bottom",
	        "code": "B"      }
	    ],
	    "joints": [
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "T",
	        "maleOffset": "T.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "+y"      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "R",
	        "maleOffset": "R.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "+x"      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "B",
	        "maleOffset": "B.t/2",
	        "demensionAxis": "y",
	        "centerAxis": "-y"      },
	      {
	        "type": "Dado",
	        "malePartCode": "BACK",
	        "femalePartCode": "L",
	        "maleOffset": "L.t/2",
	        "demensionAxis": "x",
	        "centerAxis": "-x"      }
	    ],
	    "dividerJoint": {
	      "type": "Dado",
	      "maleOffset": "33"
	    },
	    "shape": "square",
	    "width": 45.72,
	    "height": "wallh",
	    "thickness": "walld",
	    "fromFloor": 0,
	    "openings": [
	      {
	        "top": "T",
	        "bottom": "B",
	        "left": "L",
	        "right": "R",
	        "back": "BACK",
	        "_Type": "slice",
	        "zRotation": 0,
	        "inner": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "outer": {
	          "top": {
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          },
	          "bottom": {
	            "right": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            },
	            "left": {
	              "x": 0,
	              "y": 0,
	              "z": 0
	            }
	          }
	        },
	        "coordinates": {
	          "inner": [
	            {
	              "x": "L.c.x-L.t",
	              "y": "L.c.y + L.h/2",
	              "z": "L.c.z + L.w/2"
	            },
	            {
	              "x": "L.c.y + L.h",
	              "y": "T.c.y - T.t/2",
	              "z": "0"
	            },
	            {
	              "x": "c.w - L.t",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "R.t",
	              "y": "B.c.y + B.t/2",
	              "z": "0"
	            }
	          ],
	          "outer": [
	            {
	              "x": "0",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "c.h",
	              "z": "0"
	            },
	            {
	              "x": "c.w",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            },
	            {
	              "x": "0",
	              "y": "B.c.y - B.t/2",
	              "z": "0"
	            }
	          ]
	        },
	        "leftDepth": "cwl",
	        "rightDepth": "cwr"      }
	    ],
	    "autoToeKick": true
	  }
	}
	
});


RequireJS.addFunction('./services/cabinet/app-src/position.js',
function (require, exports, module) {
	

	
	const getDefaultSize = require('./utils.js').getDefaultSize;
	const FunctionCache = require('../../../public/js/utils/services/function-cache.js');
	const Vertex3D = require('./three-d/objects/vertex');
	const BiPolygon = require('./three-d/objects/bi-polygon');
	
	class Position {
	  constructor(assembly, sme) {
	
	    function getSme(attr, obj) {
	      if (attr === undefined) {
	        return {x: sme.eval(obj.x),
	          y: sme.eval(obj.y),
	          z: sme.eval(obj.z)}
	      } else {
	        return sme.eval(obj[attr], assembly);
	      }
	    }
	
	    let center, demension, rotation;
	    let demCoords = {};
	    let centerCoords = {};
	    let rotCoords = {};
	
	    if ((typeof assembly.rotationConfig) !== 'function') {
	      rotCoords = Position.parseCoordinates(assembly.rotationConfig, '0:0:0');
	      rotation = (attr) => getSme(attr, rotCoords);
	    } else {
	      rotation = assembly.rotationConfig;
	    }
	
	    if ((typeof assembly.centerConfig) !== 'function') {
	      centerCoords = Position.parseCoordinates(assembly.centerConfig, '0:0:0');
	      center = (attr) => getSme(attr, centerCoords);
	    } else {
	      center = assembly.centerConfig;
	    }
	
	    if ((typeof assembly.demensionConfig) !== 'function') {
	      const defSizes = getDefaultSize(assembly);
	      demCoords = Position.parseCoordinates(assembly.demensionConfig,
	      `${defSizes.width}:${defSizes.length}:${defSizes.thickness}`,
	      '0:0:0');
	      demension = (attr) => getSme(attr, demCoords);
	    } else new Promise(function(resolve, reject) {
	      demension = assembly.demensionConfig
	    });
	
	
	
	    function get(func, sme) {
	      if ((typeof func) === 'function' && (typeof func()) === 'object') return func;
	      return sme;
	    }
	
	    // function centerRelitiveToRoot(attr) {
	    //   const objectCenter = center(attr);
	    //   if (attr) {
	    //
	    //   }
	    // }
	
	
	    const group = () => {
	      const rootAssembly = assembly.getRoot();
	      return rootAssembly && rootAssembly.id();
	    }
	    this.rotation = new FunctionCache((attr) => rotation(attr), null, group, assembly);
	    this.center = new FunctionCache((attr) => center(attr), null, group, assembly);
	    this.demension = new FunctionCache((attr) => demension(attr), null, group, assembly);
	
	    this.current = () => {
	      const position = {
	        center: this.center(),
	        demension: this.demension(),
	        rotation: this.rotation()
	      };
	      assembly.getJoints().male.forEach((joint) =>
	        joint.updatePosition(position)
	      );
	      return position;
	    }
	
	    this.centerAdjust = (center, direction) => {
	      const magnitude = direction[0] === '-' ? -1 : 1;
	      const axis = direction.replace(/\+|-/, '');
	      return this.center(center) + (magnitude * this.demension(axis) / 2);
	    }
	
	    this.limits = (targetStr) => {
	      if (targetStr !== undefined) {
	        const match = targetStr.match(/^(\+|-|)([xyz])$/)
	        const attr = match[2];
	        const d = this.demension(attr)/2;
	        const pos = `+${attr}`;
	        const neg = `-${attr}`;
	        const limits = {};
	        limits[pos] = d;
	        if (match[1] === '+') return limits[pos];
	        limits[neg] = -d;
	        if (match[1] === '-') return limits[neg];
	        return  limits;
	      }
	      const d = this.demension();
	      return  {
	        x: d.x / 2,
	        '-x': -d.x / 2,
	        y: d.y / 2,
	        '-y': -d.y / 2,
	        z: d.z / 2,
	        '-z': -d.z / 2,
	      }
	    }
	
	    //TODO: this could be simpler and more effecient using vector rotations instead of line rotations.
	    const modelVecObj = (rotations) => ({
	        width: new Vertex3D(1,0,0).rotate(rotations).vector(),
	        height: new Vertex3D(0,1,0).rotate(rotations).vector(),
	        depth: new Vertex3D(0,0,1).rotate(rotations).vector()
	    });
	
	    this.toBiPolygon = () => {
	      const current = this.current();
	      const dem = current.demension;
	      const center = new Vertex3D(current.center);
	      const vecObj = modelVecObj(current.rotation);
	      return BiPolygon.fromVectorObject(dem.x, dem.y, dem.z, center, vecObj);
	    }
	
	    this.toModel = () => {
	      return this.toBiPolygon().toModel();
	    }
	
	    this.set = (obj, type, value, getter) => {
	      if ((typeof type) !== 'string') {
	        this.set(obj, 'x', type.x, getter);
	        this.set(obj, 'y', type.y, getter);
	        this.set(obj, 'z', type.z, getter);
	        return getter();
	      }
	      if (value !== undefined) obj[type] = value;
	      return getter(type);
	    }
	
	    this.parseCoordinates = (...args) => Position.parseCoordinates(...args);
	    this.setDemension = (type, value) => this.set(demCoords, type, value, demension);
	    this.setCenter = (type, value) => this.set(centerCoords, type, value, center);
	    this.setRotation = (type, value) => this.set(rotCoords, type, value, rotation);
	    this.toString = () => {
	      const curr = this.current();
	      curr.center = new Vertex3D(curr.center);
	      curr.demension = new Vertex3D(curr.demension);
	      curr.rotation = new Vertex3D(curr.rotation);
	      return `center: ${curr.center}, demensions: ${curr.demension}, rotation: ${curr.rotation}`;
	    }
	  }
	}
	
	Position.targeted = (attr, x, y, z) => {
	  const all = attr === undefined;
	  const dem = {
	    x: all || attr === 'x' && x(),
	    y: all || attr === 'y' && y(),
	    z: all || attr === 'z' && z()
	  };
	  return all ? {x,y,z} : dem[attr];
	}
	Position.axisStrRegex = /(([xyz])(\(([0-9]*)\)|))/;
	Position.rotateStrRegex = new RegExp(Position.axisStrRegex, 'g');
	Position.touching = (pos1, pos2) => {
	  const touchingAxis = (axis) => {
	    if (pos1[`${axis}1`] === pos2[`${axis}0`])
	      return {axis: `${axis}`, direction: '+'};
	    if (pos1[`${axis}0`] === pos2[`${axis}1`])
	      return {axis: `${axis}`, direction: '-'};
	  }
	  if (!Position.within(pos1, pos2)) return null;
	  return touchingAxis('x') || touchingAxis('y') || touchingAxis('z') || null;
	}
	Position.within = (pos1, pos2, axises) => {
	  const axisTouching = (axis) => {
	    if (axises !== undefined && axises.index(axis) === -1) return true;
	    const p10 = pos1[`${axis}0`];
	    const p11 = pos1[`${axis}1`];
	    const p20 = pos2[`${axis}0`];
	    const p21 = pos2[`${axis}1`];
	    return (p10 >= p20 && p10 <= p21) ||
	            (p11 <= p21 && p11 >= p20);
	  }
	  return axisTouching('x') && axisTouching('y') && axisTouching('z');
	}
	
	Position.parseCoordinates = function() {
	  let coordinateMatch = null;
	  for (let index = 0; coordinateMatch === null && index < arguments.length; index += 1) {
	    const str = arguments[index];
	    if (typeof str === 'string') {
	      coordinateMatch = str.match(Position.demsRegex);
	    }
	  }
	  if (coordinateMatch === null) {
	    throw new Error(`Unable to parse coordinates`);
	  }
	  return {
	    x: coordinateMatch[1],
	    y: coordinateMatch[2],
	    z: coordinateMatch[3]
	  }
	}
	
	Position.demsRegex = /([^:]{1,}?):([^:]{1,}?):([^:]{1,})/;
	module.exports = Position
	
});


RequireJS.addFunction('./services/cabinet/app-src/error.js',
function (require, exports, module) {
	

	
	
	
	class InvalidComputation {
	  constructor(attributes) {
	    this.errorCode = 400;
	    this.message = 'Error within input parameters';
	    const keys = Object.keys(attributes);
	    for (let index = 0; index < keys.length; index += 1) {
	      const key = keys[index];
	      this.message += `\n\t${key}: '${value}'`;
	    }
	  }
	}
	module.exports = InvalidComputation
	
	
	
	
	
});


RequireJS.addFunction('./services/cabinet/app-src/init.js',
function (require, exports, module) {
	

	
	require('../../../public/js/utils/utils.js');
	const $t = require('../../../public/js/utils/$t');
	$t.loadFunctions(require('../generated/html-templates'));
	const User = require('./displays/user.js');
	
	// Object Classes
	// require('./bind.js');
	require('./objects/assembly/init-assem');
	require('./objects/joint/init');
	const Assembly = require('./objects/assembly/assembly.js');
	const Properties = require('./config/properties.js');
	const PopUp = require('../../../public/js/utils/display/pop-up.js');
	
	// Display classes
	const du = require('../../../public/js/utils/dom-utils.js');
	const EPNTS = require('../generated/EPNTS.js');
	const Displays = require('./services/display-svc.js');
	require('./objects/room');
	const TwoDLayout = require('./displays/two-d-layout.js');
	const ThreeDMainModel = require('./displays/three-d-main.js');
	require('./three-d/layout/init');
	const PropertyDisplay = require('./displays/property.js');
	const DisplayManager = require('./display-utils/displayManager.js');
	const utils = require('./utils.js');
	
	// TODO: remove
	const FunctionCache = require('../../../public/js/utils/services/function-cache.js');
	FunctionCache.disable();
	
	
	// Run Tests
	if (EPNTS.getEnv() === 'local') {
	  require('../test/run');
	}
	
	function updateDivisions (target) {
	  const name = target.getAttribute('name');
	  const index = Number.parseInt(target.getAttribute('index'));
	  const value = Number.parseFloat(target.value);
	  const inputs = target.parentElement.parentElement.querySelectorAll('.division-pattern-input');
	  const id = du.find.up('.opening-cnt', target).getAttribute('opening-id');
	  const opening = Assembly.get(id);
	  const values = opening.dividerLayout().fill;
	  for (let index = 0; values && index < inputs.length; index += 1){
	    const value = values[index];
	    if(value) inputs[index].value = value;
	  }
	  ThreeDMainModel.update(opening);
	}
	
	function getValue(code, obj) {
	  if ((typeof obj) === 'object' && obj[code] !== undefined) return obj[code];
	  return CONSTANTS[code].value;
	}
	
	
	const breakPathSplit = du.url.breakdown().path.split('/');
	const urlSuffix = breakPathSplit.length === 3 ? breakPathSplit[2] : undefined;
	const pageId = {template: 'template-manager', cost: 'cost-manager', home: 'app',
	                pattern: 'pattern-manager', property: 'property-manager-cnt'
	              }[urlSuffix] || 'app';
	function init(body){
	  if (body) Properties.load(body);
	
	  if (urlSuffix && urlSuffix !== 'order') {
	      require('./cost/init-costs.js');
	      const mainDisplayManager = new DisplayManager('display-ctn', 'menu', 'menu-btn', pageId);
	      if (urlSuffix === 'cost') {
	        const CostManager = require('./displays/managers/cost.js');
	        const costManager = new CostManager('cost-manager', 'cost');
	      } else if (urlSuffix === 'template') {
	        const TemplateManager = require('./displays/managers/template.js');
	        const templateDisplayManager = new TemplateManager('template-manager');
	      } else {
	        const modelDisplayManager = new DisplayManager('model-display-cnt', 'display-menu');
	        const propertyDisplay = new PropertyDisplay('#property-manager');
	        Displays.register('propertyDisplay', propertyDisplay);
	        const OrderDisplay = require('./displays/order.js');
	        du.on.match('change', '.open-orientation-radio,.open-division-input', updateDivisions);
	        orderDisplay = new OrderDisplay('#order-cnt');
	        setTimeout(TwoDLayout.init, 1000);
	        setTimeout(ThreeDMainModel.init, 1000);
	    }
	  } else if (urlSuffix === 'order') {
	    const modelDisplayManager = new DisplayManager('model-display-cnt', 'display-menu');
	    const viewDisplayManager = new DisplayManager('display-cnt', 'main-display-menu');
	    let order = require('./displays/single-order').order();
	    setTimeout(TwoDLayout.init, 1000);
	    setTimeout(ThreeDMainModel.init, 1000);
	  }
	}
	
	if (User.loginAvailible()) Request.get(EPNTS.config.get(), init, console.error);
	else init();
	
	const popUp = new PopUp({resize: false, noBackdrop: true});
	
	du.on.match('click', '*', (elem, event) => {
	  const errorMsg = elem.getAttribute('error-msg');
	  if (errorMsg) {
	    popUp.positionOnElement(elem).bottom();
	    popUp.updateContent(errorMsg);
	    popUp.show();
	    event.stopPropagation();
	  } else popUp.close();
	});
	
});


RequireJS.addFunction('./services/cabinet/app-src/utils.js',
function (require, exports, module) {
	

	
	
	const removeSuffixes = ['Part', 'Section'].join('|');
	function formatConstructorId (obj) {
	  return obj.constructor.name.replace(new RegExp(`(${removeSuffixes})$`), '');
	}
	
	function getDefaultSize(instance) {
	  const constructorName = instance.constructor.name;
	  if (constructorName === 'Cabinet') return {length: 24 * 2.54, width: 50*2.54, thickness: 21*2.54};
	  return {length: 0, width: 0, thickness: 0};
	}
	
	exports.formatConstructorId = formatConstructorId;
	exports.getDefaultSize = getDefaultSize;
	
});


RequireJS.addFunction('./services/cabinet/app-src/show.js',
function (require, exports, module) {
	

	
	const Panel = require('./objects/assembly/assemblies/panel.js');
	
	class Show {
	  constructor(name) {
	    this.name = name;
	    Show.types[name] = this;
	  }
	}
	Show.types = {};
	Show.listTypes = () => Object.values(Show.types);
	new Show('None');
	new Show('Flat');
	new Show('Inset Panel');
	module.exports = Show
	
	
	
	
	
});


RequireJS.addFunction('./services/cabinet/app-src/division-patterns.js',
function (require, exports, module) {
	
const Measurement = require('../../../public/js/utils/measurement.js');
	const CustomEvent = require('../../../public/js/utils/custom-event.js');
	
	const mostResent = {};
	const defaullt = {'a': 6, 'b': 10, 'c': 12};
	function bestGuess(char) {
	  return mostResent[char] || defaullt[char] || 4;
	}
	
	class Element {
	  constructor(id, index, count) {
	    let value;
	    this.id = id;
	    this.count = count || 1;
	    this.indexes = [index];
	    this.value = (val) => {
	      if (val !== undefined) {
	        value = new Measurement(val);
	      }
	      return value;
	    }
	    this.value(bestGuess(id));
	  }
	}
	
	class Pattern {
	  constructor(str, updateOrder, changeEvent) {
	    changeEvent ||= new CustomEvent('change');
	    this.onChange = changeEvent.on;
	    this.str = str;
	    let unique = {};
	    for (let index = 0; index < str.length; index += 1) {
	      const char = str[index];
	      if (unique[char] === undefined) {
	        unique[char] = {char, count: 1};
	      } else {
	        unique[char].count++;
	      }
	    }
	    const uniqueStr = Object.keys(unique).join('');
	    this.unique = () => uniqueStr;
	    this.equals = this.unique.length === 1;
	
	    this.clone = (str) => {
	      const clone = new Pattern(str, updateOrder, changeEvent);
	      clone.elements = elements;
	      setTimeout(() => changeEvent.trigger(null, clone), 10);
	      return clone;
	    }
	
	    this.values = () => {
	      const valueObj = {};
	      const elems = Object.values(elements);
	      elems.forEach((elem) => {
	        const value = elem.value().decimal();
	        if (updateOrder.indexOf(elem.id) !== -1 && Number.isFinite(value))
	          valueObj[elem.id] = value;
	      });
	      return valueObj;
	    }
	
	    if ((typeof str) !== 'string' || str.length === 0)
	      throw new Error('Must define str (arg0) as string of length > 1');
	
	    const elements = {};
	    const values = {};
	    updateOrder ||= [];
	    for (let index = 0; index < str.length; index += 1) {
	      const char = str[index];
	      if (elements[char]) {
	        elements[char].count++;
	        elements[char].indexes.push(index);
	      } else {
	        elements[char] = new Element(char, index);
	      }
	    }
	
	    this.ids = Object.keys(elements);
	    this.size = str.length;
	    let lastElem;
	    this.satisfied = () => updateOrder.length === uniqueStr.length - 1;
	
	    function onlyOneUnique(uniqueVals, dist) {
	      const count = uniqueVals[0].count;
	      const value = dist / count;
	      const values = new Array(count).fill(value);
	      const list = new Array(count).fill(value);
	      const fill = [new Measurement(value).display()];
	      return {values, list, fill, str};
	    }
	
	    function numbersOnly(uniqueVals, dist) {
	      let count = 0;
	      for (let index = 0; index < str.length; index += 1) {
	        count += Number.parseInt(str.charAt(index));
	      }
	      const unitDist = dist / count;
	      let retObj = {list: [], fill: [], str, values: {}};
	      for (let index = 0; index < str.length; index += 1) {
	        const char = str.charAt(index);
	        const units = Number.parseInt(char);
	        const value = units * unitDist;
	        retObj.list[index] = value;
	        if (retObj.values[char] === undefined) {
	          retObj.values[char] = value;
	          retObj.fill[retObj.list.fill.length] = value;
	        }
	      }
	      return retObj;
	    }
	
	    function ensureValidUpdateOrder(uniqueVals) {
	      for (let index = 0; index < updateOrder.length; index++) {
	        if (uniqueVals.filter(o => o.char === updateOrder[index]).length !== 1) updateOrder.splice(index, 1);
	      }
	      for (let index = 0; index < uniqueVals.length; index++) {
	        const char = uniqueVals[index].char;
	        const orderTooShort = updateOrder.length < uniqueVals.length - 1;
	        const includedInOrder = updateOrder.indexOf(char) !== -1;
	        if (orderTooShort && !includedInOrder) updateOrder = [char].concat(updateOrder);
	        else if (!orderTooShort && !includedInOrder) {
	          lastElem = elements[uniqueVals[index].char];
	        }
	      }
	      while (updateOrder.length > uniqueVals.length - 1) {
	        lastElem = elements[updateOrder.splice(0, 1)[0]];
	      }
	    }
	
	    const numbersOnlyReg = /^[0-9]{1,}$/;
	    const calc = (dist) => {
	      // map of unitValues
	      const values = {};
	
	      const uniqueVals = Object.values(unique);
	      if (uniqueVals.length === 1) return onlyOneUnique(uniqueVals, dist);
	
	      if (str.trim().match(numbersOnlyReg)) return numbersOnly(uniqueVals, dist);
	
	      if (uniqueVals.length > 1) ensureValidUpdateOrder(uniqueVals);
	      updateOrder.forEach((id) => {
	        const elem = elements[id];
	        dist -= elem.count * elem.value().decimal();
	        values[elem.id] = elem.value().value();
	      });
	      if (lastElem === undefined) throw new Error('This should not happen');
	
	      lastElem.value(new Measurement(dist / lastElem.count).value());
	      values[lastElem.id] = lastElem.value().value();
	
	      const list = [];
	      let fill = [];
	      for (let index = 0; index < str.length; index += 1)
	        list[index] = values[str[index]];
	      for (let index = 0; index < uniqueVals.length; index += 1) {
	        fill[index] = elements[uniqueVals[index].char].value().display();
	      }
	      const retObj = {values, list, fill, str};
	      return retObj;
	    }
	
	    this.value = (id, value) => {
	      if (value !== undefined) {
	        const index = updateOrder.indexOf(id);
	        if (index !== -1) updateOrder.splice(index, 1);
	        updateOrder.push(id);
	        if (updateOrder.length === this.ids.length) {
	          lastElem = elements[updateOrder[0]];
	          updateOrder.splice(0, 1);
	        }
	        value = elements[id].value(value);
	        mostResent[id] = value.decimal();
	        changeEvent.trigger(null, this);
	        return value;
	      } else {
	        return elements[id].value().decimal();
	      }
	    }
	
	    this.display = (id) => elements[id].value().display();
	
	    this.toJson = () => {
	      return {str: this.str, values: this.values()};
	    }
	
	    this.elements = elements;
	    this.calc = calc;
	  }
	}
	
	Pattern.fromJson = (json) => {
	  const pattern = new Pattern(json.str);
	  const keys = Object.keys(json.values);
	  keys.forEach((key) => pattern.value(key, json.values[key]));
	  return pattern;
	};
	
	const p1 = new Pattern('babcdaf');
	p1.value('b', 2);
	p1.value('a', 2);
	p1.value('c', 3);
	p1.value('d', 4);
	p1.value('b', 2);
	p1.value('f', 5);
	p1.calc(20);
	const p2 = new Pattern(' // ^^%');
	module.exports = Pattern
	
});


RequireJS.addFunction('./services/cabinet/app-src/cost/init-costs.js',
function (require, exports, module) {
	

	
	
	const Cost = require('./cost.js');
	const Material = require('./types/material.js');
	const Labor = require('./types/labor.js');
	
	Cost.register(Material);
	Cost.register(Labor);
	
});


RequireJS.addFunction('./services/cabinet/app-src/display-utils/displayManager.js',
function (require, exports, module) {
	

	
	const du = require('../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../public/js/utils/$t.js');
	
	class DisplayManager {
	  constructor(displayId, listId, switchId, selected) {
	    if (switchId && !listId) throw new Error('switchId can be defined iff listId is defined');
	    const id = String.random();
	    const instance = this;
	    this.list = (func) => {
	      const list = [];
	      const runFunc = (typeof func) === 'function';
	      const displayElems = du.id(displayId).children;
	      for (let index = 0; index < displayElems.length; index += 1) {
	        const elem = displayElems[index];
	        let id = elem.id || String.random(7);
	        elem.id = id;
	        name = elem.getAttribute('name') || id;
	        const item = {id, name, link: elem.getAttribute('link')};
	        if (runFunc) func(elem);
	        list.push(item);
	      }
	      return list;
	    }
	
	    function updateActive(id) {
	      const items = document.querySelectorAll('.display-manager-input');
	      for (let index = 0; index < items.length; index += 1) {
	        const elem = items[index];
	        elem.getAttribute('display-id') === id ?
	              du.class.add(elem, 'active') : du.class.remove(elem, 'active');
	      }
	    }
	
	    function open(id) {
	      const displayElems = du.id(displayId).children;
	      for (let index = 0; index < displayElems.length; index += 1) {
	        const elem = displayElems[index];
	        if (elem.id === id) {
	          const link = elem.getAttribute('link');
	          if (link) {
	            window.location.href = link;
	            return;
	          }
	          elem.hidden = false;
	        }
	        else elem.hidden = true;
	      }
	      updateActive(id);
	    }
	
	    this.open = open;
	
	    const children = du.id(displayId).children;
	
	    if (switchId) {
	      du.on.match('click', `#${switchId}`, (target, event) => {
	        const listElem = du.id(listId);
	        listElem.hidden = !listElem.hidden;
	      });
	      document.addEventListener('click', (event) => {
	        const listElem = du.id(listId);
	        const target = event.target;
	        const withinList = du.find.up(`#${listId}`, target) !== undefined;
	        if (!withinList && target.id !== switchId &&listElem)
	          listElem.hidden = true;
	      });
	    }
	    DisplayManager.instances[id] = this
	    if ((typeof selected) === 'string') setTimeout(() => open(selected), 100);
	    else if (children.length > 0) {
	      this.list();
	      open(children[0].id);
	    }
	    if (listId) {
	      du.id(listId).innerHTML = DisplayManager.template.render({id, switchId, list: this.list()});
	    }
	  }
	}
	
	DisplayManager.instances = {};
	DisplayManager.template = new $t('display-manager');
	
	du.on.match('click', '.display-manager-input', (target, event) => {
	  const displayManager = du.find.up('.display-manager', target);
	  const displayManagerId = displayManager.id;
	  const displayId = target.getAttribute('display-id');
	  DisplayManager.instances[displayManagerId].open(displayId);
	});
	module.exports = DisplayManager
	
});


RequireJS.addFunction('./services/cabinet/app-src/display-utils/information-bar.js',
function (require, exports, module) {
	

	
	const du = require('../../../../public/js/utils/dom-utils.js');
	
	class InformationBar {
	  constructor() {
	    const container = du.create.element('div');
	    container.className = 'information-bar';
	
	    this.show = () => container.hidden = false;
	    this.hide = () => container.hidden = true;
	    this.update = (html) => container.innerHTML = html;
	
	    document.body.append(container);
	  }
	}
	module.exports = InformationBar
	
	
	
	
	
});


RequireJS.addFunction('./services/cabinet/app-src/services/cabinet-opening-coordinates.js',
function (require, exports, module) {
	
const Line3D = require('../three-d/objects/line.js');
	const Vertex3D = require('../three-d/objects/vertex.js');
	const Polygon3D = require('../three-d/objects/polygon.js');
	const BiPolygon = require('../three-d/objects/bi-polygon.js');
	const Cutter = require('../objects/assembly/assemblies/cutter.js');
	const Panel = require('../objects/assembly/assemblies/panel.js');
	const Butt = require('../objects/joint/joints/butt.js');
	// TODO: fix required coordinate layout leftTop, rightTop, RightBottom, leftBottom
	class CabinetOpeningCorrdinates {
	  constructor(cabinet, sectionProperties) {
	    const config = sectionProperties.config();
	    let subassemblies = [];
	    const instance = this;
	
	    this.divide = sectionProperties.divide;
	    this.setSection = sectionProperties.setSection;
	    this.sections = sectionProperties.sections;
	    this.vertical = sectionProperties.vertical;
	    this.normal = sectionProperties.normal;
	    this.sectionProperties = () => sectionProperties;
	    this.pattern = sectionProperties.pattern;
	    this.top = sectionProperties.top;
	    this.bottom = sectionProperties.bottom;
	    this.left = sectionProperties.left;
	    this.right = sectionProperties.right;
	    this.back = sectionProperties.back;
	    this.coordinates = sectionProperties.coordinates;
	
	    const origGetSub = sectionProperties.getSubassemblies;
	    sectionProperties.getSubassemblies = () => {
	      if (subassemblies.length)
	        return origGetSub().concat(subassemblies);
	      return origGetSub();
	    }
	
	    function defaultCoordinates() {
	      const right = instance.right();
	      const left = instance.left();
	      const top = instance.top();
	      const bottom = instance.bottom();
	
	      const topMax = top.position().centerAdjust('y', '+z');
	      const topMin = top.position().centerAdjust('y', '-z');
	      const leftMax = left.position().centerAdjust('x', '+z');
	      const leftMin = left.position().centerAdjust('x', '-z');
	      const rightMin = right.position().centerAdjust('x', '-z');
	      const rightMax = right.position().centerAdjust('x', '+z');
	      const bottomMin = bottom.position().centerAdjust('y', '-z');
	      const bottomMax = bottom.position().centerAdjust('y', '+z');
	
	      return {
	        inner: [
	          {x: leftMax, y: topMin, z: 0},
	          {x: rightMin, y: topMin, z: 0},
	          {x: rightMin, y: bottomMax, z: 0},
	          {x: leftMax, y: bottomMax, z: 0}
	        ],
	        outer: [
	          {x: leftMin, y: topMax, z: 0},
	          {x: rightMax, y: topMax, z: 0},
	          {x: rightMax, y: bottomMin, z: 0},
	          {x: leftMin, y: bottomMin, z: 0}
	        ]
	      }
	    }
	
	    function manualCoordinates(object) {
	      return cabinet.evalObject(object);;
	    }
	
	    let printVerts = (verts) => '(' + leftPlane[0].vertices().join('),(') + ')';
	
	    function backCoordinates() {
	      const right = instance.right();
	      const left = instance.left();
	      const top = instance.top();
	      const bottom = instance.bottom();
	      const back = cabinet.getAssembly(config.back);
	      const center = Vertex3D.center(bottom.position().center(), top.position().center());
	
	      const biPolyLeft = left.position().toBiPolygon();
	      const biPolyRight = right.position().toBiPolygon();
	      const biPolyTop = top.position().toBiPolygon();
	      const biPolyBottom = bottom.position().toBiPolygon();
	      const leftPolys = biPolyLeft.furthestOrder(center);
	      const rightPolys = biPolyRight.furthestOrder(center);
	      const topPolys = biPolyTop.furthestOrder(center);
	      const bottomPolys = biPolyBottom.furthestOrder(center);
	
	      const backCenter = back.position().center();
	      const outLineLeft = Line3D.centerClosestTo(backCenter, leftPolys[0].lines());
	      const outLineRight = Line3D.centerClosestTo(backCenter, rightPolys[0].lines());
	
	      const inLineLeft = Line3D.centerClosestTo(backCenter, leftPolys[1].lines());
	      const inLineRight = Line3D.centerClosestTo(backCenter, rightPolys[1].lines());
	
	      const topTopPlane = topPolys[0].toPlane();
	      const bottomTopPlane = topPolys[1].toPlane();
	      const bottomBottomPlane = bottomPolys[0].toPlane();
	      const topBottomPlane = bottomPolys[1].toPlane();
	
	      const topLeftOut = topTopPlane.intersection.line(outLineLeft);
	      const topRightOut = topTopPlane.intersection.line(outLineRight);
	      const bottomRightOut = bottomBottomPlane.intersection.line(outLineRight);
	      const bottomLeftOut = bottomBottomPlane.intersection.line(outLineLeft);
	
	      const topLeftIn = bottomTopPlane.intersection.line(inLineLeft);
	      const topRightIn = bottomTopPlane.intersection.line(inLineRight);
	      const bottomRightIn = topBottomPlane.intersection.line(inLineRight);
	      const bottomLeftIn = topBottomPlane.intersection.line(inLineLeft);
	
	      return {
	        in: new Polygon3D([topLeftIn, topRightIn, bottomRightIn, bottomLeftIn]),
	        out: new Polygon3D([topLeftOut, topRightOut, bottomRightOut, bottomLeftOut]),
	        center
	      }
	    }
	
	    // TODO-maybe: centerOffset was intended to enable rotation of the planes...
	    function sliceCoordinates(leftLen, rightLen, centerOffset) {
	      const backCoords = backCoordinates();
	      const outerBackPoly = backCoords.out;
	      const innerBackPoly = backCoords.in;
	      const innerDirPoly = innerBackPoly.parrelleNear(backCoords.center);
	
	      const oflpv = outerBackPoly.parrelleAt(-leftLen).vertices();
	      const ofrpv = outerBackPoly.parrelleAt(-rightLen).vertices();
	      const outer = [oflpv[0], ofrpv[1], ofrpv[2], oflpv[3]];
	      const outerPoly = new Polygon3D([oflpv[0], ofrpv[1], ofrpv[2], oflpv[3]]);
	      const outerPlane = outerPoly.toPlane();
	
	      const ibpv = innerBackPoly.vertices();
	      const idpv = innerDirPoly.vertices();
	      const i0 = outerPlane.intersection.line(new Line3D(ibpv[0], idpv[0]));
	      const i1 = outerPlane.intersection.line(new Line3D(ibpv[1], idpv[1]));
	      const i2 = outerPlane.intersection.line(new Line3D(ibpv[2], idpv[2]));
	      const i3 = outerPlane.intersection.line(new Line3D(ibpv[3], idpv[3]));
	
	      const corner2corner = outer[0].distance(outer[2]);
	
	      const biPoly = BiPolygon.fromPolygon(outerPoly, corner2corner/-2, 0, {x: corner2corner, y: corner2corner});
	      const partCode = 'gerf';
	      const partName = 'Gerf';
	      const cutter = new Cutter.Model(partCode, () => partName, biPoly.toModel);
	      subassemblies = [cutter];
	      const joint = (otherPartCode) => new Butt(partCode, otherPartCode);
	      cutter.addJoints(joint('T'), joint('B'), joint('R'), joint('L'));
	
	
	
	      return {inner: [i0,i1,i2,i3], outer};
	    }
	
	
	
	
	    this.update = () => {
	      let coords;
	      try {
	        switch (config._Type) {
	          case 'location':
	          coords = manualCoordinates(config.coordinates); break;
	          case 'slice':
	          coords = sliceCoordinates(cabinet.eval(config.leftDepth), cabinet.eval(config.rightDepth));break;
	        }
	      } catch (e) {
	        console.warn(`Failed to determine coordinates of the specified type: '${config._Type}'`);
	        console.warn(e);
	      }
	
	      if (coords === undefined) coords = defaultCoordinates();
	
	      sectionProperties.updateCoordinates(coords);
	      return coords;
	    }
	  }
	}
	
	module.exports = CabinetOpeningCorrdinates;
	
});


RequireJS.addFunction('./services/cabinet/app-src/display-utils/toggle-display-list.js',
function (require, exports, module) {
	

	
	const du = require('../../../../public/js/utils/dom-utils.js');
	
	
	const ToggleDisplayList = {};
	ToggleDisplayList.class = 'toggle-display-list';
	ToggleDisplayList.funcs = {};
	
	ToggleDisplayList.onShow = (displayId, func) => {
	  if ((typeof func) === 'function') {
	    if (ToggleDisplayList.funcs[displayId] === undefined) {
	      ToggleDisplayList.funcs[displayId] = [];
	    }
	    ToggleDisplayList.funcs[displayId].push(func);
	  }
	}
	
	ToggleDisplayList.runFuncs = (displayId) => {
	  if (ToggleDisplayList.funcs[displayId] === undefined) return;
	  ToggleDisplayList.funcs[displayId].forEach((func) => func(displayId));
	}
	
	ToggleDisplayList.toggle = function (elem, event) {
	  const target = event.target;
	  const children = elem.children;
	  for (let index = 0; index < children.length; index += 1) {
	    const child = children[index];
	    if (target === child) {
	      du.class.add(child, 'active');
	      const displayId = child.getAttribute('display-id');
	      du.id(displayId).hidden = false;
	      ToggleDisplayList.runFuncs(displayId);
	    } else {
	      du.class.remove(child, 'active');
	      du.id(child.getAttribute('display-id')).hidden = true;
	    }
	  }
	}
	
	du.on.match('click', `.${ToggleDisplayList.class}`, ToggleDisplayList.toggle);
	
	module.exports = ToggleDisplayList;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/cabinet.js',
function (require, exports, module) {
	

	
	const Show = require('../show.js');
	const Select = require('../../../../public/js/utils/input/styles/select.js');
	const ThreeDMain = require('../displays/three-d-main.js');
	const ThreeDModel = require('../three-d/three-d-model.js');
	const TwoDLayout = require('../displays/two-d-layout');
	const OpenSectionDisplay = require('./open-section.js');
	const CabinetConfig = require('../config/cabinet-configs.js');
	const Cabinet = require('../objects/assembly/assemblies/cabinet.js');
	const ExpandableList = require('../../../../public/js/utils/lists/expandable-list.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const Request = require('../../../../public/js/utils/request.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const bind = require('../../../../public/js/utils/input/bind.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const Object3D = require('../three-d/layout/object.js');
	const Inputs = require('../input/inputs.js');
	const EPNTS = require('../../generated/EPNTS');
	
	
	function getHtmlElemCabinet (elem) {
	  const cabinetId = du.find.up('[cabinet-id]', elem).getAttribute('cabinet-id');
	  return Cabinet.get(cabinetId);
	}
	
	class CabinetDisplay {
	  constructor(parentSelector, group) {
	    let propId = 'Half Overlay';
	    let displayId = String.random();
	    const instance = this;
	    this.propId = (id) => {
	      if (id ===  undefined) return propId;
	      propId = id;
	    }
	    function displayValue(val) {
	      return new Measurement(val).display();
	    }
	    const getHeader = (cabinet, $index) =>
	        CabinetDisplay.headTemplate.render({cabinet, $index, displayValue, displayId});
	    const showTypes = Show.listTypes();
	    const getBody = (cabinet, $index) => {
	      if (expandList.activeKey() === $index) {
	        TwoDLayout.panZoom.once();
	        ThreeDMain.update(cabinet);
	      }
	      const scope = {$index, cabinet, showTypes, OpenSectionDisplay};
	      return CabinetDisplay.bodyTemplate.render(scope);
	    }
	
	    function inputValidation(values) {
	      // const validName = values.name !== undefined;
	      // const validType = CabinetConfig.valid(values.type, values.id);
	      if(true) return true;
	      return {type: 'You must select a defined type.'};
	    }
	
	    function updateLayout(target) {
	      const attr = target.name === 'thickness' ? 'height' : 'width';
	      const cabinet = getHtmlElemCabinet(target);
	      const obj3D = Object3D.get(cabinet.id());
	      const value = new Measurement(target.value, true).decimal();
	      console.log('new cab val', value);
	      // obj3D.snap.top()[attr](value);
	      ThreeDMain.update(cabinet);
	    }
	
	    du.on.match('enter:focusout', '.cabinet-id-input.dem[name="width"],.cabinet-id-input.dem[name="thickness"', updateLayout);
	
	    function updateCabValue(cabinet, attr) {
	      const inputCnt = du.find(`[cabinet-id='${cabinet.id()}']`);
	      const input = du.find.down(`[name='${attr}']`, inputCnt);
	      input.value = displayValue(cabinet[attr]());
	    }
	
	    function removeFromLayout(elem, cabinet) {
	      group.room().layout().removeByPayload(cabinet);
	      TwoDLayout.panZoom.once();
	    }
	
	    function linkLayout(cabinet, obj3D) {
	      const snap = obj3D.snap.top();
	      if (snap.width() !== cabinet.width()) {
	        cabinet.width(snap.width());
	        updateCabValue(cabinet, 'width');
	      }
	      if (snap.height() !== cabinet.thickness()) {
	        cabinet.thickness(snap.height());
	        updateCabValue(cabinet, 'thickness');
	      }
	    }
	
	    function updateObjLayout(elem, cabinetModel) {
	      console.log('model update');
	    }
	
	    ThreeDModel.onRenderObjectUpdate(updateObjLayout);
	
	    const getObject = (values) => {
	      const cabinet = CabinetConfig.get(group, values.type, values.layout, values.name);
	      return cabinet;
	    };
	    this.active = () => expandList.active();
	    const expListProps = {
	      list: group.objects,
	      // dontOpenOnAdd: true,
	      type: 'top-add-list',
	      inputTree:   CabinetConfig.inputTree(),
	      parentSelector, getHeader, getBody, getObject, inputValidation,
	      listElemLable: 'Cabinet'
	    };
	    const expandList = new ExpandableList(expListProps);
	    expandList.afterRemoval(removeFromLayout);
	    this.refresh = () => expandList.refresh();
	
	    const cabinetKey = (path) => {
	      const split = path.split('.');
	      const index = split[0];
	      const key = split[1];
	      const cabinet = expListProps.list[index];
	      return {cabinet, key};
	    }
	
	    const valueUpdate = (path, value) => {
	      const cabKey = cabinetKey(path);
	      const decimal = new Measurement(value, true).decimal();
	      cabKey.cabinet.value(cabKey.key, !Number.isNaN(decimal) ? decimal : value);
	      TwoDLayout.panZoom.once();
	      ThreeDMain.update(cabKey.cabinet);
	    }
	
	    const attrUpdate = (path, value) => {
	      const cabKey = cabinetKey(path);
	      const decimal = new Measurement(value, true).decimal();
	      cabKey.cabinet[cabKey.key](!Number.isNaN(decimal) ? decimal : value);
	    }
	
	    const saveSuccess = () => console.log('success');
	    const saveFail = () => console.log('failure');
	    const save = (target) => {
	      const index = target.getAttribute('index');
	      const cabinet = expListProps.list[index];
	      if (cabinet.name !== undefined) {
	        Request.post(EPNTS.cabinet.add(cabinet.name()), cabinet.toJson(), saveSuccess, saveFail);
	        console.log('saving');
	      } else {
	        alert('Please enter a name if you want to save the cabinet.')
	      }
	    }
	
	    // WTFs
	    // CabinetConfig.onUpdate(() => props.inputOptions = CabinetConfig.list());
	    bind(`.cabinet-input`, valueUpdate,
	                  {validation: Measurement.validation('(0,)')});
	    bind(`[display-id="${displayId}"].cabinet-id-input`, attrUpdate);
	    du.on.match('click', '.save-cabinet-btn', save);
	  }
	}
	CabinetDisplay.bodyTemplate = new $t('cabinet/body');
	CabinetDisplay.headTemplate = new $t('cabinet/head');
	module.exports = CabinetDisplay
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/controls-2d.js',
function (require, exports, module) {
	
const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	
	class Controls2d extends Lookup {
	  constructor(parentSelector, getLayout, panZ) {
	    super();
	    const navId = `orientation-arrows-${this.id()}`;
	    let moveCount = 0;
	    const instance = this;
	    let centerWithin = true;
	    this.navId = () => navId;
	    this.space = () => '&nbsp;&nbsp;';
	    CustomEvent.all(this, 'up', 'right', 'down', 'left', 'center');
	    this.centerCode = () => {
	      const panCenter = panZ.center();
	      console.log(panCenter);
	      centerWithin = getLayout().within(panCenter);
	      return !centerWithin ? 8982 : 9633;
	    }
	
	    function updateHtml() {
	      const elem = du.find(parentSelector);
	      if (elem === undefined) throw new Error(`No container found: '${parentSelector}'`);
	      elem.innerHTML = Controls2d.template.render(instance);
	    }
	
	    panZ.onTranslate((hmm) => {
	      moveCount++;
	      updateHtml();
	    });
	
	    updateHtml();
	
	    this.on.up((elem, detail) => {
	      getLayout().nextLevel();
	      panZ.once();
	    });
	    this.on.down((elem, detail) => {
	      getLayout().prevLevel();
	      panZ.once();
	    });
	
	    this.on.right((elem, detail) => {
	      panZ.displayTransform.rotate += Math.PI/-4;
	      panZ.once();
	    });
	    this.on.left((elem, detail) => {
	      panZ.displayTransform.rotate += Math.PI/4;
	      panZ.once();
	    });
	    this.on.center((elem, detail) => {
	      const layout = getLayout();
	      if (centerWithin) {
	        layout.straightenUp();
	        panZ.once();
	      } else {
	        panZ.centerOn(layout.center().x(), layout.center().y());
	      }
	    });
	
	  }
	}
	
	Controls2d.template = new $t('2d/controls');
	
	du.on.match('click', '.controls-2d>tbody>tr>td[dir]', function (target) {
	  const tableElem = du.find.up('[l-id]', target);
	  if (!tableElem) return;
	  const id = tableElem.getAttribute('l-id');
	  const instance = Controls2d.get(id);
	  const direction = target.getAttribute('dir');
	  switch (direction) {
	    case 'u':
	      instance.trigger.up(target, {direction, instance});
	      break;
	    case 'r':
	      instance.trigger.right(target, {direction, instance});
	      break;
	    case 'd':
	      instance.trigger.down(null, {direction, instance});
	      break;
	    case 'l':
	      instance.trigger.left(target, {direction, instance});
	      break;
	    case 'c':
	      instance.trigger.center(target, {direction, instance});
	      break;
	  }
	});
	
	module.exports = Controls2d;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/face-sketch.js',
function (require, exports, module) {
	
const du = require('../../../../public/js/utils/dom-utils.js');
	const Draw2D = require('../../../../public/js/utils/canvas/two-d/draw.js');
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line.js');
	const Vertex2d = require('../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const PanZoom = require('../../../../public/js/utils/canvas/two-d/pan-zoom.js');
	const ThreeDModel = require('../three-d/three-d-model.js');
	const LineMeasurement2d = require('../../../../public/js/utils/canvas/two-d/objects/line-measurement.js');
	
	
	class FaceSketch {
	  constructor(clazz) {
	    clazz ||= 'front-sketch';
	    function draw(event, model) {
	      if (model === undefined) return;
	      let centerOn = new Vertex2d({x:0, y:0});
	      console.log(model);
	    }
	
	    ThreeDModel.onRenderObjectUpdate(draw);
	  }
	}
	
	module.exports = FaceSketch;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/feature.js',
function (require, exports, module) {
	

	const $t = require('../../../../public/js/utils/$t');
	
	class FeatureDisplay {
	  constructor(assembly, parentSelector) {
	    this.html = () => FeatureDisplay.template.render({features: assembly.features, id: 'root'});
	    this.refresh = () => {
	      const container = document.querySelector(parentSelector);
	      container.innerHTML = this.html;
	    }
	  }
	}
	FeatureDisplay.template = new $t('features');
	module.exports = FeatureDisplay
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/group.js',
function (require, exports, module) {
	

	
	const Group = require('../objects/group.js');
	const PropertyConfig = require('../config/property/config.js');
	const Properties = require('../config/properties.js');
	const CabinetDisplay = require('./cabinet.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const Select = require('../../../../public/js/utils/input/styles/select.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const bind = require('../../../../public/js/utils/input/bind.js');
	const ThreeDMain = require('../displays/three-d-main.js');
	
	const currentStyleState = {};
	
	function disableButton(values, dit, elem) {
	  const nId = dit.node.constructor.decode(dit.root().id()).id;
	  const currState = currentStyleState[nId];
	  const rootId = dit.node.constructor.decode(dit.root().id()).id;
	  const button = du.find(`button[root-id='${rootId}']`);
	  if (button) button.hidden = Object.equals(currState, values);
	  const headers = du.find.downAll('.group-header', du.find.up('.group-cnt', button));
	  headers.forEach((header) => {
	    header.hidden = currState.style !== header.getAttribute("cab-style");
	    if (!header.hidden) du.find.down('.group-key', header).innerText = currState.subStyle;
	  });
	}
	
	class GroupDisplay extends Lookup {
	  constructor(group) {
	    super();
	    function setCurrentStyleState(values) {
	      values = values || dit.values();
	      const nId = dit.node.constructor.decode(dit.root().id()).id;
	      currentStyleState[nId] = values;
	      disableButton(values, dit);
	      return values;
	    }
	    function onCabinetStyleSubmit(values) {
	      setCurrentStyleState(values);
	      group.propertyConfig.set(values.style, values.subStyle);
	      ThreeDMain.update();
	    }
	
	    let initialized = false;
	    function initializeDitButton() {
	      if (initialized) disableButton(dit.values(), dit);
	      else {
	        disableButton(setCurrentStyleState(), dit);
	        initialized = true;
	      }
	    }
	    const dit = GroupDisplay.DecisionInputTree(onCabinetStyleSubmit, group.propertyConfig);
	    function styleSelector() {
	      return dit.root().payload().html();
	    }
	    function propertyHtml() {return GroupDisplay.propertyMenuTemplate.render({styleSelector})};
	    this.bodyHtml = () =>  {
	      setTimeout(initializeDitButton, 200);
	      return GroupDisplay.bodyTemplate.render({group, propertyHtml});
	    }
	    this.html = () => {
	      return GroupDisplay.headTemplate.render({group, propertyHtml, groupDisplay: this, body: this.bodyHtml()});
	    }
	
	    this.cabinetDisplay = new CabinetDisplay(`[group-id="${group.id()}"].cabinet-cnt`, group);
	    this.cabinet = () => this.cabinetDisplay().active();
	  }
	}
	
	GroupDisplay.DecisionInputTree = (onSubmit, propertyConfigInst) => {
	  const dit = new DecisionInputTree(undefined, {buttonText: 'Change'});
	  dit.onChange(disableButton);
	  dit.onSubmit(onSubmit);
	  const propertyConfig = new PropertyConfig();
	  const styles = propertyConfig.cabinetStyles();
	  const cabinetStyles = new Select({
	    name: 'style',
	    list: styles,
	    inline: true,
	    label: 'Style',
	    value: propertyConfigInst.cabinetStyle()
	  });
	
	  const hasFrame = new Select({
	      name: 'FrameStyle',
	      inline: true,
	      list: ['Frameless', 'Framed', 'Frame Only'],
	      value: 'Frameless'
	    });
	
	  const style = dit.branch('style', [hasFrame, cabinetStyles]);
	  styles.forEach((styleName) => {
	    const properties = Properties.groupList(styleName);
	    const selectObj = Object.keys(properties);
	    const select = new Select({
	      name: 'subStyle',
	      inline: true,
	      list: selectObj,
	      value: propertyConfigInst.cabinetStyleName()
	    });
	    const condtionalPayload = new DecisionInputTree.ValueCondition('style', [styleName], [select]);
	    style.conditional(styleName, condtionalPayload);
	  });
	
	  return dit;
	}
	
	du.on.match('click', `.group-display-header`, (target) => {
	  const allBodys = du.find.all('.group-display-body');
	  for (let index = 0; index < allBodys.length; index += 1) {
	    allBodys[index].hidden = true;
	  }
	  const allHeaders = du.find.all('.group-display-header');
	  for (let index = 0; index < allHeaders.length; index += 1) {
	    du.class.remove(allHeaders[index], 'active');
	  }
	  du.class.add(target, 'active');
	  const body = du.find.closest('.group-display-body', target);
	  const groupDisplayId = du.find.up('[group-display-id]', target).getAttribute('group-display-id');
	  const groupDisplay = GroupDisplay.get(groupDisplayId);
	  body.innerHTML = groupDisplay.bodyHtml();
	  groupDisplay.cabinetDisplay.refresh();
	  body.hidden = false;
	});
	
	GroupDisplay.valueUpdate = (target) => {
	  const group = Group.get(target.getAttribute('group-id'));
	  const value = target.value;
	  group.name(value);
	}
	
	du.on.match('change', `[group-id].group-input`, GroupDisplay.valueUpdate);
	
	GroupDisplay.headTemplate = new $t('group/head');
	GroupDisplay.bodyTemplate = new $t('group/body');
	GroupDisplay.propertyMenuTemplate = new $t('properties/property-menu');
	module.exports = GroupDisplay
	
});


RequireJS.addFunction('./services/cabinet/app-src/config/cabinet-layouts.js',
function (require, exports, module) {
	
const Handle = require('../objects/assembly/assemblies/hardware/pull.js');
	
	const map = {};
	const list = () => Object.keys(map);
	
	class CabinetLayout {
	  constructor(name, build) {
	    this.name = () => name;
	    this.build = build;
	    if (map[name]) throw new Error(`CabinetLayout '${name}' already exists`);
	    map[name] = this;
	  }
	}
	
	
	module.exports = {map, list};
	
	new CabinetLayout('1dDD', (cabinet) => {
	  cabinet.width(18*2.54);
	
	  const opening = cabinet.openings[0];
	
	  opening.divide(2);
	  opening.vertical(false);
	  opening.sections[0].setSection("DrawerSection");
	  opening.sections[1].setSection("DualDoorSection");
	  opening.pattern('ab').value('a', 6);
	});
	
	new CabinetLayout('1dD', (cabinet) => {
	  cabinet.width(18*2.54);
	
	  const opening = cabinet.openings[0];
	
	  opening.divide(1);
	  opening.vertical(false);
	  opening.sections[0].setSection("DrawerSection");
	  opening.sections[1].setSection("DoorSection");
	  opening.pattern('ab').value('a', 6);
	});
	
	new CabinetLayout('3d', (cabinet) => {
	  cabinet.width(18*2.54);
	
	  const opening = cabinet.openings[0];
	
	  opening.divide(2);
	  opening.vertical(false);
	  opening.sections[0].setSection("DrawerSection");
	  opening.sections[1].setSection("DrawerSection");
	  opening.sections[2].setSection("DrawerSection");
	  opening.pattern('abb').value('a', 6);
	});
	
	new CabinetLayout('3dsb3d', (cabinet) => {
	  cabinet.width(60*2.54);
	
	  const opening = cabinet.openings[0];
	  opening.divide(2);
	  opening.sectionProperties().pattern('bab').value('a', 30*2.54);
	  const left = opening.sections[0];
	  const center = opening.sections[1];
	  const right = opening.sections[2];
	  const a = 6*2.54
	
	  left.divide(2);
	  left.vertical(false);
	  left.sections[0].setSection("DrawerSection");
	  left.sections[1].setSection("DrawerSection");
	  left.sections[2].setSection("DrawerSection");
	  left.pattern('abb').value('a', a);
	
	  center.divide(1);
	  center.vertical(false);
	  center.sections[1].setSection('DualDoorSection');
	  center.pattern('ab').value('a', a);
	  const centerTop = center.sections[0];
	
	  centerTop.divide(2);
	  centerTop.sections[0].setSection("DoorSection");
	  centerTop.sections[1].setSection("FalseFrontSection");
	  centerTop.sections[2].setSection("DoorSection");
	  centerTop.pattern('ztz').value('t', 15*2.54);
	  centerTop.sections[0].cover().pull().location(Handle.location.RIGHT);
	  centerTop.sections[2].cover().pull().location(Handle.location.LEFT);
	
	  right.divide(2);
	  right.vertical(false);
	  right.sections[0].setSection("DrawerSection");
	  right.sections[1].setSection("DrawerSection");
	  right.sections[2].setSection("DrawerSection");
	  right.pattern('abb').value('a', a);
	});
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/open-section.js',
function (require, exports, module) {
	

	
	const SectionProperties = require('../objects/assembly/assemblies/section/section-properties.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const bind = require('../../../../public/js/utils/input/bind.js');
	const ExpandableList = require('../../../../public/js/utils/lists/expandable-list.js');
	const MeasurementInput = require('../../../../public/js/utils/input/styles/measurement.js');
	const ThreeDMain = require('./three-d-main.js');
	const StringMathEvaluator = require('../../../../public/js/utils/string-math-evaluator.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const FeatureDisplay = require('./feature');
	const Inputs = require('../input/inputs.js');
	
	
	class SectionDisplay {
	  constructor (section) {
	    this.render = (scope) => {
	      scope.featureDisplay = new FeatureDisplay(scope.opening).html();
	      const cId = scope.opening.constructor.name;
	      if (cId === 'SectionProperties') {
	        return OpenSectionDisplay.html(scope.opening, scope.list, scope.sections);
	      }
	      return SectionDisplay.template(section).render(scope);
	    }
	  }
	}
	
	const templates = {};
	const fileLocations = {};
	SectionDisplay.template = (section) => {
	  const cName = section.constructor.name;
	  if (fileLocations[cName] === undefined) {
	    const filename = cName.replace(/Section$/, '')
	                            .replace(/([a-z])([A-Z])/g, '$1-$2')
	                            .toLowerCase();
	    fileLocations[cName] = `sections/${filename}`;
	  }
	  const templatePath = fileLocations[cName];
	  if (templates[templatePath] === undefined) templates[templatePath] = new $t(templatePath);
	  return templates[templatePath];
	}
	
	du.on.match('change', '.feature-radio', (target) => {
	  const allRadios = document.querySelectorAll(`[name="${target.name}"]`);
	  allRadios.forEach((radio) => radio.nextElementSibling.hidden = true);
	  target.nextElementSibling.hidden = !target.checked;
	});
	
	displays = {};
	SectionDisplay.render = (scope) => {
	  const uId = scope.opening.id();
	  if (displays[uId] === undefined) displays[uId] = new SectionDisplay(scope.opening);
	  return displays[uId].render(scope);
	}
	
	const OpenSectionDisplay = {};
	
	OpenSectionDisplay.html = (opening) => {
	  const openDispId = OpenSectionDisplay.getId(opening);
	  OpenSectionDisplay.sections[opening.id()] = opening;
	  if (opening.sectionCount() > 1) OpenSectionDisplay.refresh(opening, true);
	  const patternInputHtml = OpenSectionDisplay.patterInputHtml(opening);
	  const sections = SectionProperties.list();
	  return OpenSectionDisplay.template.render({opening, openDispId, patternInputHtml,
	                                            sections, OpenSectionDisplay});
	}
	
	OpenSectionDisplay.getSelectId = (opening) => `opin-division-pattern-select-${opening.id()}`;
	OpenSectionDisplay.template = new $t('opening');
	OpenSectionDisplay.listBodyTemplate = new $t('divide/body');
	OpenSectionDisplay.listHeadTemplate = new $t('divide/head');
	OpenSectionDisplay.sections = {};
	OpenSectionDisplay.lists = {};
	OpenSectionDisplay.getId = (opening) => `open-section-display-${opening.id()}`;
	
	OpenSectionDisplay.getList = (root) => {
	  let openId = root.id();
	  if (OpenSectionDisplay.lists[openId]) return OpenSectionDisplay.lists[openId];
	  // const sections = SectionProperties.sections();
	  // const getObject = (target) => sections[Math.floor(Math.random()*sections.length)];
	  const parentSelector = `#${OpenSectionDisplay.getId(root)}`
	  const list = root.sections;
	  const hideAddBtn = true;
	  const selfCloseTab = true;
	  let exList;
	  const clean = (name) => name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/ Section$/, '');
	  const getHeader = (opening, index) => {
	    return OpenSectionDisplay.listHeadTemplate.render({opening, clean});
	  }
	  const getBody = (opening) => {
	    const list = OpenSectionDisplay.getList(root);
	    const getFeatureDisplay = (assem) => new FeatureDisplay(assem).html();
	    const assemblies = opening.getSubassemblies();
	    return SectionDisplay.render({assemblies, getFeatureDisplay, opening, list});
	  }
	  const findElement = (selector, target) => du.find.down(selector, du.find.up('.expandable-list', target));
	  const expListProps = {
	    parentSelector, getHeader, getBody, list, hideAddBtn,
	    selfCloseTab, findElement, startClosed: true, removeButton: false
	  }
	  exList = new ExpandableList(expListProps);
	  OpenSectionDisplay.lists[openId] = exList;
	  return exList;
	}
	OpenSectionDisplay.dividerControlTemplate = new $t('divider-controls');
	OpenSectionDisplay.dividerHtml = (opening) => {
	  const selector = `[opening-id="${opening.id()}"].opening-cnt > .divider-controls`;
	  const patternInputHtml = OpenSectionDisplay.patterInputHtml(opening);
	  return OpenSectionDisplay.dividerControlTemplate.render({opening, patternInputHtml});
	}
	OpenSectionDisplay.updateDividers = (opening) => {
	  const focusInfo = du.focusInfo();
	  const selector = `[opening-id="${opening.id()}"].opening-cnt > .divider-controls`;
	  const dividerControlsCnt = document.querySelector(selector);
	  dividerControlsCnt.innerHTML = OpenSectionDisplay.dividerHtml(opening);
	  du.focus(focusInfo);
	  console.log();
	}
	
	OpenSectionDisplay.changeIds = {};
	OpenSectionDisplay.refresh = (opening, rapid, onlyIfPending) => {
	  if (OpenSectionDisplay.changeIds[opening.id()] === undefined)
	    OpenSectionDisplay.changeIds[opening.id()] = {nextId: 0, lastId: 0};
	  let idObj = OpenSectionDisplay.changeIds[opening.id()];
	  let changeId = idObj.nextId;
	  if (!onlyIfPending || changeId > idObj.lastId) {
	    idObj.nextId = ++changeId;
	    setTimeout(()=> {
	      if (changeId === idObj.nextId) {
	        idObj.lastId = changeId;
	        const id = OpenSectionDisplay.getId(opening);
	        const target = du.id(id);
	        const listCnt = du.find.up('.expandable-list', target);
	        if (!listCnt) return;
	        const listId = Number.parseInt(listCnt.getAttribute('ex-list-id'));
	
	        const type = opening.isVertical() === true ? 'pill' : 'sidebar';
	        OpenSectionDisplay.updateDividers(opening);
	        OpenSectionDisplay.getList(opening).refresh(type);
	        const dividerSelector = `[opening-id='${opening.id()}'].division-count-input`;
	        // listCnt.querySelector(dividerSelector).focus();
	      }
	    }, rapid ? 200 : 2000);
	  }
	}
	
	OpenSectionDisplay.patternContainerSelector = (opening) =>
	  `.open-pattern-input-cnt[opening-id='${opening.id()}']`;
	
	OpenSectionDisplay.lastInputValues = {};
	OpenSectionDisplay.patterInputHtml = (opening) => {
	  const pattern = opening.pattern();
	  const patCntSelector = OpenSectionDisplay.patternContainerSelector(opening);
	
	  let inputHtml = '';
	  const unique = pattern.unique();
	  for (let index = 0; index < unique.length; index += 1) {
	    const id = unique[index];
	    let fill = opening.dividerLayout().fill;
	    const measInput = Inputs('pattern', {
	      label: id,
	      placeholder: id,
	      name: id,
	      value: fill[index]
	    });
	    measInput.on('keyup', (value, target) => {
	      opening.pattern().value(target.name, Measurement.decimal(target.value));
	      fill = opening.dividerLayout().fill;
	      const patternCnt = document.querySelector(patCntSelector);
	      const inputs = patternCnt.querySelectorAll('input');
	      fill.forEach((value, index) => {
	        if (inputs[index] !== target)
	          inputs[index].value = value;
	      });
	
	    });
	    inputHtml += measInput.html();
	    measInput.on('change', (value, target) => {
	      if (opening.pattern().satisfied()) {
	        const cabinet = opening.getAssembly('c');
	        ThreeDMain.update(cabinet);
	      }
	    })
	  }
	  return inputHtml;
	};
	
	OpenSectionDisplay.getOpening = (target) => {
	  const openId = target.getAttribute('opening-id');
	  return OpenSectionDisplay.sections[openId];
	}
	
	OpenSectionDisplay.evaluator = new StringMathEvaluator();
	
	OpenSectionDisplay.patternInputSelector = (opening) =>
	  `[name='pattern'][opening-id='${opening.id()}']`;
	
	OpenSectionDisplay.onPatternChange = (target) => {
	  const opening = OpenSectionDisplay.getOpening(target);
	  const newVal = target.value || 'a';
	  const cntSelector = OpenSectionDisplay.patternContainerSelector(opening);
	  const inputCnt = document.querySelector(OpenSectionDisplay.patternContainerSelector(opening));
	  if (opening.pattern().str !== newVal) {
	    opening.pattern(newVal).str;
	    const html = OpenSectionDisplay.patterInputHtml(opening);
	    document.querySelector(cntSelector).innerHTML = html;
	    if (newVal.length < 2) du.id(OpenSectionDisplay.getId(opening)).innerHTML = '';
	    else OpenSectionDisplay.refresh(opening);
	    const cabinet = opening.getAssembly('c');
	    ThreeDMain.update(cabinet);
	  }
	  if (inputCnt !== null) {
	    inputCnt.hidden = opening.pattern().equals;
	  }
	}
	
	function expiditeRefresh(target) {
	  const opening = OpenSectionDisplay.getOpening(target);
	  OpenSectionDisplay.refresh(opening, true, true);
	}
	
	OpenSectionDisplay.onOrientation = (target) => {
	  const openId = target.getAttribute('open-id');
	  const value = target.value;
	  const opening = OpenSectionDisplay.sections[openId];
	  opening.vertical(value === 'vertical');
	  OpenSectionDisplay.refresh(opening);
	};
	
	OpenSectionDisplay.onSectionChange = (target) => {
	  // ExpandableList.value('selected', target.value, target);
	  let section = ExpandableList.get(target);
	  if (!(section instanceof SectionProperties)) {
	    const index = du.find.up('[index]', target).getAttribute('index');
	    section = section.openings[index].sectionProperties();
	  }
	  section.setSection(target.value === "Open" ? null : target.value);
	  ThreeDMain.update(section);
	}
	
	du.on.match('keyup', '.division-pattern-input', OpenSectionDisplay.onPatternChange);
	du.on.match('change', '.division-pattern-input', expiditeRefresh);
	du.on.match('click', '.open-orientation-radio', OpenSectionDisplay.onOrientation);
	du.on.match('change', '.section-selection', OpenSectionDisplay.onSectionChange)
	module.exports = OpenSectionDisplay
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/opening-sketch.js',
function (require, exports, module) {
	
const du = require('../../../../public/js/utils/dom-utils.js');
	const Draw2D = require('../../../../public/js/utils/canvas/two-d/draw.js');
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line.js');
	const Vertex2d = require('../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const PanZoom = require('../../../../public/js/utils/canvas/two-d/pan-zoom.js');
	const LineMeasurement2d = require('../../../../public/js/utils/canvas/two-d/objects/line-measurement.js');
	
	
	class OpeningSketch {
	  constructor(id) {
	    let sketch, panZ, elem, cabinet;
	
	    function getSections(sections, list) {
	      list ||= [];
	      for (let index = 0; index < sections.length; index++) {
	        const section = sections[index];
	        if (sections.length > 0 || sections.cover()) {
	          list.push(section);
	          getSections(section.sections, list);
	        }
	      }
	      return list;
	    }
	
	    function draw() {
	      if (cabinet === undefined) return;
	      // sketch.ctx().drawImage(0,0)
	
	      const allLines = [];
	      for (let index = 0; index < cabinet.openings.length; index++) {
	        const sections = getSections(cabinet.openings[index].sections);
	        for (let si = 0; si < sections.length; si++) {
	          const section = sections[si];
	          if (section.sections.length < 1) {
	            const center = JSON.copy(section.innerCenter());
	            center.x*=-1;
	            sketch.text(section.partName(), center, 6, 'grey');
	          }
	          const inner = JSON.copy(section.coordinates().inner);
	          const outer = JSON.copy(section.coordinates().outer);
	
	          inner[0].x*=-1;inner[1].x*=-1;inner[2].x*=-1;inner[3].x*=-1;
	          outer[0].x*=-1;outer[1].x*=-1;outer[2].x*=-1;outer[3].x*=-1;
	          let lines = [new Line2d(inner[0], inner[1]),
	                          new Line2d(inner[1], inner[2]),
	                          new Line2d(inner[2], inner[3]),
	                          new Line2d(inner[3], inner[0])];
	          sketch(lines, undefined, .3);
	          lines = [new Line2d(outer[0], outer[1]),
	                          new Line2d(outer[1], outer[2]),
	                          new Line2d(outer[2], outer[3]),
	                          new Line2d(outer[3], outer[0])];
	          sketch(lines, 'green', .3);
	          allLines.concatInPlace(lines);
	        }
	      }
	      const cabLimits = cabinet.position().limits();
	      const dir = -1;
	      const cabinetOutline = [
	        new Line2d({x: dir*0, y: 2*cabLimits['y']}, {x: dir*2*cabLimits['x'], y: 2*cabLimits['y']}),
	        new Line2d({x: dir*2*cabLimits['x'], y: 2*cabLimits['y']}, {x: dir*2*cabLimits['x'], y: 0}),
	        new Line2d({x: dir*2*cabLimits['x'], y: 0}, {x: dir*0, y: 0}),
	        new Line2d({x: dir*0, y: 0}, {x: dir*0, y: 2*cabLimits['y']}),
	      ];
	      sketch(cabinetOutline, 'red', .3);
	      allLines.concatInPlace(cabinetOutline);
	
	      const measurements = LineMeasurement2d.measurements(allLines);
	      sketch(measurements, 'grey', 1);
	    }
	
	    function init() {
	      elem = du.id(id);
	      const canvas = du.create.element('canvas');
	      elem.append(canvas);
	      sketch = new Draw2D(canvas, true);
	      panZ = new PanZoom(sketch.canvas(), draw);
	    }
	
	    this.cabinet = (cab) => (cab.constructor.name === 'Cabinet' && (cabinet = cab)) || cabinet;
	
	    setTimeout(init, 500);
	  }
	}
	
	module.exports = OpeningSketch;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/order.js',
function (require, exports, module) {
	

	
	const du = require('../../../../public/js/utils/dom-utils.js');
	const UFObj = require('./information/utility-filter.js');
	const RoomDisplay = require('./room.js');
	const Order = require('../objects/order.js');
	const Request = require('../../../../public/js/utils/request.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const ExpandableObject = require('../../../../public/js/utils/lists/expandable-object.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const EPNTS = require('../../generated/EPNTS.js')
	const ToggleDisplayList = require('../../app-src/display-utils/toggle-display-list');
	const Inputs = require('../input/inputs.js');
	
	class OrderDisplay {
	  constructor(parentSelector, orders) {
	    const roomDisplays = {};
	    let active;
	    const getHeader = (order, $index) =>
	        OrderDisplay.headTemplate.render({order, $index});
	
	    const setInfo = (order, index) => () => {
	      console.log('oid:', order.id());
	      const elem = du.id(`uf-info-${order.id()}`);
	      if (elem)
	        UTF.buildDisplay(elem, new UFObj(order));
	    }
	
	    function initOrder(order, index) {
	      roomDisplays[order.id()] = new RoomDisplay('#room-pills', order);
	      ToggleDisplayList.onShow(`information-display-${order.id()}`, setInfo(order, index));
	      // expandList.afterRender(setInfo(order, index));
	      return order;
	    }
	
	    function loadOrder(index, start) {
	      return function (orderData) {
	        const order = new Order().fromJson(orderData);
	        initOrder(order, index);
	        expandList.set(index, order);
	        expandList.refresh();
	        console.log('load Time:', new Date().getTime() - start);
	      }
	    }
	
	    const getBody = (order, $index) => {
	      if (order.loaded) {
	        let propertyTypes = Object.keys(['insetfordabet', 'pickles']);
	        active = roomDisplays[order.id()];
	        return OrderDisplay.bodyTemplate.render({$index, order, propertyTypes});
	      } else {
	        const start = new Date().getTime();
	        Request.get(EPNTS.order.get(order.name()), loadOrder($index, start), console.error);
	        return 'Loading...';
	      }
	    }
	    const getObject = (values) => initOrder(new Order(values.name));
	    this.active = () => active;
	
	    const expListProps = {
	      list: orders,
	      inputValidation: (values) => values.name ? true :
	          'You must Define a name',
	      parentSelector, getHeader, getBody, getObject,
	      listElemLable: 'Order', type: 'sidebar',
	      inputTree: OrderDisplay.configInputTree()
	    };
	    const expandList = new ExpandableObject(expListProps);
	    expandList.afterRender(() => {if (active !== undefined) active.refresh()});
	
	    const saveSuccess = () => console.log('success');
	    const saveFail = () => console.log('failure');
	    const save = (target) => {
	      const index = target.getAttribute('index');
	      const order = expandList.get(index);
	      Request.post(EPNTS.order.add(order.name()), order.toJson(), saveSuccess, saveFail);
	      console.log('saving');
	    }
	
	    const attrUpdate = (attr) => (target) => {
	      const index = target.getAttribute('index');
	      const order = expandList.get(index);
	      order[attr] = target.value;
	    };
	
	    function addOrders(names) {
	      names.forEach((name) => expListProps.list[name] = new Order(name, null));
	      expandList.refresh();
	    }
	    Request.get(EPNTS.order.list(), addOrders);
	
	    du.on.match('change', '.order-name-input', attrUpdate('name'));
	    du.on.match('click', '.save-order-btn', save);
	  }
	}
	OrderDisplay.bodyTemplate = new $t('order/body');
	OrderDisplay.headTemplate = new $t('order/head');
	OrderDisplay.builderBodyTemplate = new $t('order/builder/body');
	OrderDisplay.builderHeadTemplate = new $t('order/builder/head');
	OrderDisplay.infoBodyTemplate = new $t('order/information/body');
	OrderDisplay.infoHeadTemplate = new $t('order/information/head');
	
	OrderDisplay.configInputTree = () => {
	  const dit = new DecisionInputTree();
	  dit.leaf('Config', [Inputs('name')]);
	  return dit;
	}
	module.exports = OrderDisplay
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/orientation-arrows.js',
function (require, exports, module) {
	
const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	
	class OrientationArrows extends Lookup {
	  constructor(parentSelector) {
	    super();
	    const navId = `orientation-arrows-${this.id()}`;
	    this.navId = () => navId;
	    this.space = () => '&nbsp;&nbsp;';
	    CustomEvent.all(this, 'up', 'right', 'down', 'left', 'center');
	
	    const elem = du.find(parentSelector);
	    if (elem === undefined) throw new Error(`No container found: '${parentSelector}'`);
	    elem.innerHTML = OrientationArrows.template.render(this);
	
	    this.on.up((elem, detail) => console.log('up', detail.direction));
	    this.on.right((elem, detail) => console.log('right', detail.direction));
	    this.on.down((elem, detail) => console.log('down', detail.direction));
	    this.on.left((elem, detail) => console.log('left', detail.direction));
	    this.on.center((elem, detail) => console.log('center', detail.direction));
	
	  }
	}
	
	OrientationArrows.template = new $t('orientation-arrows');
	
	du.on.match('click', '.orient-arrows>tbody>tr>td[dir]', function (target) {
	  const tableElem = du.find.up('[l-id]', target);
	  if (!tableElem) return;
	  const id = tableElem.getAttribute('l-id');
	  const instance = OrientationArrows.get(id);
	  const direction = target.getAttribute('dir');
	  switch (direction) {
	    case 'u':
	      instance.trigger.up(target, {direction, instance});
	      break;
	    case 'r':
	      instance.trigger.right(target, {direction, instance});
	      break;
	    case 'd':
	      instance.trigger.down(null, {direction, instance});
	      break;
	    case 'l':
	      instance.trigger.left(target, {direction, instance});
	      break;
	    case 'c':
	      instance.trigger.center(target, {direction, instance});
	      break;
	  }
	});
	
	module.exports = OrientationArrows;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/property.js',
function (require, exports, module) {
	

	
	const Properties = require('../config/properties.js');
	const Property = require('../config/property.js');
	const Cost = require('../cost/cost.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const bind = require('../../../../public/js/utils/input/bind.js');
	const RadioDisplay = require('../display-utils/radio-display.js');
	const EPNTS = require('../../generated/EPNTS');
	const $t = require('../../../../public/js/utils/$t.js');
	const Inputs = require('../input/inputs.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const ExpandableObject = require('../../../../public/js/utils/lists/expandable-object.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	
	// TODO: Rewrite program started to have nested properties no longer making display convoluted(SP).
	const changed = (id) => Properties.changes.changed(id);
	const shouldHide = (prop) => prop.value() === null;
	const hideAll = (properties) => {
	  for (let index = 0; index < properties.length; index += 1) {
	    if (properties[index].value() !== null) return false;
	  }
	  return properties.length > 0;
	}
	
	function updateSaveAll() {
	  const saveAllBtn = du.find('#property-manager-save-all');
	  saveAllBtn.hidden = !Properties.changes.changesExist();
	  if (saveAllBtn.hidden) {
	    const saveBtns = du.find.all('.save-change');
	    saveBtns.forEach((saveBtn) => saveBtn.hidden = true);
	  }
	}
	
	function saveAll() {
	  Properties.changes.saveAll();
	  save();
	  updateSaveAll();
	}
	
	
	function save() {
	  Request.post(EPNTS.config.save(), Properties.config(), console.log, console.error);
	}
	
	function get() {
	  Request.get(EPNTS.config.get(), console.log);
	}
	
	class PropertyDisplay {
	  constructor(containerSelector) {
	    let currProps;
	
	    const noChildren = (properties, groups) => () =>
	          properties.length === 0 && Object.keys(groups).length === 0;
	
	    function childScope (key) {
	      const list = Properties.hasValue(key);
	      if (list.length === 0) return;
	
	      const id = String.random();
	      const getObject = (values) => {
	        let properties = Properties.new(key,  values.name);
	        return {name: values.name, id, changed, properties};
	      }
	      const inputTree = PropertyDisplay.configInputTree();
	      const expListProps = {
	        parentSelector: `#config-expand-list-${id}`,
	        getHeader: (scope) =>
	                    PropertyDisplay.configHeadTemplate.render(scope),
	        getBody: (scope) =>
	                    PropertyDisplay.configBodyTemplate.render({
	                      name: scope.name,
	                      properties: scope.properties,
	                      changed
	                    }),
	        inputValidation: inputTree.validate,
	        listElemLable: 'Config',
	        list, getObject, inputTree
	      };
	      setTimeout(() => {
	        const expList = new ExpandableObject(expListProps);
	        expList.afterRemoval((element, detail) => {
	          console.log(detail);
	          console.log('placehoder');
	          Properties.changes.delete(detail.properties._ID);
	        });
	      }, 500);
	      return id;
	    }
	
	    function getScope(key, group) {
	      key = key || '';
	      const id = String.random();
	      let radioId = group.radioId || PropertyDisplay.counter++;
	      const properties = [];
	      const groups = {};
	      const label = key.replace(PropertyDisplay.camelReg, '$1 $2');
	      const scope = {key, label, properties, groups, recurse, radioId, id,
	                      noChildren: noChildren(properties, groups),
	                      branch: key.match(PropertyDisplay.branchReg)};
	      PropertyDisplay.uniqueMap[id] = scope;
	      const keys = Object.keys(group.values);
	      radioId = PropertyDisplay.counter++;
	      for( let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        const value = group.values[key];
	        childScope(key, id);
	      }
	      return scope;
	    }
	
	    this.update = () => {
	      const propKeys = Properties.propertiesToDefine();
	      const propertyObjs = {};
	      const childIdMap = [];
	      for (let index = 0; index < propKeys.length; index += 1) {
	        const key = propKeys[index];
	        const props = Properties(key);
	        const propObj = props;
	        propertyObjs[key] = propObj;
	        childIdMap[key] = childScope(key);
	      }
	      const id = String.random();
	      const values = {values: propertyObjs, id, childIdMap, hideAll, Properties};
	      const contianer = document.querySelector(containerSelector);
	      contianer.innerHTML =
	          PropertyDisplay.template.render(values);
	    };
	
	    function updateProperties(name, value) {
	    }
	    bind('property-cnt', updateProperties);
	    new RadioDisplay('property-container', 'radio-id');
	    this.update();
	  }
	}
	
	// bind('property-branch-selector', '');
	
	du.on.match('change', 'select[name="property-branch-selector"]', (target) => {
	  const childTargets = target.parentElement.children[1].children;
	  const childElem = childTargets[target.value];
	  // TODO: set config property: childElem.innerText;
	  du.hide(childTargets);
	  du.show(childElem);
	});
	
	function setPropertyElemValue(elem, idAttr, value) {
	  const id = elem.getAttribute(idAttr);
	  const group = elem.getAttribute('name');
	  const property = Property.get(id);
	  property.value(value, true);
	}
	
	function updateMeasurements () {
	  measureElems = du.find.all('[measurement-id]:not([measurement-id=""])');
	  measureElems.forEach((elem) => {
	    const id = elem.getAttribute('measurement-id');
	    const measurement = Measurement.get(id);
	    elem.value = measurement.display();
	  });
	}
	
	function updateRadio(elem) {
	  const name = elem.getAttribute('name');
	  Properties.config()
	  const elems = du.find.all(`input[type="radio"][name='${name}']`);
	  elems.forEach((elem) => setPropertyElemValue(elem, 'prop-radio-update', false));
	  setPropertyElemValue(elem, 'prop-radio-update', true);
	  if (name.substr(0, 4) === 'UNIT') {
	    Measurement.unit(elem.value);
	    updateMeasurements();
	  }
	}
	
	function updateValueDisplay(elem) {
	  const id = elem.getAttribute('measurement-id');
	  const measurement = Measurement.get(id);
	  elem.value = measurement.display();
	}
	
	function updateValue(elem) {
	  setPropertyElemValue(elem, 'prop-value-update', elem.value);
	  const saveBtn = du.find.closest('.save-change', elem);
	  saveBtn.hidden = !changed(saveBtn.getAttribute('properties-id'));
	  const measurementId = Property.get(elem.getAttribute('prop-value-update')).measurementId();
	  elem.setAttribute('measurement-id', measurementId);
	  updateSaveAll();
	}
	
	function updateBoolean(elem) {
	  setPropertyElemValue(elem, 'prop-boolean-update', elem.checked);
	  const saveBtn = du.find.closest('.save-change', elem);
	  saveBtn.hidden = !changed(saveBtn.getAttribute('properties-id'));
	  updateSaveAll();
	}
	
	function saveChange(elem) {
	  const id = elem.getAttribute('properties-id');
	  Properties.changes.save(id);
	  elem.hidden = true;
	  updateSaveAll();
	  save();
	}
	
	
	du.on.match('keyup', '[prop-value-update]', updateValue);
	du.on.match('change', '[prop-boolean-update]', updateBoolean);
	du.on.match('focusout', '[measurement-id]', updateValueDisplay);
	du.on.match('change', '[prop-radio-update]', updateRadio);
	du.on.match('click', '#property-manager-save-all', saveAll);
	du.on.match('click', '[properties-id]:not([properties-id=""])', saveChange);
	
	PropertyDisplay.attrReg = /^_[A-Z_]{1,}/;
	PropertyDisplay.branchReg = /^OR_(.{1,})/;
	PropertyDisplay.camelReg = /([a-z])([A-Z])/g;
	PropertyDisplay.counter = 0;
	PropertyDisplay.template = new $t('properties/properties');
	PropertyDisplay.configBodyTemplate = new $t('properties/config-body');
	PropertyDisplay.configHeadTemplate = new $t('properties/config-head');
	PropertyDisplay.radioTemplate = new $t('properties/radio');
	PropertyDisplay.uniqueMap = {};
	PropertyDisplay.configMap = {};
	
	PropertyDisplay.configInputTree = () => {
	  const dit = new DecisionInputTree(console.log);
	  dit.leaf('Config', [Inputs('name')]);
	  return dit;
	}
	
	module.exports = PropertyDisplay
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/room.js',
function (require, exports, module) {
	

	
	const Room = require('../objects/room.js');
	const CabinetDisplay = require('./cabinet.js');
	const GroupDisplay = require('./group.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const ExpandableObject = require('../../../../public/js/utils/lists/expandable-object.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const Inputs = require('../input/inputs.js');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const TwoDLayout = require('../displays/two-d-layout');
	
	class RoomDisplay extends Lookup {
	  constructor(parentSelector, order) {
	    super();
	
	    const groupDisplays = {};
	    const getHeader = (room, $index) =>
	        RoomDisplay.headTemplate.render({room, $index});
	
	    const getBody = (room, $index) => {
	      TwoDLayout.set(room.layout());
	      return RoomDisplay.bodyTemplate.render({$index, room, groupHtml});
	    }
	
	    const groupHtml = (group) => {
	      if (groupDisplays[group.id()] === undefined) {
	        groupDisplays[group.id()] = new GroupDisplay(group);
	      }
	      return groupDisplays[group.id()].html();
	    }
	
	    const getObject = (values) => {
	      const room = new Room(values.name);
	      return room;
	    }
	    this.active = () => expandList.active();
	
	    function getExpandList() {
	      const expandParentSelector = `${parentSelector}[order-id="${order.id()}"]`;
	      const expandList = ExpandableObject.bySelector(parentSelector);
	      if (expandList) return expandList;
	
	      const expListProps = {
	        list: order.rooms,
	        parentSelector, getHeader, getBody, getObject,
	        inputValidation: (values) => values.name !== '' ? true : 'name must be defined',
	        listElemLable: 'Room', type: 'pill',
	        inputTree: RoomDisplay.configInputTree()
	      };
	      return new ExpandableObject(expListProps);
	    }
	
	    this.order =(o) => {
	      if (o) {
	        order = o;
	        du.find(parentSelector).setAttribute('order-id', order.id());
	        getExpandList();
	      }
	      return order;
	    }
	    this.order(order);
	
	    this.refresh = () => expandList.refresh();
	  }
	}
	
	du.on.match('click', '.group-add-btn', (target) => {
	  const id = target.getAttribute('room-id');
	  const room = Room.get(id);
	  const orderId = du.find.up('[order-id]', target).getAttribute('order-id');
	  const roomDisplay = RoomDisplay.get(orderId);
	  room.addGroup();
	  roomDisplay.refresh();
	});
	
	RoomDisplay.configInputTree = () => {
	  const dit = new DecisionInputTree(console.log);
	  dit.leaf('Room', [Inputs('name')]);
	  return dit;
	}
	RoomDisplay.bodyTemplate = new $t('room/body');
	RoomDisplay.headTemplate = new $t('room/head');
	module.exports = RoomDisplay
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/section.js',
function (require, exports, module) {
	

});


RequireJS.addFunction('./services/cabinet/app-src/displays/single-order.js',
function (require, exports, module) {
	
const Order = require('../objects/order.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const OrderSaveManager = require('../services/order-save-manager.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const DataList = require('../../../../public/js/utils/input/data-list.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const NoActivityRunner = require('../../../../public/js/utils/services/no-activity-runner.js');
	
	const orderSelectCnt = du.id('order-select-cnt');
	const orderNameInput = du.id('order-name-input');
	const orderVersionInput = du.id('order-version-input');
	const dateStr = new Date().toLocaleDateString("en-US", options).replace(/\//g, '-');
	let order = new Order(`Orderststs ${dateStr}`);
	orderNameInput.value = order.name();
	orderVersionInput.value = order.versionId();
	
	var options = {  year: 'numeric', day: 'numeric' };
	var today  = new Date();
	
	console.log(today.toLocaleDateString("en-US", options)); // Saturday, September 17, 2016
	order.addRoom('kitchen');
	
	const RoomDisplay = require('./room');
	let roomDisplay = new RoomDisplay('#room-cnt', order);
	
	
	const saveCntId = 'order-select-cnt';
	const getAutoSaveElem = (selector) => () => du.find.down(selector, du.id(saveCntId));
	const getStatusElem = getAutoSaveElem('.status');
	const getAutoSaveBtn = getAutoSaveElem('button');
	
	const cookieId = () => `last-active-order`;
	const cookieValue = () => `${saveMan.activeOrderName()},${saveMan.activeVersionId()}`;
	const setCookie = () => du.cookie.set(cookieId(), cookieValue());
	const getCookie = () => du.cookie.get(cookieId(), ',', 'name', 'version');
	
	const cookieVals = getCookie();
	const orderName = cookieVals.name || order.name();
	const versionId = cookieVals.version || 'original';
	
	
	let counter = 0;
	const saveMan = new OrderSaveManager(() => order.toJson(), orderName, versionId);
	
	const obj = {order: () => order};
	
	function onChange(values, dit) {
	  console.log('change');
	}
	
	function onSubmit(values, dit) {
	  console.log('submit');
	}
	
	const orderSelCnt = du.id('order-selector-cnt');
	const orderInput = new Input({
	  name: 'order',
	  inline: true,
	  label: 'Order:'
	});
	
	const versionInput = new Input({
	  name: 'version',
	  inline: true,
	  label: 'Version:'
	});
	orderSelCnt.innerHTML = orderInput.html() + versionInput.html();
	
	const orderDataList = new DataList(orderInput);
	const versionDataList = new DataList(versionInput);
	
	du.on.match('click', `#${saveCntId}>button`, async (elem) =>{
	  if (elem.innerText === 'Choose Save Location') {
	    await saveMan.init();
	    orderSelCnt.hidden = false;
	    elem.innerHTML = 'Open/Create';
	  } else {
	    const orderName = orderInput.value();
	    const versionId = versionInput.value();
	    switch (elem.innerText) {
	      case 'Create':
	        versionId ||= 'original';
	        saveMan.switch(orderName, versionId);
	        break;
	      case 'Save':
	        saveMan.save();
	        break;
	      case 'Open':
	        saveMan.switch(orderName, versionId);
	        break;
	    }
	  }
	});
	
	const noActRunnner = new NoActivityRunner(10000, () => saveMan.on(false));
	du.on.match('mouseout', '*', (elem) => {
	  saveMan.on(saveMan.initialized());
	  noActRunnner();
	})
	
	function updateButtonText() {
	  const inputOrderName = orderInput.value();
	  const inputVersionId = versionInput.value();
	  const state = saveMan.state(inputOrderName, inputVersionId);
	  let buttonText = 'Open/Create';
	  orderButton.disabled = false;
	  switch (state) {
	    case 'new order': buttonText = 'Create'; break;
	    case 'new version': buttonText = 'Create'; break;
	    case 'active': buttonText = 'Save'; break;
	    case 'switch version': buttonText = 'Open'; break;
	    case 'switch order': buttonText = 'Open'; break;
	    default:
	      orderButton.disabled = true;
	  }
	  orderButton.innerText = buttonText;
	
	}
	
	const orderButton = du.find(`#${saveCntId}>button`);
	function updateOrderInput() {
	  orderDataList.setList(saveMan.orderNames());
	  const orderName = orderInput.value() || saveMan.activeOrderName();
	  versionDataList.setList(saveMan.versionIds(orderName));
	  updateButtonText();
	}
	function onVersionChange(elem, details) {
	  setCookie();
	}
	const timeCnt = du.id('save-time-cnt');
	function updateTime() {
	  timeCnt.innerText = `Last Save: ${new Date().toLocaleTimeString()}`;
	}
	du.on.match('click', '#save-time-cnt', () => saveMan.save() || resetOrderAndVersion());
	
	let firstSwitch = true;
	function switchOrder(elem, details) {
	  if (order.worthSaveing()) {
	    if (firstSwitch) {
	      const state = saveMan.state(order.name(), order.versionId());
	      if (state === 'new order' || state === 'new version') {
	        saveMan.save(order.name(), order.versionId());
	      } else if (state === 'switch order' || state === 'active') {
	        const notTakenVersion = saveMan.undefinedVersion(order.name(), order.versionId());
	        if (confirm(`An order and version already exist with this\nname/version: '${order.name()}'/'${order.versionId()}'.\n\nPress ok to save as '${order.name()}'/'${notTakenVersion}'\nor\nPress cancel to avoid it being saving.`) == true) {
	          saveMan.save(order.name(), notTakenVersion, order.toJson());
	        }
	      }
	    }
	  }
	  firstSwitch = false;
	  updateOrderInput();
	  if (details.contents === '') return order = new Order(details.orderName, details.versionId);
	  try {
	    order = Object.fromJson(JSON.parse(details.contents));
	    roomDisplay.order(order);
	    orderNameInput.value = order.name(details.orderName);
	    orderVersionInput.value = order.versionId(details.versionId);
	    resetOrderAndVersion();
	    console.log('details');
	  } catch (e) {
	    console.warn(e);
	  }
	}
	
	function resetOrderAndVersion() {
	  orderInput.setValue('');
	  versionInput.setValue('');
	  updateOrderInput();
	}
	
	let orderChangeInFocus = false;
	
	let processing;
	du.on.match('focusout:enter', '#order-name-input', async () => {
	  const newName = orderNameInput.value;
	  if (!saveMan.on()) {
	    order.name(newName);
	  } else if (!processing && newName !== order.name()) {
	    if (confirm(`This will rename all versions. From '${order.name()}' to '${newName}'\n\nAre you sure?`) == true) {
	      processing = true;
	      await saveMan.changeOrderName(newName);
	      processing = false;
	    } else {
	      orderNameInput.value = order.name();
	    }
	  }
	})
	
	orderInput.on('keyup,change,click', updateOrderInput);
	versionInput.on('keyup,change,click', updateOrderInput);
	orderInput.on('change', () =>  versionInput.setValue(''));
	orderInput.on('focusin', () => orderInput.setValue(''));
	versionInput.on('focusin', () => versionInput.setValue(''));
	
	saveMan.onFileSystemChange(updateOrderInput);
	saveMan.onLoaded(resetOrderAndVersion);
	saveMan.onVersionChange(onVersionChange);
	saveMan.onSaved(updateTime);
	saveMan.onVersionChange(switchOrder);
	
	module.exports = obj;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/three-d-main.js',
function (require, exports, module) {
	

	// const CSG = require('../../public/js/3d-modeling/csg');
	
	const Assembly = require('../objects/assembly/assembly');
	const Handle = require('../objects/assembly/assemblies/hardware/pull.js');
	const DrawerBox = require('../objects/assembly/assemblies/drawer/drawer-box.js');
	const pull = require('../three-d/models/pull.js');
	const drawerBox = require('../three-d/models/drawer-box.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const ThreeDModel = require('../three-d/three-d-model.js');
	const ThreeView = require('three-view');
	const Vector3D = require('../three-d/objects/vector.js');
	const Line3D = require('../three-d/objects/line.js');
	const Vertex3D = require('../three-d/objects/vertex.js');
	
	// const cube = new CSG.cube({radius: [3,5,1]});
	const consts = require('../../globals/CONSTANTS');
	let threeView;
	
	// TODO: ????
	function displayPart(part) {
	  return true;
	}
	
	function groupParts(cabinet) {
	  const grouping = {displayPart, group: {groups: {}, parts: {}, level: 0}};
	  const parts = cabinet.getParts();
	  for (let index = 0; index < parts.length; index += 1) {
	    const part = parts[index];
	    const namePieces = part.partName().split('.');
	    let currObj = grouping.group;
	    let level = 0;
	    let prefix = '';
	    for (let nIndex = 0; nIndex < namePieces.length - 1; nIndex += 1) {
	      const piece = namePieces[nIndex];
	      prefix += piece;
	      if (currObj.groups[piece] === undefined) currObj.groups[piece] = {groups: {}, parts: {}};
	      currObj = currObj.groups[piece];
	      currObj.level = ++level;
	      currObj.prefix = prefix;
	      prefix += '.'
	    }
	    if (currObj.parts[part.partName()] === undefined) currObj.parts[part.partName()] = [];
	    currObj.parts[part.partName()].push(part);
	  }
	  return grouping;
	}
	
	const modelContTemplate = new $t('model-controller');
	
	du.on.match('click', '.model-state', (target) => {
	  if (event.target.tagName === 'INPUT') return;
	  const has = target.matches('.active');
	  deselectPrefix();
	  !has ? du.class.add(target, 'active') : du.class.remove(target, 'active');
	  let label = target.children[0]
	  let type = label.getAttribute('type');
	  let value = type !== 'prefix' ?
	        (type !== 'part-name' ? label.innerText : label.getAttribute('part-name')) :
	        label.nextElementSibling.getAttribute('prefix');
	  const cabinet = lastRendered;
	  const tdm = ThreeDModel.get(cabinet);
	  let partName = target.getAttribute('part-name');
	  let partId = target.getAttribute('part-id');
	  if (partId) {
	    if (!has) {
	      tdm.inclusiveTarget(type, partId);
	      threeView.isolatePart(partName, cabinet);
	    }
	  } else {
	    tdm.inclusiveTarget(type, has ? undefined : value);
	    const elem = du.find.closest('[part-code]', target);
	    const partCode = elem.getAttribute('part-code');
	    threeView.isolatePart(partCode, cabinet);
	  }
	  tdm.render();
	});
	
	function deselectPrefix() {
	  document.querySelectorAll('.model-state')
	    .forEach((elem) => du.class.remove(elem, 'active'));
	  const cabinet = lastRendered;
	  const tdm = ThreeDModel.get(cabinet);
	  tdm.inclusiveTarget(undefined, undefined);
	}
	
	function setGreaterZindex(...ids) {
	  return (target) => {
	    const zMap = [];
	    let zIndexes = [];
	    for (let index = 0; index < ids.length; index += 1) {
	      const id = ids[index];
	      const elem = du.id(id);
	      const zIndex = du.zIndex(elem);
	      zIndexes.push(zIndex);
	      zMap[zIndex] = elem;
	    }
	    zIndexes.sort().reverse();
	    target.style.zIndex = zIndexes[0];
	    for (let index = 0; index < zIndexes.length; index += 1) {
	      const elem = zMap[zIndexes[index]];
	      if (elem === target) {
	        break;
	      } else {
	        elem.style.zIndex = zIndexes[index + 1];
	      }
	    }
	  };
	}
	
	const toggleClassStr = '.model-label,.model-selector';
	function focusControls(target) {
	  const all = du.find.all(toggleClassStr);
	  for (let index = 0; index < all.length; index++) {
	    all[index].hidden = true;
	  }
	  const active = du.find.upAll(toggleClassStr, target);
	  active.push(du.find.down(toggleClassStr, target));
	  for (let index = 0; index < active.length; index++) {
	    active[index].hidden = false;
	    const siblings = active[index].parentElement.children;
	    for (let s = 0; s < siblings.length; s++) {
	      let sibTarget = du.find.down(toggleClassStr, siblings[s]);
	      if (sibTarget) sibTarget.hidden = false;
	    }
	  }
	}
	
	du.on.match('click', '.prefix-switch', (target, event) => {
	  focusControls(target);
	});
	
	du.on.match('change', '.prefix-checkbox', (target) => {
	  const cabinet = lastRendered;
	  const attr = target.getAttribute('prefix');
	  deselectPrefix();
	  ThreeDModel.get(cabinet).hidePrefix(attr, !target.checked);
	});
	
	du.on.match('change', '.part-name-checkbox', (target) => {
	  const cabinet = lastRendered;
	  const attr = target.getAttribute('part-name');
	  deselectPrefix();
	  const tdm = ThreeDModel.get(cabinet);
	  tdm.hidePartName(attr, !target.checked);
	  tdm.render();
	});
	
	du.on.match('change', '.part-id-checkbox', (target) => {
	  const cabinet = lastRendered;
	  const attr = target.getAttribute('part-id');
	  deselectPrefix();
	  const tdm = ThreeDModel.get(cabinet);
	  tdm.hidePartId(attr, !target.checked);
	  tdm.render();
	})
	
	let controllerModel;
	function updateController() {
	  controllerModel = lastRendered;
	  const controller = du.id('model-controller');
	  const grouping = groupParts(controllerModel);
	  grouping.tdm = ThreeDModel.get(controllerModel);
	  controller.innerHTML = modelContTemplate.render(grouping);
	  controller.hidden = false;
	}
	
	
	let lastRendered;
	function update(part) {
	  if (part) lastRendered = part.getAssembly('c');
	  const threeDModel = ThreeDModel.get(lastRendered);
	  if (threeDModel) {
	    threeDModel.update(lastRendered);
	    updateController();
	  }
	}
	
	function modelCenter() {
	  const model = ThreeDModel.lastActive.getLastRendered();
	  const vertices = [];
	  for (let index = 0; index < model.polygons.length; index++) {
	    const verts = model.polygons[index].vertices;
	    for (let vIndex = 0; vIndex < verts.length; vIndex++) {
	      vertices.push(verts[vIndex].pos);
	    }
	  }
	
	  return Vertex3D.center(...vertices);
	}
	
	function init() {
	  // const p = pull(5,2);
	  // const p = CSG.sphere({center: {x:0, y:0, z: 0}, radius: 10});
	  // p.setColor('black')
	  // const db = drawerBox(10, 15, 22);
	  threeView = new ThreeView();
	
	  const setZFunc = setGreaterZindex('order-cnt', 'model-cnt', `${threeView.id()}-cnt`);
	  du.on.match('click', '#model-cnt', setZFunc);
	  du.on.match('click', '#order-cnt', setZFunc);
	  du.on.match('click', `#${threeView.id()}-cnt`, setZFunc);
	  ThreeDModel.onLastModelUpdate(updateController);
	}
	
	module.exports = {init, update}
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/three-view.js',
function (require, exports, module) {
	
const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils');
	const pull = require('../three-d/models/pull.js');
	const ThreeDModel = require('../three-d/three-d-model.js');
	const Layout2D = require('../two-d/layout/layout.js')
	const Draw2D = require('../../../../public/js/utils/canvas/two-d/draw.js');
	const Polygon2d = require('../../../../public/js/utils/canvas/two-d/objects/polygon.js');
	const Polygon3D = require('../three-d/objects/polygon.js');
	const BiPolygon = require('../three-d/objects/bi-polygon.js');
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line.js');
	const LineMeasurement2d = require('../../../../public/js/utils/canvas/two-d/objects/line-measurement.js');
	const PanZoom = require('../../../../public/js/utils/canvas/two-d/pan-zoom.js');
	
	const CSG = require('../../public/js/3d-modeling/csg');
	
	function csgVert(pos, normal) {
	  return new CSG.Vertex(pos, normal);
	}
	
	function normalize (verts, normal, reverse) {
	  const returnValue = [];
	  for (let index = 0; index < verts.length; index++)
	    returnValue[index] = new CSG.Vertex(verts[index], normal);
	  return reverse ? returnValue.reverse() : returnValue;
	}
	
	class ThreeView extends Lookup {
	  constructor() {
	    super();
	    const instance = this;
	    const maxDem = window.innerHeight * .45;
	    const cnt = du.create.element('div');
	    // const p = pull(5,2);
	    const p = new BiPolygon(new Polygon3D([{x:0, y: 4, z: 0}, {x:4, y: 4, z: 0}, {x:4, y: 0, z: 0}, {x:0, y: 0, z: 0}]),
	          new Polygon3D([{x:2, y: 4, z: 4}, {x:6, y: 4, z: 4}, {x:6, y: 0, z: 4}, {x:2, y: 0, z: 4}])).toModel();
	    // console.log(JSON.stringify(new CSG.cube({radius: 2, center: [2,2,2]}), null, 2));
	    // const p = CSG.sphere({center: {x:0, y:0, z: 0}, radius: 10});
	    p.setColor([0, 255, 0])
	    let draw, panz;
	    let threeDModel;
	    document.body.append(cnt);
	    this.maxDem = () => maxDem;
	    cnt.innerHTML = ThreeView.template.render(this);
	
	    const color = 'black';
	    const width = .2;
	
	    this.toLines = () => {
	      let model = instance.lastModel();
	      if (model) {
	        const threeView = model.threeView;
	        return threeView.top().concat(threeView.right().concat(threeView.front()));
	      } else {
	        model ||= instance.lastRendered();
	        if (model === undefined) return [];
	        const threeView = model.threeView();
	        return threeView.parimeter().allLines();
	      }
	    }
	
	    function drawView (refresh) {
	      Layout2D.release(`three-view`);
	      const model = instance.lastModel() || instance.lastRendered();
	      if (model === undefined) return;
	      let allLines = instance.toLines();
	      const threeView = model.threeView;
	      if (threeView.measurments === undefined) {
	        threeView.measurments = LineMeasurement2d.measurements(allLines);
	      }
	      draw(allLines, color, width);
	      draw(threeView.measurments, 'grey');
	    }
	
	    function onPartSelect(elem) {
	      console.log(elem.value);
	      const partCode = du.find.closest(`[value="${elem.value}"`, elem).getAttribute('part-code');
	      instance.isolatePart(elem.value);
	      elem.value = '';
	    }
	
	    function init() {
	      draw = new Draw2D(du.id('three-view'), true);
	
	      panz = new PanZoom(draw.canvas(), drawView);
	      panz.centerOn(0, 0);
	
	      if (du.url.breakdown().path.match(/\/.*template$/)) {
	        setTimeout(() =>
	          ThreeDModel.setViewerSelector(`#${instance.id()}>.three-view-three-d-cnt`, '40vh'), 500);
	      }
	      du.on.match('change', '[name="partSelector"]', onPartSelect);
	    }
	
	    this.update = (cabinet) => {
	      if (threeDModel === undefined) threeDModel = new ThreeDModel(cabinet);
	      threeDModel.assembly(cabinet);
	      const model = threeDModel.update(cabinet);
	      draw.clear();
	      setTimeout(() => {
	        drawView(true);
	      }, 1000);
	      return model;
	    }
	
	    this.isolatePart = (partCode) => {
	      threeDModel = ThreeDModel.get();
	      threeDModel.setTargetPartName(partCode);
	      threeDModel.update();
	      setTimeout(() => {
	        panz.once();
	      }, 500);
	      du.id(`three-view-part-code-${this.id()}`).innerText = partCode;
	    }
	
	    this.threeDModel = () => threeDModel;
	    this.lastModel = () => threeDModel ? threeDModel.lastModel() : undefined;
	    this.lastRendered = () => threeDModel ? threeDModel.getLastRendered() : undefined;
	    this.partMap = () => threeDModel ? threeDModel.partMap() : {};
	
	    setTimeout(init, 1000);
	  }
	}
	
	function copyDrawString(elem) {
	  const id = du.find.up('.three-view-cnt', elem).getAttribute('id');
	  const threeView = ThreeView.get(id);
	  const str = Line2d.toDrawString(threeView.toLines());
	  du.copy(str);
	}
	
	du.on.match('click', '.three-view-draw-string-btn', copyDrawString);
	
	ThreeView.template = new $t('three-view');
	
	module.exports = ThreeView;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/two-d-layout.js',
function (require, exports, module) {
	const Layout2D = require('../two-d/layout/layout.js');
	const panZoom = require('../../../../public/js/utils/canvas/two-d/pan-zoom');
	const $t = require('../../../../public/js/utils/$t.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	const PopUp = require('../../../../public/js/utils/display/pop-up');
	const Properties = require('../config/properties');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const StringMathEvaluator = require('../../../../public/js/utils/string-math-evaluator.js');
	const Draw2D = require('../../../../public/js/utils/canvas/two-d/draw.js');
	const Vertex2d = require('../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line.js');
	const EPNTS = require('../../generated/EPNTS.js');
	const Snap2d = require('../../../../public/js/utils/canvas/two-d/objects/snap.js');
	const Circle2d = require('../../../../public/js/utils/canvas/two-d/objects/circle.js');
	const SnapLocation2d = require('../../../../public/js/utils/canvas/two-d/objects/snap-location.js');
	const LineMeasurement2d = require('../../../../public/js/utils/canvas/two-d/objects/line-measurement');
	const ThreeDMain = require('three-d-main');
	const ThreeDModel = require('../three-d/three-d-model.js');
	const HoverMap2d = require('../../../../public/js/utils/canvas/two-d/hover-map.js');
	
	const measurmentMap = new HoverMap2d();
	const localEnv = EPNTS.getEnv() === 'local';
	// TODO: Rename
	const TwoDLayout = {};
	
	let draw;
	const eval = new StringMathEvaluator({Math}).eval;
	const popUp = new PopUp({resize: false});
	let interactionState = {};
	
	let layout;
	TwoDLayout.set = (l) => {
	  if (l instanceof Layout2D) {
	    layout = l;
	    if (panZ) panZ.once();
	  }
	}
	
	const windowLineWidth = 8;
	const tolerance = 1;
	let lastImagePoint;
	let hovering;
	let dragging;
	let clickHolding = false;
	let mouseupId = 0;
	let mousedownId = 0;
	let popupOpen = false;
	let lastDown = 0;
	const selectTimeBuffer = 200;
	const quickChangeFuncs = {};
	
	function determineObject(id, member) {
	  const referenceObj = Layout2D.get(id);
	  switch (member) {
	    case 'object': return referenceObj.payload();
	    case 'cabinet': return referenceObj.payload();
	    case 'bridge':  return referenceObj.bridge.top();
	    default: return referenceObj;
	  }
	}
	
	function getPopUpAttrs(elem) {
	  const cnt =  du.find.up('[type-2d]', elem);
	  if (cnt === undefined) return {};
	  const member = elem.getAttribute('member');
	  const type = cnt.getAttribute('type-2d');
	  const key = elem.getAttribute('key');
	  const evaluated = eval(elem.value);
	  const raw = Number.isFinite(evaluated) ? evaluated : elem.value;
	  let value, display;
	  if (elem.getAttribute('convert') === 'false') {
	    value = elem.type === 'checkbox' ? elem.checked : raw;
	    display = value;
	  } else {
	    const measurement = new Measurement(raw, true);
	    value = measurement.decimal();
	    display = measurement.display();
	  }
	  const id = cnt.id;
	  const obj = determineObject(id, member);
	  point = {x: cnt.getAttribute('x'), y: cnt.getAttribute('y')};
	  let prevValue, cascade;
	  if (key) prevValue = Object.pathValue(obj, key);
	  const cascadeStr = elem.getAttribute('cascade');
	  if (cascadeStr) cascade = cascadeStr.split(',');
	  return {type,id,key,value,display,raw,obj,prevValue,cascade,point,elem,member};
	}
	
	function cascadeChanges(props, cascaded) {
	  cascaded ||= [];
	  if (props.cascade) {
	    for (let index = 0; index < props.cascade.length; index++) {
	      const cascadeKey = props.cascade[index];
	      if (cascaded.indexOf(cascadeKey) === -1) {
	        const input = du.find.closest(`[key="${cascadeKey}"]`, props.elem);
	        const currProps = getPopUpAttrs(input);
	        input.value = display(currProps.prevValue);
	        cascadeChanges(currProps, [cascadeKey].concat(cascaded));
	      }
	    }
	  }
	}
	
	du.on.match('enter:focusout', '.value-2d', (elem) => {
	  const props = getPopUpAttrs(elem);
	  switch (props.member) {
	    case 'object':
	      const cab = props.obj;
	      props.obj[props.key](props.raw);
	      if (cab && cab.constructor.name === 'Cabinet') {
	        const cabDemCnt = du.find(`.cabinet-dem-cnt[cabinet-id='${cab.id()}']`);
	        const idInput =  du.find.closest(`Input[name="${props.key}"]`, cabDemCnt);
	        idInput.value = props.raw;
	      }
	      panZ.once();
	      return;
	    case 'cabinet':
	      const cabinet = props.obj;
	      const cabCnt = du.find(`.cabinet-dem-cnt[cabinet-id='${cabinet.id()}']`);
	      if (cabCnt) {
	        const input = du.find.down(`input[name='${props.key}']`, cabCnt);
	        input.value = props.display;
	      }
	      cabinet[props.key](props.value);
	      ThreeDMain.update(cabinet)
	      return;
	  }
	
	  if (props.key === 'thickness') props.key = 'height';
	  Object.pathValue(props.obj, props.key, props.value);
	  cascadeChanges(props);
	  panZ.once();
	});
	
	du.on.match('change', 'input[name=\'UNIT2\']', (elem) => {
	  const props = getPopUpAttrs(elem);
	  const input = du.find.closest('.measurement-mod', elem);
	  if (input) setTimeout(() =>
	      input.value = props.obj.display(), 0);
	});
	
	function remove() {
	  if (hovering.parent) {
	    if (hovering.parent().payload().constructor.name === 'Cabinet') {
	      const cabinet = hovering.parent().payload();
	      const cabinetHeader = du.find(`.cabinet-header[cabinet-id='${cabinet.id()}']`);
	      const removeButton = du.find.closest('.expandable-item-rm-btn', cabinetHeader)
	      if (removeButton) removeButton.click();
	      else console.warn('Remove button for cabinet should be present but is not present');
	    }
	    layout.remove(hovering.parent().id());
	  } else {
	    layout.remove(hovering.id());
	  }
	  popUp.close();
	  TwoDLayout.panZoom.once();
	}
	
	du.on.match('click', '.remove-btn-2d', remove, popUp.container());
	
	du.on.match('click', '.add-door-btn-2d', (elem) => {
	  const attrs = getPopUpAttrs(elem);
	  const distance = attrs.obj.startVertex().distance(attrs.point);
	  attrs.obj.addDoor(distance);
	  panZ.once();
	});
	
	du.on.match('click', '.hinge-btn', (elem) => {
	  const attrs = getPopUpAttrs(elem);
	  attrs.obj.hinge(true);
	  panZ.once();
	});
	
	du.on.match('click', '.add-window-btn-2d', (elem) => {
	  const attrs = getPopUpAttrs(elem);
	  const distance = attrs.obj.startVertex().distance(attrs.point);
	  attrs.obj.addWindow(distance);
	  panZ.once();
	});
	
	du.on.match('click', '.add-object-btn-2d', (elem) => {
	  const props = getPopUpAttrs(elem);
	  const obj = layout.addObject(props.point, 'placeholder');
	  obj.snap2d.top().onChange(() => console.log('snap on change???????'));
	  panZ.once();
	});
	
	du.on.match('click', '.add-vertex-btn-2d', (elem) => {
	  const attrs = getPopUpAttrs(elem);
	  const point = hovering.closestPointOnLine(attrs.point);
	  layout.addVertex(point, hovering);
	  panZ.once();
	});
	
	du.on.match('enter', '.measurement-mod', (elem) => {
	  const value = eval(elem.value);
	  getPopUpAttrs(elem).obj.modify(value);
	  panZ.once();
	});
	
	// TODO: define cache better.
	function clearCache() {
	  measurementIs = {};
	}
	
	function undo(target) {
	  layout.history().back();
	  clearCache();
	  panZ.once();
	}
	
	function redo () {
	  layout.history().forward();
	  clearCache();
	  panZ.once();
	}
	
	function registerQuickChangeFunc(type, func) {
	  if ((typeof func) === 'function') quickChangeFuncs[type] = func;
	}
	
	function onMousedown(event, stdEvent) {
	  lastDown = clickHolding ? 0 : new Date().getTime();
	  lastImagePoint = {x: event.imageX, y: event.imageY};
	  event.lastImagePoint = new Vertex2d(lastImagePoint);
	  if (stdEvent.button == 0) {
	    clickHolding = !popupOpen && (clickHolding || hovering);
	    if (clickHolding) {
	      interactionState.mouseupId = undefined;
	      interactionState.mousedownId = ++mousedownId;
	    }
	    return clickHolding;
	  } else {
	    if (hovering && quickChangeFuncs[hovering.constructor.name]) {
	      quickChangeFuncs[hovering.constructor.name](hovering, event, stdEvent);
	    }
	    return true;
	  }
	}
	
	function addVertex(hovering, event, stdEvent) {
	  const point = {x: event.imageX, y: event.imageY};
	  layout.addVertex(point, hovering);
	}
	
	registerQuickChangeFunc('Wall2D', addVertex);
	registerQuickChangeFunc('Vertex2d', remove);
	registerQuickChangeFunc('Window2D', remove);
	registerQuickChangeFunc('SnapLocation2d', (snapLoc, event) => {
	  if (!snapLoc.disconnect()) {
	    const possible = layout.atWall(event.lastImagePoint);
	    if (possible instanceof Line2d) {
	      snapLoc.pairWith(possible);
	      snapLoc.parent().move(event.lastImagePoint, interactionState);
	    } else if (possible instanceof Vertex2d) {
	      snapLoc.pairWith(possible);
	      snapLoc.move(possible, interactionState);
	    }
	    else snapLoc.pairWith(new Vertex2d(event.lastImagePoint));
	  }
	});
	registerQuickChangeFunc('Door2D', (door) => door.hinge(true));
	
	function hoverId () {
	  return hovering ? hovering.toString() : undefined;
	}
	
	
	const templateMap = {};
	function getTemplate(item) {
	  const isSnap = item instanceof Snap2d;
	  const cxtrName = item.constructor.name;
	  const templateLocation = `2d/pop-up/${isSnap ? 'snap-2d' : cxtrName.toKebab()}`;
	  if (templateMap[templateLocation] === undefined) {
	    templateMap[templateLocation] = new $t(templateLocation);
	  }
	  return templateMap[templateLocation];
	}
	
	function display(value) {
	  return new Measurement(value).display();
	}
	
	let which;
	let snapLoc;
	let snapLocScope = {
	  partner: () => snapLoc && (snapLoc.pairedWith() || snapLoc.courting()),
	  snapPartner: () => snapLocScope.partner() instanceof SnapLocation2d,
	  selected: () => snapLocScope.partner() && (which === snapLocScope.name1() ? snapLoc :
	    (which === snapLocScope.name2() ? snapLocScope.partner() : undefined)),
	  targetObject: () => {const sl = snapLocScope.selected(); return (sl && sl.parent()) || snapLoc},
	  name1: () => snapLoc && snapLoc.parent().parent().name(),
	  name2: () => {
	    const partner = snapLocScope.partner();
	    return partner instanceof SnapLocation2d && partner.parent().parent().name();
	  },
	  angle: () => {
	    if (!snapLoc) return hovering.parent().angle()
	    const partner = snapLocScope.partner();
	    if (!partner) return snapLoc.parent().angle();
	    if (which === snapLocScope.name1()) return snapLoc.parent().angle();
	    if (which === snapLocScope.name2()) return partner.parent().angle();
	    return 0;
	  }
	}
	
	function updateSnapLocDisplay(elem) {
	  const angleElem = du.find.closest('[name="angle"]', elem);
	  angleElem.value = snapLocScope.angle();
	}
	
	du.on.match('change', '[name="which"]', (elem) => {
	  which = elem.value
	  hovering = snapLocScope.targetObject();
	  const angleElem = du.find.closest('[name="angle"]', elem);
	  angleElem.previousElementSibling.innerText = which !== 'Both' ? 'Angle' : 'Rotate';
	  updateSnapLocDisplay(elem);
	  panZ.once();
	});
	
	du.on.match('change', '[member="snap-loc"][name="fix"]', (elem) => {
	  const angleElem = du.find.closest('[name="angle"]', elem);
	  if (elem.checked) {
	    const center = hovering.center().copy();
	    snapLoc = hovering;
	    hovering.pairWith(center);
	    angleElem.previousElementSibling.innerText = 'Rotate';
	  } else {
	    hovering.disconnect();
	    snapLoc = null;
	    angleElem.previousElementSibling.innerText = 'Angle';
	  }
	  panZ.once();
	});
	
	
	du.on.match('enter', '[member="snap-loc"][name="angle"]', (elem) => {
	  const radians = Math.toRadians(Number.parseFloat(elem.value || 0));
	  let selected = snapLocScope.selected();
	  if (selected || !snapLoc) {
	    selected ||= hovering;
	    selected.disconnect();
	    selected.setRadians(radians);
	    hovering = selected;
	    snapLoc = null;
	    du.find.closest('.which-radio-cnt', elem).hidden = true;
	    du.find.closest('.fix-cnt', elem).hidden = false;
	  } else snapLoc.rotateAround(radians);
	  panZ.once();
	});
	
	du.on.match('enter', '[member="snap-loc"][name="x"],[member="snap-loc"][name="y"]', (elem) => {
	  const value = new Measurement(elem.value || 0, true).decimal();
	  const coord = elem.getAttribute('name');
	  let selected = snapLocScope.selected();
	  if (selected || !snapLoc) {
	    selected ||= hovering;
	    selected.disconnect();
	    const center = selected.center();
	    center[coord](value);
	    selected.move(center, interactionState);
	    hovering = selected;
	    snapLoc = null;
	    du.find.closest('.which-radio-cnt', elem).hidden = true;
	    du.find.closest('.fix-cnt', elem).hidden = false;
	  } else {
	    const center = snapLoc.center();
	    center[coord](value);
	    snapLoc.move(center, interactionState);
	  }
	  panZ.once();
	});
	
	function getTemplateScope(cxtrName, target) {
	  target ||= hovering;
	  const scope = {display, UNITS: Properties.UNITS, target, lastImagePoint};
	  switch (cxtrName) {
	    case 'SnapLocation2d':
	      hovering.pairWith();
	      snapLoc = hovering.pairedWith() ? hovering : null;
	      which = null;
	      Object.merge(scope, snapLocScope);
	      break;
	  }
	  return scope;
	}
	
	function openPopup(event, stdEvent) {
	  let html;
	  if (hovering) {
	    popupOpen = true;
	    const scope = getTemplateScope(hovering.constructor.name);
	    html = getTemplate(hovering).render(scope);
	  } else {
	    popupOpen = true;
	    const scope = getTemplateScope(undefined, layout);
	    html = getTemplate(layout).render(scope);
	  }
	  popUp.open(html, {x: event.screenX, y: event.screenY});
	}
	
	popUp.onClose((elem, event) => {
	  setTimeout(() => popupOpen = false, 200);
	  const attrs = getPopUpAttrs(du.find.closest('[type-2d]',popUp.container()));
	  lastDown = new Date().getTime();
	  clickHolding = false;
	  interactionState.mouseupId = ++mouseupId;
	  interactionState.mousedownId = undefined;
	  if (layout) layout.history().newState();
	});
	
	function onMouseup(event, stdEvent) {
	  if (stdEvent.button == 0) {
	    if (lastDown > new Date().getTime() - selectTimeBuffer) {
	      setTimeout(() => openPopup(event, stdEvent), 5);
	    } else {
	      const clickWasHolding = clickHolding;
	      clickHolding = false;
	      interactionState.mouseupId = ++mouseupId;
	      interactionState.mousedownId = undefined;
	      hovering = undefined;
	      if (layout) layout.history().newState();
	      return clickWasHolding;
	    }
	  } else {
	    console.log('rightClick: do stuff!!');
	    if (layout) layout.history().newState();
	  }
	}
	
	let pending = 0;
	function  drag(event)  {
	  const dragging = !popupOpen && clickHolding && hovering;
	  if (dragging)
	    hovering.move && hovering.move(new Vertex2d({x: event.imageX, y: event.imageY}), interactionState);
	  return dragging;
	}
	
	function hover(event) {
	  if (clickHolding) return true;
	  const vertex = new Vertex2d(event.imageX, event.imageY);
	  hovering = layout.at(new Vertex2d(vertex)) || measurmentMap.hovering(vertex);
	  let found = hovering == true;
	  return found;
	}
	
	function onMove(event) {
	  if (layout === undefined) return;
	  const canDrag = !popupOpen && lastDown < new Date().getTime() - selectTimeBuffer * 1.5;
	  return (canDrag && drag(event)) || hover(event);
	}
	
	function withinTolerance(point, map) {
	  const x0 = point.x;
	  const y0 = point.y;
	  const x1 = map.start.x;
	  const y1 = map.start.y;
	  const x2 = map.end.x;
	  const y2 = map.end.y;
	  const num = Math.abs((y2 - y1)*x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1)
	  const denom = Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));
	  return num / denom < map.tolerance;
	}
	
	function withinTolerance(point, map) {
	  const t = map.tolerance;
	  const start = map.start.point ? map.start.point() : map.start;
	  const end = map.end.point ? map.end.point() : map.end;
	  const x0 = point.x;
	  const y0 = point.y;
	  const x1 = start.x > end.x ? end.x : start.x;
	  const y1 = start.y > end.y ? end.y : start.y;
	  const x2 = start.x < end.x ? end.x : start.x;
	  const y2 = start.y < end.y ? end.y : start.y;
	  return x0>x1-t && x0 < x2+t && y0>y1-t && y0<y2+t;
	}
	
	let windowCount = 0;
	let getWindowColor = () => {
	  switch (Math.floor(Math.random() * 4)) {
	    case 0: return 'red'; case 1: return 'green';
	    case 2: return 'yellow'; case 3: return 'pink';
	  }
	  return 'white';
	}
	
	const windowDrawMap = {};
	function drawWindow(wallStartPoint, window, wallTheta) {
	  draw.beginPath();
	  const points = window.endpoints2D(wallStartPoint);
	  const lookupKey = window.toString();
	  const ctx = draw.ctx();
	  if (windowDrawMap[lookupKey] === undefined) {
	    windowDrawMap[lookupKey] = () => {
	      ctx.moveTo(points.start.x(), points.start.y());
	      ctx.lineWidth = 8;
	      ctx.strokeStyle = hoverId() === window.toString() ? 'green' : 'blue';
	      ctx.lineTo(points.end.x(), points.end.y());
	      ctx.stroke();
	    }
	  }
	  windowDrawMap[lookupKey]();
	}
	
	function doorDrawingFunc(startpointLeft, startpointRight) {
	  return (door) => {
	    const ctx = draw.ctx();
	    ctx.beginPath();
	    ctx.strokeStyle = hoverId() === door.toString() ? 'green' : 'black';
	    const hinge = door.hinge();
	
	    if (hinge === 4) {
	      ctx.moveTo(startpointLeft.x(), startpointLeft.y());
	      ctx.lineWidth = 8;
	      ctx.strokeStyle = hoverId() === door.toString() ? 'green' : 'white';
	      ctx.lineTo(startpointRight.x(), startpointRight.y());
	      ctx.stroke();
	    } else {
	      const offset = Math.PI * hinge / 2;
	      const initialAngle = (door.wall().radians() + offset) % (2 * Math.PI);
	      const endAngle = initialAngle + (Math.PI / 2);
	
	      if (hinge === 0 || hinge === 3) {
	        ctx.moveTo(startpointRight.x(), startpointRight.y());
	        ctx.arc(startpointRight.x(), startpointRight.y(), door.width(), initialAngle, endAngle, false);
	        ctx.lineTo(startpointRight.x(), startpointRight.y());
	      } else {
	        ctx.moveTo(startpointLeft.x(), startpointLeft.y());
	        ctx.arc(startpointLeft.x(), startpointLeft.y(), door.width(), endAngle, initialAngle, true);
	        ctx.lineTo(startpointLeft.x(), startpointLeft.y());
	      }
	
	      ctx.fillStyle = 'white';
	      ctx.fill();
	    }
	    ctx.stroke();
	  }
	}
	
	const doorDrawMap = {};
	function drawDoor(startpoint, door, wallTheta) {
	  const lookupKey = door.toString();
	  if (doorDrawMap[lookupKey] === undefined) {
	    const initialAngle = wallTheta;
	    const width = door.width();
	
	    const distLeft = door.fromPreviousWall() + width;
	    const startpointLeft = {x: startpoint.x + distLeft * Math.cos(theta), y: startpoint.y + distLeft * Math.sin(theta)};
	    const distRight = door.fromPreviousWall();
	    const startpointRight = {x: startpoint.x + distRight * Math.cos(theta), y: startpoint.y + distRight * Math.sin(theta)};
	    doorDrawMap[lookupKey] = doorDrawingFunc(door.startVertex(), door.endVertex(), initialAngle);
	  }
	  doorDrawMap[lookupKey](door);
	}
	
	const blank = 40;
	const hblank = blank/2;
	function drawMeasurementValue(line, midpoint, measurement) {
	  if (line === undefined) return;
	  const ctx = draw.ctx();
	  midpoint = line.midpoint();
	
	  ctx.save();
	  ctx.lineWidth = 0;
	  const length = measurement.display();
	  const textLength = length.length;
	  ctx.translate(midpoint.x(), midpoint.y());
	  ctx.rotate(line.radians());
	  ctx.beginPath();
	  ctx.fillStyle = hoverId() === measurement.toString() ? 'green' : "white";
	  ctx.strokeStyle = 'white';
	  ctx.rect(textLength * -3, -8, textLength * 6, 16);
	  ctx.fill();
	  ctx.stroke();
	
	  ctx.beginPath();
	  ctx.lineWidth = 4;
	  ctx.strokeStyle = 'black';
	  ctx.fillStyle =  'black';
	  ctx.fillText(length, 0, 0);
	  ctx.stroke()
	  ctx.restore();
	}
	
	const measurementLineMap = {};
	const getMeasurementLine = (vertex1, vertex2) => {
	  const lookupKey = `${vertex1} => ${vertex2}`;
	  if (measurementLineMap[lookupKey] === undefined) {
	    const line = new Line2d(vertex1, vertex2);
	    measurementLineMap[lookupKey] = new LineMeasurement2d(line)
	  }
	  return measurementLineMap[lookupKey];
	}
	
	let measurementValues = [];
	function measurementValueToDraw(line, midpoint, measurement) {
	  measurementValues.push({line, midpoint, measurement});
	}
	
	function drawMeasurementValues() {
	  let values = measurementValues;
	  measurementValues = [];
	  measurmentMap.clear();
	  for (let index = 0; index < values.length; index += 1) {
	    let m = values[index];
	    measurmentMap.add(m.line, 10, m.measurement);
	    drawMeasurementValue(m.line, m.midpoint, m.measurement);
	  }
	}
	
	const measurementLineWidth = 3;
	let measurementIs = {};
	function drawMeasurement(measurement, level, focalVertex)  {
	  const lookupKey = `${measurement.toString()}-[${level}]`;
	  // if (measurementIs[lookupKey] === undefined) {
	    measurementIs[lookupKey] = measurement.I(level);
	  // }
	  const lines = measurementIs[lookupKey];
	  const center = layout.vertices(focalVertex, 2, 3);
	  const isHovering = hoverId() === measurement.toString();
	  const measurementColor = isHovering ? 'green' : 'grey';
	  try {
	    draw.beginPath();
	    const isWithin = layout.within(lines.furtherLine().midpoint());
	    const line = isWithin ? lines.closerLine() : lines.furtherLine();
	    const midpoint = Vertex2d.center(line.startLine.endVertex(), line.endLine.endVertex());
	    if (isHovering) {
	      draw.line(line.startLine, measurementColor, measurementLineWidth);
	      draw.line(line.endLine, measurementColor, measurementLineWidth);
	      draw.line(line, measurementColor, measurementLineWidth);
	    }
	    measurementValueToDraw(line, midpoint, measurement);
	    return line;
	  } catch (e) {
	    console.error('Measurement render error:', e);
	  }
	}
	
	function measureOnWall(list, level) {
	  for (let index = 0; index < list.length; index += 1) {
	    let item = list[index];
	    const wall = item.wall();
	    const points = item.endpoints2D();
	    const measureLine1 = getMeasurementLine(wall.startVertex(), points.start);
	    const measureLine2 = getMeasurementLine(points.end, wall.endVertex());
	    measureLine1.modificationFunction(item.fromPreviousWall);
	    measureLine2.modificationFunction(item.fromNextWall);
	    drawMeasurement(measureLine1, level, wall.startVertex())
	    drawMeasurement(measureLine2, level, wall.startVertex())
	    level += 4;
	  }
	  return level;
	}
	
	function includeDetails() {
	  return !dragging && (popupOpen)
	}
	
	function drawWall(wall) {
	  let color = hoverId() === wall.toString() ? 'green' : 'black';
	  if (wall.endVertex().isFree()) color = 'red';
	  draw.line(wall, color, 4);
	  const endpoint = wall.endVertex().point();
	
	  wall.doors().forEach((door) =>
	    drawDoor(startpoint, door, wall.radians()));
	  wall.windows().forEach((window) =>
	    drawWindow(startpoint, window, wall.radians()));
	
	  let level = 8;
	  if (includeDetails()) {
	    const vertices = wall.vertices();
	    let measLines = {};
	    level = measureOnWall(wall.doors(), level);
	    level = measureOnWall(wall.windows(), level);
	  }
	  const measurement = new LineMeasurement2d(wall, undefined, undefined, layout.reconsileLength(wall));
	  drawMeasurement(measurement, level, wall.startVertex());
	
	  return endpoint;
	}
	
	function drawAngle(vertex) {
	  const text = Math.round(vertex.angle() * 10) / 10;
	  const bisector = vertex.bisector(30);
	  const sv = bisector.startVertex();
	  const ev = bisector.endVertex();
	  const point = sv.distance(vertex) < ev.distance(vertex) ? ev : sv;
	  const radians = bisector.perpendicular().radians();
	  draw.text(text, point, {radians, size: 5});
	}
	
	function vertexColor(vertex) {
	  if (hovering && hovering.constructor.name === 'Wall2D') {
	      if (hovering.startVertex().toString() === vertex.toString()) return 'blue';
	      if (hovering.endVertex().toString() === vertex.toString()) return 'yellow';
	  }
	  const isHovering = hoverId() === vertex.toString();
	  return isHovering ? 'green' : 'white';
	}
	
	function drawVertex(vertex) {
	  const isHovering = hoverId() === vertex.toString();
	  const fillColor = vertexColor(vertex);
	  const p = vertex.point();
	  const radius = isHovering ? 6 : 4;
	  const circle = new Circle2d(radius, p);
	  draw.circle(circle, 'black', fillColor);
	  if (layout.objects().length === 0 || vertex.showAngle) drawAngle(vertex);
	}
	
	function drawObjects(objects, defaultColor, dontDrawSnapLocs) {
	  defaultColor ||= 'black';
	  let target;
	  objects.forEach((obj) => {
	    const color = hoverId() === obj.snap2d.top().toString() ? 'green' : defaultColor;
	    draw(obj.snap2d.top(), color, 3);
	    if (!dontDrawSnapLocs) {
	      obj.snap2d.top().snapLocations().forEach((snapLoc) => {
	        const beingHovered = hoverId() === snapLoc.toString();
	        const identfied = Snap2d.identfied(snapLoc);
	        const snapColor = identfied ? 'red' : (beingHovered ? 'green' :
	        (snapLoc.courting() ? 'white' : (snapLoc.pairedWith() ? 'black' : undefined)));
	        const hasPartner = snapLoc.courting() || snapLoc.pairedWith();
	        const radius = identfied ? 6 : (beingHovered || hasPartner ? 4 : 1.5);
	        if (!beingHovered) draw(snapLoc, snapColor, radius);
	        else target = {radius, color: snapColor};
	      });
	    }
	  });
	  if (target) draw(hovering, target.color, target.radius);
	}
	
	function illustrate(canvas) {
	  if (layout === undefined) return;
	  SnapLocation2d.clear();
	  let lastEndPoint = {x: 20, y: 20};
	
	  draw.beginPath();
	  const walls = layout.walls();
	  let previousEndpoint;
	  let wl = walls.length;
	  walls.forEach((wall, index) => {
	    lastEndPoint = drawWall(wall, lastEndPoint);
	    const previousWall = walls[(index - 1) % wl];
	    if (previousEndpoint)
	      drawVertex(wall.startVertex());
	    previousEndpoint = lastEndPoint;
	  }, true);
	  drawVertex(walls[0].startVertex());
	  drawMeasurementValues();
	
	  let objects = layout.level();
	  let allObjects = layout.objects();
	  drawObjects(allObjects, '#85858ebd', true);
	  drawObjects(objects);
	}
	
	const Controls2d = require('controls-2d');
	let panZ;
	let controls2d;
	function init() {
	  const canvas = document.getElementById('two-d-model-canvas');
	  const height = du.convertCssUnit('80vh');
	  canvas.height = height;
	  canvas.width = height;
	  draw = new Draw2D(canvas);
	  panZ = panZoom(canvas, illustrate);
	  panZ.onMove(onMove);
	  panZ.onMousedown(onMousedown);
	  panZ.onMouseup(onMouseup);
	  controls2d = new Controls2d('#two-d-model .orientation-controls', () => layout, panZ);
	  // draw(canvas);
	  TwoDLayout.panZoom = panZ;
	  ThreeDModel.onRenderObjectUpdate(panZ.once);
	  // du.on.match('keycombo(Control,z)', '*', undo);
	  // du.on.match('keycombo(Control,Shift,Z)', '*', redo);
	  du.on.match('keycombo()', '*', (target, event) => {
	    interactionState.keycombonation = event.keycombonation;
	  });
	  du.on.match('keycombo(Control, )', '*', layout.straightenUp);
	}
	
	TwoDLayout.init = init;
	module.exports = TwoDLayout;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/user.js',
function (require, exports, module) {
	
const du = require('../../../../public/js/utils/dom-utils.js');
	const APP_ID = require('../../globals/CONSTANTS.js').APP_ID;
	const Request = require('../../../../public/js/utils/request.js');
	const EPNTS = require('../../generated/EPNTS');
	const $t = require('../../../../public/js/utils/$t.js');
	
	class User {
	  constructor() {
	    const stateAttr = 'user-state';
	    let state, cnt, email, password;
	
	    let la;
	    function loginAvailible(){
	      if (la === undefined) la = du.id('login') !== null;
	      return la;
	    }
	    this.loginAvailible = loginAvailible;
	
	    function updateDisplay(s) {
	      state = s ? User.states[s] : state;
	      cnt = cnt || du.id('login-cnt');
	      cnt.innerHTML = state.template.render({email, password});
	    }
	
	    const hideLogin = () => {
	      if (loginAvailible()) du.id('login').hidden = true;
	    }
	    const showLogin = () =>{
	      if (loginAvailible()) du.id('login').hidden = false;
	    }
	    function successfulRegistration(body) {
	      updateDisplay('CONFIRMATION_MESSAGE');
	    }
	
	    function register(target) {password
	      const fail = du.appendError(target, 'Registration Failed: Email already registered');
	      const body = {email, password};
	      document.cookie = `${APP_ID}=${email}:invalid`;
	      Request.post(EPNTS.user.register(), body, successfulRegistration, fail);
	    }
	
	    function successfulLogin(body, res) {
	      const newAuth = res.getResponseHeader('authorization');
	      document.cookie = `${APP_ID}=${newAuth}`;
	      hideLogin();
	    }
	
	    const getEmail = () => du.cookie.get(APP_ID, ':', 'email').email;
	    this.credential = User.credential;
	
	    function login(target) {
	      const fail = du.appendError(target, 'Login Failed: Invalid Email and/or Password');
	      const body = {email, password};
	      Request.post(EPNTS.user.login(), body, successfulLogin, fail);
	    }
	
	    function resendActivation(target) {
	      const fail = du.appendError(target, 'Email Not Registered Or Already Active');
	      const body = {email: getEmail()};
	      Request.post(EPNTS.user.resendActivation(), body, successfulRegistration, fail);
	    }
	
	    function logout() {
	      du.cookie.remove(APP_ID);
	      showLogin();
	      updateDisplay('LOGIN')
	    }
	
	    function resetPassword(target) {
	      const fail = du.appendError(target, 'Server Error Must have occured... try again in a few minutes');
	      const body = {email, newPassword: password};
	      Request.post(EPNTS.user.resetPasswordRequest(), body, successfulRegistration, fail);
	    }
	
	    du.on.match('click', `[${stateAttr}]`, (elem) => {
	      const stateId = elem.getAttribute(stateAttr);
	      if (User.states[stateId]) {
	        updateDisplay(stateId);
	      } else console.error(`Invalid State: '${stateId}'`);
	    });
	
	    du.on.match('click', '#register', register);
	    du.on.match('click', '#login-btn', login);
	    du.on.match('click', '#resend-activation', resendActivation);
	    du.on.match('click', '#reset-password', resetPassword);
	    du.on.match('click', '#logout-btn', logout);
	
	    du.on.match('change', 'input[name="email"]', (elem) => email = elem.value);
	    du.on.match('change', 'input[name="password"]', (elem) => password = elem.value);
	
	    function statusCheck(body) {
	      switch (body) {
	        case 'Not Registered':
	          updateDisplay('LOGIN')
	          break;
	        case 'Not Activated':
	          updateDisplay('CONFIRMATION_MESSAGE');
	          break;
	        case 'Logged In':
	          hideLogin();
	          break;
	        case 'Logged Out':
	          updateDisplay('LOGIN')
	          break;
	        default:
	
	      }
	    }
	
	    Request.globalHeader('Authorization', this.credential);
	    if (this.loginAvailible() && this.credential()) Request.get(EPNTS.user.status(), statusCheck);
	    else if (loginAvailible()) updateDisplay('LOGIN');
	  }
	}
	
	User.states = {};
	User.states.LOGIN = {
	  template: new $t('login/login')
	};
	User.states.CONFIRMATION_MESSAGE = {
	  template: new $t('login/confirmation-message')
	};
	User.states.CREATE_ACCOUNT = {
	  template: new $t('login/create-account')
	};
	User.states.RESET_PASSWORD = {
	  template: new $t('login/reset-password')
	};
	
	User.credential = () => du.cookie.get(APP_ID);
	
	
	User = new User();
	module.exports = User
	
});


RequireJS.addFunction('./services/cabinet/app-src/config/cabinet-template.js',
function (require, exports, module) {
	
const cabinetsJson = require('../../public/json/cabinets.json');
	const Cabinet = require('../objects/assembly/assemblies/cabinet.js')
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const PropertyConfig = require('./property/config');
	
	class CabinetTemplate extends Lookup {
	  constructor(type) {
	    super();
	    const instance = this;
	    const initialVals = (typeof type) === 'object' ? type : {
	      type, values: [], subassemblies: [], joints: [], dividerJoint: {},
	      shape: 'square',
	      width: 18 * 2.54,
	      height: 34 * 2.54,
	      thickness: 24 * 2.54,
	      fromFloor: 0,
	      openings: [CabinetTemplate.defaultPartCodeOpening()],
	      autoToeKick: false
	    };
	    Object.getSet(this, initialVals);
	    CabinetTemplate.map[type] = this;
	
	    function getCabinet(length, width, thickness, pc) {
	      const cabinet = Cabinet.build(instance.type(), undefined, instance.toJson());
	      cabinet.length(length || this.height());
	      cabinet.width(width || this.width());
	      cabinet.thickness(thickness || this.thickness());
	
	      cabinet.propertyConfig(pc instanceof PropertyConfig ? pc : new PropertyConfig());
	      return cabinet;
	    }
	    this.getCabinet = getCabinet;
	
	    this.codeMap = () => {
	      let codeMap = {};
	      Object.values(this.subassemblies()).forEach((sa) => codeMap[sa.code] = sa);
	      return codeMap;
	    }
	
	    this.validPartCode = (code) => this.codeMap()[code] !== undefined;
	    const vpc = this.validPartCode;
	
	    this.validOpenings = () => {
	      const bms = this.openings();
	      for (let index = 0; index < bms.length; index += 1) {
	        const bm = bms[index];
	        if (!(vpc(bm.top) && vpc(bm.bottom) && vpc(bm.right) &&
	                vpc(bm.left) && vpc(bm.bottom))) {
	          return false;
	        }
	      }
	      return true;
	    }
	    this.validateDividerJoint = () => {
	      const j = this.dividerJoint();
	      return j.type === 'Butt' || (j.type === 'Dado' && j.maleOffset > 0);
	    }
	
	    const offsetReg = /(-|\+|)[xyz]/;
	    this.validOffset = (offset) => offset && offset.match(offsetReg) !== null;
	    const vo = this.validOffset;
	
	    this.validateJoint = (joint, malePartCode, femalePartCode) => {
	      let isValid = vpc(malePartCode) && vpc(femalePartCode);
	      switch (joint.type) {
	        case "Dado":
	          return isValid && joint.maleOffset > 0 && vo(joint.demensionToOffset) &&
	                  vo(joint.centerOffset);
	        default:
	          return true;
	      }
	    }
	    this.validateJoints = () => {
	      let joints = this.joints();
	      for (let index = 0; index < joints.length; index += 1) {
	        if (!this.validateJoint(joints[index])) return false;
	      }
	      return true;
	    }
	
	    this.evalEqn = (eqn, cab) => {
	      cab ||= getCabinet();
	      return cab.eval(eqn);
	    }
	
	    this.evalObject = (eqn, cab) => {
	      cab ||= getCabinet();
	      return cab.evalObject(eqn);
	    }
	
	    this.validateEquation = (eqn, cab) => {
	      return !Number.isNaN(this.evalEqn(eqn, cab));
	    }
	    const veq = this.validateEquation;
	
	    this.validateValues = (cab) => {
	      try {
	        cab ||= getCabinet();
	      } catch (e) {
	        return false;
	      }
	      const values = Object.values(this.values());
	      for (let index = 0; index < values.length; index += 1) {
	        if (!veq(values[index].eqn, cab)) return false;
	      }
	      return true;
	    }
	
	    this.validateSubassembly = (subAssem, cab) => {
	      try {
	        cab ||= getCabinet();
	      } catch (e) {
	        return false;
	      }
	
	      const c = subAssem.center;
	      const d = subAssem.demensions;
	      const r = subAssem.rotation;
	      return vpc(subAssem.code) &&
	              r.length === 3 && veq(r[0], cab) && veq(r[1], cab) && veq(r[2], cab) &&
	              veq(c[0], cab) && veq(c[1], cab) && veq(c[2], cab) &&
	              veq(d[0], cab) && veq(d[1], cab) && veq(d[2], cab);
	    }
	
	    this.validateSubassemblies = (cab) => {
	      try {
	        cab ||= getCabinet();
	      } catch (e) {
	        return false;
	      }      const subAssems = Object.values(this.subassemblies());
	      for (let index = 0; index < subAssems.length; index += 1) {
	        if (!this.validateSubassembly(subAssems[index])) return false;
	      }
	      return true;
	    }
	
	    this.valid = () => {
	      let cab;
	      try {
	        cab ||= getCabinet();
	      } catch (e) {
	        return false;
	      }
	      return this.validateValues(cab) && this.validOpenings() &&
	              this.validateDividerJoint() && this.validateJoints() &&
	              this.validateSubassemblies(cab);
	    }
	  }
	}
	
	CabinetTemplate.map = {};
	CabinetTemplate.defaultList = () => {
	  const list = [];
	  const keys = Object.keys(cabinetsJson);
	  // comment out to get corner-wall to be the first.
	  // keys.sort();
	  for (let index = 0; index < keys.length; index += 1) {
	    list.push(new CabinetTemplate().fromJson(cabinetsJson[keys[index]]));
	  }
	  return list;
	}
	
	CabinetTemplate.typeUndefined = (type) => CabinetTemplate.map[type] === undefined;
	CabinetTemplate.defaultPartCodeOpening = () => ({
	    _Type: "part-code",
	    top: "pt",
	    bottom: "pb",
	    left: "pl",
	    right: "pr",
	    back: "pback"
	  }
	);
	
	CabinetTemplate.defaultLocationOpening = () => ({
	  _Type: "location",
	  zRotation: 0,
	  inner: {
	    top: {left: {x: 0, y: 0, z: 0}, right: {x: 0, y: 0, z: 0}},
	    bottom: {right:{x: 0, y: 0, z: 0}, left: {x: 0, y: 0, z: 0}}
	  },
	  outer: {
	    top: {left: {x: 0, y: 0, z: 0}, right: {x: 0, y: 0, z: 0}},
	    bottom: {right:{x: 0, y: 0, z: 0}, left: {x: 0, y: 0, z: 0}}
	  }
	});
	
	module.exports = CabinetTemplate;
	
});


RequireJS.addFunction('./services/cabinet/app-src/config/cabinet-configs.js',
function (require, exports, module) {
	

	
	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	const Select = require('../../../../public/js/utils/input/styles/select.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const Inputs = require('../input/inputs.js');
	const DecisionInputTree = require('../../../../public/js/utils/input/decision/decision.js');
	const Cabinet = require('../objects/assembly/assemblies/cabinet.js');
	const Request = require('../../../../public/js/utils/request.js');
	const EPNTS = require('../../generated/EPNTS.js');
	const CabinetTemplate = require('./cabinet-template');
	const ValueCondition = require('../../../../public/js/utils/input/decision/decision.js').ValueCondition;
	const Cabinets = require('../../public/json/cabinets.json');
	const CabinetLayouts = require('./cabinet-layouts');
	
	const configs = {};
	class CabinetConfig {
	  constructor(cabinets, id) {
	    let cabinetList = {};
	    let cabinetKeys = {};
	    let configKeys;
	
	    this.valid = (type, id) => (!id ?
	                  cabinets[type] : cabinetKeys[type][id]) !== undefined;
	
	    this.inputTree = () => {
	      const types = JSON.parse(JSON.stringify(configKeys));
	      const typeInput = new Select({
	        name: 'type',
	        label: 'Type',
	        inline: false,
	        class: 'center',
	        list: types
	      });
	      const nameInput = new Input({
	        name: 'name',
	        inline: true,
	        label: 'Name (optional)',
	        class: 'center',
	      });
	      const layoutInput = new Input({
	        label: 'Layout (Optional)',
	        name: 'layout',
	        inline: true,
	        class: 'center',
	        clearOnDblClick: true,
	        list: CabinetLayouts.list()
	      });
	
	      const inputs = [layoutInput, nameInput, typeInput];
	      const inputTree = new DecisionInputTree();
	      // inputTree.onSubmit((t) => {
	      //   inputTree.payload().inputArray[1].setValue('', true)
	      //   inputTree.children()[0].payload().inputArray[0].setValue('', true)
	      // });
	      inputTree.leaf('Cabinet', inputs);
	
	      return inputTree;
	    };
	    this.get = (group, type, layout, name) => {
	      let cabinet = Cabinet.build(type, group);
	      if (layout && CabinetLayouts.map[layout]) CabinetLayouts.map[layout].build(cabinet);
	      cabinet.name(name);
	      return cabinet;
	    };
	
	    const allCabinetKeys = Object.keys(cabinets);
	    allCabinetKeys.forEach((key) => {
	      const type = cabinets[key].partName;
	      if (cabinetKeys[type] === undefined)  cabinetKeys[type] = {};
	      if (cabinetKeys[type][key] === undefined)  cabinetKeys[type][key] = {};
	      cabinetKeys[type][key] = cabinets[key];
	    });
	
	    cabinetList = cabinets;
	    configKeys = Object.keys(cabinets);
	    configs[id] = this;
	  }
	}
	
	let currConfig = new CabinetConfig(Cabinets, 'default');
	const updateEvent = new CustomEvent('update');
	
	module.exports = {
	  switch: (configId) => {
	    if (configs[configId] !== undefined) {
	      currConfig = configs[configId];
	      updateEvent.trigger();
	    }
	  },
	  configList: () => Object.keys(configs),
	  valid: (...args) => currConfig.valid(...args),
	  onUpdate: (func) => updateEvent.on(func),
	  inputTree: (...args) => currConfig.inputTree(...args),
	  get: (...args) => currConfig.get(...args),
	  new: (json, id) => new CabinetConfig(json, id)
	}
	
	// Request.get(EPNTS.cabinet.list(), (cabinets) => {
	//   new CabinetConfig(cabinets, 'user');
	//   module.exports.switch('user');
	// }, console.error);
	
	
	
	
	
	
	// ---------------------- Layout Specific Input Tree -----------------------//
	// this.inputTree = () => {
	//   const types = JSON.parse(JSON.stringify(configKeys));
	//   const typeInput = new Select({
	//     name: 'type',
	//     label: 'Type',
	//     inline: false,
	//     class: 'center',
	//     list: types
	//   });
	//   const nameInput = new Input({
	//     name: 'name',
	//     inline: false,
	//     label: 'Name (optional)',
	//     class: 'center',
	//   });
	//   const inputs = [typeInput, nameInput];
	//   const inputTree = new DecisionInputTree();
	//   inputTree.onSubmit((t) => {
	//     inputTree.payload().inputArray[1].setValue('', true)
	//     inputTree.children()[0].payload().inputArray[0].setValue('', true)
	//   });
	//   const cabinet = inputTree.branch('Cabinet', inputs);
	//   const cabinetTypes = Object.keys(cabinetKeys);
	//   types.forEach((type) => {
	//
	//     const cabinetInput = new Input({
	//       label: 'Layout (Optional)',
	//       name: 'id',
	//       inline: false,
	//       class: 'center',
	//       clearOnDblClick: true,
	//       list: [''].concat(cabinetKeys[type] ? Object.keys(cabinetKeys[type]) : [])
	//     });
	//     cabinet.conditional(type, new ValueCondition('type', type, [cabinetInput]));
	//   });
	//   return inputTree;
	// };
	
});


RequireJS.addFunction('./services/cabinet/app-src/config/properties.js',
function (require, exports, module) {
	

	const Property = require('./property');
	const Defs = require('./property/definitions');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	const EPNTS = require('../../generated/EPNTS');
	const Request = require('../../../../public/js/utils/request.js');
	
	let unitCount = 0;
	const UNITS = [];
	Measurement.units().forEach((unit) =>
	      UNITS.push(new Property('Unit' + ++unitCount, unit, unit === Measurement.unit())));
	UNITS._VALUE = Measurement.unit();
	
	const assemProps = {}
	const add = (key, properties) => properties.forEach((prop) => {
	  if (assemProps[key] === undefined) assemProps[key] = {};
	  assemProps[key][prop.code()] = prop;
	});
	
	add('Overlay', [Defs.ov]);
	add('Reveal', [Defs.r,Defs.rvt,Defs.rvb,Defs.rvr,Defs.rvl]);
	add('Inset', [Defs.is]);
	add('Cabinet', [Defs.h,Defs.w,Defs.d,Defs.sr,Defs.sl,Defs.rvibr,Defs.rvdd,
	                Defs.tkbw,Defs.tkd,Defs.tkh,Defs.pbt,Defs.iph, Defs.brr,
	                Defs.frw,Defs.frt,Defs.bid,Defs.tid]);
	add('Panel', [Defs.h,Defs.w,Defs.t]);
	add('Guides', [Defs.l,Defs.dbtos,Defs.dbsos,Defs.dbbos]);
	add('DoorAndFront', [Defs.daffrw,Defs.dafip])
	add('Door', [Defs.h,Defs.w,Defs.t]);
	add('DrawerBox', [Defs.h,Defs.w,Defs.d,Defs.dbst,Defs.dbbt,Defs.dbid,Defs.dbn]);
	add('DrawerFront', [Defs.h,Defs.w,Defs.t,Defs.mfdfd]);
	add('Frame', [Defs.h,Defs.w,Defs.t]);
	add('Handle', [Defs.l,Defs.w,Defs.c2c,Defs.proj]);
	add('Hinge', [Defs.maxtab,Defs.mintab,Defs.maxol,Defs.minol]);
	add('Opening', []);
	
	
	function definitionsRequired(group) {
	  const required = [];
	  if (assemProps[group] === undefined) return [];
	  Object.values(assemProps[group]).forEach((prop) => {
	    if (prop instanceof Property && prop.value() !== null) required.push(prop);
	  });
	  return required;
	}
	
	function propertiesToDefine() {
	  const propNames = [];
	  const keys = Object.keys(assemProps);
	  keys.forEach((key) => {
	    if (definitionsRequired(key).length !== 0) {
	      propNames.push(key);
	    }
	  });
	  return propNames;
	}
	
	const excludeKeys = ['_ID', '_NAME', '_GROUP', 'properties'];
	function assemProperties(clazz, filter) {
	  clazz = (typeof clazz) === 'string' ? clazz : clazz.constructor.name;
	  props = assemProps[clazz] || [];
	  if ((typeof filter) != 'function') return props;
	  props = props.filter(filter);
	  return props;
	}
	
	
	let config = {};
	const changes = {};
	const copyMap = {};
	assemProperties.changes = {
	  saveAll: () => Object.values(changes).forEach((list) => assemProperties.changes.save(list._ID)),
	  save: (id) => {
	    const list = changes[id];
	    if (!list) throw new Error(`Unkown change id '${id}'`);
	    const group = list._GROUP;
	    if (config[group] === undefined) config[group] = [];
	    if(copyMap[id] === undefined) {
	      config[group][list._NAME] = {name: list._NAME, properties: JSON.clone(list, excludeKeys, true)};
	      copyMap[list._ID] = config[group][list._NAME].properties;
	    } else {
	      const tempList = changes[id];
	      for (let index = 0; index < tempList.length; index += 1) {
	        const tempProp = tempList[index];
	        const configProp = copyMap[id][index];
	        configProp.value(tempProp.value());
	      }
	    }
	   },
	  deleteAll: () => Object.values(changes).forEach((list) => assemProperties.changes.delete(list._GROUP)),
	  delete: (id) => {
	    delete config[changes[id][0].name()][changes[id]._NAME];
	    delete changes[id];
	    delete copyMap[id];
	  },
	  changed: (id) => {
	    const list = changes[id];
	    if (list === undefined) return false;
	    for (let index = 0; index < list.length; index += 1) {
	      const prop = list[index];
	      if (prop === undefined || (copyMap[list._ID] !== undefined && copyMap[list._ID][index] === undefined)) {
	        console.log('booyacka!');
	      }
	      if (copyMap[list._ID] === undefined || !copyMap[list._ID][index].equals(prop)) {
	        return true;
	      }
	    }
	    return false;
	  },
	  changesExist: () => {
	      const lists = Object.values(changes);
	      for (let index = 0; index < lists.length; index += 1) {
	        if (assemProperties.changes.changed(lists[index]._ID)) {
	          return true;
	        }
	      }
	      return false;
	  }
	}
	
	assemProperties.config = () => {
	  const plainObj = {};
	  const keys = Object.keys(config);
	  for (let index = 0; index < keys.length; index += 1) {
	    const key = keys[index];
	    const lists = config[key];
	    const listKeys = Object.keys(lists);
	    plainObj[key] = {};
	    for (let lIndex = 0; lIndex < listKeys.length; lIndex += 1) {
	      const listKey = listKeys[lIndex];
	      const list = lists[listKey];
	      const propObj = {name: listKey, properties: []};
	      plainObj[key][listKey] = propObj;
	      list.properties.forEach((property) =>
	          propObj.properties.push(property.toJson(excludeKeys, true)))
	    }
	  }
	  return plainObj;
	}
	assemProperties.list = () => Object.keys(assemProps);
	assemProperties.new = (group, name) => {
	  if (assemProps[group]) {
	    const list = [];
	    let addIndex = 0;
	    const ogList = Object.values(assemProps[group]);
	    for (let index = 0; index < ogList.length; index += 1) {
	      if (hasValueFilter(ogList[index])) {
	        list[addIndex++] = ogList[index].clone();
	      }
	    }
	    list._ID = String.random();
	    list._GROUP = group;
	    list._NAME = name;
	    changes[list._ID] = list;
	    return list;
	  }
	  throw new Error(`Requesting invalid Property Group '${group}'`);
	}
	
	assemProperties.instance = () => {
	  const keys = Object.keys(assemProps);
	  const clone = {};
	  keys.forEach((key) => {
	    const props = Object.values(assemProps[key]);
	    if (clone[key] === undefined) clone[key] = {};
	    props[keys] = {};
	    props.forEach((prop) => clone[key][prop.code()] = prop.clone());
	  });
	  return clone;
	};
	
	assemProperties.getSet = (group, setName) => {
	  const clone = {};
	  let propertyObj = config[group][setName];
	  propertyObj.properties.forEach((prop) => clone[prop.code()] = prop.clone());
	  clone.__KEY = setName;
	  return clone;
	}
	
	const dummyFilter = () => true;
	assemProperties.groupList = (group, filter) => {
	  filter = filter || dummyFilter;
	  const groupList = config[group];
	  const changeList = {};
	  if (groupList === undefined) return {};
	  const groupKeys = Object.keys(groupList);
	  for (let index = 0; index < groupKeys.length; index += 1) {
	    const groupKey = groupKeys[index];
	    const list = groupList[groupKey];
	    const properties = groupList[list.name].properties;
	    const codes = properties.map((prop) => prop.code());
	    // const newProps = assemProps[group].filter((prop) => codes.indexOf(prop.code()) === -1)
	    //                   .filter(filter);
	    // newProps.forEach((prop) => properties.push(prop.clone()));
	    changeList[list.name] = {name: list.name, properties: []};
	    for (let pIndex = 0; pIndex < properties.length; pIndex += 1) {
	      const prop = properties[pIndex];
	      changeList[list.name].properties.push(prop.clone());
	    }
	    const id = String.random();
	    const set = changeList[list.name].properties;
	    set._ID = id;
	    set._NAME = list.name;
	    changes[id] = set;
	    copyMap[id] = properties;
	  }
	  return changeList;
	}
	
	const hasValueFilter = (prop) => prop.value() !== null;
	assemProperties.hasValue = (group) => {
	  if (props === undefined) return [];
	  return assemProperties.groupList(group, hasValueFilter);
	}
	
	const list = (key) =>
	    assemProps[key] ? Object.values(assemProps[key]) : [];
	
	const noValueFilter = (prop) => prop.value() === null;
	assemProperties.noValue = (group) => {
	  const props = list(group);
	  if (props === undefined) return [];
	  return props.filter(noValueFilter);
	}
	
	assemProperties.all = () => {
	  const props = {};
	  const keys = Object.keys(assemProps);
	  keys.forEach((key) => {
	    const l = [];
	    list(key).forEach((prop) => l.push(prop));
	    props[key] = l;
	  });
	  return props;
	}
	
	assemProperties.UNITS = UNITS;
	
	assemProperties.load = (body) => {
	  config = Object.fromJson(body);
	}
	
	assemProperties.definitionsRequired = definitionsRequired;
	assemProperties.propertiesToDefine = propertiesToDefine;
	module.exports = assemProperties;
	
});


RequireJS.addFunction('./services/cabinet/app-src/input/inputs.js',
function (require, exports, module) {
	const MeasurementInput = require('../../../../public/js/utils/input/styles/measurement.js');
	const Cost = require('../cost/cost.js');
	const Select = require('../../../../public/js/utils/input/styles/select.js');
	const Material = require('../cost/types/material.js');
	const Company = require('../objects/company.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const Labor = require('../cost/types/labor.js');
	
	
	const defined = {};
	function add (name, input) {
	  if (defined[name]) {
	    throw new Error(`Input by the name of '${name}' is already defined`)
	  }
	  defined[name] = input;
	}
	
	module.exports = (name, properties) => defined[name].clone(properties);
	
	
	add('length', new MeasurementInput({
	  type: 'text',
	  placeholder: 'Length',
	  name: 'length',
	  class: 'center'
	}));
	
	add('width', new MeasurementInput({
	  type: 'text',
	  label: 'x',
	  placeholder: 'Width',
	  name: 'width',
	  class: 'center'
	}));
	
	add('depth', new MeasurementInput({
	  type: 'text',
	  label: 'x',
	  placeholder: 'Depth',
	  name: 'depth',
	  class: 'center'
	}));
	
	add('cost', new MeasurementInput({
	  type: 'number',
	  label: '$',
	  placeholder: 'Cost',
	  name: 'cost'
	}));
	
	add('pattern', new MeasurementInput({
	  type: 'text',
	  class: 'pattern-input',
	}));
	
	
	add('offsetLen', new MeasurementInput({
	  type: 'text',
	  label: 'Offset',
	  placeholder: 'Length',
	  name: 'offsetLength',
	  class: 'center',
	}));
	
	add('offsetWidth', new MeasurementInput({
	  type: 'text',
	  label: 'x',
	  placeholder: 'Width',
	  name: 'offsetWidth',
	  class: 'center',
	}));
	
	add('offsetDepth', new MeasurementInput({
	  type: 'text',
	  label: 'x',
	  placeholder: 'Depth',
	  name: 'offsetDepth',
	  class: 'center',
	}));
	
	
	add('costType', new Select({
	  placeholder: 'Type',
	  name: 'type',
	  class: 'center',
	  list: Cost.typeList
	}));
	
	add('method', new Select({
	  name: 'method',
	  class: 'center',
	  list: Material.methodList,
	}));
	
	add('company', new Select({
	  name: 'company',
	  label: 'Company',
	  class: 'center',
	  list: [''].concat(Object.keys(Company.list)),
	  value: ''
	}));
	
	add('childCost', new Select({
	    name: 'child',
	    label: 'Default',
	    class: 'center',
	}));
	
	
	add('id', new Input({
	  type: 'text',
	  placeholder: 'Id',
	  name: 'id',
	  class: 'center',
	  validation: /^\s*[^\s]{1,}\s*$/,
	  errorMsg: 'You must enter an Id'
	}));
	
	add('propertyId', new Input({
	  type: 'text',
	  placeholder: 'Property Id',
	  name: 'propertyId',
	  class: 'center',
	  validation: /^[a-zA-Z\.]{1}$/,
	  errorMsg: 'Alpha Numeric Value seperated by \'.\'.<br>I.E. Cabinet=>1/2 Overlay = Cabinet.12Overlay'
	}));
	
	add('propertyValue', new Input({
	  type: 'text',
	  placeholder: 'Property Value',
	  name: 'propertyValue',
	  class: 'center'
	}));
	
	add('costId', new Input({
	  type: 'text',
	  placeholder: 'Id',
	  name: 'id',
	  class: 'center',
	  validation: (id, values) =>
	      id !== '' && (!values.referenceable || Object.values(Cost.defined).indexOf(id) === -1),
	  errorMsg: 'You must an Id: value must be unique if Referencable.'
	}));
	
	add('name', new Input({
	  type: 'text',
	  placeholder: 'Name',
	  name: 'name',
	  value: 'peach',
	  class: 'center',
	  validation: /^\s*[^\s].*$/,
	  errorMsg: 'You must enter a Name'
	}));
	
	add('color', new Input({
	  type: 'color',
	  validation: /.*/,
	  placeholder: 'color',
	  name: 'color',
	  class: 'center'
	}));
	
	add('optional', new Input({
	  label: 'Optional',
	  name: 'optional',
	  type: 'checkbox',
	  default: false,
	  validation: [true, false],
	  targetAttr: 'checked'
	}));
	
	add('modifyDemension', new Input({
	  label: 'Modify Demension',
	  name: 'modifyDemension',
	  type: 'checkbox',
	  default: false,
	  validation: [true, false],
	  targetAttr: 'checked'
	}));
	
	add('partNumber', new Input({
	  label: 'Part Number',
	  name: 'partNumber',
	  type: 'text'
	}));
	
	add('count', new Input({
	  label: 'Count',
	  name: 'count',
	  type: 'number',
	  value: 1
	}));
	
	add('quantity', new Input({
	  label: 'Quantity',
	  name: 'quantity',
	  type: 'number',
	  value: 0
	}));
	
	add('hourlyRate', new Input({
	  label: 'Hourly Rate',
	  name: 'hourlyRate',
	  type: 'number',
	}));
	
	add('hours', new Input({
	  label: 'Hours',
	  name: 'hours',
	  type: 'number',
	  value: 0
	}));
	
	add('laborType', new Input({
	  name: 'laborType',
	  placeholder: 'Labor Type',
	  label: 'Type',
	  class: 'center',
	  clearOnClick: true,
	  list: Labor.types
	}));
	
	add('formula', new Input({
	  name: 'formula',
	  placeholder: 'Formula',
	  label: 'Formula',
	  class: 'center'
	}));
	
});


RequireJS.addFunction('./services/cabinet/app-src/input/validation.js',
function (require, exports, module) {
	

	
	const InvalidComputation = require('./error.js');
	
	class ObjectValidator {
	  constructor() {
	    const validators =  {};
	    this.add = (name, validator) => {
	      if (!(validator instanceof ObjectValidator) && !(validator instanceof Validator)) {
	        throw new Error('Invalid Validator');
	      }
	      validator[name] = validator;
	    }
	    this.validate = (obj) => {
	      if (typeof obj !== 'object') throw new InvalidComputation()
	      const keys = Object.keys(validators);
	    }
	  }
	}
	
	
	class Validator {
	  constructor(validator, props, info) {
	    let type, validate;
	    const complement = props.explanation;
	
	    let defaultExpl;
	    if (validator instanceof Regex) {
	      type = 'Regex';
	      if (props.complement) {
	        defaultExpl = 'Value must fit regex expression';
	        validate = (value) => validator.match('value');
	      } else {
	        defaultExpl = 'Value must not fit regex expression';
	        validate = (value) => !validator.match('value');
	      }
	    } else if (Array.isArray(validator)) {
	      if (props.complement) {
	        defaultExpl = 'Value must exist within array';
	        validate = (value) => validator.indexOf(value) !== -1;
	      } else {
	        defaultExpl = 'Value must not exist within array';
	        validate = (value) => validator.indexOf(value) === -1;
	      }
	    }
	
	    props.explanation = props.explanation || defaultExpl;
	
	    val = val === undefined && elem ? elem.value : val;
	    if (val === undefined) return false;
	    if (valid !== undefined && val === value) return valid;
	    let valValid = true;
	    if (props.validation instanceof RegExp) {
	      valValid = val.match(props.validation) !== null;
	    }
	    else if ((typeof props.validation) === 'function') {
	      valValid = props.validation.apply(null, arguments);
	    }
	    else if (Array.isArray(props.validation)) {
	      valValid = props.validation.indexOf(val) !== -1;
	    }
	
	    return valValid;
	  }
	}
	exports.ObjectValidator = ObjectValidator
	exports.Validator = Validator
	
	
	
	
	
});


RequireJS.addFunction('./services/cabinet/app-src/config/property.js',
function (require, exports, module) {
	
const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const Measurement = require('../../../../public/js/utils/measurement.js');
	
	
	
	class Property extends Lookup {
	  // clone constructor(code, value) {
	  constructor(code, name, props) {
	    super();
	    let value;// = (typeof props) === 'object' && props !== null ? props.value : undefined;
	    const children = [];
	
	    const initVals = {
	      code, name, description: props instanceof Object ? props.description : undefined
	    }
	    Object.getSet(this, initVals, 'value', 'code', 'name', 'description', 'properties');
	
	    this.value = (val, notMetric) => {
	      if (val !== undefined && value !== val) {
	        const measurement = new Measurement(val, notMetric);
	        const measurementVal = measurement.value();
	        value = Number.isNaN(measurementVal) ? val : measurement;
	      }
	      return value instanceof Measurement ? value.value() : value;
	    }
	
	    this.display = () => {
	      return value instanceof Measurement ? value.display() : value;
	    }
	
	    this.measurementId = () => value instanceof Measurement ? value.id() : undefined;
	
	    if ((typeof props) !== 'object' ||  props === null) {
	      this.value(props);
	      props = {};
	    }
	    this.properties(props || {});
	
	    const existingProp = Property.list[code];
	    let clone = false;
	    if (this.properties().value !== undefined) {
	      this.value(this.properties().value, this.properties().notMetric);
	    }
	
	    // if (existingProp) {
	    //   value = value || existingProp.value();
	    //   name = existingProp.name();
	    //   this.properties(existingProp.properties());
	    //   clone = true;
	    // }
	
	    if ((typeof value) === 'number')
	      value = new Measurement(value, this.properties().notMetric);
	
	
	    this.addChild = (property) => {
	      if (property instanceof Property && property.code() === this.code()) {
	            if (children.indexOf(property) === -1) children.push(property);
	            else throw new Error('Property is already a child');
	      }
	      else throw new Error('Child is not an instance of Property or Code does not match');
	    }
	
	    this.children = () => JSON.clone(children);
	
	    this.equals = (other) =>
	        other instanceof Property &&
	        this.value() === other.value() &&
	        this.code() === other.code() &&
	        this.name() === other.name() &&
	        this.description() === other.description();
	
	    this.clone = (val) => {
	      const cProps = this.properties();
	      cProps.clone = true;
	      cProps.value = val === undefined ? this.value() : val;
	      cProps.description = this.description();
	      delete cProps.notMetric;
	      return new Property(this.code(), this.name(), cProps);
	    }
	    if(!clone) Property.list[code] = this;
	    else if (!this.properties().copy && Property.list[code]) Property.list[code].addChild(this);
	  }
	}
	Property.list = {};
	Property.DO_NOT_CLONE = true;
	
	new Property();
	
	module.exports = Property
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/three-d-model.js',
function (require, exports, module) {
	

	const CSG = require('../../public/js/3d-modeling/csg');
	
	const du = require('../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../public/js/utils/$t.js');
	const FunctionCache = require('../../../../public/js/utils/services/function-cache.js');
	
	const Polygon3D = require('./objects/polygon');
	const BiPolygon = require('./objects/bi-polygon');
	const Polygon2d = require('../../../../public/js/utils/canvas/two-d/objects/polygon');
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line');
	const Vertex2d = require('../../../../public/js/utils/canvas/two-d/objects/vertex');
	const Vertex3D = require('./objects/vertex');
	const Vector3D = require('./objects/vector');
	const Line3D = require('./objects/line');
	const Plane = require('./objects/plane');
	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	const OrientationArrows = require('../displays/orientation-arrows.js');
	const Viewer = require('../../public/js/3d-modeling/viewer.js').Viewer;
	const addViewer = require('../../public/js/3d-modeling/viewer.js').addViewer;
	const ToleranceMap = require('../../../../public/js/utils/tolerance-map.js');
	const CabinetModel = require('./cabinet-model');
	
	const colors = {
	  indianred: [205, 92, 92],
	  gray: [128, 128, 128],
	  fuchsia: [255, 0, 255],
	  lime: [0, 255, 0],
	  black: [0, 0, 0],
	  lightsalmon: [255, 160, 122],
	  red: [255, 0, 0],
	  maroon: [128, 0, 0],
	  yellow: [255, 255, 0],
	  olive: [128, 128, 0],
	  lightcoral: [240, 128, 128],
	  green: [0, 128, 0],
	  aqua: [0, 255, 255],
	  white: [255, 255, 255],
	  teal: [0, 128, 128],
	  darksalmon: [233, 150, 122],
	  blue: [0, 0, 255],
	  navy: [0, 0, 128],
	  salmon: [250, 128, 114],
	  silver: [192, 192, 192],
	  purple: [128, 0, 128]
	}
	
	const colorChoices = Object.keys(colors);
	let colorIndex = 0;
	function getColor(name) {
	  if(colors[name]) return colors[name];
	  return colors[colorChoices[colorIndex++ % colorChoices.length]];
	  // return colors.white;
	}
	
	class ThreeDModel {
	  constructor(assembly) {
	    const hiddenPartIds = {};
	    const hiddenPartNames = {};
	    const hiddenPrefixes = {};
	    const instance = this;
	    let hiddenPrefixReg;
	    let extraObjects = [];
	    let inclusiveTarget = {};
	    let partMap;
	    let renderId;
	    let targetPartName;
	    let lastRendered;
	    let rootAssembly = assembly.getRoot();
	    this.setTargetPartName = (id) =>
	      targetPartName = id;
	    this.getLastRendered = () => lastRendered;
	
	    this.assembly = (a) => {
	      if (a !== undefined) {
	        assembly = a;
	        rootAssembly = a.getRoot();
	      }
	      return assembly;
	    }
	
	    this.partMap = () => partMap;
	    this.isTarget = (type, value) => {
	      return inclusiveTarget.type === type && inclusiveTarget.value === value;
	    }
	    this.inclusiveTarget = function(type, value) {
	      let prefixReg;
	      if (type === 'prefix') prefixReg = new RegExp(`^${value}`)
	      inclusiveTarget = {type, value, prefixReg};
	    }
	
	    function inclusiveMatch(part) {
	      if (!inclusiveTarget.type || !inclusiveTarget.value) return null;
	      switch (inclusiveTarget.type) {
	        case 'prefix':
	          return part.partName().match(inclusiveTarget.prefixReg) !== null;
	          break;
	        case 'part-name':
	          return part.partName() === inclusiveTarget.value;
	        case 'part-id':
	          return part.id() === inclusiveTarget.value;
	        default:
	          throw new Error('unknown inclusiveTarget type');
	      }
	    }
	
	    function manageHidden(object) {
	      return function (attr, value) {
	        if (value === undefined) return object[attr] === true;
	       object[attr] = value === true;
	       instance.render();
	      }
	    }
	
	    // Quick and dirty
	    function centerModel(model) {
	      const offset = model.distCenter();
	      offset.z += 100;
	      offset.y -= 50;
	      offset.x -= 50;
	      model.translate(offset);
	    }
	
	    function buildHiddenPrefixReg() {
	      const list = [];
	      const keys = Object.keys(hiddenPrefixes);
	      for (let index = 0; index < keys.length; index += 1) {
	        const key = keys[index];
	        if (hiddenPrefixes[key] === true) {
	          list.push(key);
	        }
	      }
	      hiddenPrefixReg = list.length > 0 ? new RegExp(`^${list.join('|')}`) : null;
	    }
	
	    this.hidePartId = manageHidden(hiddenPartIds);
	    this.hidePartName = manageHidden(hiddenPartNames);
	    this.hidePrefix = manageHidden(hiddenPrefixes);
	
	    function hasHidden(hiddenObj) {
	      const keys = Object.keys(hiddenObj);
	      for(let i = 0; i < hiddenObj.length; i += 1)
	        if (hidden[keys[index]])return true;
	      return false;
	    }
	    this.noneHidden = () => !hasHidden(hiddenPartIds) &&
	        !hasHidden(hiddenPartNames) && !hasHidden(hiddenPrefixes);
	
	    this.depth = (label) => label.split('.').length - 1;
	
	    function hidden(part, level) {
	      if (!part.included()) return true;
	      const im = inclusiveMatch(part);
	      if (im !== null) return !im;
	      if (instance.hidePartId(part.id())) return true;
	      if (instance.hidePartName(part.partName())) return true;
	      if (hiddenPrefixReg && part.partName().match(hiddenPrefixReg)) return true;
	      return false;
	    }
	
	    // Remove if colors start behaving correctly, can be use to debug.
	    let xzFootprint;
	    function createXZfootprint(model, cabinet) {
	      const cube = CSG.cube({demensions: [cabinet.width(),1,cabinet.thickness()], center: model.center});
	      xzFootprint = cube.intersect(model);
	      // xzFootprint = Polygon2d.lines(...twoDmap.xz);
	    }
	
	    this.xzFootprint = () => xzFootprint;
	
	    function coloring(part) {
	      if (part.partName() && part.partName().match(/.*Frame.*/)) return getColor('blue');
	      else if (part.partName() && part.partName().match(/.*Drawer.Box.*/)) return getColor('green');
	      else if (part.partName() && part.partName().match(/.*Handle.*/)) return getColor('silver');
	      return getColor('red');
	    }
	
	    const randInt = (start, range) => start + Math.floor(Math.random() * range);
	    function debugColoring() {
	      return [randInt(0, 255),randInt(0, 255),randInt(0, 255)];
	    }
	
	    this.addVertex = (center, radius, color) => {
	      radius ||= .5;
	      const vertex = CSG.sphere({center, radius});
	      vertex.setColor(getColor(color));
	      extraObjects.push(vertex);
	    }
	
	    this.removeAllExtraObjects = () => extraObjects = [];
	
	
	    function toTwoDpolys(model) {
	      if (model === undefined) return undefined;
	      if (model.threeView) return model;
	      const polys = Polygon3D.fromCSG(model.polygons);
	      polys.normals = model.normals;
	      Polygon3D.merge(polys);
	      const threeView = Polygon3D.toThreeView(polys, polys.normals);
	      model.threeView = threeView;
	      return model;
	    }
	
	    let lm;
	    this.lastModel = () => toTwoDpolys(lm);
	
	    let cabinetModel;
	    this.render = function () {
	      ThreeDModel.lastActive = this;
	      const cacheId = rootAssembly.id();
	      FunctionCache.on('sme');
	      FunctionCache.on(cacheId);
	
	      const startTime = new Date().getTime();
	      buildHiddenPrefixReg();
	      function buildObject(assem) {
	        let a = assem.toModel();
	        if (a === undefined) {
	          console.log('coooooommmmmmmmooooonnn')
	          assem.toModel();
	        }
	        let normals = a.normals;
	        // const c = assem.position().center();
	        const e=1;
	        // a.center({x: c.x * e, y: c.y * e, z: -c.z * e});
	        a.setColor(...getColor());
	        assem.getJoints().female.forEach((joint) => {
	          if (joint.apply()) {
	            const male = joint.getMale();
	            const m = male.toModel();
	            a = a.subtract(m);
	          }
	        });
	        // else a.setColor(1, 0, 0);
	        a.normals = normals;
	        return a;
	      }
	      const assemblies = this.assembly().getParts();
	      const root = assemblies[0].getRoot();
	      cabinetModel = new CabinetModel(root);
	      let a;
	      partMap = {};
	      for (let index = 0; index < assemblies.length; index += 1) {
	        const assem = assemblies[index];
	        if ((typeof assem.partName) !== 'function') {
	          console.log('here')
	        }
	        partMap[assem.id()] = {path: assem.path(), code: assem.partCode(), name: assem.partName()};
	        const b = buildObject(assem);
	        cabinetModel.add(assem, b);
	        if (!hidden(assem)) {
	          // const c = assem.position().center();
	          // b.center({x: approximate(c.x * e), y: approximate(c.y * e), z: approximate(-c.z * e)});
	          if (a === undefined) a = b;
	          else if (b && b.polygons.length !== 0) {
	            a = a.union(b);
	          }
	          if (assem.partName() === targetPartName) {
	            lm = b.clone();
	            // lm.normals = assem.toBiPolygon().normals();
	            // lm.reverseRotate(assem.position().rotation());
	            const lastModel = this.lastModel();
	            lastModelUpdateEvent.trigger(undefined, lastModel);
	          }
	        }
	      }
	      cabinetModel.complexModel(a);
	      if (a && ThreeDModel.getViewer(a)) {
	        let displayModel = cabinetModel.complexModel();//a.simple ? a.simple : a;
	        console.log(`Precalculations - ${(startTime - new Date().getTime()) / 1000}`);
	        // centerModel(displayModel);
	        extraObjects.forEach(obj => displayModel.polygons.concatInPlace(obj.polygons));
	        // displayModel = displayModel.union(CSG.axis());
	        viewer.mesh = displayModel.toMesh();
	        viewer.gl.ondraw();
	        lastRendered = cabinetModel;
	        renderObjectUpdateEvent.trigger(undefined, lastRendered);
	        console.log(`Rendering - ${(startTime - new Date().getTime()) / 1000}`);
	      }
	      FunctionCache.off(cacheId);
	      FunctionCache.off('sme');
	    }
	
	    this.update = () => {
	      const rId = renderId = String.random();
	      ThreeDModel.renderId = renderId;
	      setTimeout(() => {
	        if(renderId === rId) instance.render();
	      }, 250);
	    };
	  }
	}
	
	function centerOnObj(x,y,z) {
	  const model = ThreeDModel.lastActive.getLastRendered().complexModel();
	  const center = model.center.copy();
	  center.x += 200 * y;
	  center.y += -200 * x;
	  center.z += 100;
	  const rotation = {x: x*90, y: y*90, z: z*90};
	
	  return [center, rotation];
	}
	
	let viewer;
	let viewerSelector = '#three-d-model';
	let viewerSize = '60vh';
	ThreeDModel.setViewerSelector = (selector, size) => {
	  viewerSelector = selector;
	  viewerSize = size || viewerSize;
	  viewer = undefined;
	}
	
	ThreeDModel.getViewer = (model) => {
	  if (viewer) return viewer;
	  const canvas = du.find(viewerSelector);
	  if (canvas) {
	    const size = du.convertCssUnit(viewerSize);
	    if (model === undefined) return undefined;
	    viewer = new Viewer(model, size, size, 50);
	    addViewer(viewer, viewerSelector);
	    const orientArrows = new OrientationArrows(`${viewerSelector} .orientation-controls`);
	    orientArrows.on.center(() =>
	      viewer.viewFrom(...centerOnObj(0,0, 0)));
	    orientArrows.on.up(() =>
	      viewer.viewFrom(...centerOnObj(1, 0,0)));
	    orientArrows.on.down(() =>
	      viewer.viewFrom(...centerOnObj(-1,0,0)));
	    orientArrows.on.left(() =>
	      viewer.viewFrom(...centerOnObj(0,-1,0)));
	    orientArrows.on.right(() =>
	      viewer.viewFrom(...centerOnObj(0,1,0)));
	  }
	  return viewer;
	}
	
	ThreeDModel.models = {};
	ThreeDModel.get = (assembly) => {
	  if (assembly === undefined) return ThreeDModel.lastActive;
	  if (ThreeDModel.models[assembly.id()] === undefined) {
	    ThreeDModel.models[assembly.id()] = new ThreeDModel(assembly);
	  }
	  return ThreeDModel.models[assembly.id()];
	}
	ThreeDModel.render = (part) => {
	  const renderId = String.random();
	  ThreeDModel.renderId = renderId;
	  setTimeout(() => {
	    if(ThreeDModel.renderId === renderId) {
	      const cacheId = part.getRoot().id();
	      FunctionCache.on(cacheId);
	      ThreeDModel.get(part).render();
	      FunctionCache.off(cacheId);
	    }
	  }, 2500);
	};
	
	const lastModelUpdateEvent = new CustomEvent('lastModelUpdate');
	ThreeDModel.onLastModelUpdate = (func) => lastModelUpdateEvent.on(func);
	
	const renderObjectUpdateEvent = new CustomEvent('renderObjectUpdate');
	ThreeDModel.onRenderObjectUpdate = (func) => renderObjectUpdateEvent.on(func);
	
	
	module.exports = ThreeDModel
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/cabinet-model.js',
function (require, exports, module) {
	
const Vertex3D = require('./objects/vertex');
	const Line3D = require('./objects/line');
	const Vector3D = require('./objects/vector');
	const Polygon3D = require('./objects/polygon');
	const BiPolygon = require('./objects/bi-polygon');
	const Plane = require('./objects/plane');
	const Polygon2d = require('../../../../public/js/utils/canvas/two-d/objects/polygon');
	const Vertex2d = require('../../../../public/js/utils/canvas/two-d/objects/vertex');
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line');
	const SnapPolygon = require('../../../../public/js/utils/canvas/two-d/objects/snap/polygon');
	const StarLineMap = require('../../../../public/js/utils/canvas/two-d/maps/star-line-map');
	const EscapeMap = require('../../../../public/js/utils/canvas/two-d/maps/escape');
	
	
	class CabinetModel {
	  constructor(cabinet) {
	    const assemblies = [];
	    let cabinetCSG;
	    const instance = this;
	    let center, threeView, silhouette, complexModel;
	    cabinet.snap2d = {};
	    cabinet.view = {};
	
	    this.cabinet = () => cabinet;
	    this.rotation = () => (cabinet && cabinet.position().rotation()) || {x:0, y:0, z:0};
	    this.add = (assembly, csg) => {
	      if (assembly && assembly.inElivation) {
	        assemblies.push(assembly);
	      }
	      if (cabinet.children().indexOf(assembly) !== -1) {
	        // TODO: Hacky fix errors created by toModel not including joint information
	        if (cabinetCSG === undefined) cabinetCSG = csg;//assembly.toModel(true);
	        else cabinetCSG = cabinetCSG.union(csg);//assembly.toModel(true));
	      }
	    }
	
	    this.normals = () => {
	      const normals = [];
	      for (let index = 0; index < cabinet.openings.length; index++) {
	        const sectionProps = cabinet.openings[index].sectionProperties();
	        normals.push(sectionProps.outerPoly().normal());
	      }
	      return normals;
	    }
	
	    this.normal = () => new Vector3D(Math.mean(this.normals(), ['i', 'j', 'k']));
	
	    this.center = () => {
	      if (!center) {
	        if (cabinetCSG === undefined) return new Vertex3D(0,0,0);
	        const polys = cabinetCSG.polygons;
	        for (let index = 0; index < polys.length; index++) {
	          const poly = polys[index];
	          const verts = poly.vertices;
	          const targetAttrs = {'pos.x': 'x', 'pos.y': 'y', 'pos.z': 'z'};
	          const midrangePoint = Math.midrange(poly.vertices, targetAttrs);
	          poly.center = new Vertex3D(midrangePoint);
	          poly.plane = new Plane(...verts.slice(0,3).map(v =>v.pos));
	        }
	        const targetAttrs = {'center.x': 'x', 'center.y': 'y', 'center.z': 'z'};
	        center = new Vertex3D(Math.midrange(polys, targetAttrs));
	      }
	      return center;
	    }
	
	    this.threeView = () => {
	      if (!threeView) {
	        const polys = Polygon3D.fromCSG(cabinetCSG.polygons);
	        threeView = Polygon3D.toThreeView(polys);
	      }
	      return threeView;
	    }
	
	    function silhouetteFrom2d(parimeter, length, rotation) {
	      rotation ||= {x: 0, y: 0, z:0};
	      const cabRotation = instance.rotation();
	      rotation.x += cabRotation.x;
	      rotation.y += cabRotation.y;
	      rotation.z += cabRotation.z;
	      const poly = Polygon3D.from2D(parimeter);
	      poly.rotate(rotation);
	      const silhouette = BiPolygon.fromPolygon(poly, 0, length);
	      if (silhouette) {
	        silhouette.center(instance.center());
	      }
	      return silhouette;
	    }
	
	    this.cabinetSilhouette = () => {
	      if (!silhouette) {
	        const threeView = this.threeView();
	
	        const frontMinMax = Vertex2d.minMax(Line2d.vertices(threeView.front()));
	        const height = frontMinMax.diff.y();
	        const width = frontMinMax.diff.x();
	        const depth = Vertex2d.minMax(Line2d.vertices(threeView.right())).diff.x();
	
	        silhouette = {};
	        silhouette.front = silhouetteFrom2d(threeView.parimeter().front(), depth);
	        silhouette.right = silhouetteFrom2d(threeView.parimeter().right(), width, {x: 0, y: 90, z: 0});
	        silhouette.top = silhouetteFrom2d(threeView.parimeter().top(), height, {x:90,y:0,z:0});
	      }
	      return silhouette;
	    }
	
	    this.toModel = (simpler, centerOn) => {
	      const offset = new Vertex3D(new Vertex3D(centerOn).minus(this.center()));
	      let model = this.cabinetSilhouette().top.toModel();
	      model.translate(offset);
	      for (let index = 0; !simpler && index < assemblies.length; index++) {
	        const csg = assemblies[index].toModel(true);
	        csg.translate(offset);
	        model = model.union(csg);
	      }
	      return model;
	    }
	
	    this.viewFromVector = (vector, in2D, axis) => {
	      let output = cabinet.toBiPolygon();
	      output.center(this.center());
	      if (in2D) {
	        output = Polygon3D.toTwoD(output.toPolygons(), vector, axis);
	        axis ||= output.axis;
	        // output = Polygon2d.toParimeter(output).lines();
	      } else {
	        output = output.toModel();
	      }
	      for (let i = 0; i < assemblies.length; i++) {
	        if (in2D) {
	          // TODO: overwiting this.toModel causes the commented line to fail.... should be rectified.
	          // const twoDlines = Polygon3D.toTwoD(assemblies[i].toBiPolygon().toPolygons(), vector, axis);
	          const polygons = Polygon3D.fromCSG(assemblies[i].toModel(true).polygons);
	          const twoDlines = Polygon3D.toTwoD(polygons, vector, axis);
	          output.concatInPlace(twoDlines);
	        } else
	          output.union(assemblies[i].toModel());
	      }
	      return output;
	    }
	
	    function build() {
	      const c = cabinet;
	      const threeView = instance.threeView();
	      let topview = threeView.parimeter().top();
	      const layout = c.group().room().layout();
	      const normals = instance.normals();
	      const dist = c.width() > c.thickness() ? c.width() : c.thickness();
	      const lines = topview.lines();
	      const topCenter = Vertex2d.center(Line2d.vertices(lines));
	      const cabRotation = instance.rotation();
	      const normalLines = normals.map((n) => {
	        const searchLine = Line3D.startAndVector(instance.center().copy(), n.scale(dist));
	        const veiwFromVect = Line3D.viewFromVector([searchLine], threeView.normals.top())[0];
	        const searchLine2d = veiwFromVect.to2D(threeView.axis().top[0], threeView.axis().top[1]);
	        searchLine2d.translate(new Line2d(searchLine2d.startVertex().copy(), topCenter.copy()));
	        // TODO: I should fix the root cause that requires the x coord to be mirrored;
	        searchLine2d.mirrorX();
	        // searchLine2d.mirrorY();
	        return searchLine2d;
	      });
	      const faceIndecies = normalLines.map((normalLine) => {
	        for (let index = 0; index < lines.length; index++) {
	          if (lines[index].findSegmentIntersection(normalLine, true))
	            return index;
	        }
	      });
	      topview.faceIndecies(faceIndecies);
	      return topview;
	    }
	
	    this.topviewSnap = () => {
	      const c = cabinet;
	      const shouldBuild = !c.snapObject || c.width() !== c.snapObject.width ||
	        c.thickness() !== c.snapObject.thickness;
	      if (shouldBuild)  {
	        const topview = build();
	        topview.mirrorY();
	        c.view.top =  topview;
	        if (!c.snap3d  || c.snap3d.snap2d.top === undefined) {
	          const layout = c.group().room().layout();
	          const layoutObject = layout.addObject(c.id(), c, c.partName(), topview);
	          c.snap3d = layoutObject;
	        } else {
	          const polygon = c.snap3d.snap2d.top().polygon();
	          topview.centerOn(polygon.center());
	          topview.radians(polygon.radians())
	          const lines = polygon.lines();
	          for (let index = 0; index < lines.length; index++) {
	            const startVertex = lines[index].startVertex();
	            startVertex.point(topview.vertex(index).point());
	          }
	        }
	      }
	      return c.snap3d.snap2d.top();
	    }
	
	    function addComplexModelAttrs(model) {
	      const max = new Vertex3D(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);
	      const min = new Vertex3D(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);
	      const polys = model.polygons;
	      for (let index = 0; index < polys.length; index++) {
	        const poly = polys[index];
	        const verts = poly.vertices;
	        const targetAttrs = {'pos.x': 'x', 'pos.y': 'y', 'pos.z': 'z'};
	        const midrangePoint = Math.midrange(poly.vertices, targetAttrs);
	        poly.center = new Vertex3D(midrangePoint);
	        poly.plane = new Plane(...verts.slice(0,3).map(v =>v.pos));
	      }
	      const targetAttrs = {'center.x': 'x', 'center.y': 'y', 'center.z': 'z'};
	      model.center = new Vertex3D(Math.midrange(polys, targetAttrs));
	      model.max = max;
	      model.min = min;
	    }
	
	    this.complexModel = (model) => {
	      if (model !== undefined) {
	        try {
	          addComplexModelAttrs(model);
	          complexModel = model;
	          this.topviewSnap();
	        } catch (e) {
	          console.warn(e);
	        }
	      }
	      return complexModel;
	    }
	
	    this.topVector = () => Line3D.fromVector(this.normal(), undefined, {x:90,y:0,z:0}).vector();
	    this.rightVector = () => Line3D.fromVector(this.normal(), undefined, {x:0,y:90,z:0}).vector();
	
	    this.frontView = () => this.viewFromVector(this.normal(), true);
	    this.topView = () => this.viewFromVector(this.topVector(), true);
	    this.rightView = () => this.viewFromVector(this.rightVector(), true);
	  }
	}
	
	module.exports = CabinetModel;
	
});


RequireJS.addFunction('./services/cabinet/app-src/cost/cost-tree.js',
function (require, exports, module) {
	
const Properties = require('../config/properties.js');
	const Assembly = require('../objects/assembly/assembly.js');
	const LogicTree = require('../../../../public/js/utils/logic-tree.js');
	const LogicWrapper = LogicTree.LogicWrapper;
	
	class CostDecision {
	  constructor(type, name, relation, formula) {
	    Object.getSet(this, {type, name, costs: [], relation, isChoice: false});
	    this.requiredProperties = Properties.noValue(name);
	    if (this.relation) {
	      if (formula) {
	        function makeDecision(wrapper) {
	          return true;
	        }
	        this.relation = RelationInput.relationsObjs[relation](makeDecision);
	        this.condition = (wrapper) => this.relation.eval(wrapper.children(), wrapper.payload.value());
	      } else {
	        this.isChoice(true);
	      }
	    }
	  }
	}
	
	class CostTree {
	  constructor(logicTree) {
	    const idMap = {};
	    logicTree = CostTree.suplement(logicTree);
	    this.tree = () => logicTree;
	    this.root = () => logicTree.root();
	    const getWrapper = (wrapperId) => (LogicWrapper.get(wrapperId) || this.root());
	
	    this.branch = (wrapperId, name) =>
	            get(wrapperId).branch(String.random(), new CostDecision('Branch', name));
	    this.leaf = (wrapperId, name) =>
	            get(wrapperId).leaf(String.random(), new CostDecision('Leaf', name));
	    this.select = (wrapperId, name, relation, formula) =>
	            get(wrapperId).select(String.random(), new CostDecision('Select', name, relation, formula));
	    this.multiselect = (wrapperId, name, relation, formula) =>
	            get(wrapperId).multiselect(String.random(), new CostDecision('Multiselect', name, relation, formula));
	    this.conditional = (wrapperId, name, relation, formula) =>
	            get(wrapperId).conditional(String.random(), new CostDecision('Conditional', name, relation, formula));
	
	  }
	}
	
	
	CostTree.propertyList = Properties.all();
	CostTree.types = ['branch', 'select', 'conditional', 'multiselect', 'leaf'];
	CostTree.suplement = (logicTree) => {
	  if (!(logicTree instanceof LogicWrapper)) {
	    logicTree = new LogicTree();
	    logicTree.branch('root');
	  }
	  const root = logicTree.root();
	  const assemClassIds = Properties.list();
	  assemClassIds.forEach((classId) => {
	    if (root.node.getNodeByPath(classId) === undefined)
	      root.branch(classId, new CostDecision('Branch', classId));
	  });
	  return logicTree;
	}
	CostTree.choices = [];
	
	
	CostTree.CostDecision = CostDecision;
	module.exports = CostTree;
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/company.js',
function (require, exports, module) {
	

	
	const Door = require('./assembly/assemblies/door/door.js');
	
	class Company {
	  constructor(properties) {
	    if (!properties.name) throw new Error('Company name must be defined')
	    if (Company.list[properties.name] !== undefined) throw new Error('Company name must be unique: name already registered');
	    this.name = () => properties.name;
	    this.email = () => properties.email;
	    this.address = () => properties.address;
	    Company.list[this.name()] = this;
	  }
	}
	
	Company.list = {};
	new Company({name: 'Central Door'});
	new Company({name: 'Central Wood'});
	new Company({name: 'ADC'});
	new Company({name: 'Accessa'});
	new Company({name: 'Top Knobs'});
	new Company({name: 'Richelieu'});
	module.exports = Company
	
	
	
	
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/group.js',
function (require, exports, module) {
	
const PropertyConfig = require('../config/property/config');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	
	let groupIndex = -2;
	class Group extends Lookup {
	  constructor(room, name, id) {
	    super(id);
	    room ||= Group.defaultRoom;
	    const initialVals = {
	      name: name || new String(groupIndex++),
	    }
	    Object.getSet(this, initialVals);
	    this.propertyConfig = new PropertyConfig();
	    this.objects = [];
	    this.room = () => room;
	
	    this.resolve = (one, two, three) => {
	      if (one) {
	        if (one === 'baseh' || one === 'ceilh') {
	          console.log('gotcha bitch');
	        }
	        const layout = room.layout();
	        if (layout && (typeof two) === 'string') {
	          const lower = two.toLowerCase();
	          if(lower === 'ceilh' || 'ceillingheight' === lower) return layout.ceilingHeight(three);
	          if(lower === 'baseh' || 'baseheight' === lower) return layout.baseHeight(three);
	          if(lower === 'wallh' || 'wallheight' === lower) return layout.wallHeight(three);
	          if(lower === 'based' || 'basedepth' === lower) return layout.baseDepth(three);
	          if(lower === 'walld' || 'walldepth' === lower) return layout.wallDepth(three);
	          if(lower === 'walle' || 'wallelevation' === lower) return layout.wallElevation(three);
	          if(lower === 'counterh' || 'counterheight' === lower) return layout.counterHeight(three);
	        }
	        return this.propertyConfig(one, two, three);
	      }
	
	    }
	
	
	
	
	
	    this.toJson = () => {
	      const json = {objects: [], _TYPE: 'Group'};
	      this.objects.forEach((obj) => json.objects.push(obj.toJson()));
	      json.name = this.name();
	      json.id = this.id();
	      json.roomId = this.room().id();
	      json.propertyConfig = this.propertyConfig.toJson();
	      return json;
	    }
	  }
	}
	
	Group.count = 0;
	new Group();
	
	Group.fromJson = (json) => {
	  const group = new Group(json.room, json.name, json.id);
	  group.propertyConfig = PropertyConfig.fromJson(json.propertyConfig);
	  json.objects.forEach((objJson) => {
	    const jsonClazz = Object.class.get(json.objects[0]._TYPE);
	    const obj = jsonClazz.fromJson(objJson, group);
	    group.objects.push(obj);
	    obj.group(group);
	  });
	  return group;
	}
	
	module.exports = Group;
	
});


RequireJS.addFunction('./services/cabinet/app-src/services/order-save-manager.js',
function (require, exports, module) {
	
const du = require('../../../../public/js/utils/dom-utils.js');
	const CustomEvent = require('../../../../public/js/utils/custom-event');
	
	class OrderSaveManager {
	  constructor(contentFunc, initialOrderName, initialVersionId) {
	    if ((typeof contentFunc) !== 'function') throw new Error('Must give a content function or else whats the point?');
	    let cabinetConfig, propertyConfig, costConfig;
	    let workingDir, ordersDir;
	    let orderDirectories = {};
	    let activeOrderDir, activeVersion;
	    let orderVersionObj = {};
	    let counter = 0;
	    let autoSaveOn = null;
	    const instance = this;
	
	    const loadingEvent = new CustomEvent('loading');
	    const loadedEvent = new CustomEvent('loaded');
	    const savingEvent = new CustomEvent('saving');
	    const savedEvent = new CustomEvent('saved');
	    const fileSystemChangeEvent = new CustomEvent('fileSystemChange');
	    const versionChangeEvent = new CustomEvent('versionChange');
	    this.onLoading = loadingEvent.on;
	    this.onLoaded = loadedEvent.on;
	    this.onSaving = savingEvent.on;
	    this.onSaved = savedEvent.on;
	    this.onFileSystemChange = fileSystemChangeEvent.on;
	    this.onVersionChange = versionChangeEvent.on;
	
	    const jsonRegEx = /^(.{1,})\.json$/;
	    const clean = (jsonName) => jsonName.replace(jsonRegEx, '$1');
	    const format = (jsonName) => jsonName.replace(jsonRegEx, '$1') + '.json';
	    const activeOrderName = () => activeOrderDir && activeOrderDir.name;
	    const activeVersionId = () => activeVersion && clean(activeVersion.name);
	    const alreadyActive = (orderName, versionId) => orderName === activeOrderName() &&
	                          activeVersion && format(versionId) === activeVersion.name;
	
	    this.on = (bool) => {
	      const on = bool !== undefined ?  bool : autoSaveOn;
	      if (on !== autoSaveOn) {
	        autoSaveOn = on;
	        if (autoSaveOn) autoSave();
	      }
	      return autoSaveOn;
	    }
	    this.undefinedVersion = (orderName, versionId) => {
	      const versions = orderVersionObj[orderName];
	      if (versions.indexOf(clean(versionId)) === -1) return versionId;
	      let count = 1;
	      while (versions.indexOf(clean(`${versionId}-${count}`)) !== -1) count++;
	      return `${versionId}-${count}`;
	    }
	    this.remove = (orderName) => {
	      ordersDir.removeEntry(orderName);
	      delete orderVersionObj[orderName];
	    }
	    this.toggle = () => this.on(!autoSaveOn);
	    this.open = async (orderName, versionId) => {
	      if (!versionId && orderVersionObj[orderName].length === 1)
	        versionId = orderVersionObj[orderName][0]
	      orderName = orderName.replace(/\//g, '-');
	      versionId = versionId.replace(/\//g, '-');
	      if (orderVersionObj[orderName] === undefined) orderVersionObj[orderName] = [];
	      if (orderVersionObj[orderName].indexOf(versionId) === -1) orderVersionObj[orderName].push(versionId);
	      const orderDirectoryHandle =
	        await ordersDir.getDirectoryHandle(orderName, {create: true});
	      const versionFileHandle =
	        await orderDirectoryHandle.getFileHandle(format(versionId), {create: true});
	
	      return {orderDirectoryHandle, versionFileHandle};
	    }
	    this.state = (orderName, versionId) => {
	      if (!orderName) return 'invalid';
	      if (orderVersionObj[orderName] === undefined) return 'new order';
	      const isActiveOrder = orderName === this.activeOrderName();
	      const onlyOneVersion = orderVersionObj[orderName].length === 1;
	      if (isActiveOrder) {
	        const isActiveVersion = onlyOneVersion || versionId === this.activeVersionId();
	        if (isActiveVersion) return 'active'
	        else if (!versionId) return 'invalid';
	        else if (orderVersionObj[orderName].indexOf(versionId) !== -1) return 'switch version';
	        else return 'new version';
	      }
	      if (onlyOneVersion) return 'switch order'
	      if (!versionId) return 'invalid';
	      if (orderVersionObj[orderName].indexOf(versionId) === -1) return 'new version';
	      return  'switch order';
	    }
	
	    this.activeOrderName = activeOrderName;
	    this.activeVersionId = activeVersionId;
	    this.orderNames = () => Object.keys(orderVersionObj);
	    this.versionIds = (orderName) => orderVersionObj[orderName];
	    this.save = async function (orderName, versionId, data) {
	      data ||= contentFunc();
	      let version = activeVersion;
	      const argsDefined = orderName && versionId && data;
	      if (argsDefined) version = (await this.open(orderName, versionId)).versionFileHandle;
	      if (version) {
	        counter++;
	        savingEvent.trigger(null, this);
	        const writable = await version.createWritable();
	        if ((data instanceof Object)) data = JSON.stringify(data, null, 2);
	        await writable.write({type: 'write', data});
	        await writable.close();
	        savedEvent.trigger(null, this);
	      }
	    }
	
	    const decoder = new TextDecoder();
	    async function read(versionHandle) {
	      const file = await (versionHandle || activeVersion).getFile();
	      const stream = file.stream()
	      const reader = stream.getReader();
	      const fileSize = file.size;
	      const buffer = new DataView(new ArrayBuffer(fileSize));
	      const gibberish = await reader.read(buffer);
	      const text = decoder.decode(gibberish.value);
	      return text;
	    }
	
	    this.read = read;
	
	    this.switch = async function (orderName, versionId) {
	      const opened = await this.open(orderName, versionId);
	      activeOrderDir = opened.orderDirectoryHandle;
	      orderName = activeOrderDir.name;
	      activeVersion = opened.versionFileHandle;
	      versionId = clean(activeVersion.name);
	      const contents = await read();
	      versionChangeEvent.trigger(null, {orderName, versionId, contents});
	      return contents;
	    }
	
	    let saveCount = 0;
	    function autoSave() {
	      if (autoSaveOn) {
	        setTimeout(autoSave, 10000);
	        instance.save();
	      }
	    }
	
	    async function versionList(orderHandler, nameOnly) {
	      const orderName = orderHandler.name;
	      const versions = await orderHandler.values();
	      const list = [];
	      let next;
	      do {
	        next = await versions.next();
	        if (!orderVersionObj[orderName]) orderVersionObj[orderName] = [];
	        if (next.value) {
	          const value = nameOnly ? clean(next.value.name) : next.value;
	          list.push(value);
	        }
	      } while (!next.done)
	      return list;
	    }
	
	    async function changeOrderName(newOrderName) {
	      const versionHandlers = await versionList(activeOrderDir);
	      for (let index = 0; index < versionHandlers.length; index++) {
	        const vHandle = versionHandlers[index];
	        const contents = await read(vHandle);
	        const vId = vHandle.name;
	        await this.save(newOrderName, vId, contents);
	        await activeOrderDir.removeEntry(format(vId));
	      }
	      this.remove(activeOrderName());
	      this.switch(newOrderName, activeVersionId());
	    }
	    this.changeOrderName = changeOrderName;
	
	    let initialized = false;
	    this.initialized = () => initialized;
	    async function init() {
	      workingDir = await window.showDirectoryPicker();
	      let perms = await workingDir.queryPermission();
	      ordersDir = await workingDir.getDirectoryHandle('orders', {create: true});
	      ordersDir = await workingDir.getDirectoryHandle('orders', {create: true});
	      loadingEvent.trigger(null, instance);
	      cabinetConfig = await workingDir.getFileHandle('cabinet.json', { create: true });
	      propertyConfig = await workingDir.getFileHandle('property.json', { create: true });
	      costConfig = await workingDir.getFileHandle('cost.json', { create: true });
	      const values = await ordersDir.values();
	      let next;
	      do {
	        next = await values.next();
	        if (next.value && next.value.kind === 'directory') {
	          const orderHandler = next.value;
	          orderVersionObj[orderHandler.name] = await versionList(orderHandler, true);
	        }
	      } while(!next.done);
	      await instance.switch(initialOrderName, initialVersionId);
	      const text = await read();
	      loadedEvent.trigger(null, instance);
	      fileSystemChangeEvent.trigger(null, instance);
	      autoSaveOn = true;
	      initialized = true;
	      autoSave();
	    }
	    this.init = init;
	  }
	}
	
	module.exports = OrderSaveManager;
	
});


RequireJS.addFunction('./services/cabinet/app-src/services/history.js',
function (require, exports, module) {
	
class History {
	  constructor() {
	    let changes = [];
	    let changesIndex = [];
	
	      this.addChange = (forward, back) => {
	        changes = changes.slice(0, changesIndex);
	        changes.push({forward, back});
	        changesIndex++;
	      }
	
	    this.getSet = (obj, initialVals, ...attrs) => {
	      attrs = Object.getSet(obj, initialVals, ...attrs);
	      const objFuncs = {};
	      attrs.forEach((attr) => {
	        objFuncs[attr] = obj[attr];
	        obj[attr] = (value) => {
	          if (value !== undefined) {
	            const oldValue = objFuncs[attr]();
	            const back = () => objFuncs[attr](oldValue);
	            const forward = () => objFuncs[attr](value);
	            this.addChange(obj, forward, back);
	          }
	          return objFuncs[attr](value);
	        }
	      });
	    }
	
	    this.undo = () => {
	      const change = changes[--changesIndex];
	      change.back();
	    }
	
	    this.redo = () => {
	      const change = changes[++changesIndex];
	      change.forward();
	    }
	
	    this.canUndo =() => changesIndex > 0;
	    this.canRedo = () => changeIndex < changes.length - 1;
	  }
	}
	
	module.exports = History;
	
});


RequireJS.addFunction('./services/cabinet/app-src/services/divide-properties.js',
function (require, exports, module) {
	

	class DivideProperties {
	  constructor(length, center, rotation) {
	    Object.getSet(this, {length, center, rotation})
	  }
	}
	
});


RequireJS.addFunction('./services/cabinet/app-src/services/display-svc.js',
function (require, exports, module) {
	class Register {
	  constructor() {
	    const registered = {};
	    this.register = function (nameOobj, obj) {
	      if ((typeof nameOobj) !== 'object') {
	        registered[nameOobj] = obj;
	      } else {
	        const keys = Object.keys(nameOobj);
	        for (let index = 0; index < keys.length; index += 1) {
	          const key = keys[index];
	          registered[key] = nameOobj[key];
	        }
	      }
	    }
	    this.get = (name) => registered[name];
	  }
	}
	
	module.exports = new Register();
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/order.js',
function (require, exports, module) {
	

	
	const Room = require('./room.js');
	
	class Order {
	  constructor(name, versionId, id) {
	    if (id === null) this.loaded = false;
	    else this.loaded = true;
	    versionId ||= 'original';
	    const initialVals = {
	      name: name || ++Order.count,
	      id: id || String.random(32),
	    }
	    Object.getSet(this, initialVals, 'rooms');
	    Object.getSet(this, {_TEMPORARY: true, name, versionId});
	    this.rooms = {};
	    this.worthSaveing = () => {
	      const keys = Object.keys(this.rooms);
	      const roomCount = keys.length;
	      if (roomCount === 0) return false;
	      if (roomCount > 1) return true;
	      const groups = this.rooms[keys[0]].groups;
	      return groups && groups[0].objects.length > 0;
	    }
	    this.addRoom = (name) => this.rooms[name] = new Room(name);
	  }
	}
	
	Order.count = 0;
	module.exports = Order
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/room.js',
function (require, exports, module) {
	

	
	const Cabinet = require('./assembly/assemblies/cabinet.js');
	const Group = require('./group.js');
	const Lookup = require('../../../../public/js/utils/object/lookup');
	const Layout2D = require('../two-d/layout/layout.js');
	
	
	class Room extends Lookup {
	  constructor(name, id, layout) {
	    super(id || String.random());
	    const instance = this;
	
	    function groupMap(map, detailLists, listId) {
	      for(let index = 0; index < detailLists[listId].length; index += 1) {
	        const cabinet = detailLists[listId][index];
	        const groupId = cabinet.group().id();
	        if (map[groupId] === undefined) map[groupId] = {added: [], removed: []};
	        map[groupId][listId].push(cabinet);
	      }
	    }
	
	    function onLayoutChange(elem, detail) {
	      const cabGroupMap = {};
	      groupMap(cabGroupMap, detail.objects, 'removed');
	      groupMap(cabGroupMap, detail.objects, 'added');
	
	      instance.groups.forEach((g) => {
	        if (cabGroupMap[g.id()]) {
	          g.objects.removeAll(cabGroupMap[g.id()].removed);
	          g.objects.concatInPlace(cabGroupMap[g.id()].added);
	        }
	      });
	      console.log('onlaychan', detail);
	    }
	    const initialVals = {
	      name: name || `Room ${Room.count++}`,
	      layout: layout || new Layout2D()
	    }
	    initialVals.layout.onStateChange(onLayoutChange);
	    Object.getSet(this, initialVals, 'groups');
	    this.groups = [new Group(this)];
	    this.addGroup = () => this.groups.push(new Group(this));
	  }
	};
	Room.count = 0;
	
	Room.fromJson = (json) => {
	  const room = new Room(json.name, json.id, Object.fromJson(json.layout));
	  room.groups = [];
	  for (let index = 0; index < json.groups.length; index++) {
	    const groupJson = json.groups[index];
	    groupJson.room = room;
	    room.groups.push(Group.fromJson(groupJson));
	  }
	  return room;
	}
	
	Group.defaultRoom = new Room('defaultRoom');
	
	module.exports = Room;
	
});


RequireJS.addFunction('./services/cabinet/app-src/cost/cost.js',
function (require, exports, module) {
	

	
	const Company = require('../objects/company.js');
	const Input = require('../../../../public/js/utils/input/input.js');
	const Lookup = require('../../../../public/js/utils/object/lookup.js');
	const StringMathEvaluator = require('../../../../public/js/utils/string-math-evaluator.js');
	const Assembly = require('../objects/assembly/assembly.js');
	
	
	// constructors
	// Cost({name, Method: Cost.methods.LINEAR_FEET, cost, length})
	// Cost({name, Method: Cost.methods.SQUARE_FEET, cost, length, width})
	// Cost({name, Method: Cost.methods.CUBIC_FEET, cost, length, width, depth})
	// Cost({name, Method: Cost.methods.UNIT, cost})
	// Cost((name, Cost, formula));
	// props. - (optional*)
	// id - Cost identifier
	// method - Method for calculating cost
	// length - length of piece used to calculate unit cost
	// width - width of piece used to calculate unit cost
	// depth - depth of piece used to calculate unit cost
	// cost - cost of piece used to calculate unit cost
	// formula* - formula used to apply cost to part
	// company* - Company to order from.
	// partNumber* - Part number to order part from company
	// Cost* - Reference Cost.
	
	class Cost extends Lookup {
	  //constructor(id, Cost, formula)
	  constructor(props) {
	    super(props.name);
	    props = props || {};
	    this.props = () => props;
	    let deleted = false;
	    const instance = this;
	    const lastUpdated = props.lastUpdated || new Date().getTime();
	    props.requiredBranches = props.requiredBranches || [];
	    this.lastUpdated = new Date(lastUpdated).toLocaleDateString();
	    Object.getSet(this, props, 'group', 'objectId', 'id', 'parent');
	    this.level = () => {
	      let level = -1;
	      let curr = this;
	      while(curr instanceof Cost) {
	        level++;
	        curr = curr.parent();
	      }
	      return level;
	    }
	  }
	}
	
	Cost.types = {};
	
	Cost.freeId = (group, id) => Object.values(Cost.group(group).defined).indexOf(id) === -1;
	Cost.remove = (id) => Cost.get(id).remove();
	
	Cost.constructorId = (name) => name.replace(/Cost$/, '');
	Cost.register = (clazz) => {
	  Cost.types[Cost.constructorId(clazz.prototype.constructor.name)] = clazz;
	  Cost.typeList = Object.keys(Cost.types).sort();
	}
	
	Cost.evaluator = new StringMathEvaluator(null, (attr, assem) => Assembly.resolveAttr(assem, attr))
	
	module.exports = Cost
	
});


RequireJS.addFunction('./services/cabinet/app-src/display-utils/radio-display.js',
function (require, exports, module) {
	

	const CustomEvent = require('../../../../public/js/utils/custom-event.js');
	const InformationBar = require('./information-bar.js');
	const du = require('../../../../public/js/utils/dom-utils.js');
	
	class RadioDisplay {
	  constructor(radioClass, groupAttr, alternateToggleClass) {
	    const afterSwitchEvent = new CustomEvent('afterSwitch');
	    const beforeSwitchEvent = new CustomEvent('beforeSwitch');
	    const selector = (attrVal) => {
	      return groupAttr ? `.${radioClass}[${groupAttr}="${attrVal}"]` : `.${radioClass}`;
	    }
	
	    const infoBar = new InformationBar();
	
	    function path () {
	      let path = '';
	      const info = du.find.downInfo(`.${radioClass}.open`, document.body, null, `.${radioClass}.close`);
	      info.matches.forEach((obj) => {
	        const header = obj.node.children[0];
	        if (header && header.getBoundingClientRect().y < 8) {
	          path += `${header.innerText}=>`
	        }
	      });
	      return path;
	    }
	
	    function triggerAlternateToggles(target) {
	      if (alternateToggleClass) {
	        const alterToggles = document.querySelectorAll(alternateToggleClass);
	        alterToggles.forEach((elem) => elem.hidden = false);
	        const closest = du.closest(alternateToggleClass, target);
	        if (closest) closest.hidden = true;
	      }
	    }
	    this.beforeSwitch = (func) => beforeSwitchEvent.on(func);
	    this.afterSwitch = (func) => afterSwitchEvent.on(func);
	
	
	    du.on.match('scroll', `*`, (target, event) => {
	      infoBar.update(path());
	    });
	
	    let previousHeader;
	    du.on.match('click', `.${radioClass} > .expand-header`, (targetHeader, event) => {
	      const target = targetHeader.parentElement;
	      const attrVal = target.getAttribute(groupAttr);
	      const targetBody = target.children[1];
	      const hidden = targetBody.hidden;
	      targetBody.hidden = !hidden;
	      beforeSwitchEvent.trigger(previousHeader, {previousHeader, targetHeader});
	      if (hidden) {
	        du.class.add(targetHeader, 'active');
	        du.class.swap(target, 'open', 'close');
	        const siblings = document.querySelectorAll(selector(attrVal));
	        for (let index = 0; index < siblings.length; index += 1) {
	          if (siblings[index] !== target) {
	            const sibHeader = siblings[index].children[0];
	            const sibBody = siblings[index].children[1];
	            du.class.swap(siblings[index], 'close', 'open');
	            sibBody.hidden = true;
	            du.class.remove(sibHeader, 'active');
	          }
	        }
	        afterSwitchEvent.trigger(targetHeader, {previousHeader, targetHeader});
	        previousHeader = targetHeader;
	      } else {
	        du.class.swap(target, 'close', 'open');
	        du.class.remove(targetHeader, 'active');
	        afterSwitchEvent.trigger(targetHeader, {previousHeader, targetHeader});
	        previousHeader = null;
	      }
	      infoBar.update(path());
	    });
	  }
	}
	module.exports = RadioDisplay
	
});


RequireJS.addFunction('./services/cabinet/app-src/two-d/layout/corner.js',
function (require, exports, module) {
	
const Vertex2d = require('../../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const Line2d = require('../../../../../public/js/utils/canvas/two-d/objects/line');
	const Wall2D = require('wall');
	
	class Corner2d extends Vertex2d {
	  constructor(layout, point) {
	    if (point instanceof Vertex2d) {
	      point = point.point();
	    }
	    super(point);
	    Lookup.convert(this);
	    let angleLock = false;
	    let angleInc = 22.5;
	    let lengthInc = 2.54;
	    const instance = this;
	
	    this.nextWall = () => layout.nextWall(this, 1);
	    this.prevWall = () => layout.prevWall(this, -1);
	    this.angleLock = (on) => {
	      if (on === true || on === false) angleLock = on;
	      return angleLock;
	    }
	    this.isFree = () => layout.isFreeCorner(this);
	    this.angleInc = (increment) => {
	      if (increment > .01 && increment <= 45) angleInc = on;
	      return angleLock;
	    }
	    this.lengthInc = (increment) => {
	      if (increment > .01 && increment < 10) angleInc = on;
	      return angleLock;
	    }
	    this.angle = (degrees) => {
	      const currDeg = (this.nextWall().degrees() - this.prevWall().degrees() + 360) % 360;
	      if (Number.isFinite(degrees)) {
	        const offset = Math.toRadians((degrees - currDeg)/2);
	
	        const prev = this.prevWall();
	        const newPrev = Line2d.startAndTheta(this, prev.negitive().radians() - offset);
	        const prevStartVert = newPrev.findIntersection(prev.startVertex().prevWall());
	        prev.startVertex().point(prevStartVert);
	
	        const next = this.nextWall();
	        const newNext = Line2d.startAndTheta(this, next.radians() + offset);
	        const nextEndVert = newNext.findIntersection(next.endVertex().nextWall());
	        next.endVertex().point(nextEndVert);
	        angleLock = true;
	      }
	      return Math.round(currDeg * 10) / 10;
	    }
	
	    const angleDist = (angle1, angle2) => {
	      angle1 = angle1 % 360;
	      angle2 = angle2 % 360;
	      const dist1 = Math.abs(angle1 - angle2);
	      const dist2 = Math.abs(angle1 - 360 - angle2);
	      return dist1 < dist2 ? dist1 : dist2;
	    }
	    const cleanAngle = (degrees) => {
	      let offset = degrees%angleInc;
	      offset = offset > angleInc/2 ? angleInc - offset : -1*offset;
	      return (degrees + offset) % 360
	    }
	
	    function determineAngle(prevWall, currAngle) {
	      const angle = currAngle === undefined ? prevWall.angle() : currAngle;
	      const currRads = Math.toRadians(angle);
	
	      const smallerAngle = cleanAngle(angle - angleInc);
	      const adjustedAngle = cleanAngle(angle);
	      const biggerAngle = cleanAngle(angle + angleInc);
	      const smDist = angleDist(angle, smallerAngle);
	      const adjDist = angleDist(angle, adjustedAngle);
	      const bigDist = angleDist(angle, biggerAngle);
	      const chooseAdj =  adjDist < smDist && adjDist < bigDist;
	      const newAngle = chooseAdj ? adjustedAngle : (smDist < bigDist ? smallerAngle : biggerAngle);
	      return newAngle;
	    }
	
	    this.straightenUp = () => {
	      const corners = layout.vertices();
	      let freeCount = 0;
	      let currAngle;
	      let currLength;
	      for (let index = 0; freeCount < 2 && index < corners.length*2; index++) {
	        const corner = corners[index % corners.length];
	        const prevWall = corner.prevWall();
	        if (freeCount > 0 && !corner.isFree()) {
	          const length = currLength === undefined ? prevWall.length() : currLength;
	          const newAngle = determineAngle(prevWall, currAngle);
	          const rads = Math.toRadians(newAngle);
	          const newLine = Line2d.startAndTheta(prevWall.startVertex(), rads, length);
	          const newEndPoint = newLine.endVertex();
	          const before = corner.angle();
	          currAngle = corner.nextWall().angle();
	          currLength = corner.nextWall().length();
	          prevWall.endVertex().point(newEndPoint);
	        } else if (corner.isFree()) {
	          freeCount++;
	        }
	      }
	    }
	
	    const toRads = (degrees) => Math.toRadians(degrees - degrees%angleInc)
	
	    this.bisector = (dist) => this.prevWall().bisector(this.nextWall(), dist);
	  }
	}
	
	module.exports = Corner2d;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/vertex.js',
function (require, exports, module) {
	
const Matrix = require('./matrix');
	const Vector3D = require('./vector');
	const Vertex2d = require('../../../../../public/js/utils/canvas/two-d/objects/vertex');
	const approximate = require('../../../../../public/js/utils/approximate.js');
	const approx10 = approximate.new(10);
	const CSG = require('../../../public/js/3d-modeling/csg.js');
	const Tolerance = require('../../../../../public/js/utils/tolerance.js');
	const ToleranceMap = require('../../../../../public/js/utils/tolerance-map.js');
	
	
	class Vertex3D {
	  constructor(x, y, z) {
	    if (x instanceof Vertex3D) return x;
	    if (x instanceof Vector3D) {
	      this.x = x.i();
	      this.y = x.j();
	      this.z = x.k();
	    } else if (x === undefined) {
	      this.x = 0;
	      this.y = 0;
	      this.z = 0;
	    } else if (arguments.length == 3) {
	      this.x = x;
	      this.y = y;
	      this.z = z;
	    } else if ('x' in x) {
	      this.x = x.x;
	      this.y = x.y;
	      this.z = x.z;
	    } else {
	      this.x = x[0];
	      this.y = x[1];
	      this.z = x[2];
	    }
	
	    this.viewFromVector = (vector) => Vertex3D.viewFromVector([this], vector);
	
	    this.translate = (vector, doNotModify) => {
	      let vertex = this;
	      if (doNotModify === true) vertex = this.copy();
	      vertex.x += vector.i();
	      vertex.y += vector.j();
	      vertex.z += vector.k();
	      return vertex;
	    }
	
	    this.positionAt = (vertex) => {
	      this.x = vertex.x;
	      this.y = vertex.y;
	      this.z = vertex.z;
	    }
	
	    this.usless = () => Number.NaNfinity(x, y, z);
	
	    this.vector = (vector) => {
	      const v = vector;
	      if (v) return new Vector3D(this.x + v.i(), this.y + v.j(), this.z + v.k());
	      return new Vector3D(this.x, this.y, this.z);
	    }
	
	    this.rotate = (rotations, center) => {
	      CSG.rotatePointAroundCenter(rotations, this, center);
	      return this;
	    }
	
	    this.reverseRotate = (rotations, center) => {
	      CSG.rotatePointAroundCenter(rotations, this, center, true);
	      return this;
	    }
	
	    this.matrix = () => {
	      return new Matrix([[this.x, this.y, this.z]]);
	    }
	
	    this.distance = (other) => {
	      const xDiff = this.x - other.x;
	      const yDiff = this.y - other.y;
	      const zDiff = this.z - other.z;
	
	      return Math.sqrt(xDiff*xDiff + yDiff*yDiff + zDiff*zDiff);
	    }
	
	    this.distanceVector = (other) => {
	      const xDiff = other.x - this.x;
	      const yDiff = other.y - this.y;
	      const zDiff = other.z - this.z;
	
	      return new Vector3D(xDiff, yDiff, zDiff);
	    }
	
	    this.minus = (other) => {
	      const xDiff = this.x - other.x;
	      const yDiff = this.y - other.y;
	      const zDiff = this.z - other.z;
	
	      return new Vector3D(xDiff, yDiff, zDiff);
	    }
	
	    this.inverseVector = () => {
	      return new Vertex3D(this.x * -1, this.y* -1, this.z * -1);
	    }
	
	    this.to2D = (x, y) => Vertex3D.to2D([this], x, y)[0];
	
	    this.copy = () => new Vertex3D(this.x, this.y, this.z);
	    this.clone = this.copy;
	    this.equals = (other) => other && Vertex3D.tolerance.within(this, other);
	    this.toString = () => `(${approx10(this.x)},${approx10(this.y)},${approx10(this.z)})`;
	    this.toAccurateString = () => `${approximate(this.x)},${approximate(this.y)},${approximate(this.z)}`;
	  }
	}
	
	const tol = .000000001;
	Vertex3D.tolerance = new Tolerance({x: tol, y: tol, z: tol});
	
	// returned direction is of list2 relitive to list 1
	// dirArr = [forward, backward, up, down, left, right];
	Vertex3D.direction = (vertList1, vertList2, tolerance, axisOnly) => {
	  tolerance ||= .1;
	  let dirArr = [true, true, true, true, true, true];
	  for (let i = 0; i < vertList1.length; i++) {
	    const vert1 = vertList1[i];
	    for (let j = 0; j < vertList2.length; j++) {
	      const vert2 = vertList2[j];
	      dirArr[0] &&= vert1.z > vert2.z - tolerance;
	      dirArr[1] &&= vert1.z < vert2.z + tolerance;
	      dirArr[2] &&= vert1.y < vert2.y + tolerance;
	      dirArr[3] &&= vert1.y > vert2.y - tolerance;
	      dirArr[4] &&= vert1.x > vert2.x - tolerance;
	      dirArr[5] &&= vert1.x < vert2.x + tolerance;
	    }
	    if (dirArr[0] && dirArr[1]) dirArr[0] = dirArr[1] = false;
	    if (dirArr[2] && dirArr[3]) dirArr[2] = dirArr[3] = false;
	    if (dirArr[4] && dirArr[5]) dirArr[4] = dirArr[5] = false;
	
	    const zDir = dirArr[0] ? 'forward' : (dirArr[1] ? 'backward' : undefined);
	    const yDir = dirArr[2] ? 'up' : (dirArr[3] ? 'down' : undefined);
	    const xDir = dirArr[4] ? 'left' : (dirArr[5] ? 'right' : undefined);
	
	    if (zDir && yDir && xDir) return axisOnly ? null : `${xDir} ${yDir} ${zDir}`;
	    if (zDir) {
	      if (yDir) return axisOnly ? null : `${yDir} ${zDir}`;
	      if (xDir) return axisOnly ? null : `${xDir} ${zDir}`;
	      return zDir;
	    }
	    if (xDir) {
	      if (yDir) return axisOnly ? null : `${xDir} ${yDir}`;
	      return xDir
	    }
	    return yDir ? yDir : null;
	  }
	}
	
	Vertex3D.uniqueFilter = () => {
	  const map = new ToleranceMap({x: tol, y: tol, z: tol});
	  return (vert) => {
	    if (!(vert instanceof Vertex3D)) return false;
	    if (map.matches(vert).length > 0) return false;
	    map.add(vert);
	    return true;
	  }
	}
	
	Vertex3D.center = (...vertices) => {
	  if (Array.isArray(vertices[0])) vertices = vertices[0];
	  let x = 0;
	  let y = 0;
	  let z = 0;
	  let count = 0;
	  vertices.forEach((vertex) => {
	    if (Number.isFinite(vertex.x + vertex.y + vertex.z)) {
	      count++;
	      x += vertex.x;
	      y += vertex.y;
	      z += vertex.z;
	    } else {
	      throw new Error("Vertex contains a non-number");
	    }
	  });
	  return new Vertex3D({x: x/count, y: y/count, z: z/count});
	}
	
	Vertex3D.to2D = (vertices, x, y) => {
	  const verts2D = [];
	  for (let index = 0; index < vertices.length; index++) {
	    verts2D.push(new Vertex2d(vertices[index][x], vertices[index][y]));
	  }
	  return verts2D;
	}
	
	Vertex3D.viewFromVector = (vertices, vector, filter) => {
	  const negitive = !vector.positive();
	  const orthoVerts = [];
	  const runFilter = (typeof filter) === 'function';
	  for (let index = 0; index < vertices.length; index++) {
	    const vertex = vertices[index];
	    const u = new Vector3D(vertex.x, vertex.y, vertex.z);
	    const projection = u.projectOnTo(vector);
	    let orthogonal = u.minus(projection).scale(negitive ? 1 : -1);
	    orthogonal = new Vertex3D(orthogonal);
	    if (!runFilter || (runFilter && filter(orthogonal, vertex)))
	      orthoVerts.push(orthogonal);
	  }
	  return orthoVerts;
	}
	
	Vertex3D.nearest = (vertices, target) => {
	  let closest;
	  for (let index = 0; index < vertices.length; index++) {
	    const vertex = vertices[index];
	    const dist = target.distance(vertex);
	    if (closest === undefined || closest.dist > dist) {
	      closest = {dist, vertex};
	    }
	  }
	  return closest.vertex;
	}
	
	Vertex3D.sortByCenter = (center) => {
	  return (v1, v2) => {
	    const d1 = v1.distance(v2);
	    const d2 = v2.distance(v1);
	    d1 === d2 ? 0 : (d1 < d2 ? -1 : 1);
	  }
	}
	
	module.exports = Vertex3D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/managers/cost.js',
function (require, exports, module) {
	

	
	const CostTree = require('../../cost/cost-tree.js');
	const Assembly = require('../../objects/assembly/assembly.js');
	const du = require('../../../../../public/js/utils/dom-utils.js');
	const $t = require('../../../../../public/js/utils/$t.js');
	const DecisionInputTree = require('../../../../../public/js/utils/input/decision/decision.js');
	const Select = require('../../../../../public/js/utils/input/styles/select');
	const Input = require('../../../../../public/js/utils/input/input');
	const RelationInput = require('../../../../../public/js/utils/input/styles/select/relation');
	const Inputs = require('../../input/inputs.js');
	const RadioDisplay = require('../../display-utils/radio-display.js');
	
	class CostManager {
	  constructor(id, name) {
	    const costTree = new CostTree();
	    this.root = () => costTree.root();
	    this.update = () => {
	      const html = CostManager.mainTemplate.render(this);
	      du.find(`#${id}`).innerHTML = html;
	    }
	    this.nodeInputHtml = () => CostManager.nodeInput().payload().html();
	    this.headHtml = (node) =>
	        CostManager.headTemplate.render({node, CostManager: this});
	    this.bodyHtml = (node) =>
	        CostManager.bodyTemplate.render({node, CostManager: this});
	    this.loadPoint = () => console.log('load');
	    this.savePoint = () => console.log('save');
	    this.fromJson = () => {};
	    this.update();
	  }
	}
	
	CostManager.mainTemplate = new $t('managers/cost/main');
	CostManager.headTemplate = new $t('managers/cost/head');
	CostManager.bodyTemplate = new $t('managers/cost/body');
	CostManager.propertySelectTemplate = new $t('managers/cost/property-select');
	CostManager.costInputTree = (costTypes, objId, onUpdate) => {
	  const logicTree = new LogicTree();
	  return logicTree;
	}
	CostManager.nodeInput = () => {
	  const dit = new DecisionInputTree();
	  const typeSelect = new Select({
	    name: 'type',
	    list: CostTree.types,
	    value: CostTree.types[0]
	  });
	  const selectorType = new Select({
	    name: 'selectorType',
	    list: ['Manual', 'Auto'],
	    value: 'Manual'
	  });
	  const propertySelector = new Select({
	    name: 'propertySelector',
	    list: CostTree.propertyList,
	  });
	
	  const accVals = ['select', 'multiselect', 'conditional'];
	  const condtionalPayload = new DecisionInputTree.ValueCondition('type', accVals, [selectorType]);
	  const type = dit.branch('Node', [Inputs('name'), typeSelect]);
	  const selectType = type.conditional('selectorType', condtionalPayload);
	  const payload = [Inputs('formula'), propertySelector, RelationInput.selector];
	  const condtionalPayload2 = new DecisionInputTree.ValueCondition('selectorType', 'Auto', payload);
	  selectType.conditional('formula', condtionalPayload2);
	  return dit;
	}
	new RadioDisplay('cost-tree', 'radio-id');
	
	new CostManager('cost-manager', 'cost');
	
	function abbriviation(group) {
	  return Assembly.classes[group] ? Assembly.classes[group].abbriviation : 'nope';
	}
	const scope = {groups: CostTree.propertyList, abbriviation};
	// du.id('property-select-cnt').innerHTML =
	//       CostManager.propertySelectTemplate.render(scope);
	module.exports = CostManager
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/vector.js',
function (require, exports, module) {
	
const approximate = require('../../../../../public/js/utils/approximate.js').new(1);
	const Tolerance = require('../../../../../public/js/utils/tolerance.js');
	
	
	function isZero(val) {
	  return Vector3D.tolerance.bounds.i.within(val, 0);
	}
	
	function isZeros() {
	  for (let index = 0; index < arguments.length; index++) {
	    if (!isZero(arguments[index])) return false;
	  }
	  return true;
	}
	
	
	class Vector3D {
	  constructor(i, j, k) {
	    if (i instanceof Vector3D) return i;
	    if (i instanceof Object) {
	      if (i.x !== undefined) {
	        k = i.z;
	        j = i.y;
	        i = i.x;
	      } else {
	        k = i.k;
	        j = i.j;
	        i = i.i;
	      }
	    }
	    this.i = () => i;
	    this.j = () => j;
	    this.k = () => k;
	
	    this.magnitude = () => Math.sqrt(this.i()*this.i() + this.j()*this.j() + this.k()*this.k());
	    this.magnitudeSQ = () => this.i()*this.i() + this.j()*this.j() + this.k()*this.k();
	    this.minus = (vector) => {
	      if (!(vector instanceof Vector3D)) vector = new Vector3D(vector, vector, vector);
	      return new Vector3D(this.i() - vector.i(), this.j() - vector.j(), this.k() - vector.k());
	    }
	    this.add = (vector) => {
	      if (!(vector instanceof Vector3D)) vector = new Vector3D(vector, vector, vector);
	      return new Vector3D(this.i() + vector.i(), this.j() + vector.j(), this.k() + vector.k());
	    }
	    this.scale = (coef) => {
	      return new Vector3D(coef*this.i(), coef*this.j(), coef*this.k());
	    }
	    this.sameDirection = (otherVect) => {
	      return approximate.sameSign(otherVect.i(), this.i()) &&
	              approximate.sameSign(otherVect.j(), this.j()) &&
	              approximate.sameSign(otherVect.k(), this.k());
	    }
	    this.divide = (vector) => {
	      if (!(vector instanceof Vector3D)) vector = new Vector3D(vector, vector, vector);
	      return new Vector3D(this.i() / vector.i(), this.j() / vector.j(), this.k() / vector.k());
	    }
	    this.toArray = () => [this.i(), this.j(), this.k()];
	    this.dot = (vector) =>
	      this.i() * vector.i() + this.j() * vector.j() + this.k() * vector.k();
	    this.perpendicular = (vector) =>
	      Vector3D.tolerance.within(this.dot(vector), 0);
	    this.parrelle = (vector) => {
	      let coef = isZero(this.i()) ? 0 : this.i() / vector.i();
	      if (isZero(coef)) coef = isZero(this.j()) ? 0 : this.j() / vector.j();
	      if (isZero(coef)) coef = isZero(this.k()) ? 0 : this.k() / vector.k();
	      if (isZero(coef)) return false;
	      const equivVect = new Vector3D(vector.i() * coef, vector.j() * coef, vector.k() * coef);
	      return Vector3D.tolerance.within(equivVect, this);
	    }
	    this.crossProduct = (other) => {
	      const i = this.j() * other.k() - this.k() * other.j();
	      const j = this.i() * other.k() - this.k() * other.i();
	      const k = this.i() * other.j() - this.j() * other.i();
	      const mag = Math.sqrt(i*i+j*j+k*k);
	      return new Vector3D(i/mag,j/-mag,k/mag);
	    }
	    this.inverse = () => new Vector3D(this.i()*-1, this.j()*-1, this.k()*-1);
	
	    this.projectOnTo = (v) => {
	      const multiplier = this.dot(v) / v.magnitudeSQ();
	      return v.scale(multiplier);
	    }
	
	    this.unit = () => {
	      const i = this.i();const j = this.j();const k = this.k();
	      const magnitude = Math.sqrt(i*i+j*j+k*k);
	      return new Vector3D(i/magnitude, j/magnitude, k/magnitude);
	    }
	
	    this.positive = () =>
	      i > 0 || (isZero(i) && j > 0) || (isZeros(i,j) && k > 0) ||
	      isZeros(i, j, k);
	    this.equals = (vector) => Vector3D.tolerance.within(vector, this);
	    this.toString = () => `<${i},  ${j},  ${k}>`;
	  }
	}
	
	const tol = .00000001;
	Vector3D.tolerance = new Tolerance({i: tol, j: tol, k: tol});
	
	Vector3D.mostInLine = (vectors, target) => {
	  let closest;
	  target = target.unit();
	  for (let index = 0; index < vectors.length; index++) {
	    const vector = vectors[index];
	    const dist = vector.minus(target).magnitude();
	    if (closest === undefined || closest.dist > dist) {
	      closest = {dist, vector};
	    }
	  }
	  return closest.vector;
	}
	
	
	module.exports = Vector3D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/polygon.js',
function (require, exports, module) {
	
const Polygon2D = require('../../../../../public/js/utils/canvas/two-d/objects/polygon.js');
	const Line3D = require('./line');
	const Vertex3D = require('./vertex');
	const Vector3D = require('./vector');
	const Plane = require('./plane');
	const ToleranceMap = require('../../../../../public/js/utils/tolerance-map.js');
	const Tolerance = require('../../../../../public/js/utils/tolerance.js');
	const within = Tolerance.within(.0000001);
	
	const CSG = require('../../../public/js/3d-modeling/csg.js');
	let lastMi;
	
	const place = (vert, no, one, two, three) => {
	  let count = 0;
	  if (within(vert.x, 0)) count++;
	  if (within(vert.y, 0)) count++;
	  if (within(vert.z, 0)) count++;
	  switch (count) {
	    case 0: return no.push(vert);
	    case 1: return one.push(vert);
	    case 2: return two.push(vert);
	    case 3: return three.push(vert);
	  }
	}
	
	class Polygon3D {
	  constructor(initialVertices) {
	    let lines = [];
	    let map;
	    let normal;
	    let instance = this;
	
	    function planePoints() {
	      const noZeros = [];
	      const oneZero = [];
	      const twoZeros = [];
	      const origin = [];
	
	      for (let index = 0; index < lines.length; index++) {
	        const line = lines[index];
	        const sv = line.startVertex;
	        const mp = line.midpoint();
	        place(sv, noZeros, oneZero, twoZeros, origin);
	        place(mp, noZeros, oneZero, twoZeros, origin);
	      }
	      return noZeros.concat(oneZero).concat(twoZeros).concat(origin);
	    }
	
	    function getPlane() {
	      let points = planePoints();
	      let parrelle = true;
	      let index = 2;
	      const point1 = points[0];
	      const point2 = points[1];
	      let point3;
	      while (parrelle && index < points.length) {
	        point3 = points[index]
	        let vector1 = point1.minus(point2);
	        let vector2 = point3.minus(point2);
	        parrelle = vector1.parrelle(vector2);
	        index++;
	      }
	      return new Plane(point1, point2, point3);
	    }
	    this.toPlane = getPlane;
	
	    this.rotate = (rotations, center) => {
	      center ||= this.center();
	      for(let index = 0; index < lines.length; index++) {
	        lines[index].startVertex.rotate(rotations, center);
	      }
	    }
	
	    function calcNormal() {
	      let points = this.vertices();
	      let vector1, vector2;
	      let parrelle = true;
	      let index = 0;
	      while (parrelle && index < points.length - 2) {
	        vector1 = points[index + 1].minus(points[index])
	        vector2 = points[index + 2].minus(points[index]);
	        parrelle = vector1.parrelle(vector2);
	        index++;
	      }
	      if (parrelle)
	        throw new Error('InvalidPolygon: points are in a line');
	
	      const normVect = vector1.crossProduct(vector2);
	      return normVect.scale(1 / normVect.magnitude());
	    }
	    this.normal = calcNormal;
	
	    this.translate = (vector) => {
	      const verts = [];
	      for (let index = 0; index < lines.length; index++) {
	        verts.push(lines[index].startVertex.translate(vector, true));
	      }
	      return new Polygon3D(verts);
	    }
	
	    this.perpendicular = (poly) => {
	      return this.normal().perpendicular(poly.normal());
	    }
	    const xyNormal = new Vector3D(0,0,1);
	    const yzNormal = new Vector3D(1,0,0);
	    const xzNormal = new Vector3D(0,1,0);
	    this.inXY = () => this.perpendicular(xyPoly);
	    this.inYZ = () => this.perpendicular(yzPoly);
	    this.inXZ = () => this.perpendicular(xzPoly);
	
	    this.parrelle = (poly) => {
	      const normal = this.normal();
	      if (normal === undefined || poly.normal() === undefined) return false;
	      return normal.parrelle(poly.normal());
	    }
	
	    this.offset = (left, right, up, down) => {
	      lines[0].adjustLength(left - lines[0].length(), false);
	      lines[0].adjustLength(lines[0].length() - right, true);
	      lines[2].adjustLength(lines[2].length() - left, true);
	      lines[2].adjustLength(right - lines[2].length(), false);
	
	      lines[1].adjustLength(up - lines[1].length(), false);
	      lines[1].adjustLength(lines[1].length() - down, true);
	      lines[3].adjustLength(lines[3].length() - up, true);
	      lines[3].adjustLength(down - lines[3].length(), false);
	    }
	
	    this.parrelleAt = (distance) => {
	      const normal = this.normal();
	      const scaled = normal.scale(distance);
	      const vertices = this.vertices();
	      for (let index = 0; index < vertices.length; index++) {
	        vertices[index].translate(scaled);
	      }
	      return new Polygon3D(vertices);
	    }
	
	    this.parrelleNear = (target, distance) => {
	      distance ||= 100;
	      const center = this.center();
	      const targetDistance = center.distance(target);
	      const posPlane = this.parrelleAt(distance);
	      if (posPlane.center().distance(target) < targetDistance) return posPlane;
	      return this.parrelleAt(-distance);
	    }
	
	    this.vertices = () => {
	      if (lines.length === 0) return [];
	      const vertices = [];
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        vertices.push(line.startVertex);
	      }
	
	      return JSON.clone(vertices);
	    }
	
	    this.vertex = (index) => lines[Math.mod(index, lines.length)].startVertex.copy();
	
	    this.isClockwise = () => {
	      let sum = 0;
	      for (let index = 0; index < lines.length; index += 1) {
	        const point1 = lines[index].startVertex;
	        const point2 = lines[index].startVertex;
	        sum += (point2.x - point1.x)*(point2.y + point1.y)*(point2.z - point1.z);
	      }
	      return sum > 0;
	    }
	
	    this.lines = () => JSON.clone(lines);
	    this.line = (index) => JSON.clone(lines[Math.mod(index, lines.length)]);
	    this.startLine = () => lines[0];
	    this.endLine = () => lines[lines.length - 1];
	
	    const tol = .00001;
	    this.lineMap = (force) => {
	      if (!force && map !== undefined) return map;
	      if (lines.length === 0) return {};
	      map = new ToleranceMap({'startVertex.x': tol, 'startVertex.y': tol, 'startVertex.z': tol,
	                              'endVertex.x': tol, 'endVertex.y': tol, 'endVertex.z': tol});
	      let lastEnd;
	      if (!lines[0].startVertex.equals(lines[lines.length - 1].endVertex)) throw new Error('Broken Polygon');
	      for (let index = 0; index < lines.length; index++) {
	        lines[index]._POLY_INDEX = index;
	        map.add(lines[index]);
	      }
	      return map;
	    }
	
	    this.copy = () => new Polygon3D(Line3D.vertices(lines, false));
	
	    this.equals = (other) => {
	      if (!(other instanceof Polygon3D)) return false;
	      const verts = this.vertices();
	      const otherVerts = other.vertices();
	      if (verts.length !== otherVerts.length) return false;
	      let otherIndex = undefined;
	      let direction;
	      for (let index = 0; index < verts.length * 2; index += 1) {
	        const vIndex = index % verts.length;
	        if (otherIndex === undefined) {
	          if (index > verts.length) {
	            return false
	          } if(verts[index].equals(otherVerts[0])) {
	            otherIndex = otherVerts.length * 2;
	          }
	        } else if (otherIndex === otherVerts.length * 2) {
	          if (verts[vIndex].equals(otherVerts[1])) direction = 1;
	          else if(verts[vIndex].equals(otherVerts[otherVerts.length - 1])) direction = -1;
	          else return false;
	          otherIndex += direction * 2;
	        } else if (!verts[vIndex].equals(otherVerts[otherIndex % otherVerts.length])) {
	          return false;
	        } else {
	          otherIndex += direction;
	        }
	      }
	      return true;
	    }
	
	    function getLine(line) {
	      const lineMap = this.lineMap();
	      const matches = lineMap.matches(line) || lineMap.matches(line.negitive());
	      if (matches && matches.length > 1) throw new Error('THIS SHOULD NOT HAPPEN!!!! REMOVE LINES IS BROKEN... probably');
	      return matches ? matches[0] : null;
	    }
	
	    this.getLines = (startVertex, endVertex, reverse) => {
	      const subSection = [];
	      let completed = false;
	      let shared;
	      const compareLine = new Line3D(startVertex, endVertex);
	      const compareLineI = new Line3D(endVertex,startVertex);
	
	      const doubleLen = lines.length * 2;
	      for (let steps = 0; steps < doubleLen; steps += 1) {
	        const index =  (!reverse ? steps : (doubleLen - steps - 1)) % lines.length;
	        const curr = lines[index];
	        if (!shared) {
	          if (compareLine.equals(curr) || compareLineI.equals(curr)) shared = curr;
	        } else {
	          if (shared === curr) {
	            completed = true;
	            break;
	          } else subSection.push(!reverse ? curr : curr.negitive());
	        }
	      }
	      if (completed) return subSection;
	    }
	
	    this.center = () => {
	      const verts = [];
	      for (let index = 0; index < lines.length; index++) {
	        verts.push(lines[index].startVertex);
	      }
	      return Vertex3D.center(verts);
	    }
	
	    this.addVertices = (list) => {
	      if (list === undefined) return;
	      const verts = [];
	      const endLine = this.endLine();
	      for (let index = 0; index < list.length + 1; index += 1) {
	        if (index < list.length) verts[index] = new Vertex3D(list[index]);
	        if (index === 0 && endLine) endLine.endVertex = verts[0];
	        else if (index > 0) {
	          const startVertex = verts[index - 1];
	          const endVertex = verts[index] || this.startLine().startVertex;
	          const line = new Line3D(startVertex, endVertex);
	          lines.push(line);
	          const prevLine = lines[lines.length - 2];
	          // if (lines.length > 1 && !(normal instanceof Vector3D)) normal = calcNormal(line, prevLine);
	          // else if (lines.length > 2) {
	          //   const equal = normal.equals(calcNormal(line, prevLine));
	          //   if (equal === false) {
	          //     console.log('Trying to add vertex that does not lie in the existing plane');
	          //   }
	          // }
	        }
	      }
	      if (verts.length > 0 && lines.length > 0) {
	        if (endLine) endline.endVertex = verts[0];
	      }
	      this.lineMap(true);
	      // this.removeLoops();
	    }
	
	    this.rebuild = (newVertices) => {
	      lines = [];
	      this.addVertices(newVertices);
	    }
	
	    this.removeLoops = () => {
	      let removed = true;
	      const orig = lines;
	      while (removed && lines.length > 0) {
	        removed = false;
	        const map = this.lineMap();
	        for (let index = 0; index < lines.length; index += 1) {
	          const line = lines[index];
	          if (line.isPoint()) {
	            lines = JSON.clone(lines);
	            lines.splice(index, 1);
	            removed = true;
	          } else {
	            const posMatch = map.matches(line);
	            const negMatch = map.matches(line.negitive());
	            if (posMatch.length > 1 || (negMatch && negMatch.length !== 0)) {
	              let match = negMatch ? negMatch[0] : posMatch[1];
	              const startIndex = line._POLY_INDEX;
	              const endIndex = match._POLY_INDEX;
	              if (startIndex > endIndex)
	              throw new Error('THIS SHOULD NOT HAPPEN!!!!!! WTF!!!!');
	              const forwardDiff = endIndex - startIndex;
	              const reverseDiff = lines.length - forwardDiff;
	              if (Math.max(forwardDiff, reverseDiff) < 3) {
	                console.log('che che');
	              }
	              if (forwardDiff > reverseDiff) {
	                lines = lines.slice(startIndex, endIndex);
	              } else {
	                lines = lines.slice(0, startIndex).concat(lines.slice(endIndex));
	              }
	
	              const newVerts = Line3D.vertices(lines, false);
	              this.rebuild(newVerts);
	              removed = true;
	              break;
	            }
	          }
	        }
	        // TODO: not sure if this will cause an issue but polygons should not have less than 3 vertices this will break toPlane functionality.
	        // if (lines.length < 3) {
	        //   console.log('che che check it out', lines.length);
	        // }
	        if (removed) this.lineMap(true);
	      }
	    }
	
	    this.path = () => {
	      let path = '';
	      this.vertices().forEach((v) => path += `${v.toString()} => `);
	      return path.substring(0, path.length - 4);
	    }
	
	
	    this.merge = (other) => {
	      if (!this.normal().parrelle(other.normal())) return;
	      const thisPlane = this.toPlane();
	      const otherPlane = other.toPlane();
	      // if (!thisPlane.equivalent(otherPlane)) return;
	      const lineMap = this.lineMap();
	      const allOtherLines = other.lines();
	      let merged;
	      for (let index = 0; index < allOtherLines.length; index += 1) {
	        const curr = allOtherLines[index];
	        let vertices, thisLines, otherLines;
	        if (lineMap.matches(curr) !== null) {
	          thisLines = this.getLines(curr.startVertex, curr.endVertex, true);
	          otherLines = other.getLines(curr.endVertex, curr.startVertex, false);
	        } else if (lineMap.matches(curr.negitive()) !== null) {
	          thisLines = this.getLines(curr.endVertex, curr.startVertex, false);
	          otherLines = other.getLines(curr.startVertex, curr.endVertex, false);
	        }
	
	        if (thisLines && otherLines) {
	          if (thisLines[0].startVertex.equals(otherLines[0].startVertex))
	            thisLines = Line3D.reverse(thisLines);
	
	          const startCheck = thisLines[0].startVertex.equals(otherLines[otherLines.length - 1].endVertex);
	          const middleCheck = thisLines[thisLines.length - 1].endVertex.equals(otherLines[0].startVertex);
	          if (!(middleCheck && startCheck))
	            console.warn('coommmmooon!!!!');
	          vertices = Line3D.vertices(otherLines.concat(thisLines), false);
	          merged = new Polygon3D(vertices);
	          try {
	            merged.normal();
	          } catch (e) {
	            console.warn('again wtf!!!');
	            new Polygon3D(vertices);
	            new Polygon3D(vertices);
	            new Polygon3D(vertices);
	          }
	        }
	      }
	
	      if (merged) {
	        return merged;
	      }
	    }
	
	    this.viewFromVector = () => Polygon3D.viewFromVector([this])[0];
	    this.mostInformation = () => Polygon3D.mostInformation([this])[0];
	
	    this.to2D = (x, y) => {
	      if (!x || !y) {
	        const mi = this.mostInformation();
	        x ||= mi[0];
	        y ||= mi[1];
	        if (lastMi && (mi[0] !== lastMi[0] || mi[1] !== lastMi[1])) {
	          console.info.subtle('change in mi');
	        }
	        lastMi = mi;
	      }
	      return new Polygon2D(Vertex3D.to2D(this.vertices(),  x, y));
	    }
	
	    this.toString = () => {
	      let str = '';
	      for (let index = 0; index < lines.length; index++) {
	        str += ` => ${lines[index].startVertex.toString()}`;
	      }
	      return `${str.substring(4)} normal: ${this.normal()}`;
	    }
	
	
	    this.toDetailString = () => {
	      let startStr = '';
	      let endStr = '';
	      for (let index = 0; index < lines.length; index++) {
	        startStr += ` => ${lines[index].startVertex.toString()}`;
	        endStr += ` => ${lines[Math.mod(index - 1, lines.length)].endVertex.toString()}`;
	      }
	      return `Start Vertices: ${startStr.substring(4)}\nEnd   Vertices: ${endStr.substring(4)}`;
	    }
	    this.addVertices(initialVertices);
	  }
	}
	
	function printMerge(target, other, merged) {
	  console.log(`target: ${target.toString()}`);
	  console.log(`other: ${other.toString()}`);
	  console.log(`merged: ${merged.toString()}`);
	  target.merge(other);
	}
	
	let doIt = false;
	Polygon3D.merge = (polygons) => {
	  let currIndex = 0;
	  while (currIndex < polygons.length - 1) {
	    const target = polygons[currIndex];
	    for (let index = currIndex + 1; index < polygons.length; index += 1) {
	      const other = polygons[index];
	      const merged = target.merge(other);
	      if (merged) {
	        if (doIt) printMerge(target, other, merged);
	        polygons[currIndex--] = merged;
	        polygons.splice(index, 1);
	        break;
	      }
	    }
	    currIndex++;
	  }
	}
	
	const xyPoly = new Polygon3D([[1,10,0],[11,2,0],[22,1,0]]);
	const yzPoly = new Polygon3D([[6,0,1],[10,0,27],[2,0,11]]);
	const xzPoly = new Polygon3D([[0,11,13],[0,12,23],[0,22,3]]);
	
	Polygon3D.mostInformation = (polygons) => {
	  const diff = {x: 0, y:0, z: 0};
	  for (let pIndex = 0; pIndex < polygons.length; pIndex++) {
	    const poly = polygons[pIndex];
	    const verts = poly.vertices();
	    const center = poly.center();
	    for(let index = 0; index < verts.length; index++) {
	      const v = verts[index];
	      diff.x += Math.abs(v.x - center.x);
	      diff.y += Math.abs(v.y - center.y);
	      diff.z += Math.abs(v.z - center.z);
	    }
	  }
	  return diff.x < diff.y ?
	        (diff.x < diff.z ? ['y', 'z'] :
	        (diff.z < diff.y ? ['x', 'y'] : ['x', 'z'])) :
	        (diff.y < diff.z ? ['x', 'z'] : ['x', 'y']);
	}
	
	const to2D = (mi) => (p) => p.to2D(mi[0],mi[1]);
	Polygon3D.toTwoD = (polygons, vector, axis) => {
	  const view = Polygon3D.viewFromVector(polygons, vector, true);
	  axis ||= Polygon3D.mostInformation(view);
	  const twoD = view.map(to2D(axis));
	  const twoDlines = Polygon2D.lines(twoD);
	  twoDlines.axis = axis;
	  return twoDlines;
	}
	
	Polygon3D.toThreeView = (polygons, normals, gap) => {
	  const ThreeView = require('../../../../../public/js/utils/canvas/two-d/objects/three-view.js');
	  return new ThreeView(polygons, normals, gap);
	}
	
	Polygon3D.fromCSG = (polys) => {
	  const isArray = Array.isArray(polys);
	  if (!isArray) polys = [polys];
	  const poly3Ds = [];
	  for (let index = 0; index < polys.length; index++) {
	    const poly = polys[index];
	    const verts = [];
	    for (let vIndex = 0; vIndex < poly.vertices.length; vIndex++) {
	      const v = poly.vertices[vIndex];
	      verts.push(new Vertex3D({x: v.pos.x, y: v.pos.y, z: v.pos.z}));
	    }
	    poly3Ds.push(new Polygon3D(verts));
	  }
	  if (!isArray) return poly3Ds[0];
	  return poly3Ds;
	}
	
	Polygon3D.fromVectorObject =
	    (width, height, center, vectorObj) => {
	  center ||= new Vertex(0,0,0);
	  vectorObj ||= {width: new Vector3D(1,0,0), height: new Vector3D(0,1,0)}
	  const hw = width/2;
	  const hh = height/2;
	  const wV = vectorObj.width;
	  const hV = vectorObj.height;
	  const vector1 = center.translate(hV.scale(hh), true).translate(wV.scale(-hw));
	  const vector2 = center.translate(hV.scale(hh), true).translate(wV.scale(hw));
	  const vector3 = center.translate(hV.scale(-hh), true).translate(wV.scale(hw));
	  const vector4 = center.translate(hV.scale(-hh), true).translate(wV.scale(-hw));
	  return new Polygon3D([vector1, vector2, vector3, vector4]);
	}
	
	Polygon3D.fromLines = (lines) => {
	  const verts = [];
	  for (let index = 0; index < lines.length; index += 1) {
	    if (!lines[index].startVertex.equals(lines[Math.mod(index - 1, lines.length)].endVertex)) throw new Error('Lines must be connected');
	    verts.push(lines[index].startVertex);
	  }
	  return new Polygon3D(verts);
	}
	
	Polygon3D.from2D = (polygon2d) => {
	  const verts = polygon2d.vertices();
	  const initialVertices = [];
	  for (let index = 0; index < verts.length; index++) {
	    const vert = verts[index];
	    initialVertices.push(new Vertex3D(vert.x(), vert.y(), 0));
	  }
	  return new Polygon3D(initialVertices);
	}
	
	const randValue = () => Math.random() > .5 ? Math.random() * 200000 - 100000 : 0;
	for (let index = 0; index < 10000; index++) {
	  const vector = new Vector3D(randValue(), randValue(), randValue());
	}
	
	Polygon3D.viewFromVector = (polygons, vector) => {
	  const orthoPolys = [];
	  for (let p = 0; p < polygons.length; p++) {
	    const vertices = polygons[p].vertices();
	    const orthoVerts = Vertex3D.viewFromVector(vertices, vector);
	    orthoPolys.push(new Polygon3D(orthoVerts));
	  }
	  return orthoPolys;
	}
	
	module.exports = Polygon3D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/plane.js',
function (require, exports, module) {
	const CSG = require('../../../public/js/3d-modeling/csg.js');
	const Vector3D = require('vector');
	const Vertex3D = require('vertex');
	const Matrix = require('matrix');
	const Line2d = require('../../../../../public/js/utils/canvas/two-d/objects/line.js');
	const Vertex2d = require('../../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const approximate = require('../../../../../public/js/utils/approximate.js').new(1000000);
	const withinTol = new (require('../../../../../public/js/utils/tolerance.js'))(.00000001).within;
	
	function isDefined(...values) {
	  for (let index = 0; index < values.length; index++) {
	    if (values[index] === undefined) return false;
	  }
	  return true;
	}
	
	class Plane extends Array {
	  constructor(...points) {
	    super();
	    let equation;
	    const instance = this;
	    if (Array.isArray(points[0])) points = points[0];
	    if (isDefined(points[0], points[0].a, points[0].b, points[0].c, points[0].d)) {
	      equation = points[0];
	      points = [];
	    }
	    for (let index = 0; index < points.length; index++) {
	      this[index] = new Vertex3D(points[index]);
	    }
	
	    this.indexOf = (point) => {
	      for (let index = 0; index < points.length; index++) {
	        if (this[index].equals(point)) return index;
	      }
	      return -1;
	    }
	
	    this.points = () => this.length > 2 ? this : this.findPoints();
	
	    this.equivalent = (other) => {
	      if (!(other instanceof Plane)) return false;
	      const oPoints = other.points();
	      for (let index = 0; index < oPoints.length; index++) {
	        // const p = oPoints[index];
	        // const thisZ = this.z(p.x, p.y);
	        // if (!withinTol(thisZ, p.z)) return false;
	        const thisEqn = this.equation();
	        const otherEqn = other.equation();
	        if (!withinTol(thisEqn.a, otherEqn.a)) return false;
	        if (!withinTol(thisEqn.b, otherEqn.b))  return false;
	        if (!withinTol(thisEqn.c, otherEqn.c))  return false;
	      }
	      return true;
	    }
	
	    this.XYrotation = () => {
	      const eqn = this.equation();
	
	      const a2b2 = eqn.a * eqn.a + eqn.b * eqn.b;
	      const a2b2c2 = eqn.a * eqn.a + eqn.b * eqn.b + eqn.c * eqn.c;
	      const roota2b2c2 = Math.sqrt(a2b2c2);
	      const cos = eqn.c / roota2b2c2;
	      const sin = Math.sqrt(a2b2 / a2b2c2);
	      const u1 = eqn.b / Math.sqrt(a2b2);
	      const u2 = - eqn.a / Math.sqrt(a2b2);
	
	      const rotationMatrix = new Matrix([
	        [cos+u1*u1*(1-cos), u1*u2*(1-cos),     u2*sin],
	        [u1*u2*(1-cos),     cos+u2*u2*(1-cos), -u1*sin],
	        [-u2*sin,           u1*sin,             cos],
	      ])
	      return rotationMatrix;
	    }
	
	    this.rotate = (rotation, center) => {
	      center ||= this.center();
	      for (let index = 0; index < this.length; index++) {
	        this[index].rotate(rotation, center);
	      }
	    }
	
	    this.matrixRotation = (rotationMatrix) => {
	      const eqn = this.equation();
	      const planeMatrix = new Matrix([[eqn.a], [eqn.b], [eqn.c]]);
	      const planeMatrix2 = new Matrix([[eqn.a, eqn.b, eqn.c]]);
	      return rotationMatrix.dot(planeMatrix);
	    }
	
	    this.reverseRotate = (rotation, center) => {
	      center ||= this.center();
	      for (let index = 0; index < this.length; index++) {
	        this[index].reverseRotate(rotation, center);
	      }
	    }
	
	    this.x = (y,z, vertex) => {
	      y ||= 0;
	      z ||= 0;
	      const eqn = this.equation();
	      const x = (eqn.b * y + eqn.c * z + eqn.d) / eqn.a
	      if (x) return new Vertex3D(x,y,z);
	      return x;
	    }
	
	    this.y = (x,z, vertex) => {
	      x ||= 0;
	      z ||= 0;
	      const eqn = this.equation();
	      const y = (eqn.a * x + eqn.c * z + eqn.d) / eqn.b
	      if (y) return new Vertex3D(x,y,z);
	      return y;
	    }
	
	    this.z = (x,y, vertex) => {
	      x ||= 0;
	      y ||= 0;
	      const eqn = this.equation();
	      const z = (eqn.b * y + eqn.a * x + eqn.d) / eqn.c;
	      if (z) return new Vertex3D(x,y,z);
	      return z;
	    }
	
	    this.equation = () => {
	      if (equation && this.length < 3) return equation;
	      const systemOfEquations = Matrix.mapObjects(this.points(), ['x','y','z']);
	
	      try {
	        const answer = systemOfEquations.solve([1,1,1]);
	        const returnValue = {a: answer[0][0], b: answer[1][0], c: answer[2][0], d: 1};
	        return returnValue;
	      } catch (e) {
	        console.log('booblaa booblaa');
	      }
	    }
	
	    this.equationEqualToZ = () => {
	      const eqn = this.equation();
	      const a = approximate;
	      return `(${a(eqn.a)}x + ${a(eqn.b)}y + ${a(eqn.d)}) / ${a(eqn.c)}`;
	    }
	
	    // TODO: this function does not work!
	    this.findPoints = (count) => {
	      console.warn.subtle(60000, 'This Function does not work properly');
	      count ||= 3;
	      const limit = count * 3 + 11;
	      const pts = [];
	      let state = 0;
	      let value = 100000;
	      while (pts.length < count) {
	         let func = state === 0 ? this.x : (state === 1 ? this.y : this.z);
	         let point = value % 2 ? func(value * 2, value*-1, true) : func(value, value, true);
	         if (!point.usless() && (pts.length === 0 || (pts.equalIndexOf(point)))) pts.push(point);
	         value += 13;
	         state = ++state % 3;
	         // if (value > limit) throw new Error('Cant find points');
	      }
	      return pts;
	    }
	
	    this.parrelleTo = (axis) => {
	      const pts = this.points();
	      return approximate.eq(pts[0][axis], pts[1][axis], pts[2][axis]);
	    }
	
	    this.normal = () => {
	      const points = this.points();
	      const vector1 = points[1].vector().minus(points[0]);
	      const vector2 = points[2].vector().minus(points[0]);
	      const normVect = vector1.crossProduct(vector2);
	      return normVect.scale(1 / normVect.magnitude());
	    }
	
	    this.distance = (vertex) => {
	      if (!(vertex instanceof Vertex3D)) throw new Error('Sorry... I only implemented this relitive to a Vertex3D');
	      const v = vertex;
	      const eqn = this.equation();
	      const c = this.center();
	      const num = Math.abs(eqn.a*(v.x-c.x)+eqn.b*(v.y-c.y)+eqn.c*(v.z-c.z));
	      const denom = Math.sqrt(eqn.a*eqn.a+eqn.b*eqn.b+eqn.c*eqn.c);
	      return num/denom;
	    }
	
	    this.center = () => Vertex3D.center.apply(null, this);
	
	    const epsilon = 1e-6;
	    function lineIntersection(line, segment, directional) {
	      const vect0 = line.startVertex.vector();
	      const vect1 = line.endVertex.vector();
	      const planePoint = instance.points()[0];
	      const planeNormal = instance.normal();
	      let u = vect1.minus(vect0);
	      let dot = planeNormal.dot(u);
	
	      if (Math.abs(dot) > epsilon) {
	        let w = vect0.minus(planePoint);
	        let fac = -planeNormal.dot(w) / dot;
	        u = u.scale(fac);
	        const intersection = new Vertex3D(vect0.add(u));
	        if (segment) {
	          if (frac <= 1 && frac >= 0) return intersection;
	          return null;
	        }
	        if (directional) {
	          const endDist = line.endVertex.distance(intersection);
	          const startDist = line.startVertex.distance(intersection);
	          if (endDist > line.length() && endDist > startDist) return null;
	        }
	        return intersection;
	      }
	
	      return null;
	    }
	
	    this.intersection = {};
	
	    this.intersection.line = (line) => lineIntersection(line);
	    this.intersection.line.segment = (line) => lineIntersection(line, true);
	    this.intersection.line.directional = (line) => lineIntersection(line, null, true);
	
	    this.equals = (other) => {
	      if (!Array.isArray(other) || this.length !== other.length) return false;
	      const startIndex = this.indexOf(other[0]);
	      if (startIndex === -1) return false;
	      for (let index = startIndex; index < this.length + startIndex; index++) {
	        const i = Math.mod(index, this.length);
	        if (!this[i].equals(other[i])) return false;
	      }
	      return true;
	    }
	  }
	}
	
	Plane.makePlane1MeetPlane2 = function (plane1, plane2, rotation) {
	  const centerP1 = Vertex3D.center.apply(null, plane1);
	  const rotated1 = new Plane(JSON.copy(plane1));
	  const rotated2 = new Plane(JSON.copy(plane2));
	  rotated1.reverseRotate(rotation, centerP1);
	  rotated2.reverseRotate(rotation, centerP1);
	  const center1 = Vertex3D.center.apply(null, rotated1);
	  for (let index = 1; index < rotated1.length; index++)
	    if (approximate.neq(rotated1[0].z, rotated1[index].z)) throw new Error('Invalid planeRotation: Rotation reversed should make all z coordinates equal to each other');
	  const zValue = rotated1[0].z;
	  const keep1 = [];
	  const keep2 = [];
	  const intersections = [];
	  const plane2Line2d = new Line2d(rotated2[0], rotated2[1]).combine(new Line2d(rotated2[2], rotated2[3]));
	  const p2l2Midpoint = plane2Line2d.midpoint();
	  const len = rotated1.length;
	  let keep = keep1;
	  for (let index = 0; index < rotated1.length; index++) {
	    rotated1[index] = new Vertex2d(rotated1[index]);
	    const nextIndex = (index + 1) % len;
	    const prevIndex = Math.mod(index - 1, len);
	    const positiveLine = new Line2d(rotated1[nextIndex], rotated1[index]);
	    const negativeLine = new Line2d(rotated1[prevIndex], rotated1[index]);
	    const intersection1 = positiveLine.findDirectionalIntersection(plane2Line2d, 1000);
	    const intersection2 = negativeLine.findDirectionalIntersection(plane2Line2d, 1000);
	    if (intersections.length > 0) keep = keep2;
	    if (!intersection1 && !intersection2) keep.push(rotated1[index]);
	    else if (!intersection1) intersections.push(intersection2);
	    else if (!intersection2) intersections.push(intersection1);
	    else {
	      const dist1 = p2l2Midpoint.distance(intersection1);
	      const dist2 = p2l2Midpoint.distance(intersection2);
	      intersections.push(dist1 > dist2 ? intersection1 : intersection2);
	    }
	  }
	  const newPlaneRotated = keep1.concat(intersections).concat(keep2);
	  for (let index = 0; index < newPlaneRotated.length; index++) {
	    newPlaneRotated[index] = {
	      x: newPlaneRotated[index].x(),
	      y: newPlaneRotated[index].y(),
	      z: zValue
	    }
	  }
	
	  CSG.rotatePointsAroundCenter(rotation, newPlaneRotated, centerP1);
	  return new Plane(...newPlaneRotated);
	}
	
	Plane.bisector = (p1, p2) => {
	  const eq1 = p1.equation();
	  const eq2 = p2.equation();
	
	  const denom1 = Math.sqrt(eq1.a * eq1.a + eq1.b * eq1.b + eq1.c * eq1.c);
	  const denom2 = Math.sqrt(eq2.a * eq2.a + eq2.b * eq2.b + eq2.c * eq2.c);
	
	  const a1 = denom2*eq1.a;
	  const b1 = denom2*eq1.b;
	  const c1 = denom2*eq1.c;
	  const d1 = denom2*eq1.d;
	
	  const a2 = denom1*eq2.a;
	  const b2 = denom1*eq2.b;
	  const c2 = denom1*eq2.c;
	  const d2 = denom1*eq2.d;
	
	  const plane1 = new Plane({a: a1 + a2, b: b1 + b2, c: c1 + c2, d: d1 + d2});
	  const plane2 = new Plane({a: a1 - a2, b: b1 - b2, c: c1 - c2, d: d1 - d2});
	
	  const obtuse = (eq1.a*eq2.a + eq1.b*eq2.b + eq1.c*eq2.c) < 0
	  if (obtuse) return {obtuse: plane1, accute: plane2};
	  return {obtuse: plane2, accute: plane1};
	}
	
	// TODO: not used but could be helpful. - fix
	Plane.fromPointNormal = (point, normal) => {
	  const fixed = [];
	  const a = normal.i();
	  const b = normal.j();
	  const c = normal.k();
	  const vectArray = normal.toArray();
	
	  if (a===0 && b===0 && c===0) return;
	
	  const x0 = point.x;
	  const y0 = point.y;
	  const z0 = point.z;
	  const pointArray = [x0, y0, z0];
	  let startIndex = 0;
	  while (vectArray[startIndex] === 0) startIndex++;
	  const get = (x,y) => {
	    const ansI = startIndex;
	    const aI = (startIndex + 1) % 3;
	    const bI = (startIndex + 2) % 3;
	    const answer = (vectArray[aI]*(x-pointArray[aI])+vectArray[bI]*(y-pointArray[bI])-vectArray[ansI]*pointArray[ansI])/-vectArray[ansI];
	    const p = [];p[ansI] = answer;p[aI] = x;p[bI] = y;
	    return new Vertex3D(...p);
	    // (a*(x-x0)+b*(y-y0)-c*z0)/-c;
	  }
	  // there is a chance that these three points will be colinear.... not likely and I have more important stuff to do.
	
	  const point1 = get(13,677);
	  const point2 = get(127,43);
	  const point3 = get(107,563);
	  return new Plane(point1, point2, point3);
	}
	
	module.exports = Plane;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/layout/object.js',
function (require, exports, module) {
	
const Lookup = require('../../../../../public/js/utils/object/lookup.js');
	const Vertex3D = require('../../three-d/objects/vertex.js');
	const Vertex2d = require('../../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const SnapSquare = require('../../../../../public/js/utils/canvas/two-d/objects/snap/square.js');
	
	class Bridge2dTo3D {
	  constructor(obj3D, xCoord, xDem, yCoord, yDem) {
	    const axis = 'z' !== xCoord && 'z' !== yCoord ? 'z' :
	                  ('x' !== xCoord && 'x' !== yCoord ? 'x' : 'y');
	    function setXYZ(x, y, z) {
	      if (x instanceof Vertex2d) {
	        y = x.y();
	        x = x.x();
	      }
	      if (x instanceof Vertex3D) {
	        y = x.y;
	        zs = x.z;
	        x = x.x;
	      }
	      const center3D = obj3D.center();
	      let updated = false;
	      if (x !== undefined) {
	        center3D[xCoord] = x;
	        updated = true;
	      }
	      if (y !== undefined) {
	        center3D[yCoord] = y;
	        updated = true;
	      }
	      if (z !== undefined) {
	        center3D[axis] = z;
	        updated = true;
	      }
	
	      if (updated) {
	        obj3D.center(center3D);
	      }
	      return obj3D.center();
	    }
	
	    this.layout = obj3D.layout;
	    this.id = obj3D.id;
	    this.name = obj3D.name;
	    this.x = (x) => setXYZ(x)[xCoord];
	    this.y = (y) => setXYZ(undefined, y)[yCoord];
	    this.center = (newCenter) => {
	      const center3D = setXYZ(newCenter);
	      return new Vertex2d(center3D[xCoord], center3D[yCoord]);
	    }
	    this.fromFloor = (distance) => setXYZ(undefined, undefined, distance)[axis];
	    this.fromCeiling = (distance) => {
	      const fromFloor = this.fromFloor();
	      const ceilh = obj3D.layout().ceilingHeight();
	      const height = obj3D.height();
	      if (Number.isFinite(distance)) {
	        const fromFloor = ceilh - height - distance;
	        this.fromFloor(fromFloor);
	      }
	      return ceilh - (this.fromFloor() + height);
	    }
	    this.height = (value) => {
	      if(value) obj3D[yDem](value);
	      return obj3D[yDem]();
	    }
	    this.width = (value) => {
	      if(value) obj3D[xDem](value);
	      return obj3D[xDem]();
	    }
	    this.radians = (rads) => {
	      if (rads !== undefined && rads > 0) {
	        console.log('rads:', this.radians());
	      }
	      const rotation = obj3D.rotation();
	      if (rads !== undefined) {
	        const radDiff = rads - Math.toRadians(rotation[axis]);
	        rotation[axis] = Math.toDegrees(rads);
	        obj3D.rotation(rotation);
	      }
	      return Math.toRadians(rotation[axis]);
	    }
	    this.angle = (angle) => {
	      if (angle !== undefined) this.radians(Math.toRadians(angle));
	      return Math.toDegrees(this.radians());
	    }
	    this.rotate = (rads) => this.radians(rads + Math.toRadians(obj3D.rotation()[axis]));
	  }
	}
	
	class Object3D extends Lookup {
	  constructor(layout, payload) {
	    // super(undefined, undefined, true);
	    super();
	    this.layout = () => layout;
	    this.snap2d = {};
	    this.bridge = {};
	    Object.getSet(this, {center: new Vertex3D(),
	                          height: 34*2.54,
	                          width: 32*2.54,
	                          thickness: 24*2.54,
	                          rotation: {x: 0, y: 0, z:0},
	                          name: ``});
	
	    this.payload = () => payload;
	
	    // Consider simplifying bridge, should only need the rotation axis as argument;
	
	    this.bridge.top = () => new Bridge2dTo3D(this, 'x', 'width', 'z', 'thickness');
	    let topview = new SnapSquare(this.bridge.top(), 10);
	    this.snap2d.top = () => topview;
	    this.shouldSave = () => true;
	
	    this.toString = () => `${this.constructor.name}: at${this.center()} ${payload}`;
	  }
	}
	
	const objectClasses = [Object3D];
	
	Object3D.register = (clazz) => {
	  objectClasses.push(clazz);
	}
	
	Object3D.new = (...args) => {
	  for (let index = objectClasses.length - 1; index > -1; index--) {
	    const object = new (objectClasses[index])(...args);
	    if (object) return object;
	  }
	  throw new Error('something went wrong...');
	}
	
	new Object3D();
	module.exports = Object3D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/matrix.js',
function (require, exports, module) {
	
const Approximate = require('../../../../../public/js/utils/approximate.js');
	const Tolerance = require('../../../../../public/js/utils/tolerance.js');
	const FixedValue = require('./fixed-value');
	const within = Tolerance.within(.0001);
	
	const withinTight = Tolerance.within(.000000001);
	const isZero = (val) => withinTight(val, 0);
	
	function findRowColumnCount (array) {
	  let rows = array.length;
	  let columns = array[0].length;
	  for (let i = 0; i < array.length; i++) {
	    const row = array[i];
	    columns = row.length > columns ? row.length : columns;
	  }
	  return {rows, columns};
	}
	
	function columnValidator (min, max) {
	  return (target, key, value) => {
	    if (key > max || key < min) {
	      throw new Error('An assignment error was made or you need to resize your matrix');
	    }
	    if ((typeof value) !== 'number' && !(value instanceof Number)) {
	      throw new Error('Matrix must be filled with numbers');
	    }
	    target[key] = value;
	    return true;
	  }
	}
	
	function rowValidator () {
	  return (target, key, value) => {
	    if (Number.isNaN(Number.parseInt(key))) {
	      throw new Error('You do not have access to the numerical attributes of a Matrix object, they are reserved for rows and cannot be modified');
	    }
	    target[key] = value;
	    return true;
	  }
	}
	
	class Matrix extends Array {
	  constructor(values, rows, columns) {
	    super();
	    if (!rows || !columns) {
	      const max = findRowColumnCount(values);
	      if (!rows) rows = max.rows;
	      if (!columns) columns = max.columns;
	    }
	
	    for (let i = 0; i < rows; i +=1) {
	      this[i] = new Proxy([], { set: columnValidator(0, columns) });
	      for (let j = 0; j < columns; j ++) {
	        const value = values && values[i] && values[i][j];
	        this[i][j] = !value ? 0 : value;
	      }
	    }
	
	    new Proxy(this, {set: rowValidator()});
	
	    this.rows = () => rows;
	    this.columns = () => columns;
	
	    this.remove = (rowIndex, columnIndex) => {
	      if ((typeof rowIndex) !== 'number') rowIndex = Number.MAX_SAFE_INTEGER;
	      else rowIndex = Math.mod(rowIndex, rows);
	      if ((typeof columnIndex) !== 'number') columnIndex = Number.MAX_SAFE_INTEGER;
	      else columnIndex = Math.mod(columnIndex, columns);
	
	      const rowLimit = rowIndex > -1 && rowIndex < rows ? rows - 1 : rows;
	      const columnLimit = columnIndex > -1 && columnIndex < columns ? columns - 1 : columns;
	      let matrix = new Matrix(null, rowLimit, columnLimit);
	      for (let i = 0; i < rows; i++) {
	        if (i !== rowIndex) {
	          const rowI = i < rowIndex ? i : i - 1;
	          for (let j = 0; j < columns; j++) {
	            if (j !== columnIndex) {
	              const columnJ = j < columnIndex ? j : j - 1;
	              matrix[rowI][columnJ] = this[i][j];
	            }
	          }
	        }
	      }
	      return matrix;
	    }
	
	    this.replaceRow = (rowIndex, values) => {
	      rowIndex = Math.mod(rowIndex, rows);
	
	      for (let j = 0; j < columns; j++) {
	        this[rowIndex][j] = values[j];
	      }
	    }
	
	    this.replaceColumn = (columnIndex, values) => {
	      columnIndex = Math.mod(columnIndex, rows);
	
	      for (let i = 0; i < rows; i++) {
	        this[i][columnIndex] = values[i];
	      }
	    }
	
	    this.minor = (index) => {
	      return this.remove(0, index);
	    }
	
	    this.toArray = () => JSON.copy(this);
	
	    const nonZeroIndex = (cIndex, matrix, startRowIndex) => {
	      for (let index = startRowIndex; index < rows; index++) {
	        if (!isZero(matrix[index][cIndex])) return index;
	      }
	      return null;
	    }
	
	    this.fixedColumns = () => {
	      const fixed = [];
	      let found = false;
	      for (let cIndex = 0; cIndex < columns; cIndex++) {
	        let firstVal = this[0][cIndex];
	        let isFixed = true;
	        for (let rIndex = 1; isFixed && rIndex < rows; rIndex++) {
	          isFixed = within(firstVal, this[rIndex][cIndex]);
	        }
	        if (isFixed === true) found = true;
	        fixed[cIndex] = isFixed;
	      }
	      if (found) return fixed;
	      return null;
	    }
	
	    this.square = () => this.rows() === this.columns();
	
	    this.solvable = () => {
	      const uniqRows = this.uniqueRows();
	      if (!uniqRows.square()) return false;
	      const rref = this.rowEchelon(true);
	      return rref.equals(Matrix.identity(uniqRows.rows()));
	    }
	
	    this.uniqueRows = () => {
	      const unique = [];
	      for (let index = 0; index < rows; index++) {
	        let isUnique = true;
	        for (let uRow = 0; uRow < unique.length; uRow++) {
	          let same = true;
	          for (let uCol = 0; uCol < columns; uCol++) {
	            if (!within(unique[uRow][uCol], this[index][uCol]))
	              same = false;
	          }
	          if (same) isUnique = false;
	        }
	        if (isUnique)  unique.push(Array.from(this[index]));
	      }
	      return new Matrix(unique);
	    }
	
	    function eliminateConfusion(matrix) {
	      for(let cIndex = 0; matrix.rows() > matrix.columns() && cIndex < matrix.columns(); cIndex++) {
	        let values = {};
	        for(let rIndex = 0; rIndex < matrix.rows(); rIndex++) {
	          if (values[matrix[rIndex][cIndex]] !== undefined) {
	            matrix = matrix.remove(rIndex);
	            break;
	          } else values[matrix[rIndex][cIndex]] = true;
	        }
	      }
	      while(matrix.rows() > matrix.columns()) matrix = matrix.remove(matrix.rows()-1);
	      return matrix;
	    }
	
	    this.properDemension = () => {
	      const info = {fixedValues: []};
	      let rowReduced = this.uniqueRows();
	      const fixedColumns = rowReduced.fixedColumns();
	      for (let index = columns; fixedColumns && index >= 0; index--) {
	         if (fixedColumns[index]) {
	           info.fixedValues[index] = new FixedValue(rowReduced[0][index], index);
	           rowReduced = rowReduced.remove(null, index);
	         }
	      }
	      info.matrix = eliminateConfusion(rowReduced);
	      return info;
	    }
	
	    this.rowEchelon = (reduced) => {
	      const echelon = this.toArray();
	      let pivot = 0;
	      for (let rIndex = 0; pivot < columns && rIndex < rows; rIndex++) {
	        const eRow = echelon[rIndex];
	        const firstValidIndex = nonZeroIndex(pivot, echelon, rIndex);
	        if (firstValidIndex !== rIndex) {
	          if (firstValidIndex === null) pivot++;
	          else echelon.swap(rIndex, firstValidIndex);
	          rIndex--;
	        } else {
	          let startIndex = rIndex;
	          if (reduced) {
	            startIndex = 0;
	            eRow.scale(1/eRow[pivot]);
	          }
	          const pivotValue = eRow[pivot];
	          for (let r2Index = startIndex; r2Index < rows; r2Index++) {
	            if (r2Index !== rIndex) {
	              const row = echelon[r2Index];
	              if (row[pivot] !== 0) {
	                const pivotRatio = row[pivot] / -pivotValue;
	                row.add((val, index) => pivotRatio * eRow[index]);
	              }
	            }
	          }
	        }
	      }
	
	      return new Matrix(echelon);
	    }
	
	    const bigEnough = (val) => Math.abs(val) > .00000001;
	    this.consise = () => {
	      const removedColumns = [];
	      let consiseMatrix = this.copy();
	      for (let j = columns - 1; j > -1; j--) {
	        // const initialValue = this[0][j];
	        let notZero = false;
	        for (let i = 0; i < rows; i++) {
	            notZero ||= bigEnough(this[i][j]);
	        }
	        if (!notZero) {
	          removedColumns.push(j);
	          consiseMatrix = consiseMatrix.remove(undefined, j);
	        }
	      }
	
	      const changes = [];
	      const keepRows = [consiseMatrix[0]];
	      const moreInfo = (row) => {
	        for (let i = 0; i < keepRows.length; i++) {
	          const kRow = keepRows[i];
	          for (let j = 0; j < kRow.length; j++) {
	            if (!changes[j] && !within(kRow[j], row[j])) {
	              changes[j] = true;
	              keepRows.push(row);
	              return;
	            }
	          }
	        }
	      }
	      for (let i = 1; keepRows.length < keepRows[0].length && i < rows; i++) {
	        const row = consiseMatrix[i];
	        if (keepRows.equalIndexOf(row) === -1) moreInfo(row);
	      }
	      return {removedColumns, matrix:  new Matrix(keepRows)};
	    }
	
	    this.determinate = () => {
	      if (rows === 2) return this[0][0] * this[1][1] - this[0][1] * this[1][0];
	
	      let sign = 1;
	      let sum = 0;
	      let colNum = 0;
	      while (colNum < columns) {
	        const minor = this.minor(colNum);
	        const determinate = minor.determinate();
	        sum += this[0][colNum++] * determinate * sign;
	        sign *= -1;
	      }
	      return sum;
	    }
	
	    this.solve2 = (answer) => {
	      const consiseObj = this.consise();
	      const consiseMatrix = consiseObj.matrix;
	      const removedColumns = consiseObj.removedColumns;
	      const solution = new Matrix(null, columns, 1);
	      answer ||= new Array(columns).fill(0);
	      let consiseIndex = 0;
	      const determinate = consiseMatrix.determinate();
	      for (let j = 0; j < columns; j++) {
	        let value;
	        if (removedColumns.indexOf(j) !== -1) value = 0;
	        else {
	          const matrix = consiseMatrix.copy()
	          matrix.replaceColumn(consiseIndex++, answer);
	          const matrixDeterminate = matrix.determinate();
	          value = matrixDeterminate / determinate;
	        }
	        solution[j][0] = value;
	      }
	      return solution;
	    }
	
	    this.solve = (answer) => {
	      const properDemension = this.properDemension();
	      const matrix = properDemension.matrix;
	      const fixedValues = properDemension.fixedValues;
	      const solution = new Matrix(null, columns, 1);
	      answer ||= new Array(columns).fill(0);
	      let consiseIndex = 0;
	      const determinate = matrix.determinate();
	      for (let j = 0; j < columns; j++) {
	        let value;
	        if (fixedValues[j] !== undefined) value = fixedValues[j];//new Number(fixedValues[j]);
	        else {
	          const detMat = matrix.copy()
	          detMat.replaceColumn(consiseIndex++, answer);
	          const matrixDeterminate = detMat.determinate();
	          value = matrixDeterminate / determinate;
	        }
	        solution[j][0] = value;
	      }
	      return solution;
	    }
	
	    this.dot = (other) => {
	      if (this.columns() !== other.rows()) throw new Error('this.columns() and other.rows() much match for a dot product');
	      const result = new Matrix(null, this.rows(), other.columns());
	      let ri = 0;
	      let rj = 0;
	      for (let i = 0; i < rows; i++) {
	        for (let oj = 0; oj < other.columns(); oj++) {
	          let value = 0;
	          for (let j = 0; j < columns; j++) {
	            value = value + this[i][j] * other[j][oj];
	          }
	          result[i][oj] = value;
	        }
	      }
	      return result;
	    }
	
	    this.scale = (coef, oddOnly) => {
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < columns; j++) {
	          if (!oddOnly || (i + j) % 2 === 1) {
	            this[i][j] = this[i][j] * coef;
	          }
	        }
	      }
	    }
	
	    this.approximate = (accuracy) => {
	      const approximate = Approximate.new(accuracy);
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < columns; j++) {
	          this[i][j] = approximate(this[i][j]);
	        }
	      }
	    }
	
	    this.transpose = () => {
	      const rows = this.rows();
	      const cols = this.columns();
	      const result = new Matrix(null, cols, rows);
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < cols; j++) {
	          result[j][i] = this[i][j];
	        }
	      }
	      return result;
	    }
	
	    this.diagonal = () => {
	      const rows = this.rows();
	      const cols = this.columns();
	      const result = new Matrix(null, cols, rows);
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < cols; j++) {
	          if (i + j !== rows - 1) {
	            result[rows - i - 1][cols - j - 1] = this[i][j];
	          } else {
	            result[i][j] = this[i][j];
	          }
	        }
	      }
	      return result;
	    }
	
	    this.multiply = (other) => {
	      const result = new Matrix(null, this.rows(), other.columns());
	      for (let i = 0; i < this.rows(); i++) {
	        for (let j = 0; j < this.columns(); j++) {
	          let sum = 0
	          for (let k = 0; k < other.rows(); k++) {
	            sum = sum + this[i][k] * other[k][j]
	            result[i][j] = sum
	          }
	        }
	      }
	      return result;
	    }
	
	    this.inverse = () => {
	      let inverse;
	      if (this.rows() === 2) {
	        inverse = this.diagonal();
	        inverse.scale(-1, true);
	        inverse.scale(1/this.determinate());
	        return inverse;
	      }
	
	      const rows = this.rows();
	      const cols = this.columns();
	      inverse = new Matrix(null, rows, columns);
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < cols; j++) {
	          const minor = this.remove(i, j);
	          const value = minor.determinate();
	          inverse[i][j] = value;
	        }
	      }
	      inverse.scale(-1, true);
	      inverse = inverse.transpose();
	      inverse.scale(1/this.determinate());
	      return inverse;
	    }
	
	    this.toString = (formatFunc) => {
	      const maxLen = {before: 1, after: 0};
	      formatFunc ||= (val) => val;
	      const format = (val) => {
	        val = `${formatFunc(val)}`;
	        const decimalIndex = val.indexOf('.');
	        let spaceBefore, spaceAfter;
	        if (decimalIndex === -1) {
	          spaceBefore = new Array(maxLen.before - val.length).fill(' ').join('');
	          spaceAfter = new Array(maxLen.after).fill(' ').join('');
	        } else {
	          spaceBefore = new Array(maxLen.before - decimalIndex).fill(' ').join('');
	          spaceAfter = new Array(maxLen.after - (val.length - decimalIndex)).fill(' ').join('');
	        }
	        return `${spaceBefore}${val}${spaceAfter}`;
	
	      }
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < columns; j++) {
	          let string = `${formatFunc(this[i][j])}`;
	          const decimalIndex = string.indexOf('.');
	          if (decimalIndex === -1) {
	            if (string.length > maxLen.before) maxLen.before = string.length;
	          } else {
	            const beforeLen = decimalIndex;
	            if (beforeLen > maxLen.before) maxLen.before = beforeLen;
	            const afterLen = string.length + 1 - decimalIndex;
	            if (afterLen > maxLen.after) maxLen.after = afterLen;
	          }
	        }
	      }
	
	      let str = '';
	      for (let i = 0; i < rows; i++) {
	        str += '|'
	        for (let j = 0; j < columns; j++) {
	          str += `${format(this[i][j])}`;
	        }
	        str += '|\n'
	      }
	      return str.substring(0, str.length - 1);
	    }
	
	    this.approxToString = (accuracy) => {
	      const approximate = Approximate.new(accuracy);
	      return this.toString((val) => approximate(val));
	    }
	
	    this.equals = (other) => {
	      if (other.rows() !== rows || other.columns() !== columns) return false;
	      for (let i = 0; i < rows; i++) {
	        for (let j = 0; j < columns; j++) {
	          if (!within(other[i][j], this[i][j])) return false;
	        }
	      }
	      return true;
	    }
	
	    this.copy = () => new Matrix(this);
	
	  }
	}
	
	Matrix.identity = (rows) => {
	  let identity = new Matrix(null, rows, rows);
	  for (let i = 0; i < rows; i++) {
	    for (let j = 0; j < rows; j++) {
	      if (i === j) identity[i][i] = 1;
	      else identity[i][j] = 0;
	    }
	  }
	  return identity;
	}
	
	Matrix.rotation = function (roll, pitch, yaw) {
	  if (roll instanceof Object) {
	    pitch = Math.toRadians(roll.y);
	    yaw = Math.toRadians(roll.z);
	    roll = Math.toRadians(roll.x);
	  }
	  roll ||= 0;
	  pitch ||= 0;
	  yaw ||= 0;
	  var cosa = Math.cos(yaw);
	  var sina = Math.sin(yaw);
	
	  var cosb = Math.cos(pitch);
	  var sinb = Math.sin(pitch);
	
	  var cosc = -1*Math.cos(roll);
	  var sinc = -1*Math.sin(roll);
	
	  var Axx = cosa*cosb;
	  var Axy = cosa*sinb*sinc - sina*cosc;
	  var Axz = cosa*sinb*cosc + sina*sinc;
	
	  var Ayx = sina*cosb;
	  var Ayy = sina*sinb*sinc + cosa*cosc;
	  var Ayz = sina*sinb*cosc - cosa*sinc;
	
	  var Azx = -sinb;
	  var Azy = cosb*sinc;
	  var Azz = cosb*cosc;
	
	  return new Matrix([
	    [Axx, Axy, Axz],
	    [Ayx, Ayy, Ayz],
	    [Azx, Azy, Azz],
	  ]);
	}
	
	Matrix.fromGL = (glMatrix) => {
	  return new Matrix( [[glMatrix[0], glMatrix[1], glMatrix[2], glMatrix[3]],
	                      [glMatrix[4], glMatrix[5], glMatrix[6], glMatrix[7]],
	                      [glMatrix[8], glMatrix[9], glMatrix[10],  glMatrix[11]],
	                      [glMatrix[12], glMatrix[13], glMatrix[14],  glMatrix[15]]]);
	}
	
	Matrix.fromVertex = (vertex) => {
	  return new Matrix( [[vertex.x],
	                      [vertex.y],
	                      [vertex.z],
	                      [1]]);
	}
	
	Matrix.mapObjects = (objects, attrs) => {
	  const matrix = new Matrix(null, attrs.length, attrs.length);
	  const val = (funcOval) => (typeof funcOval) === 'function' ? funcOval() : funcOval;
	  for (let i = 0; i < objects.length; i++) {
	    const obj = objects[i];
	    for (let j = 0; j < attrs.length; j++) {
	      matrix[i][j] = Function.orVal(obj[attrs[j]]);
	    }
	  }
	  return matrix;
	}
	
	module.exports = Matrix;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/layout/init.js',
function (require, exports, module) {
	
const Object3D = require('./object');
	const Assembly3D = require('./objects/assembly');
	
	Object3D.register(Assembly3D);
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/line.js',
function (require, exports, module) {
	
const Vector3D = require('./vector');
	const Vertex3D = require('./vertex');
	const Line2d = require('../../../../../public/js/utils/canvas/two-d/objects/line');
	const Plane = require('./plane');
	const FixedValue = require('./fixed-value');
	const withinTol = new (require('../../../../../public/js/utils/tolerance.js'))(.00000001).within;
	
	const zero = (val) => {
	  if (withinTol(val, 0)) return 0
	  return val;
	}
	
	// TODO: It would be nice if this[0] === this.startvertex && this[1] === endVertex
	class Line3D {
	  constructor(startVertex, endVertex) {
	    if (startVertex === undefined || endVertex === undefined) throw new Error('Lines must have a start and an end point');
	    this.startVertex = new Vertex3D(startVertex);
	    this.endVertex = new Vertex3D(endVertex);
	    const instance = this;
	
	    this.clone = () => new Line3D(this.startVertex.clone(), this.endVertex.clone());
	
	    this.negitive = () => new Line3D(this.endVertex, this.startVertex);
	    this.equals = (other) => this.startVertex && this.endVertex && other &&
	        this.startVertex.equals(other.startVertex) && this.endVertex.equals(other.endVertex);
	    this.vector = () => {
	      let i = this.endVertex.x - this.startVertex.x;
	      let j = this.endVertex.y - this.startVertex.y;
	      let k = this.endVertex.z - this.startVertex.z;
	      return new Vector3D(i,j,k);
	    };
	
	    this.translate = (vector) => {
	      this.startVertex.translate(vector);
	      this.endVertex.translate(vector);
	    }
	
	    this.isPoint = () => this.startVertex.equals(this.endVertex);
	
	    this.planeAt = (rotation) => {
	      const two = new Vertex3D({x: this.startVertex.x + 1, y: this.startVertex.y, z: this.startVertex.z});
	      two.rotate(rotation, this.startVertex);
	      const three = {x: this.endVertex.x + 1, y: this.endVertex.y, z: this.endVertex.z};
	      thtee.rotate(rotation, this.endVertex);
	      return new Plane(this.startVertex.copy(), two, three, this.endVertex.copy());
	    }
	
	    this.on = (vertex, tolerance) => {
	      tolerance ||= .01;
	    }
	
	    const setCoef = (index, obj, t) => {
	      let offset = ((index + 1) % 3);
	      let coord = String.fromCharCode(offset + 120);
	      let coef = String.fromCharCode(offset + 97);
	      if (withinTol(instance.endVertex[coord], instance.startVertex[coord]))
	        obj[coef] = new FixedValue(instance.startVertex[coord]);
	      else
	        obj[coef] = (instance.endVertex[coord] - instance.startVertex[coord]) / t;
	    }
	
	    this.equation = () => {
	      const returnValue = {};
	      for (let i = 0; i < 3; i++) {
	        let coord = String.fromCharCode(i + 120);
	        let t = this.endVertex[coord] - this.startVertex[coord];
	        if (t !== 0) {
	          setCoef(i, returnValue, t);
	          setCoef(i + 1, returnValue, t);
	          setCoef(i + 2, returnValue, t);
	          break;
	        }
	      }
	      if (returnValue.a === undefined) throw new Error('This Line is a point... I think...');
	      return returnValue;
	    }
	
	    this.toString = () => `${new String(this.startVertex)} => ${new String(this.endVertex)}`;
	    this.toNegitiveString = () => `${new String(this.endVertex)} => ${new String(this.startVertex)}`;
	
	    this.midpoint = () => new Vertex3D(
	      (this.endVertex.x +this.startVertex.x) / 2,
	      (this.endVertex.y +this.startVertex.y) / 2,
	      (this.endVertex.z +this.startVertex.z) / 2
	    );
	
	    this.length = () => this.vector().magnitude();
	
	    this.fromStart = (distance) => this.startVertex.translate(this.vector().unit().scale(distance), true);
	    this.fromEnd = (distance) => this.endVertex.translate(this.vector().unit().scale(distance), true);
	
	    this.adjustLength = (change, fromStartVertex) => {
	      if ((typeof change) !== 'number' || change === 0) return;
	      const unitVec = this.vector().unit();
	      if (fromStartVertex !== undefined) {
	        if (fromStartVertex === true) {
	          this.endVertex.positionAt(this.startVertex.translate(unitVec.scale(change), true));
	        } else {
	          this.startVertex.positionAt(this.endVertex.translate(unitVec.scale(change), true));
	        }
	      } else {
	        const len = this.length();
	        const halfChangeMag = change/2;
	        const halfDistVec = unitVec.scale(halfChangeMag);
	       this.startVertex.translate(halfDistVec.inverse());
	       this.endVertex.translate(halfDistVec);
	      }
	    }
	
	    this.polarize = (vertex) => {
	      if (this.startVertex.distance(vertex) > this.endVertex.distance(vertex)) {
	        const temp = this.startVertex;
	        this.startVertex = this.endVertex;
	        this.endVertex = temp;
	      }
	      return this;
	    }
	
	    this.pointAtDistance = (distance) => {
	      const point =this.startVertex.copy();
	      const unitVec = this.vector().unit();
	      point.translate(unitVec.scale(distance));
	      return point;
	    }
	
	    // this.mirror = (degrees, vertices) => {
	    //   const axis =
	    //   for (let index = 0; index < vertices.length; index++) {
	    //     CSG.ArbitraryRotate(vert, degrees, axis);
	    //   }
	    // }
	
	    this.rotate = (rotation, center) => {
	      center ||= this.midpoint();
	     this.startVertex.rotate(rotation, center);
	     this.endVertex.rotate(rotation, center);
	    }
	
	    this.reverseRotate = (rotation, center) => {
	      center ||= this.midpoint();
	     this.startVertex.reverseRotate(rotation, center);
	     this.endVertex.reverseRotate(rotation, center);
	    }
	
	    this.to2D = (x,y) => Line3D.to2D([this], x, y)[0];
	
	    this.acquiescent = (trendSetter) => {
	      if (!(trendSetter instanceof Line2d)) return this;
	      const shouldReverse = trendSetter.endVertex.distance(this.endVertex) <
	                            trendSetter.endVertex.distance(this.startVertex);
	      if (shouldReverse) return this.negitive();
	      return this;
	    }
	  }
	}
	
	Line3D.vertices = (lines, true4startfalse4end) => {
	  const verts = [];
	  const includeBoth = true4startfalse4end !== true && true4startfalse4end !== false;
	  const includeStart = includeBoth || true4startfalse4end === true;
	  const includeEnd = includeBoth || true4startfalse4end === false;
	  for (let index = 0; index < lines.length; index += 1) {
	    if (includeStart) verts.push(lines[index].startVertex.copy());
	    if (includeEnd) verts.push(lines[index].endVertex.copy());
	  }
	  return verts;
	}
	
	Line3D.vertices1 = (lines) => {
	  const verts = [];
	  for (let index = 0; index < lines.length; index += 1) {
	    verts.push(lines[index].endVertex.copy());
	  }
	  return verts;
	}
	
	Line3D.adjustVertices = (vert1, vert2, change) => {
	  const line = new Line3D(vert1, vert2);
	  line.adjustLength(change);
	}
	
	Line3D.startAndVector = (startVertex, offsetVector) => {
	  const endVertex = startVertex.translate(offsetVector, true);
	  return new Line3D(startVertex, endVertex);
	}
	
	Line3D.to2D = (lines, x, y) => {
	  const lines2d = [];
	  for (let index = 0; index < lines.length; index++) {
	    const startV = lines[index].startVertex.to2D(x, y);
	    const endV = lines[index].endVertex.to2D(x, y);
	    lines2d.push(new Line2d(startV, endV));
	  }
	  return lines2d;
	}
	
	Line3D.fromVector = (vector, startVertex, rotation) => {
	  const sv = new Vertex3D(startVertex);
	  const ev = sv.translate(vector, true)
	  const line = new Line3D(sv, ev);
	  if (rotation) line.rotate(rotation);
	  return line;
	}
	
	Line3D.viewFromVector = (lines, vector) => {
	  const orthoLines = [];
	  for (let p = 0; p < lines.length; p++) {
	    const startVert = lines[p].startVertex;
	    const endVert = lines[p].endVertex;
	    const orthoVerts = Vertex3D.viewFromVector([startVert, endVert], vector);
	    orthoLines.push(new Line3D(orthoVerts[0], orthoVerts[1]));
	  }
	  return orthoLines;
	}
	
	
	Line3D.reverse = (list) => {
	  let reversed = [];
	  for (let index = list.length - 1; index > -1; index--) {
	    reversed.push(list[index].negitive());
	  }
	  return reversed;
	}
	
	Line3D.centerFurthestFrom = (vertex, list) => {
	  let furthest;
	  for (let index = 1; index < list.length; index++) {
	    const line = list[index];
	    const dist = list[index].midpoint().distance(vertex);
	    if (!furthest || furthest.dist < dist) furthest = {line, dist};
	  }
	  return closest;
	}
	
	Line3D.centerClosestTo = (vertex, list) => {
	  let closest;
	  for (let index = 1; index < list.length; index++) {
	    const line = list[index];
	    const dist = list[index].midpoint().distance(vertex);
	    if (!closest || closest.dist > dist) closest = {line, dist};
	  }
	  return closest.line;
	}
	
	Line3D.endpointClosestTo = (vertex, list) => {
	  let closest;
	  for (let index = 1; index < list.length; index++) {
	    const line = list[index];
	    const sdist = list[index].endVertex.distance(vertex);
	    const edist = list[index].startVertex.distance(vertex);
	    const dist = sdist < edist ? sdist : edist;
	    if (!closest || closest.dist > dist) closest = {line, dist};
	  }
	  return closest.line;
	}
	
	Line3D.sharedEndpoint = (...lines) => {
	  const vertices = Line3D.vertices(lines);
	  if (vertices.length === 2) return vertices;
	  for (let index = 0; index < vertices.length; index++) {
	    const vertex = vertices[index];
	    let existsInAll = true;
	    for (let lIndex = 0; existsInAll && lIndex > lines.length; lIndex++) {
	      const line = lines[lIndex];
	      const startEq = line.startVertex.equals(vertex);
	      const endEq = line.endVertex.equals(vertex);
	      existsInAll = startEq || endEq;
	    }
	    if (existsInAll) return vertex;
	  }
	  return null;
	}
	
	module.exports = Line3D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/bi-polygon.js',
function (require, exports, module) {
	
const CSG = require('../../../public/js/3d-modeling/csg.js');
	const Line3D = require('line');
	const Vector3D = require('vector');
	const Vertex3D = require('vertex');
	const Polygon3D = require('polygon');
	const Plane = require('plane');
	
	class BiPolygon {
	  constructor(polygon1, polygon2) {
	    const face1 = polygon1.vertices();
	    const face2 = polygon2.vertices();
	    const instance = this;
	    if (face1.length !== face2.length) throw new Error('Polygons need to have an equal number of vertices');
	
	    let normal = {};
	    function calcNormal() {
	      if (normal === undefined) {
	        const pNorm1 = polygon1.normal();
	        const pNorm1I = pNorm1.inverse();
	        const center1 = polygon1.center();
	        const center2 = polygon2.center();
	        const cOffsetNorm = center1.translate(pNorm1, true);
	        const cOffsetNormI = center1.translate(pNorm1I, true);
	        normal.front = cOffsetNorm.distance(center2) > cOffsetNormI.distance(center2) ?
	            cOffsetNorm : cOffsetNormI;
	        const topApproxVector = face2[3].distanceVector(face2[0]).unit();
	        const normVert = new Vertex3D(normal.front);
	        normVect.rotate({x:1,y:0,z:0});
	      }
	      return normal;
	    }
	
	    this.copy = () => new BiPolygon(polygon1.copy(), polygon2.copy());
	
	    this.front = () => new Polygon3D(face1);
	    this.back = () => new Polygon3D(face2);
	
	    this.faceNormal = (index) => face2[index || 0].distanceVector(face1[index || 0]).unit();
	
	    this.normal = () => this.flippedNormal() ? polygon1.normal() : polygon1.normal().inverse();
	    this.normalTop = () => polygon1.lines()[1].vector().unit().inverse();
	    this.normalRight = () => this.normalTop().crossProduct(this.normal()).unit().inverse();
	
	    this.normals = () => ({
	      top: this.normalTop(),
	      front: this.normal(),
	      right: this.normalRight()
	    });
	
	    this.furthestOrder = (vertex) => {
	      const front = this.front();
	      const back = this.back();
	      return front.center().distance(vertex) > back.center().distance(vertex) ?
	              [front, back] : [back, front];
	    }
	
	    this.closestOrder = (vertex) => this.furthestOrder(vertex).reverse();
	
	    this.translate = (vector) => {
	      for (let index = 0; index < face1.length; index++) {
	        face1[index].translate(vector);
	        face2[index].translate(vector);
	      }
	    }
	
	    this.center = (newCenter) => {
	      if (!(newCenter instanceof Vertex3D))
	        return new Vertex3D(Math.midrange(face1.concat(face2), ['x', 'y', 'z']));
	      const center = this.center();
	      this.translate(newCenter.minus(center));
	      return this.center();
	    }
	
	    this.closerPlane = (vertex) => {
	      const poly1 = new Plane(...face1);
	      const poly2 = new Plane(...face2);
	      return poly1.center().distance(vertex) < poly2.center().distance(vertex) ? poly1 : poly2;
	    }
	
	    this.furtherPlane = (vertex) => {
	      const poly1 = new Plane(...face1);
	      const poly2 = new Plane(...face2);
	      return poly1.center().distance(vertex) > poly2.center().distance(vertex) ? poly1 : poly2;
	    }
	
	    this.flippedNormal = () => {
	      const face1Norm = new Polygon3D(face1).normal();
	      return this.faceNormal().sameDirection(face1Norm);
	    }
	
	
	    function normalize (verts, reverse) {
	      const normal =  new Polygon3D(verts).normal().toArray();
	      const returnValue = [];
	      for (let index = 0; index < verts.length; index++)
	        returnValue[index] = new CSG.Vertex(verts[index], normal);
	      return reverse ? returnValue.reverse() : returnValue;
	    }
	
	    this.toModel = () => {
	      const flippedNormal = this.flippedNormal();
	      const front = new CSG.Polygon(normalize(face1, !flippedNormal));
	      front.plane.normal = front.vertices[0].normal.clone();//new CSG.Vector([0,1, 0,0]);
	      const back = new CSG.Polygon(normalize(face2, flippedNormal));
	      back.plane.normal = back.vertices[0].normal.clone();//new CSG.Vector([0,0,1,0,0]);
	      const polygonSets = [front, back];
	
	      for (let index = 0; index < face1.length; index++) {
	        const index2 = (index + 1) % face1.length;
	         const vertices = [face1[index], face1[index2], face2[index2], face2[index]];
	         const normalized = normalize(vertices, flippedNormal);
	         polygonSets.push(new CSG.Polygon(normalized));
	         polygonSets[polygonSets.length - 1].plane.normal = normalized[0].normal.clone();
	      }
	
	      const polys = CSG.fromPolygons(polygonSets);
	      polys.normals = {
	        front: this.normal(),
	        right: this.normalRight(),
	        top: this.normalTop()
	      }
	      return polys;
	    }
	
	    this.toPolygons = () => {
	      const polygons = [new Polygon3D(face1), new Polygon3D(face2)];
	
	      for (let index = 0; index < face1.length; index++) {
	        const index2 = (index + 1) % face1.length;
	         const vertices = [face1[index], face1[index2], face2[index2], face2[index]];
	         polygons.push(new Polygon3D(vertices));
	      }
	      return polygons;
	    }
	
	    this.to2D = (vector) => {
	      return Polygon3D.toTwoD([this.front(), this.back()], vector);
	    }
	
	
	    this.toString = () => {
	      let face1Str = '';
	      let face2Str = '';
	      for (let index = 0; index < face1.length; index++) {
	        face1Str += `(${face1[index].toString()}), `;
	        face2Str += `(${face2[index].toString()}), `;
	      }
	      face1Str = face1Str.substring(0, face1Str.length - 2);
	      face2Str = face2Str.substring(0, face2Str.length - 2);
	      return `${face1Str}\n${face2Str}`;
	    }
	  }
	}
	
	BiPolygon.fromPolygon = (polygon, distance1, distance2, offset) => {
	  distance2 ||= 0;
	  const verts = polygon.vertices();
	  // if (verts.length < 4) return undefined;
	  if (verts.length < 3) return undefined;
	  const verts1 = JSON.clone(verts);
	  // TODO: consider moving
	  if (offset) {
	    Line3D.adjustVertices(verts1[0], verts1[1], offset.x);
	    Line3D.adjustVertices(verts1[1], verts1[2], offset.y);
	    Line3D.adjustVertices(verts1[2], verts1[3], offset.x);
	    Line3D.adjustVertices(verts1[3], verts1[0], offset.y);
	  }
	  const verts2 = JSON.clone(verts1);
	  const poly1 = (new Polygon3D(verts1)).parrelleAt(distance1);
	  const poly2 = (new Polygon3D(verts2)).parrelleAt(distance2);
	  return new BiPolygon(poly1, poly2);
	}
	
	BiPolygon.fromVectorObject =
	    (width, height, depth, center, vectorObj) => {
	      center ||= new Vertex3D(0,0,0);
	      vectorObj ||= {width: new Vector3D(1,0,0), height: new Vector3D(0,1,0), depth: new Vector3D(0,0,1)};
	      const frontCenter = center.translate(vectorObj.depth.scale(depth/-2), true);
	      const front = Polygon3D.fromVectorObject(width, height, frontCenter, vectorObj);
	      const backCenter = center.translate(vectorObj.depth.scale(depth/2), true);
	      const back = Polygon3D.fromVectorObject(width, height, backCenter, vectorObj);
	      return new BiPolygon(front, back);
	}
	
	module.exports = BiPolygon;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/models/pull.js',
function (require, exports, module) {
	

	const CSG = require('../../../public/js/3d-modeling/csg');
	const Polygon3D = require('../objects/polygon.js');
	const BiPolygon = require('../objects/bi-polygon.js');
	
	function pull(length, height) {
	  var rspx = length - .75;
	  var h = height-.125;
	  var gerth = 2.54/4;
	  // var rCyl = CSG.cylinder({start: [rspx, .125, .125-height], end: [rspx, .125, .125], radius: .25})
	  // var lCyl = CSG.cylinder({start: [.75, .125, .125 - height], end: [.75, .125, .125], radius: .25})
	  // var mainCyl = CSG.cylinder({start: [0, .125, .125], end: [length, .125, .125], radius: .25})
	  var rCyl = CSG.cube({demensions: [gerth, gerth, h], center: [rspx/2, 0, h/-2]});
	  var lCyl = CSG.cube({demensions: [gerth, gerth, h], center: [rspx/-2, 0, h/-2]});
	  var mainCyl = CSG.cube({demensions: [length, gerth, gerth], center: [0, 0, 0]});
	
	  return mainCyl.union(lCyl).union(rCyl);
	}
	
	function getVectorObj(line, normal) {
	  const midNormOffset = line.midpoint().translate(normal);
	  const lineNormPoly = new Polygon3D([line.startVertex.copy(), line.endVertex.copy(), midNormOffset]);
	  return {
	    depth: normal,
	    width: line.vector().unit(),
	    height: lineNormPoly.normal(),
	  };
	}
	
	function pull(baseCenter, line, normal, projection, cTOc) {
	  var gerth = 2.54/4;
	  let length = cTOc + gerth;
	  const vecObj = getVectorObj(line, normal);
	
	  let sideProjection = projection - gerth;
	  const centerRL = baseCenter.translate(vecObj.depth.scale(sideProjection/2), true);
	  const centerLeft = centerRL.translate(vecObj.width.scale(cTOc/-2), true);
	  const centerRight = centerRL.translate(vecObj.width.scale(cTOc/2), true);
	  const centerMain = baseCenter.translate(vecObj.depth.scale(projection - gerth/2));
	
	  var lCyl = BiPolygon.fromVectorObject(gerth, gerth, sideProjection, centerLeft, vecObj);
	  var rCyl = BiPolygon.fromVectorObject(gerth, gerth, sideProjection, centerRight, vecObj);
	  var mainCyl = BiPolygon.fromVectorObject(length, gerth, gerth, centerMain, vecObj);
	
	  return mainCyl.toModel().union(lCyl.toModel()).union(rCyl.toModel());
	}
	
	function simple(baseCenter, line, normal, projection, cTOc) {
	  var gerth = 2.54/4;
	  let length = cTOc + gerth;
	  const vecObj = getVectorObj(line, normal);
	
	  let sideProjection = projection - gerth;
	  const center = baseCenter.translate(vecObj.depth.scale((sideProjection + gerth) /2), true);
	
	  return BiPolygon.fromVectorObject(length, gerth, projection, center, vecObj).toModel();
	}
	
	pull.simple = simple;
	
	module.exports = pull
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/models/drawer-box.js',
function (require, exports, module) {
	

	const CSG = require('../../../public/js/3d-modeling/csg');
	const Polygon3D = require('../objects/polygon.js');
	const BiPolygon = require('../objects/bi-polygon.js');
	
	function drawerBox(length, width, depth) {
	  const bottomHeight = 7/8;
	  const box = CSG.cube({demensions: [width, length, depth], center: [0,0,0]});
	  box.setColor(1, 0, 0);
	  const inside = CSG.cube({demensions: [width-1.5, length, depth - 1.5], center: [0, bottomHeight, 0]});
	  inside.setColor(0, 0, 1);
	  const bInside = CSG.cube({demensions: [width-1.5, length, depth - 1.5], center: [0, (-length) + (bottomHeight) - 1/4, 0]});
	  bInside.setColor(0, 0, 1);
	
	  return box.subtract(bInside).subtract(inside);
	}
	
	function unionAll(...polygons) {
	  let model = polygons[0].toModel();
	  for (let index = 1; index < polygons.length; index++) {
	    model = model.union(polygons[index].toModel());
	  }
	  return model;
	}
	
	function drawerBox(frontPoly, normal, length, props) {
	  const sideThickness = props.dbst.value();
	  const bottomThickness = props.dbbt.value();
	  const bottomHeight = props.dbid.value();
	  const norm = normal;
	
	  // In order (front, (frontMoved), back, left, right, top, bottom) Polygon: vertices are if facing polygon topLeft, topRight, bottomRight, bottomLeft
	  const fP = frontPoly;
	  const fPm = fP.translate(norm.scale(-length));
	  const bP = new Polygon3D([fPm.vertex(1), fPm.vertex(0), fPm.vertex(3), fPm.vertex(2)]);
	  const lP = new Polygon3D([bP.vertex(1), fP.vertex(0), fP.vertex(3), bP.vertex(2)]);
	  const rP = new Polygon3D([fP.vertex(1), bP.vertex(0), bP.vertex(3), fP.vertex(2)]);
	  const tP = new Polygon3D([bP.vertex(1), bP.vertex(0), fP.vertex(1), bP.vertex(0)]);
	  const btmP = new Polygon3D([bP.vertex(2), bP.vertex(3), fP.vertex(2), fP.vertex(3)]);
	
	  const front = BiPolygon.fromPolygon(fP, 0, sideThickness);
	  const back = BiPolygon.fromPolygon(bP, 0, sideThickness);
	  const left = BiPolygon.fromPolygon(lP, 0, sideThickness);
	  const right = BiPolygon.fromPolygon(rP, 0, sideThickness);
	  const bottom = BiPolygon.fromPolygon(btmP, -bottomHeight, -bottomHeight-bottomThickness);
	  return unionAll(front, back, left, right, bottom);
	}
	module.exports = drawerBox
	
});


RequireJS.addFunction('./services/cabinet/app-src/config/property/config.js',
function (require, exports, module) {
	
const Properties = require('../properties');
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	const IMPERIAL_US = Measurement.units()[1];
	
	class PropertyConfig {
	  constructor(props) {
	    Object.getSet(this);
	    props = props || Properties.instance();
	    let style = props.style || PropertyConfig.lastStyle;
	    let styleName = props.styleName || PropertyConfig.lastStyleName ||
	                    Object.keys(Properties.groupList(style))[0];
	    if (styleName)
	      props[style] = Properties.getSet(style, styleName);
	
	    function isReveal() {return style === 'Reveal';}
	    function isInset() {return style === 'Inset';}
	    function isOverlay() {return !isReveal() && !isInset();}
	    function overlay() {return props['Overlay'].ov.value()}
	    function reveal() {return props['Reveal']};
	    function wallHeight() {return props['baseh'] + props['basewallgap']}
	
	    function cabinetStyles() {
	      return ['Overlay', 'Inset', 'Reveal'];
	    }
	    function cabinetStyle() {
	      return style;
	    }
	    function cabinetStyleName() {
	      return styleName;
	    }
	
	    function set(group, name) {
	      if (cabinetStyles().indexOf(group) !== -1) {
	        style = group;
	        styleName = name;
	      } else {
	        const newSet = Properties.getSet(group, name);
	        newSet.__KEY = name;
	        if (newSet === undefined) throw new Error(`Attempting to switch '${group}' to unknown property set '${name}'`);
	        props[group] = newSet;
	      }
	    }
	
	    const panelThicknessRegMetric = /^pwt([0-9]{1,})([0-9][0-9])$/;
	    const panelThicknessRegImperial = /^pwt([0-9])([0-9])$/;
	    const resolvePanelThickness = (code) => {
	      let match = code.match(panelThicknessRegImperial);
	      if (match) return new Measurement(match[1]/match[2], IMPERIAL_US).value();
	      match = code.match(panelThicknessRegMetric);
	      if (match) return new Measurement(`${match[1]}.${match[2]}`).value();
	      return undefined;
	    }
	
	    const outerCodeReg = /^(rrv|lrv|brv|trv)$/;
	    const resolveOuterReveal = (code, props) => {
	      if (!code.match(outerCodeReg)) return undefined;
	      switch (code) {
	        case 'rrv':
	          return 0.3175
	        case 'lrv':
	          return 0.3175
	        case 'brv':
	          return 0.3175
	        case 'trv':
	          return 0.3175
	        default:
	          return 0.3175
	      }
	    }
	
	    const resolveStyleStatus = (code) => {
	      switch (code) {
	        case 'isReveal': return isReveal();
	        case 'isInset': return isInset();
	        case 'isOverlay': return isOverlay();
	      }
	    }
	
	    const resolveReveals = (code, props) => {
	      switch (code) {
	        case 'frorl': return new Measurement(1/8, IMPERIAL_US).value();
	        case 'frorr': return new Measurement(1/8, IMPERIAL_US).value();
	        case 'r': if (isInset()) return 0;
	          if (isReveal()) return new Measurement(props.Reveal.r.value()).value();
	          return new Measurement(props.Cabinet.frw.value() - 2 * props.Overlay.ov.value()).value();
	        default: return resolveCostProps(code, props);
	      }
	    }
	
	    const resolveComplexProps = (code, props) => {
	      if (code === undefined) return undefined;
	      let value = resolvePanelThickness(code, props);
	      if (value !== undefined) return value;
	      value = resolveOuterReveal(code, props);
	      if (value !== undefined) return value;
	      value = resolveStyleStatus(code);
	      // if (value !== undefined) return value;
	      // value = resolveReveals(code, props);
	      return value;
	    }
	
	    const excludeKeys = ['_ID', '_NAME', '_GROUP', 'properties'];
	    function getProperties(clazz, code) {
	      clazz = (typeof clazz) === 'string' ? clazz : clazz.constructor.name;
	      const classProps = props[clazz] || {};
	      if (code === undefined) return classProps;
	      return classProps[code] === undefined ? resolveComplexProps(code, props) : classProps[code].value();
	    }
	
	    function toJson() {
	      const json = {style, styleName};
	      const keys = Object.keys(props).filter((key) => key.match(/^[A-Z]/));
	      keys.forEach((key) => {
	        json[key] = [];
	        const propKeys = Object.keys(props[key]);
	        propKeys.forEach((propKey) => {
	          if (props[key][propKey] && (typeof props[key][propKey].toJson) === 'function')
	            json[key].push(props[key][propKey].toJson())
	        });
	      });
	      return json;
	    }
	
	    getProperties.wallHeight = wallHeight;
	    getProperties.isReveal = isReveal;
	    getProperties.isInset = isInset;
	    getProperties.overlay = overlay;
	    getProperties.reveal = reveal;
	    getProperties.toJson = toJson;
	    getProperties.cabinetStyles = cabinetStyles;
	    getProperties.cabinetStyle = cabinetStyle;
	    getProperties.cabinetStyleName = cabinetStyleName;
	    getProperties.set = set;
	
	    return getProperties;
	  }
	}
	
	PropertyConfig.lastStyle = 'Overlay';
	
	PropertyConfig.fromJson = (json) => {
	  const propConfig = {style: json.style, styleName: json.styleName};
	  const keys = Object.keys(json).filter((key) => key.match(/^[A-Z]/));
	  keys.forEach((key) => {
	    const propKeys = Object.keys(json[key]);
	    propConfig[key] = {};
	    propKeys.forEach((propKey) =>
	                propConfig[key][json[key][propKey].code] = Object.fromJson(json[key][propKey]));
	  });
	  return new PropertyConfig(propConfig);
	}
	
	module.exports = PropertyConfig;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/managers/template.js',
function (require, exports, module) {
	

	const FunctionCache = require('../../../../../public/js/utils/services/function-cache.js');
	
	const Assembly = require('../../objects/assembly/assembly.js');
	const Input = require('../../../../../public/js/utils/input/input.js');
	const Select = require('../../../../../public/js/utils/input/styles/select.js');
	const MeasurementInput = require('../../../../../public/js/utils/input/styles/measurement.js');
	const DecisionInputTree = require('../../../../../public/js/utils/input/decision/decision.js');
	const Lookup = require('../../../../../public/js/utils/object/lookup.js');
	const Inputs = require('../../input/inputs.js');
	const CabinetTemplate = require('../../config/cabinet-template.js');
	const ExpandableList = require('../../../../../public/js/utils/lists/expandable-list.js');
	const $t = require('../../../../../public/js/utils/$t.js');
	const du = require('../../../../../public/js/utils/dom-utils.js');
	const RadioDisplay = require('../../display-utils/radio-display.js');
	const Bind = require('../../../../../public/js/utils/input/bind.js');
	const Joint = require('../../objects/joint/joint.js');
	const StringMathEvaluator = require('../../../../../public/js/utils/string-math-evaluator.js');
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	const ThreeView = require('../three-view.js');
	const ThreeDModel = require('../../three-d/three-d-model.js');
	const Layout2D = require('../../two-d/layout/layout.js');
	const Draw2D = require('../../../../../public/js/utils/canvas/two-d/draw.js');
	const Vertex2d = require('../../../../../public/js/utils/canvas/two-d/objects/vertex');
	const Line2d = require('../../../../../public/js/utils/canvas/two-d/objects/line');
	const Snap2d = require('../../../../../public/js/utils/canvas/two-d/objects/snap');
	const PropertyConfig = require('../../config/property/config.js');
	const cabinetBuildConfig = require('../../../public/json/cabinets.json');
	const Pattern = require('../../division-patterns.js');
	const Handle = require('../../objects/assembly/assemblies/hardware/pull.js');
	const OpeningSketch = require('../opening-sketch');
	const FaceSketch = require('../face-sketch');
	const CSG = require('../../../public/js/3d-modeling/csg.js');
	const approximate = require('../../../../../public/js/utils/approximate').new(10);
	const PanZoom = require('../../../../../public/js/utils/canvas/two-d/pan-zoom.js');
	
	let template;
	let modifyingOpening = false;
	
	let lastOpening;
	const sectionState = {
	  style: 'Overlay',
	  vertical: false,
	  innerOouter: 'true',
	  xOyOz: 'x',
	  index: 0,
	  count: 0,
	  opening: (elem) => {
	    if (elem) lastOpening = ExpandableList.get(elem);
	    return lastOpening;
	  },
	  valueObject: () => {
	    const innerOouter = sectionState.innerOouter === 'true' ? 'inner' : 'outer';
	    return sectionState.opening().coordinates[innerOouter][sectionState.index];
	  },
	  value: (val) => {
	    const target = sectionState.valueObject();
	    if (val !== undefined) {
	      target[sectionState.xOyOz] = val;
	    }
	    return target[sectionState.xOyOz];
	  },
	  updateInput: (elem) => {
	    const coordinateInput = du.find.closest("[name='opening-coordinate-value']", elem);
	    coordinateInput.value = sectionState.value();
	    updateOpenLocationDisplay(sectionState.opening(elem), elem);
	  }
	};
	
	const defalutCustomCoords = () => ({"inner": [{"x": "R.t","y": "T.c.y - T.t/2","z": "0"},
	          {"x": "c.w - L.t","y": "T.c.y - T.t/2","z": "0"},
	          {"x": "c.w - L.t","y": "B.c.y + B.t/2","z": "0"},
	          {"x": "R.t","y": "B.c.y + B.t/2","z": "0"}],
	"outer": [{"x": "0","y": "c.h","z": "0"},
	          {"x": "c.w","y": "c.h","z": "0"},
	          {"x": "c.w","y": "B.c.y - B.t/2","z": "0"},
	          {"x": "0","y": "B.c.y - B.t/2","z": "0"}]});
	
	const openingSketch = new OpeningSketch('opening-sketch-cnt');
	const faceSketch = new FaceSketch('front-sketch');
	function updateState(elem) {
	  const opening = ExpandableList.get(elem);
	  sectionState.id = opening.id;
	  sectionState.opening(elem);
	  const attr = elem.name.replace(/(.*?)-.*/, '$1');
	  if (attr === 'index') sectionState[attr] = Number.parseInt(elem.value);
	  else if (attr !== 'opening') sectionState[attr] = elem.value;
	  sectionState.updateInput(elem);
	}
	
	function updateConfig(elem) {
	  const value = elem.type === 'checkbox' ? elem.checked : elem.value;
	  sectionState[elem.name] = value;
	}
	
	du.on.match('keydown', '#template-divider-count-input', (elem,ev) => ev.preventDefault());
	du.on.match('change', '.border-location-cnt>input', updateState);
	du.on.match('change', '.section-properties>input', updateConfig);
	
	function applyDividers(cabinet) {
	  for (let index = 0; index < cabinet.openings.length; index++) {
	    const divideCount = Number.parseInt(sectionState.count);
	    const opening = cabinet.openings[index];
	    opening.vertical(sectionState.vertical);
	    opening.divide(divideCount);
	    const sectionType = sectionState.sectionType;
	    if (sectionType) {
	      for (let si = 0; si < opening.sections.length; si++) {
	        opening.sections[si].setSection(sectionType);
	      }
	    }
	    const coords = opening.update();
	  }
	}
	
	function applyTestConfiguration(cabinet) {
	  cabinet.width(60*2.54);
	
	  cabinet.openings.forEach((opening) => {
	    opening.sectionProperties().pattern('bab').value('a', 30*2.54);
	    opening.divide(2);
	    const left = opening.sections[0];
	    const center = opening.sections[1];
	    const right = opening.sections[2];
	    const a = 6*2.54
	
	    left.divide(2);
	    left.vertical(false);
	    left.sections[0].setSection("DrawerSection");
	    left.sections[1].setSection("DrawerSection");
	    left.sections[2].setSection("DrawerSection");
	    left.pattern('abb').value('a', a*2);
	
	    center.divide(1);
	    center.vertical(false);
	    center.sections[1].setSection('DualDoorSection');
	    center.pattern('ab').value('a', a);
	    const centerTop = center.sections[0];
	
	    centerTop.divide(2);
	    centerTop.sections[0].setSection("DoorSection");
	    centerTop.sections[1].setSection("FalseFrontSection");
	    centerTop.sections[2].setSection("DoorSection");
	    centerTop.pattern('ztz').value('t', 15*2.54);
	    centerTop.sections[0].cover().pull().location(Handle.location.RIGHT);
	    centerTop.sections[2].cover().pull().location(Handle.location.LEFT);
	
	    right.divide(2);
	    right.vertical(false);
	    right.sections[0].setSection("DrawerSection");
	    right.sections[1].setSection("DrawerSection");
	    right.sections[2].setSection("DrawerSection");
	    right.pattern('abb').value('a', a);
	  });
	}
	
	const setShow = (template, templateBody, attr, cabinet) => {
	  if (cabinet) {
	    const display = du.find.closest(`[name="${attr}Value"]`, templateBody);
	    const value = template[attr]();
	    display.value = toDisplay(cabinet.eval(value));
	  } else {
	    const input = du.find.closest(`input[name="${attr}"`, templateBody);
	    if (input.value.isNumber()) template[attr](new Measurement(input.value, true).decimal());
	    else template[attr](input.value);
	  }
	}
	
	function getDemPosElems (template, cabinet) {
	  const templateBody = du.find('.template-body');
	  setShow(template, templateBody, 'width', cabinet);
	  setShow(template, templateBody, 'height', cabinet);
	  setShow(template, templateBody, 'thickness', cabinet);
	  setShow(template, templateBody, 'fromFloor', cabinet)
	}
	
	FunctionCache.disable();
	function getCabinet(elem) {
	  const templateBody = du.find('.template-body');
	  const template = CabinetTemplate.get(templateBody.getAttribute('template-id'), templateBody);
	  getDemPosElems(template);
	  const cabinet = template.getCabinet();
	  getDemPosElems(template, cabinet);
	  cabinet.propertyConfig().set(sectionState.style);
	
	  if (sectionState.testDividers) applyTestConfiguration(cabinet);
	  else applyDividers(cabinet);
	  openingSketch.cabinet(cabinet);
	  console.log(`Cabinet Demesions: ${cabinet.width()} !== ${cabinet.eval('c.w')} x ${cabinet.length()} x ${cabinet.thickness()}`)
	  return cabinet;
	}
	
	const toDisplay = (value, notMetric) =>  {
	  if ((typeof value) === 'string' && value.isNumber()) value = Number.parseFloat(value);
	  if ((typeof value) === 'number') return new Measurement(value, notMetric).display();
	  return value;
	}
	
	const centerDisplay = (t) => {
	  const x = t.getCabinet().eval(t.x());
	  const y = t.getCabinet().eval(t.y());
	  const z = t.getCabinet().eval(t.z());
	  return `(${toDisplay(x)},${toDisplay(y)},${toDisplay(z)})`;
	}
	const threeView = new ThreeView();
	// du.on.match('click', '#template-list-TemplateManager_template-manager', (elem) =>
	//   du.move.inFront(elem));
	// du.on.match('click', `#${threeView.id()}>.three-view-two-d-cnt>.three-view-canvases-cnt`, (elem) =>
	//   du.move.inFront(elem));
	
	const containerClasses = {
	  values: `template-values`,
	  subassemblies: `template-subassemblies`,
	  joints: `template-joints`,
	  dividerJoint: `template-divider-joint`,
	  openings: `template-openings`
	};
	
	function resetHeaderErrors() {
	  const containers = du.find.all('.cabinet-template-input-cnt');
	  containers.forEach((cnt) => {
	    const headers = du.find.downAll('.expand-header', cnt);
	    headers.forEach((h) => du.class.remove(h, 'error'))
	  });
	}
	
	function setHeaderErrors(elem) {
	  const firstHeader = du.find.closest('.expand-header', elem);
	  const secondHeader = du.find.up('.cabinet-template-input-cnt', firstHeader).children[0];
	  du.class.add(firstHeader, 'error');
	  du.class.add(secondHeader, 'error');
	}
	
	function updateCss(elem, isValid, errorMsg) {
	  if (elem) {
	    if (isValid) {
	      du.class.remove(elem, 'error');
	      elem.setAttribute('error-msg', '');
	    } else {
	      du.class.add(elem, 'error');
	      elem.setAttribute('error-msg', errorMsg);
	      setHeaderErrors(elem);
	    }
	  }
	}
	
	const varReg = /^[$_a-zA-Z][$_a-zA-Z0-9\.]*$/;
	const variableNameCheck = (elem) => updateCss(elem, elem.value.match(varReg), `Illegal characters: ${varReg}`);
	const positiveValueCheck = (elem) => updateCss(elem, Number.parseFloat(elem.value) > 0, 'Value must be positive');
	const partCodeCheck = (template) => (elem) => updateCss(elem, template.validPartCode(elem.value), 'Invalid Part Code');
	
	function openingCodeCheck(template, opening, input) {
	  if (opening._Type === 'location') return true;
	  let count = 0;
	  let errorString = '';
	  if (!template.validPartCode(opening.top)) {count++; (errorString += 'top,');}
	  if (!template.validPartCode(opening.bottom)) {count++; (errorString += 'bottom,');}
	  if (!template.validPartCode(opening.left)) {count++; (errorString += 'left,');}
	  if (!template.validPartCode(opening.right)) {count++; (errorString += 'right,');}
	  if (!template.validPartCode(opening.back)) {count++; (errorString += 'back,');}
	  if (count === 0) updateCss(input, true);
	  else {
	    errorString = errorString.substring(0, errorString.length - 1);
	    if (count === 1) updateCss(input, false, `'${errorString}' part code is invalid (CABINET WILL NOT RENDER)`);
	    else updateCss(input, false, `Multiple part codes are invalid: ${errorString} (CABINET WILL NOT RENDER)`);
	  }
	  return count === 0;
	}
	
	function openingsCodeCheck (template, inputs) {
	  const openings = template.openings();
	  let valid = true;
	  for (let index = 0; index < openings.length; index += 1) {
	    const opening = openings[index];
	    const input = inputs[index];
	    valid &&= openingCodeCheck(template, opening, input)
	  }
	  return valid;
	}
	
	function validateEquations(template, cabinet, valueInput, eqnInput, valueIndex, eqnMap) {
	  let errorString = '';
	  let errorCount = 0;
	  let eqnKeys = Object.keys(eqnMap);
	  for (let index = 0; index < eqnKeys.length; index += 1) {
	    const key = eqnKeys[index];
	    const eqn = eqnMap[key];
	    if (index === valueIndex) {
	      const value = template.evalEqn(eqn, cabinet);
	      if (Number.isNaN(value)) {
	        errorString += `${key},`;
	        errorCount++;
	      } else {
	        const convertCheckBox = valueInput.nextElementSibling;
	        if (convertCheckBox && convertCheckBox.getAttribute('name') === 'convert' &&
	              convertCheckBox.checked) {
	          valueInput.value = new Measurement(value).display();
	        } else {
	          valueInput.value = value;
	        }
	      }
	    } else {
	      if (!template.validateEquation(eqn, cabinet)) {
	        errorString += `${key},`;
	        errorCount++;
	      }
	    }
	  }
	  if (errorCount > 0) {
	    du.class.add(eqnInput, 'error');
	    if (eqnKeys.length > 1) {
	      errorString = errorString.substring(0, errorString.length - 1);
	      updateCss(eqnInput, false, `Errors found within the following equations:${errorString}`);
	    } else {
	      updateCss(eqnInput, false, `Errors found within the equation.`)
	    }
	  } else {
	    du.class.remove(eqnInput, 'error');
	    updateCss(eqnInput, true);
	  }
	}
	
	const valueEqnCheck = (template, cabinet) => (eqnInput) => {
	  const valueInput = du.find.closest('[name="value"]', eqnInput);
	  const name = eqnInput.name;
	  const eqn = eqnInput.value;
	  const eqnMap = {};
	  eqnMap[name] = eqn;
	  validateEquations(template, cabinet, valueInput, eqnInput, 0, eqnMap);
	}
	
	const xyzEqnCheck = (template, cabinet) => (xyzInput) => {
	  const valueInput = du.find.closest('[name="value"]', xyzInput);
	  const index = Number.parseInt(du.find.closest('select', xyzInput).value);
	  const subAssem = ExpandableList.get(xyzInput);
	  const part = cabinet.getAssembly(subAssem.code);
	  const eqns = subAssem[xyzInput.name];
	  const eqnMap = {x: eqns[0], y: eqns[1], z: eqns[2]};
	  validateEquations(template, cabinet, valueInput, xyzInput, index, eqnMap);
	}
	
	function updatePartsDataList() {
	  const partMap = threeView.partMap();
	  if (!partMap) return;
	  const partKeys = Object.keys(partMap);
	  let htmlArr = [];
	  for (let index = 0; index < partKeys.length; index += 1) {
	    const id = partKeys[index];
	    const partCode = partMap[id].code;
	    const partName = partMap[id].name;
	    htmlArr.push(`<option value='${partName}' part-code='${partCode}'></option>`);
	  }
	  htmlArr.sort()
	  const datalist = du.id('part-list');
	  datalist.innerHTML = htmlArr.join('');
	}
	
	function vertexToDisplay(vertex) {
	  const x = new Measurement(vertex.x).display();
	  const y = new Measurement(vertex.y).display();
	  const z = new Measurement(vertex.z).display();
	  return `(${x}, ${y}, ${z})`;
	}
	
	function target(io, i) {
	  const targetIndex = i + (io === 'inner' ? 0 : 4);
	  return (index) => targetIndex === index;
	}
	
	function updateOpenLocationDisplay (opening, elem) {
	  const state = sectionState;
	  state.opening(elem);
	
	  const io = state.innerOouter === 'true' ? 'inner' : 'outer';
	  const i = state.index;
	  const description = `Current formula describes the ${io} boundry ${state.xOyOz} coordinate of vertex ${state.index}.`;
	  du.find.closest('.opening-location-description-cnt', elem).innerText = description;
	
	  const eqnPoint = opening.coordinates && opening.coordinates[io] && opening.coordinates[io][i];
	
	  if (eqnPoint && elem.name !== 'opening-coordinate-value')
	    du.find.closest('[name="opening-coordinate-value"]', elem).value = eqnPoint[state.xOyOz];
	
	  const cabinet = getCabinet(elem);
	  const coords = cabinet.openings[ExpandableList.getIdAndKey(elem).key].update();
	
	
	  const html = openingPointTemplate.render({display: vertexToDisplay, coords, target: target(io, i)});
	  du.find.closest('.opening-location-value-cnt', elem).innerHTML = html;
	}
	
	const openingPointTemplate = new $t('managers/template/openings/points');
	
	function onOpeningTypeChange(elem) {
	  const opening = ExpandableList.get(elem);
	  if (opening._Type !== elem.value) {
	    const isLocation = elem.value === 'location';
	    const isSlice = elem.value === 'slice';
	    const defaultFunc = isLocation ? 'defaultLocationOpening' : 'defaultPartCodeOpening';
	    const def = CabinetTemplate[defaultFunc]();
	    Object.merge(opening, def, true);
	    opening._Type = isLocation ? 'location' : (isSlice ? 'slice' : undefined);
	    if (opening._Type === 'location' && opening.coordinates === undefined)
	      opening.coordinates = defalutCustomCoords();
	    if (opening._Type === 'slice' && opening.leftDepth === undefined)
	      opening.rightDepth = opening.leftDepth = 'c.t';
	
	    du.find.closest('.border-location-cnt', elem).hidden = !isLocation;
	    du.find.closest('.border-slice-cnt', elem).hidden = !isSlice;
	    updateOpeningPartCode(du.find.closest('select', elem));
	  }
	}
	
	du.on.match('change', '.opening-type-selector', onOpeningTypeChange);
	
	function updateOpeningPoints(template, cabinet) {
	  const threeDModel = threeView.threeDModel();
	  if (threeDModel) {
	    threeDModel.removeAllExtraObjects();
	    const openings = cabinet.openings;
	    for (let index = 0; index < openings.length; index++) {
	      const opening = openings[index];
	      const size = modifyingOpening ? 1 : .25;
	      const state = sectionState;
	      const i = state.index;
	      const vertexColor = (io, i) => io !== state.innerOouter ? 'black' :
	            (modifyingOpening && i === state.index ? 'green' : 'white');
	
	      const vertexSize = (io) => modifyingOpening && io === state.innerOouter ? size*2 : size;
	
	      const coords = opening.update();
	      threeDModel.addVertex(coords.inner[0], vertexSize('true'), vertexColor('true', 0));
	      threeDModel.addVertex(coords.inner[1], vertexSize('true'), vertexColor('true', 1));
	      threeDModel.addVertex(coords.inner[2], vertexSize('true'), vertexColor('true', 2));
	      threeDModel.addVertex(coords.inner[3], vertexSize('true'), vertexColor('true', 3));
	
	      threeDModel.addVertex(coords.outer[0], vertexSize('false'), vertexColor('false', 0));
	      threeDModel.addVertex(coords.outer[1], vertexSize('false'), vertexColor('false', 1));
	      threeDModel.addVertex(coords.outer[2], vertexSize('false'), vertexColor('false', 2));
	      threeDModel.addVertex(coords.outer[3], vertexSize('false'), vertexColor('false', 3));
	    }
	  }
	}
	
	function validateOpenTemplate (elem) {
	  const templateBody = du.find('.template-body');
	  if (!templateBody || du.is.hidden(templateBody)) return;
	  resetHeaderErrors();
	  const template = CabinetTemplate.get(templateBody.getAttribute('template-id'), templateBody);
	
	  const valueNameInputs = du.find.downAll('input[attr="values"][name="name"]', templateBody);
	  valueNameInputs.forEach(variableNameCheck);
	  const subNameInputs = du.find.downAll('input[attr="subassemblies"][name="name"]', templateBody);
	  subNameInputs.forEach(variableNameCheck);
	  const subCodeInputs = du.find.downAll('input[attr="subassemblies"][name="code"]', templateBody);
	  subCodeInputs.forEach(variableNameCheck);
	
	  // const positiveInputs = du.find.downAll('input[name="thickness"],input[name="width"],input[name="height"]', templateBody);
	  // positiveInputs.forEach(positiveValueCheck);
	
	  const pcc = partCodeCheck(template);
	  const jointMaleInputs = du.find.downAll('input[attr="joints"][name="malePartCode"]', templateBody);
	  jointMaleInputs.forEach(pcc);
	  const jointFemaleInputs = du.find.downAll('input[attr="joints"][name="femalePartCode"]', templateBody);
	  jointFemaleInputs.forEach(pcc);
	
	  const openingCodeInputs = du.find.downAll('input[attr="openings"][name="partCode"]', templateBody);
	  openingsCodeCheck(template, openingCodeInputs);
	
	  try {
	    const cabinet = getCabinet(templateBody);
	
	    const depthInputs = du.find.downAll('[name=depth]', templateBody);
	    depthInputs.forEach(valueEqnCheck(template, cabinet));
	    const valueEqnInputs = du.find.downAll('input[attr="values"][name="eqn"]', templateBody);
	    valueEqnInputs.forEach(valueEqnCheck(template, cabinet));
	    const subDemInputs = du.find.downAll('input[attr="subassemblies"][name="demensions"]', templateBody);
	    subDemInputs.forEach(xyzEqnCheck(template, cabinet));
	    const subCenterInputs = du.find.downAll('input[attr="subassemblies"][name="center"]', templateBody);
	    subCenterInputs.forEach(xyzEqnCheck(template, cabinet));
	    const subRotInputs = du.find.downAll('input[attr="subassemblies"][name="rotation"]', templateBody);
	    subRotInputs.forEach(xyzEqnCheck(template, cabinet));
	    updateOpeningPoints(template, cabinet);
	    setTimeout(updatePartsDataList, 500);
	  } catch (e) {
	    console.log(e);
	  }
	}
	
	du.on.match('enter', '*', () => {
	  const templateBody = du.find('.template-body');
	  const cabinet = getCabinet(templateBody);
	  threeView.update(cabinet);
	});
	
	function getEqn(select, values) {
	  return values && values[select.value()];
	}
	
	const depthValidation = (measurment) =>
	        measurment.decimal() > 0;
	
	function getJointInputTree(func, joint, dividerJoint) {
	  joint.type ||= 'Butt';
	  const selectType = new Select({
	    name: 'type',
	    list: Object.keys(Joint.types),
	    class: 'template-select',
	    value: joint.type
	  });
	
	  const centerOffsetInput = new Select({
	    name: 'centerAxis',
	    label: 'Center Axis',
	    list: ['+x', '+y', '+z', '-x', '-y', '-z'],
	    value: joint.centerAxis
	  });
	  const demensionOffsetInput = new Select({
	    name: 'demensionAxis',
	    label: 'Demension Axis',
	    list: ['x', 'y', 'z'],
	    value: joint.demensionAxis
	  });
	
	  const depthInput = new Input({
	    label: 'Depth',
	    name: 'maleOffset',
	    value: joint.maleOffset
	  });
	
	  const dadoInputs = dividerJoint ? [depthInput] : [depthInput, centerOffsetInput, demensionOffsetInput];
	
	  const dit = new DecisionInputTree(undefined, {noSubmission: true});
	  const type = dit.branch('Type', [selectType]);
	  const condtionalPayload = new DecisionInputTree.ValueCondition('type', 'Dado', dadoInputs);
	  type.conditional('dado', condtionalPayload);
	  dit.onChange(func);
	  return dit;
	}
	
	let lastDepth;
	const jointOnChange = (vals, dit) => {
	  const selectId = dit.payload().inputArray[0].id();
	  const joint = ExpandableList.get(du.id(selectId));
	  joint.type = vals.type;
	  lastDepth = vals.maleOffset || lastDepth;
	  joint.maleOffset = lastDepth || undefined;
	  const depthInput = dit.children()[0].payload().inputArray[0];
	  // depthInput.updateDisplay();
	  joint.demensionAxis = vals.demensionAxis || undefined;
	  joint.centerAxis = vals.centerAxis || undefined;
	  console.log(vals);
	}
	
	function getTypeInput(obj) {
	  return new Select({
	    name: 'type',
	    value: obj.type,
	    class: 'template-input',
	    list: Object.keys(Assembly.components),
	    inline: true
	  });
	}
	
	function getXyzSelect(label) {
	  return new Select({
	    label,
	    name: 'xyz',
	    list: {'0': 'X', '1': 'Y', '2':'Z'},
	    inline: true
	  });
	}
	
	function getWhdSelect(label) {
	  return new Select({
	    label,
	    name: 'xyz',
	    list: {'0': 'W', '1': 'H', '2':'D'},
	    inline: true
	  });
	}
	
	function getOpeningLocationSelect() {
	  return new Select({
	    name: 'openingLocation',
	    list: ['top', 'bottom', 'left', 'right', 'back'],
	    inline: true
	  });
	}
	
	function getJoint(obj) {
	  return {obj, jointInput: getJointInputTree(jointOnChange, obj).payload()};
	}
	function getSubassembly(obj) {
	  return {typeInput:  getTypeInput(obj),
	          centerXyzSelect: getXyzSelect('Center'),
	          demensionXyzSelect: getWhdSelect('Demension'),
	          rotationXyzSelect: getXyzSelect('Rotation'),
	          getEqn, obj
	        };
	}
	
	function getOpening(obj) {
	  return {obj, select: getOpeningLocationSelect(), state: sectionState};
	}
	
	const scopes = {};
	function getScope(type, obj) {
	  obj.id = obj.id || String.random();
	  if (scopes[obj.id]) return scopes[obj.id];
	  switch (type) {
	    case 'joints':
	      scopes[obj.id] = getJoint(obj);
	      break;
	    case 'subassemblies':
	      scopes[obj.id] = getSubassembly(obj);
	      break;
	    case 'openings':
	      scopes[obj.id] = getOpening(obj);
	      break;
	    default:
	      scopes[obj.id] = {obj};
	  }
	  return scopes[obj.id];
	}
	
	const getObjects = {
	    subassemblies: () => ({
	      type: "Panel",
	      center: [0,0,0],
	      demensions: [1,1,1],
	      rotation: [0,0,0],
	      include: 'All'
	    })
	}
	
	function updateTemplateDisplay() {
	  const managerElems = du.find.all('[template-manager]');
	  for (let index = 0; index < managerElems.length; index += 1) {
	    const templateManagerId = managerElems[index].getAttribute('template-manager');
	    const templateManager =TemplateManager.get(templateManagerId);
	    templateManager.update();
	  }
	}
	
	
	function addExpandable(template, type) {
	  const containerClass = containerClasses[type];
	  let parentSelector = `[template-id='${template.id()}']>.${containerClass}`;
	  TemplateManager.headTemplate[type] ||= new $t(`managers/template/${type.toKebab()}/head`);
	  TemplateManager.bodyTemplate[type] = TemplateManager.bodyTemplate[type] === undefined ?
	                    new $t(`managers/template/${type.toKebab()}/body`) : TemplateManager.bodyTemplate[type];
	  let getHeader = (obj) => TemplateManager.headTemplate[type].render(getScope(type, obj));
	  let getBody = TemplateManager.bodyTemplate[type] ? ((obj) => TemplateManager.bodyTemplate[type].render(getScope(type, obj))) : undefined;
	  const expListProps = {
	    idAttribute: 'name',
	    list: template[type](),
	    getObject: getObjects[type],
	    renderBodyOnOpen: false,
	    parentSelector, getHeader, getBody,
	    listElemLable: type.toSentance(),
	  };
	  const expandList = new ExpandableList(expListProps);
	  expandList.afterRemoval(updateTemplateDisplay);
	  return expandList;
	}
	
	class TemplateManager extends Lookup {
	  constructor(id) {
	    super(id);
	    const parentId = `template-list-${this.id()}`;
	    this.parentId = () => parentId;
	    let currentTemplate;
	    const parentSelector = `#${parentId}`;
	    const dividerJointChange = (template) => (vals) => {
	      template.dividerJoint(vals);
	    }
	    const templateShapeInput = (template) => TemplateManager.templateShapeInput(template.shape());
	    const dividerJointInput = (template) =>
	      getJointInputTree(dividerJointChange(template), template.dividerJoint(), true).payload();
	
	    const containerSelector = (template, containerClass) => `[template-id="${template.id()}"]>.${containerClass}`;
	
	    const getHeader = (template) =>
	      TemplateManager.headTemplate.render({template, TemplateManager: this});
	    const getBody = (template) => {
	      currentTemplate = template;
	      setTimeout(() => {
	        updateExpandables(template);
	      }, 100);
	      setTimeout(() => {
	        validateOpenTemplate(du.id(parentId));
	      }, 1000);
	      return TemplateManager.bodyTemplate.render({template, TemplateManager: this,
	        containerClasses, centerDisplay, toDisplay,
	        dividerJointInput: dividerJointInput(template),
	        templateShapeInput: templateShapeInput(template)});
	      }
	
	    this.sectionState = sectionState;
	    const expandables = {};
	    function initTemplate(template) {
	      const list = [];
	      expandables[template.id()] = list;
	      return () => {
	        list.push(addExpandable(template, 'values'));
	        list.push(addExpandable(template, 'subassemblies'));
	        list.push(addExpandable(template, 'joints'));
	        list.push(addExpandable(template, 'openings', true));
	      };
	    }
	
	    function initiateCanvasViews() {
	      let drawFront, drawTop, lastModel, frontView, topSnap, panz, panzT;
	      const renderFront = () => {
	        if (drawFront === undefined) return;
	        drawFront(frontView, null, .5);
	      }
	      const renderTop = () => {
	        if (drawFront === undefined) return;
	        drawTop(topSnap, null, .5);
	      }
	      const templateBody = du.find('.template-body');
	      const frontCanvas = du.find.down('.front-sketch', templateBody);
	      const topCanvas = du.find.down('.top-sketch', templateBody);
	      if (frontCanvas !== undefined) {
	        drawFront = new Draw2D(frontCanvas);
	        panz = new PanZoom(frontCanvas, renderFront);
	        panz.centerOn(0, 0);
	        drawTop = new Draw2D(topCanvas, true);
	        panzT = new PanZoom(topCanvas, renderTop);
	        panzT.centerOn(0,0);
	      }
	
	      function updateShapeSketches(elem, model) {
	        if (model) {
	          try {
	            frontView = model.frontView();
	            const center = Vertex2d.center(Line2d.vertices(frontView));
	            panz.centerOn(center.x(), center.y());
	            topSnap = model.topviewSnap();
	            const centerT = Vertex2d.center(Line2d.vertices(topSnap));
	            panzT.centerOn(centerT.x(), centerT.y());
	            renderTop();
	            renderFront();
	          } catch (e) {
	            console.warn(e);
	          }
	        }
	      }
	
	      ThreeDModel.onRenderObjectUpdate(updateShapeSketches);
	    }
	
	    function updateExpandables(template) {
	      template ||= currentTemplate;
	      if (template === undefined) return;
	      if (!expandables[template.id()]) initTemplate(template)();
	      expandables[template.id()].forEach((e) => e.refresh());
	      initiateCanvasViews();
	    }
	    this.updateExpandables = updateExpandables;
	
	    const getObject = (values) => {
	      const cabTemp = new CabinetTemplate(values.name);
	      initTemplate(cabTemp)();
	      return cabTemp;
	    }
	
	    this.active = () => expandList.active();
	    const expListProps = {
	      list: CabinetTemplate.defaultList(),
	      inputTree: TemplateManager.inputTree(),
	      parentSelector, getHeader, getBody, getObject,
	      listElemLable: 'Template',
	      type: 'sidebar'
	    };
	    setTimeout(initTemplate(expListProps.list[0]), 200);
	    const expandList = new ExpandableList(expListProps);
	
	    this.update = () => {
	      expandList.refresh();
	    }
	    this.loadPoint = () => console.log('load');
	    this.savePoint = () => console.log('save');
	    this.fromJson = () => {};
	    const html = TemplateManager.mainTemplate.render(this);
	    du.find(`#${id}`).innerHTML = html;
	  }
	}
	
	const radioDisplay = new RadioDisplay('cabinet-template-input-cnt', 'template-id');
	radioDisplay.afterSwitch(function (header){
	  const coordinateInput = du.find.closest('[name="opening-coordinate-value"]', header);
	  const opening = ExpandableList.get(coordinateInput);
	  if (opening && opening._Type) {
	    if (opening._Type === 'location') {
	      updateState(coordinateInput);
	      sectionState.value(coordinateInput.value);
	    }
	  }
	});
	
	du.on.match('focusout:enter', '[name="opening-coordinate-value"]', (elem) => {
	  sectionState.value(elem.value || undefined);
	});
	
	function sliceDepthUpdate(elem) {
	  const opening = ExpandableList.get(elem);
	  opening[elem.name] = elem.value;
	}
	
	du.on.match('focusout:enter', '[name="leftDepth"]', sliceDepthUpdate);
	du.on.match('focusout:enter', '[name="rightDepth"]', sliceDepthUpdate);
	
	TemplateManager.inputTree = () => {
	  const dit = new DecisionInputTree();
	  dit.leaf('Template Name', [Inputs('name')]);
	  return dit;
	}
	
	TemplateManager.templateShapeInput = (value) => {
	  return new Select({
	      name: 'templateShape',
	      list: Object.keys(Snap2d.get),
	      class: 'template-shape-input',
	      value: value
	    });
	};
	
	radioDisplay.afterSwitch((elem, detail) => {
	  const newState = detail.targetHeader.innerText === 'Openings';
	  const updateModel = newState !== modifyingOpening;
	  modifyingOpening = newState;
	  updateModel && validateOpenTemplate(detail.targetHeader);
	});
	
	TemplateManager.mainTemplate = new $t('managers/template/main');
	TemplateManager.headTemplate = new $t('managers/template/head');
	TemplateManager.bodyTemplate = new $t('managers/template/body');
	TemplateManager.bodyTemplate.values = false;
	new TemplateManager('template-manager', 'template');
	
	function updateValuesTemplate(elem, template) {
	  const nameInput = du.find.closest('[name="name"]', elem);
	  const name = nameInput.value;
	  const eqn = du.find.closest('[name="eqn"]', elem).value;
	  const valueObj = ExpandableList.get(elem);
	  valueObj.key = name;
	  valueObj.eqn = eqn;
	  return true
	}
	
	function updateSubassembliesTemplate(elem, template) {
	  const nameInput = du.find.closest('[name="name"]', elem);
	  const type = du.find.closest('[name="type"]', elem).value;
	  const name = `${type}.${nameInput.value.toDot()}`;
	  const subAssem = ExpandableList.get(elem);
	  subAssem.name = nameInput.value;
	  if (elem.name === 'name') return;
	  if (elem.name === 'center' || elem.name === 'demensions' || elem.name === 'rotation') {
	    const index = du.find.closest('[name="xyz"]', elem).value;
	    const eqn = elem.value;
	    if (subAssem[elem.name] === undefined) subAssem[elem.name] = [];
	    subAssem[elem.name][index] = eqn;
	  } else if (elem.name !== 'name') {
	    subAssem[elem.name] = elem.value;
	  }
	}
	
	function switchEqn(elem) {
	  const nameInput = du.find.closest('[name="name"]', elem);
	  const type = du.find.closest('[name="type"]', elem).value;
	  const name = `${type}.${nameInput.value.toDot()}`;
	  const subAssem = ExpandableList.get(elem);
	  if (subAssem) {
	    const eqnInput = du.find.closest('input', elem);
	    const index = elem.value;
	    if (subAssem[eqnInput.name] === undefined) subAssem[eqnInput.name] = [];
	    const value = subAssem[eqnInput.name][index];
	    eqnInput.value = value === undefined ? '' : value;
	  }
	}
	
	function updateOpeningsTemplate(elem, template) {
	  const partCode = elem.value;
	  const attr = du.find.closest('select', elem).value;
	  const listElem = ExpandableList.get(elem);
	  listElem[attr] = elem.value;
	  console.log(ExpandableList.get(elem,1).toJson());
	}
	
	function updateViewShape(elem) {
	  const templateId = du.find.up('[template-id]', elem).getAttribute('template-id');
	  const template = CabinetTemplate.get(templateId);
	  template.shape(elem.value);
	}
	
	function updateJointPartCode(elem) {
	  const attr = elem.name;
	  const listElem = ExpandableList.get(elem);
	  listElem[attr] = elem.value;
	}
	
	function updateOpeningPartCode(elem) {
	  const attr = elem.value;
	  const opening = ExpandableList.get(elem);
	  const partCodeInput = du.find.closest('input', elem);
	  partCodeInput.value = opening[attr] || '';
	  updateOpenLocationDisplay(opening, elem);
	}
	
	function updateTemplate(elem, template) {
	  const attr = du.find.closest('[attr]', elem).getAttribute('attr');
	  switch (attr) {
	    case 'values': return updateValuesTemplate(elem, template);
	    case 'subassemblies': return updateSubassembliesTemplate(elem, template);
	    case 'openings': return updateOpeningsTemplate(elem, template);
	
	    default:
	
	  }
	}
	
	function updateInclude(elem) {
	  const subAssem = ExpandableList.get(elem);;
	  subAssem.include = elem.value;
	  console.log(subAssem);
	}
	
	du.on.match('change', '.template-include', updateInclude);
	du.on.match('change', '.opening-part-code-input', updateOpeningsTemplate);
	du.on.match('change', '.template-shape-input', updateViewShape);
	du.on.match('change', '[name="xyz"]', switchEqn);
	du.on.match('change', '[name="openingLocation"]', updateOpeningPartCode);
	du.on.match('change', '.template-input[name="malePartCode"],.template-input[name="femalePartCode"]', updateJointPartCode);
	du.on.match('click', '.copy-template', (elem) => {
	  const templateId = du.find.up('[template-id]', elem).getAttribute('template-id');
	  const template = CabinetTemplate.get(templateId);
	  let jsonStr = JSON.stringify(template.toJson(), null, 2);
	  jsonStr = jsonStr.replace(/.*"id":.*($|,)/g, '');
	  du.copy(jsonStr);
	});
	
	du.on.match('click', '.paste-template', (elem) => {
	  navigator.clipboard.readText()
	  .then(text => {
	    try {
	      const obj = Object.fromJson(JSON.parse(text));
	      if (!(obj instanceof CabinetTemplate)) throw new Error(`Json is of type ${obj.constructor.name}`);
	      const templateId = du.find.up('[template-id]', elem).getAttribute('template-id');
	      const template = CabinetTemplate.get(templateId);
	      template.fromJson(obj.toJson());
	      const templateManagerId = du.find.up('[template-manager]', elem).getAttribute('template-manager');
	      const templateManager =TemplateManager.get(templateManagerId);
	      templateManager.update();
	    } catch (e) {
	      alert('clipboard does not contain a valid CabinetTemplate');
	    }
	  })
	  .catch(err => {
	    console.error('Failed to read clipboard contents: ', err);
	  });
	});
	
	du.on.match('change', '.template-input', function (elem) {
	  const templateId = du.find.up('[template-id]', elem).getAttribute('template-id');
	  template = CabinetTemplate.get(templateId);
	  updateTemplate(elem, template);
	});
	
	du.on.match('change', 'input,select',   () => setTimeout(validateOpenTemplate, 0));
	
	
	module.exports = TemplateManager
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assembly.js',
function (require, exports, module) {
	

	
	const StringMathEvaluator = require('../../../../../public/js/utils/string-math-evaluator.js');
	const Position = require('../../position.js');
	const getDefaultSize = require('../../utils.js').getDefaultSize;
	const KeyValue = require('../../../../../public/js/utils/object/key-value.js');
	
	const valueOfunc = (valOfunc) => (typeof valOfunc) === 'function' ? valOfunc() : valOfunc;
	
	function maxHeight(a, b, c) {
	  const minSide = a > b ? b : a;
	  return Math.sqrt(c*c - minSide*minSide);
	}
	
	class Assembly extends KeyValue {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig, parent) {
	    super({childrenAttribute: 'subassemblies', parentAttribute: 'parentAssembly', object: true});
	
	    const instance = this;
	    let group;
	    const temporaryInitialVals = {parentAssembly: parent, _TEMPORARY: true};
	    const initialVals = {
	      part: true,
	      included: true,
	      centerConfig, demensionConfig, rotationConfig, partCode, partName,
	      propertyId: undefined,
	    }
	    const subAssems = this.subassemblies;
	    Object.getSet(this, initialVals, 'subassemblies', 'joints');
	    this.subassemblies = subAssems;
	    Object.getSet(this, temporaryInitialVals);
	    this.path = () => `${this.constructor.name}.${partName}`.toDot();
	
	    if ((typeof centerConfig) === 'function') this.centerConfig = centerConfig;
	    else this.centerConfig = centerConfig
	    if ((typeof demensionConfig) === 'function') this.demensionConfig = demensionConfig;
	    else this.demensionConfig = demensionConfig
	    if ((typeof rotationConfig) === 'function') this.rotationConfig = rotationConfig;
	    else this.rotationConfig = rotationConfig
	
	    const parentIncluded = this.included;
	
	    this.included = (value) => {
	        value = parentIncluded(value);
	        if ((typeof value) === 'string') return  group.propertyConfig(value);
	        switch (value) {
	          case true: return true;
	          case false: return false;
	          default: return true;
	        }
	    }
	
	    function getValueSmeFormatter(path) {
	      const split = path.split('.');
	      let attr = split[0];
	      let objIdStr;
	      if (split.length > 2) {
	      }
	      if (split.length > 1) {
	        objIdStr = split[0];
	        attr = split.slice(1).join('.');
	      }
	
	      let obj;
	      if (objIdStr === undefined) {
	        obj = instance;
	      } else {
	        obj = instance.getAssembly(objIdStr);
	      }
	      const returnVal = Assembly.resolveAttr(obj, attr);
	      return returnVal;
	    }
	
	    const sme = new StringMathEvaluator({Math, maxHeight}, getValueSmeFormatter);
	
	    // KeyValue setup
	    const funcReg = /length|width|thickness/;
	    this.value.addCustomFunction((key, value) => key.match(funcReg) ? this[code](value) : undefined)
	    this.value.evaluators.string = (value) => sme.eval(value, this);
	    this.value.defaultFunction = (key) => this.propertyConfig(this.constructor.name, key);
	
	    this.eval = (eqn) => sme.eval(eqn, this);
	    this.evalObject = (obj) => sme.evalObject(obj, this);
	
	    this.group = (g) => {
	      if (g) group = g;
	      return group;
	    }
	    this.layout = () => this.group().room().layout();
	    this.propertyConfig = (one, two, three) => {
	      const parent = this.parentAssembly();
	      if (parent instanceof Assembly) return parent.propertyConfig(one, two, tree);
	      const group = this.group();
	      const groupVal = group.resolve(one, two, three);
	      if (groupVal !== undefined) return groupVal;
	      return group.propertyConfig;
	    }
	
	    this.getAssembly = (partCode, callingAssem) => {
	      if (callingAssem === this) return undefined;
	      if (this.partCode() === partCode) return this;
	      if (this.subassemblies[partCode]) return this.subassemblies[partCode];
	      if (callingAssem !== undefined) {
	        const children = Object.values(this.subassemblies);
	        for (let index = 0; index < children.length; index += 1) {
	          const assem = children[index].getAssembly(partCode, this);
	          if (assem !== undefined) return assem;
	        }
	      }
	      if (this.parentAssembly() !== undefined && this.parentAssembly() !== callingAssem)
	        return this.parentAssembly().getAssembly(partCode, this);
	      return undefined;
	    }
	    let position = new Position(this, sme);
	    this.position = () => position;
	    this.toModel = this.position().toModel;
	    this.toBiPolygon = this.position().toBiPolygon;
	    this.updatePosition = () => position = new Position(this, sme);
	    this.joints = [];
	    this.values = {};
	    this.rootAssembly = () => {
	      let currAssem = this;
	      while (currAssem.parentAssembly() !== undefined) currAssem = currAssem.parentAssembly();
	      return currAssem;
	    }
	    this.getJoints = (pc) => {
	      const root = this.getRoot();
	      if (root !== this) return root.getJoints(pc || partCode);
	      pc = pc || partCode;
	      const assemList = this.getSubassemblies();
	      let jointList = [].concat(this.joints);
	      assemList.forEach((assem) => jointList = jointList.concat(assem.joints));
	      let joints = {male: [], female: []};
	      jointList.forEach((joint) => {
	        if (joint.malePartCode() === pc) {
	          joints.male.push(joint);
	        } else if (joint.femalePartCode() === pc) {
	          joints.female.push(joint);
	        }
	      });
	      return joints;
	    }
	    function initObj(value) {
	      const obj = {};
	      for (let index = 1; index < arguments.length; index += 1) {
	        obj[arguments[index]] = value;
	      }
	      return obj;
	    }
	
	
	    this.setSubassemblies = (assemblies) => {
	      this.subassemblies = {};
	      assemblies.forEach((assem) => this.subassemblies[assem.partCode()] = assem);
	    };
	
	    this.partsOf = (clazz) => {
	      const parts = this.getRoot().getParts();
	      if (clazz === undefined) return parts;
	      return parts.filter((p) => p instanceof clazz);
	    }
	
	    // TODO: wierd dependency on inherited class.... fix!!!
	    const defaultPartCode = () =>
	      instance.partCode(instance.partCode() || Assembly.partCode(this));
	
	    this.setParentAssembly = (pa) => {
	      this.parentAssembly(pa);
	      defaultPartCode();
	    }
	    this.addSubAssembly = (assembly) => {
	      if ((typeof assembly.partCode) !== 'function')
	        console.log('wtf')
	      this.subassemblies[assembly.partCode()] = assembly;
	      // assembly.setParentAssembly(this);
	    }
	
	    this.objId = this.constructor.name;
	
	    this.addJoints = function () {
	      for (let i = 0; i < arguments.length; i += 1) {
	        const joint = arguments[i];
	        this.joints.push(joint);
	        joint.parentAssemblyId(this.id());
	      }
	    }
	
	    this.addSubassemblies = function () {
	      for (let i = 0; i < arguments.length; i += 1) {
	        this.addSubAssembly(arguments[i]);
	      }
	    }
	
	    this.children = () => Object.values(this.subassemblies);
	
	    this.getSubassemblies = () => {
	      let assemblies = [];
	      this.children().forEach((assem) => {
	        assemblies.push(assem);
	        assemblies = assemblies.concat(assem.getSubassemblies());
	      });
	      return assemblies;
	    }
	    this.getParts = () => {
	      return this.getSubassemblies().filter((a) => {
	        if ((typeof a.part) !== 'function') {
	          console.log('party')
	        }
	        return a.part() && a.included()
	      });
	    }
	
	    if (Assembly.idCounters[this.objId] === undefined) {
	      Assembly.idCounters[this.objId] = 0;
	    }
	
	    Assembly.add(this);
	
	    this.width = (value) => position.setDemension('x', value);
	    this.length = (value) => position.setDemension('y', value);
	    this.thickness = (value) => position.setDemension('z', value);
	    this.toString = () => `${this.id()} - ${this.partName()}`;
	    defaultPartCode();
	  }
	}
	
	Assembly.list = {};
	Assembly.get = (id) => {
	  const keys = Object.keys(Assembly.list);
	  for (let index = 0; index < keys.length; index += 1) {
	    const assembly = Assembly.list[keys[index]][id];
	    if (assembly !== undefined) return assembly;
	  }
	  return null;
	}
	Assembly.add = (assembly) => {
	  const name = assembly.constructor.name;
	  if (Assembly.list[name] === undefined) Assembly.list[name] = {};
	  Assembly.list[name][assembly.id()] = assembly;
	}
	Assembly.all = () => {
	  const list = [];
	  const keys = Object.keys(Assembly.list);
	  keys.forEach((key) => list.concat(Object.values(Assembly.list[key])));
	  return list;
	}
	
	const positionReg = /^(c|r|d|center|rotation|demension).(x|y|z)$/;
	Assembly.resolveAttr = (assembly, attr) => {
	  if (!(assembly instanceof Assembly)) return undefined;
	  if (attr === 'length' || attr === 'height' || attr === 'h' || attr === 'l') {
	    return assembly.length();
	  } else if (attr === 'w' || attr === 'width') {
	    return assembly.width();
	  } else if (attr === 'depth' || attr === 'thickness' || attr === 'd' || attr === 't') {
	    return assembly.thickness();
	  }
	
	  const positionMatch = attr.match(positionReg);
	  if (positionMatch) {
	    const func = positionMatch[1];
	    const axis = positionMatch[2];
	    if (func === 'r' || func === 'rotation') return assembly.position().rotation(axis);
	    if (func === 'c' || func === 'center') return assembly.position().center(axis);
	    if (func === 'd' || func === 'demension') return assembly.position().demension(axis);
	  }
	
	  let groupVal;
	  if (assembly.parentAssembly() === undefined) {
	    const group = assembly.group();
	    groupVal = group.resolve(assembly, attr);
	  }
	  const assemVal = assembly.value(attr);
	  return Number.isFinite(assemVal) ? assemVal : groupVal;
	}
	Assembly.fromJson = (assemblyJson) => {
	  const demensionConfig = assemblyJson.demensionConfig;
	  const centerConfig = assemblyJson.centerConfig;
	  const rotationConfig = assemblyJson.rotationConfig;
	  const partCode = assemblyJson.partCode;
	  const partName = assemblyJson.partName;
	  const clazz = Object.class.get(assemblyJson._TYPE);
	  const assembly = new (clazz)(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	  assembly.id(assemblyJson.id);
	  assembly.value.all(assemblyJson.value.values);
	  assembly.setParentAssembly(assemblyJson.parent)
	  Object.values(assemblyJson.subassemblies).forEach((json) =>
	    assembly.addSubAssembly(Assembly.class(json._TYPE)
	                              .fromJson(json, assembly)));
	  if (assemblyJson.length) assembly.length(assemblyJson.length);
	  if (assemblyJson.width) assembly.width(assemblyJson.width);
	  if (assemblyJson.thickness) assembly.thickness(assemblyJson.thickness);
	  return assembly;
	}
	
	Assembly.classes = Object.class.object;
	Assembly.new = function (id) {
	  const clazz = Object.class.get(id);
	  if (clazz)
	    return new (clazz)(...Array.from(arguments).slice(1));
	  return null;
	};
	Assembly.class = Object.class.get;
	Assembly.classObj = Object.class.filter;
	
	Assembly.classList = (filterFunc) => Object.values(Assembly.classObj(filterFunc));
	Assembly.classIds = (filterFunc) => Object.keys(Assembly.classObj(filterFunc));
	Assembly.lists = {};
	Assembly.idCounters = {};
	
	Assembly.partCode = (assembly) => {
	  const cabinet = assembly.getAssembly('c');
	  if (cabinet) {
	    const name = assembly.constructor.name;
	    cabinet.partIndex = cabinet.partIndex || 0;
	    return `${assembly.constructor.abbriviation}`;
	  }
	}
	
	module.exports = Assembly
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/init-assem.js',
function (require, exports, module) {
	
const Assembly = require('./assembly.js');
	new Assembly();
	
	const Cabinet = require('./assemblies/cabinet.js');
	new Cabinet();
	
	const Divider = require('./assemblies/divider.js');
	new Divider();
	
	const DoorCatch = require('./assemblies/door/door-catch.js');
	new DoorCatch();
	
	const Door = require('./assemblies/door/door.js');
	new Door();
	
	const Hinges = require('./assemblies/door/hinges.js');
	new Hinges();
	
	const DrawerBox = require('./assemblies/drawer/drawer-box.js');
	new DrawerBox();
	
	const DrawerFront = require('./assemblies/drawer/drawer-front.js');
	new DrawerFront();
	
	const Guides = require('./assemblies/drawer/guides.js');
	new Guides();
	
	const Frame = require('./assemblies/frame.js');
	new Frame();
	
	const Handle = require('./assemblies/hardware/pull.js');
	new Handle();
	
	const Screw = require('./assemblies/hardware/screw.js');
	new Screw();
	
	const Panel = require('./assemblies/panel.js');
	new Panel();
	
	// const PartitionSection = require('./assemblies/section/partition/sections/divider.js');
	// new PartitionSection();
	//
	// const DividerSection = require('./assemblies/section/partition/partition');
	// new DividerSection();
	//
	// const Section = require('./assemblies/section/section.js');
	// new Section();
	//
	// const DivideSection = require('./assemblies/section/space/sections/divide-section.js');
	// new DivideSection();
	//
	// const OpeningCoverSection = require('./assemblies/section/space/sections/open-cover/open-cover.js');
	// new OpeningCoverSection();
	
	const DoorSection = require('./assemblies/section/sections/door.js');
	new DoorSection();
	
	const DrawerSection = require('./assemblies/section/sections/drawer.js');
	new DrawerSection();
	
	const DualDoorSection = require('./assemblies/section/sections/duel-door.js');
	new DualDoorSection();
	
	const FalseFrontSection = require('./assemblies/section/sections/false-front.js');
	new FalseFrontSection();
	
	// const SpaceSection = require('./assemblies/section/space/space.js');
	// new SpaceSection();
	
	const Cutter = require('./assemblies/cutter.js');
	new Cutter();
	
	Assembly.components = {
	  Divider, Panel, Cutter, Door, DrawerBox, DrawerFront, Frame,
	};
	
});


RequireJS.addFunction('./services/cabinet/app-src/config/property/definitions.js',
function (require, exports, module) {
	const Property = require('../property');
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	const IMPERIAL_US = Measurement.units()[1];
	
	const defs = {};
	
	defs.h = new Property('h', 'height', null);
	defs.w = new Property('w', 'width', null);
	defs.d = new Property('d', 'depth', null);
	defs.t = new Property('t', 'thickness', null);
	defs.l = new Property('l', 'length', null);
	
	//   Overlay
	defs.ov = new Property('ov', 'Overlay', {value: 1/2, notMetric: IMPERIAL_US});
	
	//   Reveal
	defs.r = new Property('r', 'Reveal', {value: 1/8, notMetric: IMPERIAL_US});
	defs.rvr = new Property('rvr', 'Reveal Right', {value: 1/8, notMetric: IMPERIAL_US});
	defs.rvl = new Property('rvl', 'Reveal Left', {value: 1/8, notMetric: IMPERIAL_US});
	defs.rvt = new Property('rvt', 'Reveal Top', {value: 1/2, notMetric: IMPERIAL_US});
	defs.rvb = new Property('rvb', 'Reveal Bottom', {value: 0, notMetric: IMPERIAL_US});
	
	//   Inset
	defs.is = new Property('is', 'Spacing', {value: 3/32, notMetric: IMPERIAL_US});
	
	//   Cabinet
	defs.sr = new Property('sr', 'Scribe Right', {value: 3/8, notMetric: IMPERIAL_US});
	defs.sl = new Property('sl', 'Scribe Left', {value: 3/8, notMetric: IMPERIAL_US});
	defs.rvibr = new Property('rvibr', 'Reveal Inside Bottom Rail', {value: 1/8, notMetric: IMPERIAL_US});
	defs.rvdd = new Property('rvdd', 'Reveal Dual Door', {value: 1/16, notMetric: IMPERIAL_US});
	defs.tkbw = new Property('tkbw', 'Toe Kick Backer Width', {value: 1/2, notMetric: IMPERIAL_US});
	defs.tkd = new Property('tkd', 'Toe Kick Depth', {value: 4, notMetric: IMPERIAL_US});
	defs.tkh = new Property('tkh', 'Toe Kick Height', {value: 4, notMetric: IMPERIAL_US});
	defs.pbt = new Property('pbt', 'Panel Back Thickness', {value: 1/2, notMetric: IMPERIAL_US});
	defs.iph = new Property('iph', 'Ideal Handle Height', {value: 42, notMetric: IMPERIAL_US});
	defs.brr = new Property('brr', 'Bottom Rail Reveal', {value: 1/8, notMetric: IMPERIAL_US});
	defs.frw = new Property('frw', 'Frame Rail Width', {value: 1.5, notMetric: IMPERIAL_US});
	defs.frt = new Property('frt', 'Frame Rail Thicness', {value: .75, notMetric: IMPERIAL_US});
	defs.bid = new Property('bid', 'Bottom Inset Depth', {value: 0, notMetric: IMPERIAL_US});
	defs.tid = new Property('tid', 'Top Inset Depth', {value: 0, notMetric: IMPERIAL_US});
	
	// Cabinet.AngledBackCorner
	defs.rbo = new Property('bo', 'Back Offset From Corner', {value: 24, notMetric: IMPERIAL_US});
	defs.lbo = new Property('lbo', 'Left Back Offset From Corner', {value: 24, notMetric: IMPERIAL_US});
	defs.rbo = new Property('rbo', 'Right Back Offset From Corner', {value: 24, notMetric: IMPERIAL_US});
	
	// Cabinet.Lshaped
	defs.lw = new Property('lw', 'Distance from Front to Back on the Left', {value: 24, notMetric: IMPERIAL_US});
	defs.rw = new Property('rw', 'Distance from Front to Back on the Right', {value: 24, notMetric: IMPERIAL_US});
	
	//   Panel
	
	//   Guides
	defs.dbtos = new Property('dbtos', 'Drawer Box Top Offset', .5*2.54);
	defs.dbsos = new Property('dbsos', 'Drawer Box Side Offest', 3*2.54/8);
	defs.dbbos = new Property('dbbos', 'Drawer Box Bottom Offset', 2.54/2);
	
	//   DoorAndFront
	defs.daffrw = new Property('daffrw', 'Door and front frame rail width', {value: '2 3/8', notMetric: IMPERIAL_US});
	defs.dafip = new Property('dafip', 'Door and front inset panel', {value: null});
	
	//   Door
	
	//   DrawerBox
	defs.dbst = new Property('dbst', 'Side Thickness', {value: 5/8, notMetric: IMPERIAL_US});
	defs.dbbt = new Property('dbbt', 'Box Bottom Thickness', {value: 1/4, notMetric: IMPERIAL_US});
	defs.dbid = new Property('dbid', 'Bottom Inset Depth', {value: 1/2, notMetric: IMPERIAL_US});
	defs.dbn = new Property('dbn', 'Bottom Notched', {value: true, notMetric: IMPERIAL_US});
	
	//   DrawerFront
	defs.mfdfd = new Property('mfdfd', 'Minimum Framed Drawer Front Height', {value: 6, notMetric: IMPERIAL_US})
	
	//   Frame
	
	//   Handle
	defs.c2c = new Property('c2c', 'Center To Center', null);
	defs.proj = new Property('proj', 'Projection', null);
	
	//   Hinge
	defs.maxtab = new Property('maxtab', 'Max Spacing from bore to edge of door', null);
	defs.mintab = new Property('mintab', 'Minimum Spacing from bore to edge of door', null);
	defs.maxol = new Property('maxol', 'Max Door Overlay', null);
	defs.minol = new Property('minol', 'Minimum Door Overlay', null)
	
	//   Opening
	
	module.exports = defs;
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/line-plane-int.js',
function (require, exports, module) {
	
const Vertex3D = require('./vertex');
	
	const epsilon = 1e-6;
	function intersectLinePlane(line, plane, segment) {
	  const vect0 = line.startVertex.vector();
	  const vect1 = line.endVertex.vector();
	  const planePoint = plane[0];
	  const planeNormal = plane.normal();
	  u = vect1.minus(vect0);
	  dot = planeNormal.dot(u);
	
	  if (Math.abs(dot) > epsilon) {
	    w = vect0.minus(planePoint);
	    fac = -planeNormal.dot(w) / dot;
	    u = u.scale(fac);
	    const intersection = new Vertex3D(vect0.add(u));
	    if (segment) {
	      if (frac <= 1 && frac >= 0) return intersection;
	      return null;
	    }
	    return intersection;
	  }
	
	  return null;
	}
	
	module.exports = intersectLinePlane;
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/joint/init.js',
function (require, exports, module) {
	
const Joint = require('./joint');
	
	const Butt = require('./joints/butt.js');
	const Dado = require('./joints/dado.js');
	const Miter = require('./joints/miter.js');
	const Rabbet = require('./joints/rabbet.js');
	
	Joint.types = {
	  Butt, Dado, Miter, Rabbet
	};
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/joint/joint.js',
function (require, exports, module) {
	
const Lookup = require('../../../../../public/js/utils/object/lookup.js')
	
	
	class Joint {
	  constructor(malePartCode, femalePartCode, condition) {
	    let parentAssembly;
	    const initialVals = {
	      maleOffset: 0, femaleOffset: 0, parentAssemblyId:  undefined,
	      malePartCode, femalePartCode, demensionAxis: '', centerAxis: ''
	    }
	    Object.getSet(this, initialVals);
	
	    this.apply = () => (typeof condition === 'function') ? condition(this) : true;
	
	    this.parentAssembly = () => {
	      if (!parentAssembly && this.parentAssemblyId()) {
	        parentAssembly = Lookup.get(this.parentAssemblyId());
	        this.parentAssemblyId = () => parentAssembly.id();
	      }
	      return parentAssembly;
	    }
	
	    this.updatePosition = () => {};
	
	    this.getFemale = () => this.parentAssembly().getAssembly(this.femalePartCode());
	    this.getMale = () => this.parentAssembly().getAssembly(this.malePartCode());
	
	    this.getDemensions = () => {
	      const malePos = getMale();
	      const femalePos = getFemale();
	      // I created a loop but it was harder to understand
	      return undefined;
	    }
	    this.toString = () => `${this.constructor.name}:${this.malePartCode()}->${this.femalePartCode()}`;
	
	    if (Joint.list[this.malePartCode()] === undefined) Joint.list[this.malePartCode()] = [];
	    if (Joint.list[this.femalePartCode()] === undefined) Joint.list[this.femalePartCode()] = [];
	    Joint.list[this.malePartCode()].push(this);
	    Joint.list[this.femalePartCode()].push(this);
	  }
	}
	Joint.list = {};
	Joint.regex = /([a-z0-9-_\.]{1,})->([a-z0-9-_\.]{1,})/;
	
	Joint.classes = {};
	Joint.register = (clazz) => {
	  new clazz();
	  Joint.classes[clazz.prototype.constructor.name] = clazz;
	}
	Joint.new = function (id, json) {
	  return new Joint.classes[id]().fromJson(json);
	}
	module.exports = Joint
	
});


RequireJS.addFunction('./services/cabinet/app-src/cost/types/labor.js',
function (require, exports, module) {
	

	
	const Material = require('./material.js');
	const Cost = require('../cost.js');
	
	
	// unitCost.value = (hourlyRate*hours)/length
	// calc(assembly) = unitCost.value * formula
	
	class Labor extends Material {
	  constructor (props) {
	    super(props);
	    const type = props.laborType;
	    props.hourlyRate = Labor.hourlyRates[type]
	    const parentCalc = this.calc;
	    this.cost = () => this.hourlyRate() * props.hours;
	    if (Labor.hourlyRates[type] === undefined) Labor.types.push(type);
	    Labor.hourlyRate(type, props.hourlyRate);
	
	    const parentToJson = this.toJson;
	  }
	}
	
	
	Labor.defaultRate = 40;
	Labor.hourlyRate = (type, rate) => {
	  rate = Cost.evaluator.eval(new String(rate));
	  if (!Number.isNaN(rate)) Labor.hourlyRates[type] = rate;
	  return Labor.hourlyRates[type] || Labor.defaultRate;
	}
	Labor.hourlyRates = {};
	Labor.types = [];
	Labor.explanation = `Cost to be calculated hourly`;
	
	module.exports = Labor
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/objects/fixed-value.js',
function (require, exports, module) {
	
// This is just a flag object that indicates if a value that normally changes is fixed.
	class FixedValue extends Number {
	  constructor(value, column) {
	    super(value);
	    this.column = () => column;
	    this.equals = (other) => {
	      if (!(other instanceof FixedValue)) return false;
	      return this.valueOf() === other.valueOf();
	    }
	  }
	}
	
	module.exports = FixedValue;
	
});


RequireJS.addFunction('./services/cabinet/app-src/cost/types/material.js',
function (require, exports, module) {
	

	
	const Cost = require('../cost.js');
	const Assembly = require('../../objects/assembly/assembly.js');
	
	class Material extends Cost {
	  constructor (props) {
	    super(props);
	    props = this.props();
	    props.cost = props.cost / (props.count || 1);
	    const instance = this;
	    Object.getSet(props, 'company', 'formula', 'partNumber',
	                'method', 'length', 'width', 'depth', 'cost');
	
	
	    this.unitCost = (attr) => {
	      const unitCost = Material.configure(instance.method(), instance.cost(),
	        instance.length(), instance.width(), instance.depth());
	      const copy = JSON.parse(JSON.stringify(unitCost));
	      if (attr) return copy[attr];
	      return copy;
	    }
	
	    this.calc = (assemblyOrCount) => {
	      const unitCost = this.unitCost();
	      const formula = this.formula() || unitCost.formula;
	      if (assemblyOrCount instanceof Assembly)
	        return Cost.evaluator.eval(`${unitCost.value}*${formula}`, assemblyOrCount);
	      else if (Number.isFinite(assemblyOrCount))
	        return Cost.evaluator.eval(`${unitCost.value}*${assemblyOrCount}`);
	      else
	        throw new Error('calc argument must be a number or Assembly');
	    }
	  }
	}
	
	Material.methods = {
	  LINEAR_FEET: 'Linear Feet',
	  SQUARE_FEET: 'Square Feet',
	  CUBIC_FEET: 'Cubic Feet',
	  UNIT: 'Unit'
	};
	
	Material.methodList = Object.values(Material.methods);
	
	
	Material.configure = (method, cost, length, width, depth) => {
	  const unitCost = {};
	  switch (method) {
	    case Material.methods.LINEAR_FEET:
	      const perLinearInch = Cost.evaluator.eval(`${cost}/${length}`);
	      unitCost.name = 'Linear Inch';
	      unitCost.value = perLinearInch;
	      unitCost.formula = 'l';
	      return unitCost;
	    case Material.methods.SQUARE_FEET:
	      const perSquareInch = Cost.evaluator.eval(`${cost}/(${length}*${width})`);
	      unitCost.name = 'Square Inch';
	      unitCost.value = perSquareInch;
	      unitCost.formula = 'l*w';
	      return unitCost;
	    case Material.methods.CUBIC_FEET:
	      const perCubicInch = Cost.evaluator.eval(`${cost}/(${length}*${width}*${depth})`);
	      unitCost.name = 'Cubic Inch';
	      unitCost.value = perCubicInch;
	      unitCost.formula = 'l*w*d';
	      return unitCost;
	    case Material.methods.UNIT:
	      unitCost.name = 'Unit';
	      unitCost.value = cost;
	      return unitCost;
	    default:
	      throw new Error('wtf');
	      unitCost.name = 'Unknown';
	      unitCost = -0.01;
	      formula = -0.01;
	      return unitCost;
	  }
	};
	
	Material.explanation = `Cost to be calculated by number of units or demensions`;
	
	module.exports = Material
	
});


RequireJS.addFunction('./services/cabinet/app-src/two-d/layout/window.js',
function (require, exports, module) {
	
const OnWall = require('./on-wall');
	const HoverObject2d = require('../../../../../public/js/utils/canvas/two-d/hover-map.js').HoverObject2d;
	
	class Window2D extends OnWall {
	  constructor(wall, fromPreviousWall, fromFloor, height, width) {
	    width = width || 81.28;
	    height = height || 91.44;
	    fromFloor = fromFloor || 101.6;
	    fromPreviousWall = fromPreviousWall || 20;
	    super(wall, fromPreviousWall, fromFloor, height, width);
	    const instance = this;
	    this.remove = () => this.wall().removeWindow(this);
	    this.toString = () => `${this.id()}:${this.endpoints2D().toString()}`;
	
	    this.hovering = new HoverObject2d(this.toLine, 5).hovering;
	  }
	}
	
	new Window2D();
	module.exports = Window2D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/two-d/layout/wall.js',
function (require, exports, module) {
	const Line2d = require('../../../../../public/js/utils/canvas/two-d/objects/line.js');
	const OnWall = require('./on-wall');
	const Door2D = require('./door');
	const Window2D = require('./window');
	const HoverObject2d = require('../../../../../public/js/utils/canvas/two-d/hover-map').HoverObject2d;
	
	function modifyVertex(vertex) {
	  return (props) => {
	      console.log('DummyFuncNotIntendedToBeCalled');
	  }
	}
	
	class Wall2D extends Line2d {
	  constructor(startVertex, endVertex, height, windows, doors) {
	    super(startVertex, endVertex);
	    this.startVertex().modificationFunction(modifyVertex(this.startVertex()));
	    this.endVertex().modificationFunction(modifyVertex(this.endVertex()));
	    Lookup.convert(this);
	    windows = windows || [];
	    windows.forEach((win) => win.setWall(this));
	    doors = doors || [];
	    doors.forEach((door) => door.setWall(this));
	    const wall = this;
	
	    height = height || 243.84;
	    Object.getSet(this, {height, windows, doors});
	    // this.copy = () => new Wall2D(this.length(), this.radians());
	    this.windows = () => windows;
	    this.addWindow = (fromPreviousWall) => windows.push(new Window2D(this, fromPreviousWall));
	    this.doors = () => doors;
	    this.addDoor = (fromPreviousWall) => doors.push(new Door2D(this, fromPreviousWall));
	    this.vertices = () => {
	      const verts = [this.startVertex()];
	      const doorsAndWindows = doors.concat(windows);
	      doorsAndWindows.sort(OnWall.sort);
	      doorsAndWindows.forEach((onWall) => {
	        const endpoints = onWall.endpoints2D();
	        verts.push(endpoints.start);
	        verts.push(endpoints.end);
	      });
	      verts.push(this.endVertex());
	      return verts;
	    }
	
	    this.remove = () => {
	        const prevWall = this.startVertex().prevLine();
	        const nextLine = this.endVertex().nextLine();
	        const startVertex = this.startVertex();
	        nextLine.startVertex(startVertex);
	        startVertex.nextLine(nextLine);
	    }
	
	    const hoveringStart = new HoverObject2d(() => this.startVertex(), 24).hovering;
	    const hoveringEnd = new HoverObject2d(() => this.endVertex(), 24).hovering;
	    const hoveringWall = new HoverObject2d(() => this, 10).hovering;
	    this.hovering = (v) => {
	      if (hoveringStart(v)) return this.startVertex();
	      if (hoveringEnd(v)) return this.endVertex();
	      for (let index = 0; index < windows.length; index++) {
	        if (windows[index].hovering(v)) return windows[index];
	      }
	      for (let index = 0; index < doors.length; index++) {
	        if (doors[index].hovering(v)) return doors[index];
	      }
	      return hoveringWall(v) && this;
	    }
	
	    this.removeDoor = (door) => doors.splice(doors.indexOf(door), 1);
	    this.removeWindow = (window) => windows.splice(windows.indexOf(window), 1);
	  }
	}
	Wall2D.fromJson = (json, vertexMap) => {
	  vertexMap ||= {};
	  const newSv = Object.fromJson(json.startVertex);
	  const svStr = newSv.toString();
	  const newEv = Object.fromJson(json.endVertex);
	  const evStr = newEv.toString();
	  if (vertexMap[svStr] === undefined) vertexMap[svStr] = newSv;
	  if (vertexMap[evStr] === undefined) vertexMap[evStr] = newEv;
	  const sv = vertexMap[svStr];
	  const ev = vertexMap[evStr];
	  const windows = Object.fromJson(json.windows);
	  const doors = Object.fromJson(json.doors);
	  const inst = new Wall2D(sv, ev, json.height, windows, doors);
	  inst.id(json.id);
	  return inst;
	}
	
	new Wall2D();
	module.exports = Wall2D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/two-d/layout/on-wall.js',
function (require, exports, module) {
	
const Lookup = require('../../../../../public/js/utils/object/lookup.js');
	const Vertex2d = require('../../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const Line2d = require('../../../../../public/js/utils/canvas/two-d/objects/line.js');
	
	class OnWall extends Lookup {
	  constructor(wall, fromPreviousWall, fromFloor, height, width) {
	    super();
	    Object.getSet(this, {width, height, fromFloor, fromPreviousWall}, 'wallId');
	    let start = new Vertex2d();
	    let end = new Vertex2d();
	    this.wallId = () => wall.id();
	    this.endpoints2D = () => {
	      const wallStartPoint = wall.startVertex();
	      const dist = this.fromPreviousWall();
	      const total = dist + this.width();
	      const theta = wall.radians();
	      const startPoint = {};
	      startPoint.x = wallStartPoint.x() + dist * Math.cos(theta);
	      startPoint.y = wallStartPoint.y() + dist * Math.sin(theta);
	      start.point(startPoint);
	
	      const endPoint = {};
	      endPoint.x = (wallStartPoint.x() + total * Math.cos(theta));
	      endPoint.y = (wallStartPoint.y() + total * Math.sin(theta));
	      end.point(endPoint);
	
	      return { start, end, toString: () => `${start.toString()} => ${end.toString()}`};
	    }
	    this.fromPreviousWall = (value) => {
	      value = Number.parseFloat(value);
	      if (!Number.isNaN(value)) fromPreviousWall = value;
	      return fromPreviousWall;
	    }
	    this.fromNextWall = (value) => {
	      value = Number.parseFloat(value);
	      if (value) {
	        this.fromPreviousWall(wall.length() - this.width() - value);
	      }
	      return wall.length() - this.width() - this.fromPreviousWall();
	    }
	    this.startVertex = () => {
	      const startpoint = wall.startVertex().point();
	      const theta = wall.radians();
	      const distLeft = this.fromPreviousWall() + width;
	      return new Vertex2d({x: startpoint.x + distLeft * Math.cos(theta),
	                    y: startpoint.y + distLeft * Math.sin(theta)});
	    }
	    this.endVertex = () => {
	      const startpoint = wall.startVertex().point();
	      const theta = wall.radians();
	      const distRight = this.fromPreviousWall();
	      return new Vertex2d({x: startpoint.x + distRight * Math.cos(theta),
	                            y: startpoint.y + distRight * Math.sin(theta)});
	    }
	    this.toLine = () => new Line2d(this.startVertex(), this.endVertex());
	    this.wall = () => wall;
	    this.setWall = (w) => wall = w;
	    this.move = (center) => {
	      const point = wall.closestPointOnLine(center);
	      const onLine = wall.closestPointOnLine(point, true);
	      let distanceStart = wall.startVertex().distance(point);
	      if (!onLine) {
	        let distanceEnd = wall.endVertex().distance(point);
	        if (distanceStart < distanceEnd) this.fromPreviousWall(0);
	        else this.fromPreviousWall(wall.length() - this.width());
	      } else {
	        const max = wall.length() - this.width();
	        distanceStart = distanceStart > max ? max : distanceStart;
	        this.fromPreviousWall(distanceStart);
	      }
	    };
	    this.toString = () => `${this.constructor.name}:${wall}, ${fromPreviousWall}, ${fromFloor}, ${height}, ${width}`
	  }
	}
	OnWall.sort = (ow1, ow2) => ow1.fromPreviousWall() - ow2.fromPreviousWall();
	OnWall.fromJson = (json) => {
	  const cxtr = Lookup.decode(json.id).constructor;
	  const instance = new cxtr(null, json.fromPreviousWall, json.fromFloor, json.height, json.width);
	  instance.id(json.id);
	  return instance;
	}
	
	
	module.exports = OnWall;
	
});


RequireJS.addFunction('./services/cabinet/app-src/two-d/layout/layout.js',
function (require, exports, module) {
	
const approximate = require('../../../../../public/js/utils/approximate.js').new(1);
	const Lookup = require('../../../../../public/js/utils/object/lookup.js');
	const StateHistory = require('../../../../../public/js/utils/services/state-history');
	const Vertex2d = require('../../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const Line2d = require('../../../../../public/js/utils/canvas/two-d/objects/line.js');
	const Circle2d = require('../../../../../public/js/utils/canvas/two-d/objects/circle.js');
	const CustomEvent = require('../../../../../public/js/utils/custom-event.js');
	const Property = require('../../config/property.js');
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	const IMPERIAL_US = Measurement.units()[1];
	const Wall2D = require('./wall');
	const Corner2d = require('./corner');
	const Window2D = require('./window');
	const Object3D = require('../../three-d/layout/object.js');
	const Door2D = require('./door');
	
	function withinTolerance(point, map) {
	  const t = map.tolerance;
	  const start = map.start.point ? map.start.point() : map.start;
	  const end = map.end.point ? map.end.point() : map.end;
	  const x0 = point.x;
	  const y0 = point.y;
	  const x1 = start.x > end.x ? end.x : start.x;
	  const y1 = start.y > end.y ? end.y : start.y;
	  const x2 = start.x < end.x ? end.x : start.x;
	  const y2 = start.y < end.y ? end.y : start.y;
	  return x0>x1-t && x0 < x2+t && y0>y1-t && y0<y2+t;
	}
	
	const ww = 500;
	class Layout2D extends Lookup {
	  constructor(walls) {
	    super();
	    let history;
	    const addEvent = new CustomEvent('add');
	    const removeEvent = new CustomEvent('remove');
	    const stateChangeEvent = new CustomEvent('stateChange');
	    this.onAdd = (func) => addEvent.on(func);
	    this.onRemove = (func) => removeEvent.on(func);
	    this.onStateChange = (func) => stateChangeEvent.on(func);
	
	    walls = walls || [];
	    Object.getSet(this, {objects: [], walls});
	    const initialized = walls.length > 0;
	    const instance = this;
	
	    this.startLine = () => this.walls()[0];
	    this.endLine = () => this.walls()[this.walls().length - 1];
	
	    function sortByAttr(attr) {
	      function sort(obj1, obj2) {
	        if (obj2[attr] === obj1[attr]) {
	          return 0;
	        }
	        return obj2[attr] < obj1[attr] ? 1 : -1;
	      }
	      return sort;
	    }
	
	    this.wallIndex = (wallOrIndex) => {
	      if (wallOrIndex instanceof Wall2D) {
	        for (let index = 0; index < walls.length; index += 1) {
	          if (walls[index] === wallOrIndex) return index;
	        }
	        return -1;
	      } else {
	        while(wallOrIndex < 0) wallOrIndex += walls.length;
	        return wallOrIndex % walls.length;
	      }
	    }
	
	    this.cornerIndex = (cornerOrIndex) => {
	      if (cornerOrIndex instanceof Corner2d) {
	        for (let index = 0; index < walls.length; index += 1) {
	          if (walls[index].startVertex() === cornerOrIndex) return index;
	        }
	        return -1;
	      } else {
	        while(cornerOrIndex < 0) cornerOrIndex += walls.length;
	        return cornerOrIndex % walls.length;
	      }
	    }
	
	    function relitiveWall(wallOcorner, i) {
	      let position
	      if (wallOcorner instanceof Corner2d) {
	        if (i === 0) return null;
	        position = instance.cornerIndex(wallOcorner);
	        if (i >= 0) i--;
	      } else position = instance.wallIndex(wallOcorner);
	
	      if (position === undefined) return null;
	      const relitiveList = walls.slice(position).concat(walls.slice(0, position));
	      return relitiveList[instance.wallIndex(i)];
	    }
	    this.relitiveWall = relitiveWall;
	    this.nextWall = (wall) => relitiveWall(wall, 1);
	    this.prevWall = (wall) => relitiveWall(wall, -1);
	
	    function reconsileLength (wall) {
	      return (newLength) => {
	        const moveVertex = wall.endVertex();
	        const nextLine = instance.nextWall(wall);
	        if (nextLine === undefined) wall.length(newLength);
	
	        const vertex1 = nextLine.endVertex();
	        const circle1 = new Circle2d(nextLine.length(), vertex1);
	        const vertex2 = wall.startVertex();
	        const circle2 = new Circle2d(newLength, vertex2);
	        const intersections = circle1.intersections(circle2);
	
	        const useFirst = (intersections.length !== 0 && intersections.length === 1) ||
	                  moveVertex.distance(intersections[0]) < moveVertex.distance(intersections[1]);
	        if (intersections.length === 0) {
	          wall.length(newLength);
	        } else if (useFirst) {
	          moveVertex.point(intersections[0]);
	        } else {
	          moveVertex.point(intersections[1]);
	        }
	      }
	    }
	    this.reconsileLength = reconsileLength;
	
	    const sortById = sortByAttr('id');
	    this.toJson = () => {
	      const objs = this.objects().filter(o => o.shouldSave());
	      const json = {walls: []};
	      json.id = this.id();
	      json.objects = Array.toJson(objs);
	      this.walls().forEach((wall) => {
	        json.walls.push(wall.toJson());
	      });
	      // json.walls.sort(sortById);
	      json.objects.sort(sortById);
	      const snapMap = {};
	      objs.forEach((obj) => {
	        const snapLocs = obj.snap2d.top().snapLocations.paired();
	        snapLocs.forEach((snapLoc) => {
	          const snapLocJson = snapLoc.toJson();
	          if (snapMap[snapLocJson.UNIQUE_ID] === undefined) {
	            snapMap[snapLocJson.UNIQUE_ID] = snapLocJson;
	          }
	        });
	      });
	      json.snapLocations = Object.values(snapMap);
	      json._TYPE = this.constructor.name;
	      delete json.id;
	      return json;
	    }
	
	    this.isFreeCorner = (corner) => corner === this.walls()[0].startVertex();
	    this.straightenUp = () => this.walls()[0].startVertex().straightenUp();
	
	    let ceilingHeight = new Property('ceilh', 'Heigth from the floor to the ceiling', {value: 96, notMetric: IMPERIAL_US});
	    this.ceilingHeight = (height) => {
	      if (height) {
	        ceilingHeight.value(height, true);
	      }
	      return ceilingHeight.value();
	    }
	
	    let baseHeight = new Property('baseh', 'Default height for a base cabinet', {value: 34, notMetric: IMPERIAL_US});
	    this.baseHeight = (height) => {
	      if (height) {
	        baseHeight.value(height, true);
	      }
	      return baseHeight.value();
	    }
	
	    let wallHeight = new Property('baseh', 'Default height for a base cabinet', {value: 34, notMetric: IMPERIAL_US});
	    this.wallHeight = (height) => {
	      if (height) {
	        wallHeight.value(height, true);
	      }
	      return wallHeight.value();
	    }
	
	    let baseDepth = new Property('based', 'Default depth for a base cabinet', {value: 24, notMetric: IMPERIAL_US});
	    this.baseDepth = (depth) => {
	      if (depth) {
	        baseDepth.value(depth, true);
	      }
	      return baseDepth.value();
	    }
	
	    let wallDepth = new Property('walld', 'Default depth for a wall cabinet', {value: 12, notMetric: IMPERIAL_US});
	    this.wallDepth = (depth) => {
	      if (depth) {
	        wallDepth.value(depth, true);
	      }
	      return wallDepth.value();
	    }
	
	    let counterHeight = new Property('counterh', 'Distance from baseh to wallHeight', {value: 18, notMetric: IMPERIAL_US});
	    this.counterHeight = (height) => {
	      if (height) {
	        counterHeight.value(height, true);
	      }
	      return counterHeight.value();
	    }
	
	    this.wallElevation = () => this.baseHeight() + this.counterHeight();
	
	    this.push = (...points) => {
	      points = points.map(p => new Corner2d(this, p));
	      if (this.startLine() === undefined) {
	        const walls = this.walls();
	        if (points.length < 3) throw Error('Layout must be initialized with atleast three vertices');
	        walls[0] = new Wall2D(points[0], points[1]);
	      }
	      for (let index = 1; index < points.length; index += 1) {
	        const endLine = this.endLine();
	        const startV = endLine.endVertex();
	        const endV = points[(index + 1) % points.length];
	        const currWall = new Wall2D(startV, endV);
	        walls.push(currWall);
	      }
	    }
	
	    this.addObject = (id, payload, name, polygon) => {
	      const center = Vertex2d.center.apply(null, this.vertices())
	      const obj = Object3D.new(payload, polygon);
	      obj.bridge.top().center(center);
	      obj.id(id);
	      this.objects().push(obj);
	      history.newState();
	      addEvent.trigger(undefined, payload);
	      return obj;
	    }
	
	    this.removeObject = (obj) => {
	      for (index = 0; index < this.objects().length; index += 1) {
	        if (this.objects()[index] === obj) {
	          const obj = this.objects().splice(index, 1);
	          removeEvent.trigger(undefined, obj.payload());
	          return obj;
	        }
	      }
	      return null;
	    }
	
	    this.removeByPayload = (payload) => {
	      for (index = 0; index < this.objects().length; index += 1) {
	        if (this.objects()[index].payload() === payload) {
	          const obj = this.objects().splice(index, 1);
	          removeEvent.trigger(undefined, payload);
	          return obj;
	        }
	      }
	      return null;
	    }
	
	    this.idMap = () => {
	      const idMap = {};
	      const walls = this.walls();
	      idMap[walls[0].startVertex().id()] = walls[0].startVertex();
	      walls.forEach((wall) => {
	        idMap[wall.id()] = wall;
	        const endV = wall.endVertex();
	        idMap[endV.id()] = endV;
	        wall.windows().forEach((window) => idMap[window.id()] = window);
	        wall.windows().forEach((window) => idMap[window.id()] = window);
	        wall.doors().forEach((door) => idMap[door.id()] = door);
	      });
	      this.objects().forEach((obj) => idMap[obj.id()] = obj);
	      return idMap;
	    }
	
	    this.removeWall = (wall) => {
	      if (!(wall instanceof Wall2D)) return undefined;
	      const walls = this.walls();
	      for (index = 0; index < walls.length; index += 1) {
	        const currWall = walls[index];
	        if (currWall === wall) {
	          const nextWallSv = walls[this.wallIndex(index + 1)].startVertex();
	          walls[this.wallIndex(index - 1)].endVertex(nextWallSv);
	          walls.splice(index, 1);
	          return currWall;
	        }
	      }
	      return null;
	    }
	
	    this.addVertex = (vertex, wall) => {
	      vertex = new Corner2d(this, vertex);
	      let wallIndex = this.wallIndex(wall);
	      if (wallIndex === -1) {
	        wall = walls[walls.length - 1];
	        wallIndex = this.wallIndex(wall);
	      }
	      let newWall = new Wall2D(vertex, wall.endVertex());
	      wall.endVertex(vertex);
	
	      const tail = [newWall].concat(walls.slice(wallIndex + 1));
	      walls = walls.slice(0, wallIndex + 1).concat(tail);
	    }
	
	    this.removeVertex = (vertex) => {
	      if (!(vertex instanceof Vertex2d)) return undefined;
	      const walls = this.walls();
	      for (index = 0; index < walls.length; index += 1) {
	        const wall = walls[index];
	        if (wall.startVertex() === vertex) {
	          walls[this.wallIndex(index - 1)].endVertex(walls[this.wallIndex(index + 1)].startVertex());
	          return walls.splice(index, 1);
	        }
	        if (wall.endVertex() === vertex) {
	          walls[this.wallIndex(index + 1)].startVertex(walls[this.wallIndex(index - 1)].endVertex());
	          return walls.splice(index, 1);
	        }
	      }
	      return null;
	    }
	
	    this.remove = (id) => {
	      id = id instanceof Lookup ? id.id() : id;
	      const idMap = this.idMap();
	      const walls = this.walls();
	      const wallCount = walls.length;
	      const item = idMap[id];
	      if (item === undefined) throw new Error(`Unknown id: ${id}`);
	      if (wallCount < 3 && (item instanceof Wall2D || item instanceof Vertex2d))
	          throw new Error('Cannot Remove any more vertices or walls');
	
	      return this.removeVertex(item) || this.removeWall(item) ||
	              this.removeObject(item) || item.remove();
	    }
	
	    this.vertices = (target, before, after) => {
	      const lines = this.walls();
	      if (lines.length === 0) return [];
	      const fullList = [];
	      for (let index = 0; index < lines.length; index += 1) {
	        const line = lines[index];
	        fullList.push(line.startVertex());
	      }
	      if (target) {
	        const vertices = [];
	        const index = fullList.indexOf(target);
	        if (index === undefined) return null;
	        for (let i = before; i < before + after + 1; i += 1)
	            vertices.push(fullList[Math.mod(i, fullList.length)]);
	        return vertices;
	      } else return fullList;
	
	      return vertices;
	    }
	    this.center = () => Vertex2d.center(...this.vertices());
	
	    const record = {within: [], notWithin: []};;
	    this.within = (vertex, doNotCall) => {
	      if (!doNotCall && this.within(vertex, true)) {
	        console.log.subtle('isWithin', 500);
	      }
	      vertex = new Vertex2d(vertex);
	      const endpoint = {x: 0, y: 0};
	      this.vertices().forEach(v => {
	        // TODO: figure out why negating the components causes errors....
	        // endpoint.x -= v.x() * 2;
	        // endpoint.y -= v.y() * 2;
	        endpoint.x += v.x() * 2;
	        endpoint.y += v.y() * 2;
	      });
	      // const escapeLine = new Line2d(vertex, endpoint);
	      const escapeLine = Line2d.startAndTheta(vertex, Math.random()*3.14*2, 10000000);
	      const intersections = [];
	      let onLine = false;
	      const allIntersections = [];
	      this.walls().forEach((wall) => {
	
	        const intersection = wall.findSegmentIntersection(escapeLine, true);
	        allIntersections.push(intersection);
	        if (intersection) {
	          if (intersection.equals(vertex)) onLine = true;
	          intersections.push(intersection);
	        }
	      });
	
	      const isWithin = onLine || intersections.length % 2 === 1;
	      if (!isWithin) {
	        record.notWithin.push(escapeLine);
	        if (record.notWithin.length > 500) record.notWithin = record.notWithin.slice(250);
	      } else {
	        record.within.push(escapeLine);
	        if (record.within.length > 500) record.within = record.within.slice(250);
	      }
	      return isWithin;
	    }
	
	    this.connected = () => {
	      for (let index = 0; index < walls.length; index += 1) {
	        const wall = walls[index];
	        const prevWall = this.prevWall(wall);
	        if (wall.startVertex() !== prevWall.endVertex()) return false;
	      }
	      return true;
	    }
	
	    this.payloads = () => {
	      const payloads = [];
	      this.objects().forEach((obj) => {
	        const center = obj.center();
	        const payload = obj.payload();
	        payloads.push({center, payload});
	      });
	      return payloads;
	    }
	
	    function filterCompare(list) {
	      list = list.map((o) => o.payload());
	      return list.filter((o) => o);
	    }
	
	    this.fromJson = (json) => {
	      const layout = Layout2D.fromJson(json);
	      const origWalls = this.walls();
	      const newWalls = layout.walls();
	      const wallCompare = Array.compare(origWalls, newWalls, true);
	
	      const origObjects = this.objects();
	      const newObjects = layout.objects();
	      const objCompare = Array.compare(origObjects, newObjects, true);
	
	      if (objCompare || wallCompare) {
	        const detail = {layout, objects: {added: [], removed: []}, walls: {added: [], removed: []}};
	        if (objCompare) {
	          detail.objects.added = filterCompare(objCompare.added);
	          detail.objects.removed = filterCompare(objCompare.removed);
	        }
	        if (wallCompare) {
	          detail.walls.added = filterCompare(wallCompare.added);
	          detail.walls.removed = filterCompare(wallCompare.removed);
	        }
	        stateChangeEvent.trigger(undefined, detail);
	      }
	    }
	
	    function inRange(min1, max1, min2, max2) {
	      const minWithin = (min1 <= min2 && max1 >= min2);
	      const maxWithin = minWithin || (max1 <= max2 && max1 >= min2);
	      const oneWithin = maxWithin || (max1 < max2 && min1 > min2);
	      return oneWithin;
	    }
	
	    this.levels = () => {
	      const objs = instance.objects().sortByAttr('height');
	
	      const levelList = [];
	      for (let index = 0; index < objs.length; index++) {
	        const obj = objs[index];
	        const bridge = obj.bridge.top();
	        const heightLoc = {min: bridge.fromFloor(), max: bridge.fromFloor() + obj.height()};
	        let found = false;
	        for (let lIndex = 0; lIndex < levelList.length; lIndex++) {
	          const levelObj = levelList[lIndex];
	          const loc = levelObj.heightLoc;
	          if (inRange(loc.min, loc.max, heightLoc.min, heightLoc.max)) {
	            found = true;
	            levelObj.objects.push(obj);
	          }
	        }
	        if (!found) {
	          levelList.push({heightLoc, objects: [obj]});
	        }
	      }
	      const sorted = levelList.sortByAttr('heightLoc.min');
	      return sorted.map(o => o.objects);
	    }
	
	    let savedIndex = 0;
	    this.nextLevel = () => this.level(savedIndex);
	    this.prevLevel = () => this.level(savedIndex - 2);
	    this.level = (index) => {
	      if (Number.isFinite(index)) savedIndex = index + 1;
	      const levels = this.levels();
	      const modIndex = Math.mod(savedIndex, levels.length + 2) - 1;
	      console.log.subtle(500,savedIndex,modIndex);
	      if (modIndex === -1) return [];
	      if (modIndex === levels.length) return this.objects();
	      return levels[modIndex];
	    }
	    this.activeObjects = () => this.level() || this.objects();
	
	    // if (!initialized) this.push({x:0, y:0}, {x:ww, y:0}, {x:ww,y:ww}, {x:0,y:ww});
	    if (!initialized) this.push({x:1, y:1}, {x:ww+1, y:0}, {x:ww + 1,y:ww + 1}, {x:1,y:ww});
	    // if (!initialized) this.push({x:-250, y:-250}, {x:250, y:-250}, {x:250,y:250}, {x:-250,y:250});
	    this.walls = () => walls;
	
	    history = new StateHistory(this.toJson, this.fromJson);
	    this.history = () => history;
	
	    this.snapAt = (vertex, excuded) => {
	      for (let index = 0; index < this.objects().length; index++) {
	        const obj = this.objects()[index];
	        if (excuded !== obj || Array.exists(excuded, obj)) {
	          const hovering = obj.snap2d.top().hoveringSnap(vertex, excuded);
	          if (hovering) return hovering;
	        }
	      }
	    }
	
	    this.atWall = (vertex) => {
	      for (let index = 0; index < walls.length; index++) {
	        const hovering = walls[index].hovering(vertex);
	        if (hovering) return hovering;
	      }
	    }
	
	    this.at = (vertex) => {
	      const activeObjects = this.level() || this.objects();
	      for (let index = 0; index < activeObjects.length; index++) {
	        const hovering = activeObjects[index].snap2d.top().hovering(vertex);
	        if (hovering) return hovering;
	      }
	      return this.atWall(vertex);
	    }
	
	    this.toDrawString = () => {
	      return Line2d.toDrawString(this.walls());
	    }
	  }
	}
	
	// Needs to be internal!!!!
	Layout2D.fromJson = (json) => {
	  const walls = [];
	  const vertexMap = {};
	  json.walls.forEach((wallJson) => walls.push(Wall2D.fromJson(wallJson, vertexMap)));
	
	  const layout = new Layout2D(walls);
	  layout.id(json.id);
	
	  const objects = [];
	  json.objects.forEach((o) => {
	    const center = Vertex2d.fromJson(o.center);
	    let obj = Object3D.get(o.id);
	    if (obj === undefined) {
	      obj = new Object3D(center, layout, undefined, o.name);
	      obj.payloadId(o.payloadId);
	      obj.id(o.id);
	    } else obj.fromJson(o);
	    objects.push(obj);
	  });
	  layout.objects(objects);
	  json.snapLocations.forEach((snapLocJson) => {
	    const view = snapLocJson.view;
	    const obj1 = Lookup.get(snapLocJson[0].objectId);
	    const obj2 = Lookup.get(snapLocJson[1].objectId);
	    const snapLoc1 = obj1[view]().position[snapLocJson[0].location]();
	    const snapLoc2 = obj2[view]().position[snapLocJson[1].location]();
	    snapLoc2.pairWith(snapLoc1);
	  });
	
	  console.log('isConnected:', layout.connected());
	  return layout;
	}
	
	const layoutStateChangeEvent = new CustomEvent('layoutStateChange');
	Layout2D.onStateChange = layoutStateChangeEvent.on;
	
	new Layout2D();
	module.exports = Layout2D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/two-d/layout/door.js',
function (require, exports, module) {
	
const OnWall = require('on-wall');
	const HoverObject2d = require('../../../../../public/js/utils/canvas/two-d/hover-map.js').HoverObject2d;
	
	class Door2D extends OnWall {
	  constructor() {
	    super(...arguments);
	    this.width(this.width() || 91.44);
	    this.height(this.height() || 198.12);
	    this.fromPreviousWall(this.fromPreviousWall() || 150);
	    this.fromFloor(this.fromFloor() || 0);
	    let hinge = 0;
	    Object.getSet(this, 'hinge');
	    this.toString = () => `${this.id()}:${this.endpoints2D().toString()}:${hinge}`;
	    this.remove = () => this.wall().removeDoor(this);
	    this.hinge = (val) => val === undefined ? hinge :
	      hinge = ((typeof val) === 'number' ? val : hinge + 1) % 5;
	
	    this.hovering = new HoverObject2d(this.toLine, 20).hovering;
	  }
	}
	
	Door2D.fromJson = (json) => {
	  const inst = OnWall.fromJson(json);
	  inst.hinge(json.hinge);
	  return inst;
	}
	
	new Door2D();
	module.exports = Door2D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/displays/information/utility-filter.js',
function (require, exports, module) {
	

	
	const Measurement = require('../../../../../public/js/utils/measurement.js');
	
	class UFObj {
	  constructor(order) {
	    class Row {
	      constructor(groupName, assembly, index) {
	        this.groupName = groupName;
	        this.type = assembly.constructor.name;
	        const dems = assembly.position().demension();
	        dems.y = new Measurement(dems.y).display();
	        dems.x = new Measurement(dems.x).display();
	        dems.z = new Measurement(dems.z).display();
	        this.size = `${dems.y} x ${dems.x} x ${dems.z}`;
	        this.quantity = 1;
	        this.cost = '$0';
	        this.notes = assembly.notes || '';
	      }
	    }
	    const cabinets = [];
	    const obj = [];
	    Object.values(order.rooms).forEach((room, rIndex) => room.groups.forEach((group, gIndex) => {
	      group.cabinets.forEach((cabinet, index) => {
	        const cabinetId = `${rIndex+1}-${gIndex+1}-${index+1}`;
	        cabinet.getParts().forEach((part) => {
	          const row = new Row(group.name(), part, cabinetId);
	          if (obj[row.size] === undefined) obj[row.size] = row;
	          else {
	            obj[row.size].quantity++;
	          }
	        });
	      });
	    }));
	    return Object.values(obj);
	  }
	}
	module.exports = UFObj
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/joint/joints/rabbet.js',
function (require, exports, module) {
	

	
	const Joint = require('../joint.js');
	
	class Rabbet extends Joint {
	  constructor(joinStr, defaultDepth, axis, centerOffset) {
	    super(joinStr);
	    this.maleOffset = (assembly) => {
	      return defaultDepth;
	    }
	
	    if (axis === undefined) return;
	
	    this.updatePosition = (position) => {
	      const direction = centerOffset[0] === '-' ? -1 : 1;
	      const centerAxis = centerOffset[1];
	      position.demension[axis] += defaultDepth;
	      position.center[centerAxis] += defaultDepth/2 * direction;
	    };
	  }
	}
	
	Joint.register(Rabbet);
	module.exports = Rabbet
	
	
	
	
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/joint/joints/dado.js',
function (require, exports, module) {
	
const Joint = require('../joint.js');
	
	class Dado extends Joint {
	  constructor(malePartCode, femalePartCode, condition) {
	    super(malePartCode, femalePartCode, condition);
	
	    this.updatePosition = (position) => {
	      const direction = this.centerAxis()[0] === '-' ? -1 : 1;
	      const centerAxis = this.centerAxis()[1].toLowerCase();
	      const offset = this.parentAssembly().eval(this.maleOffset());
	      const demAxis = this.demensionAxis().toLowerCase();
	      position.demension[demAxis] = position.demension[demAxis] + offset;
	      position.center[centerAxis] = position.center[centerAxis] + (offset/2 * direction);
	    };
	
	  }
	}
	
	Joint.register(Dado);
	module.exports = Dado
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/joint/joints/butt.js',
function (require, exports, module) {
	

	
	const Joint = require('../joint.js');
	
	class Butt extends Joint {
	  constructor(malePartCode, femalePartCode, condition) {
	    super(malePartCode, femalePartCode, condition);
	  }
	}
	
	Joint.register(Butt);
	module.exports = Butt
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/cabinet.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	const cabinetBuildConfig = require('../../../../public/json/cabinets.json');
	const Joint = require('../../joint/joint.js');
	const CabinetOpeningCorrdinates = require('../../../services/cabinet-opening-coordinates.js');
	const SectionProperties = require('./section/section-properties.js');
	const Measurement = require('../../../../../../public/js/utils/measurement.js');
	const Group = require('../../group');
	const Line2d = require('../../../../../../public/js/utils/canvas/two-d/objects/line');
	const Vertex2d = require('../../../../../../public/js/utils/canvas/two-d/objects/vertex');
	const Vertex3D = require('../../../three-d/objects/vertex.js');
	const Line3D = require('../../../three-d/objects/line.js');
	const CSG = require('../../../../public/js/3d-modeling/csg.js');
	const AutoToekick = require('./auto/toekick.js');
	
	const OVERLAY = {};
	OVERLAY.FULL = 'Full';
	OVERLAY.HALF = 'Half';
	OVERLAY.INSET = 'Inset';
	
	const CABINET_TYPE = {FRAMED: 'Framed', FRAMELESS: 'Frameless'};
	
	class Cabinet extends Assembly {
	  constructor(partCode, partName) {
	    super(partCode, partName);
	    // Object.getSet(this, {_DO_NOT_OVERWRITE: true}, 'length', 'width', 'thickness');
	    Object.getSet(this, 'propertyId', 'name', 'currentPosition', 'autoToeKick');
	    const instance = this;
	    let toeKickHeight = 4;
	    this.part = false;
	    this.currentPosition = () => this.position().current();
	    this.display = false;
	    this.overlay = OVERLAY.HALF;
	    this.openings = [];
	    this.type = CABINET_TYPE.FRAMED;
	    const panels = 0;
	    const framePieces = 0;
	    const addFramePiece = (piece) => framePieces.push(piece);
	    const framePieceCount = () => pieces.length;
	    const addPanel = (panel) => panels.push(panel);
	    const panelCount = () => panels.length;
	
	    const resolveOuterReveal = (panel, location) => {
	      const propConfig = this.propertyConfig();
	      if (propConfig.isInset()) {
	        return new Measurement(-1 * props.Inset.is.value()).value();
	      }
	      const definedValue = panel.railThickness() - panel.value(location);
	      let calculatedValue;
	      if (propConfig.isReveal()) {
	        calculatedValue = panel.railThickness() - propConfig.reveal();
	      } else {
	        calculatedValue = propConfig.overlay();
	      }
	      return calculatedValue < definedValue ? calculatedValue : definedValue;
	    }
	
	    const parentGetSubAssems = this.getSubassemblies;
	    let toeKick;
	    this.getSubassemblies = () => {
	      const subs = parentGetSubAssems();
	      if (this.autoToeKick()) {
	        if (toeKick === undefined) toeKick = new AutoToekick(this);
	        subs.concatInPlace(toeKick.getSubassemblies());
	        return subs.concat(toeKick);
	      }
	      return subs;
	    }
	
	    this.partCenter = () => {
	      const centers = [];
	      const subAssems = Object.values(this.subassemblies);
	      for (let index = 0; index < subAssems.length; index++) {
	        const assem = subAssems[index];
	        if (!(assem instanceof SectionProperties))
	          centers.push(assem.position().center());
	      }
	      return Vertex3D.center(...centers);
	    }
	
	    // TODO: ???? It is possible to have inner/outer intersections from
	    //       different parts..... not suure its worth the extra calculations
	    this.planeIntersection = (line) => {
	      const center = this.partCenter();
	      const vector = line.vector();
	      let closest = {};
	      const subAssems = Object.values(this.subassemblies);
	      for (let index = 0; index < subAssems.length; index++) {
	        const assem = subAssems[index];
	        if ((typeof assem.position) === 'function') {
	          const biPoly = assem.position().toBiPolygon();
	          const faces = biPoly.closestOrder(center);
	          const plane = faces[0].toPlane();
	          const intersection = plane.intersection.line(line);
	          if (intersection) {
	            const dist = line.midpoint().distance(intersection);
	            const intersectLine = new Line3D(line.midpoint(), intersection);
	            const intersectVector = intersectLine.vector();
	            const direction = vector.sameDirection(intersectVector) ? 'positive' : 'negitive';
	            if (closest[direction] === undefined || closest[direction].inner.dist > dist) {
	              const oplane = faces[1].toPlane();
	              plane.intersection.line(line)
	              const ointer = oplane.intersection.line(line);
	              const odist = ointer.distance(line.midpoint());
	              closest[direction] = {assem, inner: {dist, plane, intersection},
	              outer: {dist: odist, plane: oplane, intersection: ointer}};
	            };
	          }
	        }
	      }
	      return closest;
	    }
	
	    function bordersByIds(borderIds) {
	      const borders = {};
	      const center = borderIds.center;
	      borders.right = instance.getAssembly(borderIds.right);
	      borders.left = instance.getAssembly(borderIds.left);
	      borders.top = instance.getAssembly(borderIds.top);
	      borders.bottom = instance.getAssembly(borderIds.bottom);
	
	      const pb = instance.getAssembly(borderIds.back);
	
	      return () => {
	        const depth = pb.position().center('z') + pb.position().limits('-z');
	
	        const position = {};
	        const propConfig = instance.propertyConfig();
	        if (propConfig.isReveal()) {
	          const revealProps = propConfig.reveal();
	          position.right = borders.right.position().centerAdjust('x', '+z') - revealProps.rvr.value();
	          position.left = borders.left.position().centerAdjust('x', '-z') + revealProps.rvl.value();
	          position.top = borders.top.position().centerAdjust('y', '+z') - revealProps.rvt.value();
	          position.bottom = borders.bottom.position().centerAdjust('y', '-z') + revealProps.rvb.value();
	        } else if (propConfig.isInset()) {
	          const insetValue = propConfig('Inset').is.value();
	          position.right = borders.right.position().centerAdjust('x', '-z') - insetValue;
	          position.left = borders.left.position().centerAdjust('x', '+z') + insetValue;
	          position.top = borders.top.position().centerAdjust('y', '-z') - insetValue;
	          position.bottom = borders.bottom.position().centerAdjust('y', '+z') + insetValue;
	        } else {
	          const ov = propConfig('Overlay').ov.value();
	          position.right = borders.right.position().centerAdjust('x', '-z') + ov;;
	          position.left = borders.left.position().centerAdjust('x', '+z') - ov;
	          position.top = borders.top.position().centerAdjust('y', '-z') + ov;
	          position.bottom = borders.bottom.position().centerAdjust('y', '+z') - ov;
	        }
	
	        position.front = 0;
	        position.back = pb.position().center('z') + pb.position().limits('-z');
	
	        return {borders, position, depth, borderIds, center};
	      }
	    }
	
	    function bordersByEndPoints (borderObj) {
	      const bo = borderObj;
	
	      return () => {
	        const rotation = {x: 0, z: 0, y: instance.eval(borderObj.zRotation)};
	        let evaluated;
	
	        let points;
	        const propConfig = instance.propertyConfig();
	        if (propConfig.isReveal()) {
	          points = instance.evalObject(bo.outer);
	        } else {
	          points = instance.evalObject(bo.inner);
	        }
	
	        const pointArr = [points.top.left, points.top.right, points.bottom.right, points.bottom.left];
	        let center = Vertex3D.center.apply(null, pointArr);
	        // CSG.rotatePointsAroundCenter(rotation, pointArr, center, true);
	
	        const width = new Vertex3D(points.top.left).distance(new Vertex3D(points.top.right));
	        const length = new Vertex3D(points.bottom.left).distance(new Vertex3D(points.top.left));
	
	        //TODO: calculate real value;
	        const depth = 20 * 2.54;
	
	        const position = {};
	        if (propConfig.isReveal()) {
	          const revealProps = propConfig.reveal();
	          position.right = center.x + width/2 - revealProps.rvr.value();
	          position.left = center.x - width/2 + revealProps.rvl.value();
	          position.top = center.y + length/2 - revealProps.rvt.value();
	          position.bottom = center.y - length/2 + revealProps.rvb.value();
	        } else if (propConfig.isInset()) {
	          const insetValue = propConfig('Inset').is.value();
	          position.right = center.x + width/2 - insetValue;
	          position.left = center.x - width/2 + insetValue;
	          position.top = center.y + length/2 - insetValue;
	          position.bottom = center.y - length/2 + insetValue;
	        } else {
	          const ov = propConfig('Overlay').ov.value();
	          position.right = center.x + width/2 + ov;;
	          position.left = center.x - width/2 - ov;
	          position.top = center.y + length/2 + ov;
	          position.bottom = center.y - length/2 - ov;
	        }
	
	        return {position, depth, center, rotation};
	      }
	    }
	
	    this.index = () => {
	      const group = this.group();
	      return `${group.name()}-${group.objects.equalIndexOf(this)}`;
	    }
	
	    this.borders = (borderObj) => {
	      if (borderObj.inner) return bordersByEndPoints(borderObj);
	      return bordersByIds(borderObj);
	    }
	
	    function updateOpeningPoints(func, test) {
	      return (...args) => {
	        const shouldUpdate = test && test(...args);
	        const value = func(...args);
	        if (shouldUpdate) instance.updateOpenings();
	        return value;
	      }
	    }
	
	    this.updateOpenings = () => {
	      for (let index = 0; index < this.openings.length; index++) {
	        this.openings[index].update();
	      }
	    };
	
	    this.normals = () => {
	      const normals = [];
	      for (let index = 0; index < this.openings.length; index++) {
	        normals.push(this.openings[index].normal());
	      }
	      return normals;
	    }
	
	    this.width = updateOpeningPoints(this.width, (w) => w && this.width() !== w);
	    this.length = updateOpeningPoints(this.length, (l) => l && this.length() !== l);
	    this.thickness = updateOpeningPoints(this.thickness, (t) => t && this.thickness() !== t);
	  }
	}
	
	Cabinet.build = (type, group, config) => {
	  group ||= new Group();
	  const cabinet = new Cabinet('c', type);
	  cabinet.group(group);
	  config ||= cabinetBuildConfig[type];
	  cabinet.autoToeKick(config.autoToeKick);
	  cabinet.length(config.height);
	  cabinet.width(config.width);
	  cabinet.thickness(config.thickness);
	  cabinet.position().setCenter('y', config.fromFloor);
	  config.values.forEach((value) => cabinet.value(value.key, value.eqn));
	
	  config.subassemblies.forEach((subAssemConfig) => {
	    const type = subAssemConfig.type;
	    const name = subAssemConfig.name;
	    const demStr = subAssemConfig.demensions.join(':');
	    const centerConfig = subAssemConfig.center.join(':');
	    const rotationConfig = subAssemConfig.rotation.join(':');
	    const subAssem = Assembly.new(type, subAssemConfig.code, name, centerConfig, demStr, rotationConfig);
	    subAssem.partCode(subAssemConfig.code);
	    cabinet.addSubAssembly(subAssem);
	  });
	
	  config.joints.forEach((relationConfig) => {
	    const type = relationConfig.type;
	    const depth = relationConfig.depth;
	    const demensionToOffset = relationConfig.demensionToOffset;
	    const centerOffset = relationConfig.centerOffset;
	    const joint = Joint.new(type, relationConfig);
	    cabinet.addJoints(joint);
	  });
	
	  config.openings.forEach((config, i) => {
	    const sectionProperties = new SectionProperties(config, i);
	    const cabOpenCoords = new CabinetOpeningCorrdinates(cabinet, sectionProperties);
	    cabinet.openings.push(cabOpenCoords);
	    cabinet.addSubAssembly(sectionProperties);
	    cabOpenCoords.update();
	  });
	  return cabinet;
	}
	
	Cabinet.fromJson = (assemblyJson, group) => {
	  group ||= new Group();
	  const partCode = assemblyJson.partCode;
	  const partName = assemblyJson.partName;
	  const pos = assemblyJson.currentPosition;
	  const assembly = new Cabinet(partCode, partName);
	  assembly.name(assemblyJson.name);
	  assembly.length(pos.demension.y);
	  assembly.width(pos.demension.x);
	  assembly.group(group);
	  assembly.id(assemblyJson.id);
	  assembly.value.all(assemblyJson.value.values);
	  Object.values(assemblyJson.subassemblies).forEach((json) => {
	    const clazz = Assembly.class(json._TYPE);
	    json.parent = assembly;
	    if (clazz !== SectionProperties) {
	      assembly.addSubAssembly(Object.fromJson(json));
	    } else {
	      const sectionProperties = clazz.fromJson(json, assembly);
	      const openingCoords = new CabinetOpeningCorrdinates(assembly, sectionProperties);
	      openingCoords.update();
	      assembly.openings.push(openingCoords);
	      assembly.addSubAssembly(sectionProperties);
	    }
	  });
	  assembly.thickness(pos.demension.z);
	  const joints = Object.fromJson(assemblyJson.joints);
	  assembly.addJoints.apply(assembly, joints);
	  assembly.position().setCenter(pos.center);
	  assembly.position().setRotation(pos.rotation)
	  return assembly;
	}
	Cabinet.abbriviation = 'c';
	
	function getIntersectPoint(line, centerLine, right, dist, gap, noneAdjacent) {
	  if (noneAdjacent) {
	    if (right)
	      return centerLine.endVertex();
	    return centerLine.startVertex();
	  }
	  const parr = line.parrelle(dist);
	  if (line.isParrelle(centerLine)) {
	    if (right)
	      return parr.trimmed(gap/2).startVertex();
	    return parr.trimmed(gap/-2).endVertex();
	  }
	  return centerLine.findIntersection(parr);
	}
	
	// document location /cabinet/html/docs/door-intersect-diagram.html
	function doorIntersect(llp, lcp, rcp, rrp, ld, cd, rd, gap, padOffset) {
	  padOffset ||= 0;
	  const LL = new Line2d(llp, lcp);
	  const CL = new Line2d(lcp, rcp);
	  const RL = new Line2d(rcp, rrp);
	
	  const CLFP = CL.parrelle(cd + padOffset);
	
	  const cxlp = getIntersectPoint(LL, CLFP, false, ld + padOffset, gap, !llp);
	  const cxrp = getIntersectPoint(RL, CLFP, true, rd + padOffset, gap, !rrp);
	
	  const centerFrontTrimmed = new Line2d(cxlp, cxrp).trimmed(gap, true);
	  const centerBackTrimmed = centerFrontTrimmed.parrelle(-1 * cd);
	  const tsp = centerFrontTrimmed.startVertex();
	  const tep = centerFrontTrimmed.endVertex();
	  const clrs = CL.closestPointOnLine(tsp);
	  const crrs = CL.closestPointOnLine(tep);
	
	  const centerRightSide = new Line2d(crrs, tep);
	  const centerLeftSide = new Line2d(clrs, tsp);
	
	  const info = {center: {left: {}, right: {}}, left: {}, right: {}};
	
	
	  info.center.center = Vertex2d.center(tsp, tep, centerBackTrimmed.startVertex(), centerBackTrimmed.endVertex());
	  info.center.length = centerFrontTrimmed.length();
	  info.center.left.reveal = clrs.distance(lcp) * (CL.isOn(clrs) ? 1 : -1);
	  info.center.right.reveal = crrs.distance(rcp) * (CL.isOn(crrs) ? 1 : -1);
	
	  if (rrp){
	    const rrsp = RL.closestPointOnLine(cxrp);
	    const rightSide = new Line2d(rrsp, cxrp);
	    const rightGapTheta = CL.thetaBetween(RL);
	    const rightGapLine = Line2d.startAndTheta(rcp, CL.negitive().radians() + rightGapTheta / 2);
	    info.right.reveal = rrsp.distance(rcp) * (RL.isOn(rrsp) ? 1 : -1);
	    if (rightGapTheta > Math.PI) {
	      info.right.theta = rightGapLine.thetaBetween(rightSide);
	      info.center.right.theta = centerRightSide.thetaBetween(rightGapLine);
	    } else if (info.center.right.reveal < 0) {
	      //For meeting walls or other flat surfaces
	      info.center.right.theta = centerRightSide.thetaBetween(RL);
	    }
	  }
	
	  if (llp) {
	    const lrsp = LL.closestPointOnLine(cxlp);
	    info.left.reveal = lrsp.distance(lcp) * (LL.isOn(lrsp) ? 1 : -1);
	    const leftGapTheta = LL.thetaBetween(CL);
	    if (leftGapTheta > Math.PI) {
	      const leftSide = new Line2d(lrsp, cxlp);
	      const leftGapLine = Line2d.startAndTheta(rcp, CL.radians() - leftGapTheta / 2);
	      info.left.theta = leftSide.thetaBetween(leftGapLine);
	      info.center.left.theta = leftGapLine.thetaBetween(centerLeftSide);
	    } else if (info.center.left.reveal < 0) {
	      //For meeting walls or other flat surfaces
	      info.center.left.theta = LL.thetaBetween(centerRightSide);
	    }
	  }
	
	  return info;
	}
	
	Cabinet.doorIntersect = doorIntersect;
	
	module.exports = Cabinet
	
});


RequireJS.addFunction('./services/cabinet/app-src/three-d/layout/objects/assembly.js',
function (require, exports, module) {
	const Object3D = require('../object');
	const Vertex3D = require('../../objects/vertex.js');
	const Assembly = require('../../../objects/assembly/assembly.js');
	const SnapPolygon = require('../../../../../../public/js/utils/canvas/two-d/objects/snap/polygon.js');
	
	class Assembly3D extends Object3D {
	  constructor(assembly) {
	    super(assembly.id(), assembly);
	    if (!(assembly instanceof Assembly)) return undefined;
	
	    this.layout = assembly.layout;
	    this.center = (vertex3D) => {
	      const position = assembly.position();
	      if (vertex3D instanceof Vertex3D) {
	        position.setCenter('x', vertex3D.x);
	        position.setCenter('y', vertex3D.y);
	        position.setCenter('z', vertex3D.z);
	      }
	      return new Vertex3D(position.center());
	    }
	    this.height = assembly.length;
	    this.width = assembly.width;
	    this.thickness = assembly.thickness;
	    this.name = assembly.name;
	    this.snap2d.top = () => topSnap;
	    this.shouldSave = () => false;
	
	    this.rotation = (rotation) => {
	      if (rotation) assembly.position().setRotation(rotation);
	      return assembly.position().rotation();
	    }
	
	    const topSnap = new SnapPolygon(this.bridge.top(), assembly.view.top, 10);
	  }
	}
	
	Object3D.register(Assembly);
	
	module.exports = Assembly3D;
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/cutter.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	
	class Cutter extends Assembly {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig) {
	    super(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	    this.included(false);
	  }
	}
	Cutter.abbriviation = 'cut';
	
	class CutterModel extends Cutter {
	  constructor(partCode, partNameFunc, toModel) {
	    super(partCode);
	    this.toModel = toModel;
	    this.partName = partNameFunc;
	  }
	}
	
	Cutter.Model = CutterModel;
	
	module.exports = Cutter;
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/divider.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	
	class Divider extends Assembly {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig, toModel) {
	    if (toModel) {
	      super(partCode, partName);
	      this.toModel = toModel;
	      this.partName = partName;
	    } else super(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	
	  }
	}
	
	Divider.count = 0;
	
	Divider.abbriviation = 'dv';
	
	module.exports = Divider
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/joint/joints/miter.js',
function (require, exports, module) {
	

	
	const Joint = require('../joint.js');
	
	class Miter extends Joint {
	  constructor(joinStr) {
	    super(joinStr);
	  }
	}
	
	Joint.register(Miter);
	module.exports = Miter
	
	
	
	
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/frame.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	
	class Frame extends Assembly {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig) {
	    super(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	  }
	}
	
	Frame.abbriviation = 'fr';
	
	
	module.exports = Frame
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/has-pull.js',
function (require, exports, module) {
	const Assembly = require('../assembly.js');
	const Handle = require('./hardware/pull.js');
	
	class HasPull extends Assembly {
	  constructor(partCode, partName) {
	    super(partCode, partName);
	    const pulls = [];
	    this.pull = (index) => pulls[index || 0];
	    this.addPull = (location) => {
	      pulls.push(new Handle('pu', 'Pull', this, location));
	      this.addSubAssembly(pulls[pulls.length - 1]);
	    }
	    this.setPulls = (locations) => {
	      pulls.copy([]);
	      this.subassemblies.deleteAll();
	      locations.forEach((location) => this.addPull(location));
	    }
	  }
	}
	
	HasPull.fromJson = (json) => {
	  const hasPull = Assembly.fromJson(json);
	  const locations = [];
	  for (let index = 0; index < json.subassemblies; index++) {
	    const subAssem = json.subassemblies[index];
	    if (subAssem._TYPE === 'Handle') locations.push(Object.fromJson(subAssem));
	    else throw new Error('I dont know what this is. but you may need to modify this function');
	  }
	}
	
	module.exports = HasPull;
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/panel.js',
function (require, exports, module) {
	

	
	const Assembly = require('../assembly.js');
	
	class Panel extends Assembly {
	  constructor(partCode, partName, centerConfig, demensionConfig, rotationConfig) {
	    super(partCode, partName, centerConfig, demensionConfig, rotationConfig);
	
	    this.railThickness = () => this.thickness();
	    Object.getSet(this, {hasFrame: false});
	  }
	}
	
	Panel.abbriviation = 'pn';
	
	class PanelModel extends Panel {
	  constructor(partCode, partNameFunc, toModel) {
	    super(partCode);
	    this.toModel = toModel;
	    this.partName = (typeof partNameFunc) === 'function' ? partNameFunc : () => partNameFunc;
	  }
	}
	
	Panel.Model = PanelModel;
	module.exports = Panel
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/door/hinges.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	
	
	class Hinge extends Assembly {
	  constructor() {
	    super();
	  }
	}
	
	Hinge.abbriviation = 'hg';
	
	module.exports = Hinge
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/hardware/screw.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	
	
	class Screw extends Assembly {
	  constructor() {
	    super();
	  }
	}
	
	
	module.exports = Screw
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/hardware/pull.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	const CSG = require('../../../../../public/js/3d-modeling/csg.js');
	const pull = require('../../../../three-d/models/pull.js');
	/*
	    a,b,c
	    d,e,f
	    g,h,i
	*/
	class Handle extends Assembly {
	  constructor(partCode, partName, door, location, index, count) {
	    let instance;
	    location ||= Handle.location.CENTER;
	    function baseCenter() {
	      let center;
	      const edgeOffset = (19 * 2.54) / 16;
	      const toCenter = 3 * 2.54 + instance.centerToCenter() / 2;
	      const front = instance.parentAssembly().front();
	      const top = front.line(0);
	      // TODO: Maybe... not sure why these are flipped.
	      const left = front.line(-1);
	      const right = front.line(1);
	      const bottom = front.line(2);
	
	      switch (instance.location()) {
	        case Handle.location.TOP_RIGHT:
	          center = top.endVertex;
	          center.translate(top.vector().unit().scale(-edgeOffset));
	          center.translate(right.vector().unit().scale(toCenter));
	          break;
	        case Handle.location.TOP_LEFT:
	          center = top.startVertex;
	          center.translate(top.vector().unit().scale(edgeOffset));
	          center.translate(left.vector().unit().scale(-toCenter));
	          break;
	        case Handle.location.BOTTOM_RIGHT:
	          center = bottom.startVertex;
	          center.translate(bottom.vector().unit().scale(edgeOffset));
	          center.translate(right.vector().unit().scale(-toCenter));
	          break;
	        case Handle.location.BOTTOM_LEFT:
	          center = bottom.endVertex;
	          center.translate(bottom.vector().unit().scale(-edgeOffset));
	          center.translate(left.vector().unit().scale(toCenter));
	          break;
	        case Handle.location.TOP:
	          center = top.midpoint();
	          center.translate(right.vector().unit().scale(edgeOffset));
	          break;
	        case Handle.location.BOTTOM:
	          center = bottom.midpoint();
	          center.translate(right.vector().unit().scale(-edgeOffset));
	          break;
	        case Handle.location.RIGHT:
	          center = right.midpoint();
	          center.translate(top.vector().unit().scale(-edgeOffset));
	          break;
	        case Handle.location.LEFT:
	          center = left.midpoint();
	          center.translate(top.vector().unit().scale(edgeOffset));
	          break;
	        case Handle.location.CENTER:
	          center = front.center();
	          break;
	        break;
	        default:
	          throw new Error('Invalid pull location');
	      }
	      return center;
	    };
	
	    super(`${partCode}-${location.position.toKebab()}`, 'Handle');
	    Object.getSet(this, {location});
	    this.partName = () =>
	      `${this.parentAssembly().partName()}.Pull.${this.location().position}`;
	    this.inElivation = true;
	    instance = this;
	    index = index || 0;
	    count = count || 1;
	
	    this.count = (c) => {
	      if (c > 0) {
	        count = c;
	      }
	      return count;
	    }
	
	    function offset(center, distance) {
	      const spacing = distance / count;
	      return center - (distance / 2) + spacing / 2 + spacing * (index);
	    }
	
	    this.toModel = (simple) => {
	      const baseC = baseCenter();
	      const biPolygon = this.parentAssembly().biPolygon();
	      const front = biPolygon.front();
	      const rotated =  instance.location().rotate;
	      const line = rotated ? front.line(-1) : front.line(0);
	      const normal = biPolygon.normal();
	      if (simple)
	        return pull.simple(baseC, line, normal, this.projection(), this.centerToCenter());
	      else
	        return pull(baseC, line, normal, this.projection(), this.centerToCenter());
	    }
	
	    this.projection = () => 2.54;
	    this.centerToCenter = () => 9.6;
	  }
	}
	Handle.location = {};
	Handle.location.TOP_RIGHT = {rotate: true, position: 'TOP_Right'};
	Handle.location.TOP_LEFT = {rotate: true, position: 'TOP_LEFT'};
	Handle.location.BOTTOM_RIGHT = {rotate: true, position: 'BOTTOM_RIGHT'};
	Handle.location.BOTTOM_LEFT = {rotate: true, position: 'BOTTOM_LEFT'};
	Handle.location.TOP = {multiple: true, position: 'TOP'};
	Handle.location.BOTTOM = {multiple: true, position: 'BOTTOM'};
	Handle.location.RIGHT = {multiple: true, rotate: true, position: 'RIGHT'};
	Handle.location.LEFT = {multiple: true, rotate: true, position: 'LEFT'};
	Handle.location.CENTER = {multiple: true, position: 'CENTER'};
	
	Handle.abbriviation = 'hn';
	
	
	module.exports = Handle
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/drawer/guides.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	
	
	class Guides extends Assembly {
	  constructor() {
	    super();
	  }
	}
	
	Guides.abbriviation = 'gu';
	
	
	module.exports = Guides
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/drawer/drawer-front.js',
function (require, exports, module) {
	

	
	const HasPull = require('../has-pull.js');
	const Handle = require('../hardware/pull.js');
	
	class DrawerFront extends HasPull {
	  constructor(partCode, partName) {
	    super(partCode, partName);
	    const instance = this;
	    this.addPull(Handle.location.CENTER);
	
	    this.biPolygon = () => this.parentAssembly().getBiPolygon(partCode);
	    this.inElivation = true;
	
	    this.toModel = () => {
	      const biPolygon = this.biPolygon();
	      if (biPolygon) return biPolygon.toModel();
	      return undefined;
	    }
	
	    this.front = () => {
	      const biPoly = this.biPolygon();
	      if (biPoly === undefined) return;
	      return biPoly.front();
	    }
	    this.back = () => {
	      const biPoly = this.biPolygon();
	      if (biPoly === undefined) return;
	      return biPoly.back();
	    }
	  }
	}
	
	DrawerFront.abbriviation = 'df';
	
	
	module.exports = DrawerFront
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/drawer/drawer-box.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	const drawerBox = require('../../../../three-d/models/drawer-box.js');
	
	class DrawerBox extends Assembly {
	  constructor(partCode, partName, getFrontPoly, getNormal, getDepth) {
	    super(partCode, partName);
	
	    this.normal = () => this.parentAssembly().getNormal(partCode);
	    this.depth = () => this.parentAssembly().drawerDepth();
	    this.biPolygon = () => this.parentAssembly().getBiPolygon(partCode);
	
	    this.toModel = () => {
	      const props = this.getRoot().group().propertyConfig('DrawerBox');
	      return drawerBox(this.biPolygon(), this.normal(), this.depth(), props);
	    }
	  }
	}
	
	DrawerBox.abbriviation = 'db';
	
	
	module.exports = DrawerBox
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/door/door.js',
function (require, exports, module) {
	

	
	const HasPull = require('../has-pull.js');
	const Handle = require('../hardware/pull.js');
	
	class Door extends HasPull {
	  constructor(partCode, partName) {
	    super(partCode, partName);
	
	    this.biPolygon = () => this.parentAssembly().getBiPolygon(partCode);
	    this.toModel = () => {
	      const biPolygon = this.biPolygon();
	      if (biPolygon) return biPolygon.toModel();
	      return undefined;
	    }
	
	    this.inElivation = true;
	
	    this.front = () => {
	      const biPoly = this.biPolygon();
	      if (biPoly === undefined) return;
	      return biPoly.front();
	    }
	    this.back = () => {
	      const biPoly = this.biPolygon();
	      if (biPoly === undefined) return;
	      return biPoly.back();
	    }
	
	    this.addPull(Handle.location.TOP_RIGHT);
	    // this.setPulls([Handle.location.TOP_RIGHT,
	    // Handle.location.TOP_LEFT,
	    // Handle.location.BOTTOM_RIGHT,
	    // Handle.location.BOTTOM_LEFT,
	    // Handle.location.TOP,
	    // Handle.location.BOTTOM,
	    // Handle.location.CENTER,
	    // Handle.location.RIGHT,
	    // Handle.location.LEFT]);
	  }
	}
	
	Door.abbriviation = 'dr';
	
	
	module.exports = Door
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/door/door-catch.js',
function (require, exports, module) {
	

	
	const Assembly = require('../../assembly.js');
	
	
	class DoorCatch extends Assembly {
	  constructor() {
	    super();
	  }
	}
	
	module.exports = DoorCatch
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/auto/toekick.js',
function (require, exports, module) {
	
const Assembly = require('../../assembly');
	const PanelModel = require('../panel').Model;
	const CutterModel = require('../cutter').Model;
	const Vertex3D = require('../../../../three-d/objects/vertex');
	const Vector3D = require('../../../../three-d/objects/vector');
	const Line3D = require('../../../../three-d/objects/line');
	const Polygon3D = require('../../../../three-d/objects/polygon');
	const BiPolygon = require('../../../../three-d/objects/bi-polygon');
	const Butt = require('../../../joint/joints/butt.js');
	
	const so = 3*2.54;
	
	const tkCounters = {};
	const getId = (cab) => {
	  if (tkCounters[cab.id()] === undefined) tkCounters[cab.id()] = 0;
	  return tkCounters[cab.id()]++;
	}
	
	class AutoToekick extends Assembly {
	  constructor(cabinet) {
	    const id = getId(cabinet);
	    const atkid = `AutoToeKick${id}`;
	    super(`AUTOTK`, atkid);
	
	    Object.getSet(this, {rightEndStyle: true, leftEndStyle: false});
	    const instance = this;
	    let lastSize = new Vertex3D();
	    let toeKick;
	    let vOid;
	    let offsetToeKickPoly;
	    let supports;
	    let supportPanels = [];
	
	    const children = {}
	
	    function toModel(name, index) {
	      return () => {
	        instance.update();
	        return children[name].toModel();
	      }
	    }
	
	    const joint = (part) => (otherPartCode, condition) =>
	      part.addJoints(new Butt(part.partCode(), otherPartCode, condition));
	    const toeKickPanel = new PanelModel('tkb', `${atkid}.Backer`, toModel('toeKick'));
	    joint(toeKickPanel)('R');
	    joint(toeKickPanel)('B');
	    joint(toeKickPanel)('L');
	    const cutter = new CutterModel('tkc', `${atkid}.Cutter`, toModel('vOid'));
	    joint(cutter)('R', () => !this.rightEndStyle());
	    joint(cutter)('L', () => !this.leftEndStyle());
	    const assems = [toeKickPanel, cutter];
	
	    // function updateSupports() {
	    //   supportPanels = [];
	    //   for (let index = 0; supports && index < supports.length; index++) {
	    //     const panel = new PanelModel('tks', `${atkid}.ToeKickCutter`, toModel('supports', index));
	    //     supportPanels.push(panel);
	    //   }
	    //   return supportPanels;
	    // }
	
	    this.part = () => false;
	    this.children = () => this.getSubassemblies();
	    this.getSubassemblies = () => assems;
	
	    this.update = () => {
	      if (!lastSize.equals(cabinet.position().demension())) {
	        try{
	          lastSize = new Vertex3D(cabinet.position().demension());
	          this.toBiPolygon();
	        } catch (e) {
	          console.error('AutoToeKick: update exception');
	          console.error(e);
	        }
	      }
	    }
	
	    function corners(side, openingCenter, targetCorner, innerPoly, height, depth1, depth2) {
	      const biPoly = side.position().toBiPolygon();
	      const poly = biPoly.furthestOrder(openingCenter)[1];
	      let front = Line3D.centerClosestTo(openingCenter, poly.lines()).polarize(targetCorner);
	      const withoutUp = poly.lines().filter(l => !l.equals(front));
	      let longBottom = Line3D.endpointClosestTo(targetCorner, withoutUp).polarize(targetCorner);
	
	      let innerFront = Line3D.centerClosestTo(openingCenter, innerPoly.lines()).clone().polarize(targetCorner);
	
	      let newStart = innerPoly.toPlane().intersection.line(longBottom);
	
	      longBottom.startVertex = newStart;
	      const shortBottom = longBottom.clone();
	
	      const targetFront = Line3D.fromVector(innerFront.vector().unit().scale(height), newStart);
	      shortBottom.adjustLength(depth1, true);
	      const shortVector = shortBottom.vector();
	      const shortTop = Line3D.fromVector(shortVector, targetFront.endVertex);
	
	      if (depth2) {
	        longBottom.adjustLength(depth2, true);
	        const longVector = longBottom.vector();
	        const longTop = Line3D.fromVector(longVector, targetFront.endVertex);
	        return [shortTop.endVertex, longTop.endVertex,
	              longBottom.endVertex, shortBottom.endVertex];
	      }
	      return [targetFront.endVertex, shortTop.endVertex,
	              shortBottom.endVertex, newStart];
	    }
	
	    function buildOffset(right, left, openingCenter, coords, innerPoly, height, depth1, depth2, xyOffset) {
	      const rightLines = corners(right, openingCenter, coords.inner[2], innerPoly, height, depth1, depth2);
	      const leftLines = corners(left, openingCenter, coords.inner[3], innerPoly, height, depth1, depth2);
	      const leftPoly = new Polygon3D(leftLines);
	      const rightPoly = new Polygon3D(rightLines);
	
	      const leftLine = innerPoly.lines()[3];
	      const rightLine = innerPoly.lines()[1].negitive();
	      const bottomPlane = new Polygon3D([rightLines[2], rightLines[3], leftLines[2], leftLines[3]]).toPlane();
	      const leftStart = bottomPlane.intersection.line(leftLine);
	      const rightStart = bottomPlane.intersection.line(rightLine);
	      const leftTkLine = Line3D.fromVector(leftLine.vector().unit().scale(height), leftStart);
	      const rightTkLine = Line3D.fromVector(rightLine.vector().unit().scale(height), rightStart);
	      const tkSpacePoly = new Polygon3D([leftTkLine.endVertex, rightTkLine.endVertex, rightTkLine.startVertex, leftTkLine.startVertex]);
	      return BiPolygon.fromPolygon(tkSpacePoly, depth1, depth2, xyOffset);
	    }
	
	    function buildToeKick(tkBiPoly, tkSpacePoly) {
	      const leftInOut = instance.leftEndStyle() ? 'inner' : 'outer';
	      const rightInOut = instance.rightEndStyle() ? 'inner' : 'outer';
	      const toPoly = (intObjTop, intObjBottom) => {
	        const vert1 = intObjTop.positive[rightInOut].intersection;
	        const vert2 = intObjTop.negitive[leftInOut].intersection;
	        const vert3 = intObjBottom.positive[leftInOut].intersection;
	        const vert4 = intObjBottom.negitive[rightInOut].intersection;
	        return new Polygon3D([vert1, vert2, vert3, vert4]);
	      }
	
	      const faces = tkBiPoly.closestOrder(tkSpacePoly.center());
	      const topInner = cabinet.planeIntersection(faces[0].lines()[0]);
	      const bottomInner = cabinet.planeIntersection(faces[0].lines()[2]);
	      const topOuter = cabinet.planeIntersection(faces[1].lines()[0]);
	      const bottomOuter = cabinet.planeIntersection(faces[1].lines()[2]);
	
	      const buttToePoly2 = toPoly(topInner, bottomInner);
	      const buttToePoly1 = toPoly(topOuter, bottomOuter);
	      toeKick = new BiPolygon(buttToePoly1, buttToePoly2);
	      children.toeKick = toeKick;
	    }
	
	    // function addExtraSupports(supports) {
	    //   const back = toeKick.back();
	    //   const topLine = back.lines()[0];
	    //   const length = topLine.length();
	    //   const supportCount = Math.ceil(length / (5 * 2.54)) - 2;
	    //   if (supportCount < 1) return;
	    //
	    //   const offsetLength = length/(supportCount + 1);
	    //   const backVect = toeKick.normal();
	    //   const downVect = toeKick.front().lines()[1].vector().unit();
	    //   const half34 = so/8;
	    //   const getSupport = (at) => {
	    //     const point2 = at.translate(backVect.scale(so), true);
	    //     const point3 = at.translate(downVect.scale(so), true);
	    //     const triangle = new Polygon3D([at, point2, point3]);
	    //     return BiPolygon.fromPolygon(triangle, half34, -half34);
	    //   }
	    //
	    //
	    //   for (let index = 0; index < supportCount; index++) {
	    //     const dist = offsetLength * (index + 1);
	    //     const point = topLine.fromStart(dist);
	    //     supports.push(getSupport(point));
	    //   }
	    // }
	
	    function sidePoly(assem, targetPoint, trendSetter) {
	      const side = assem.toBiPolygon().closestOrder(targetPoint)[0];
	      const verts = side.vertices();
	      const closestPoint = Vertex3D.nearest(verts, targetPoint);
	      let vects;
	      for (let index = 0; index < verts.length; index += 1) {
	        const vert = verts[index];
	        if (vert.equals(closestPoint)) {
	          const next = verts[(index + 1) % verts.length];
	          const prev = verts[(index + verts.length - 1) % verts.length];
	          vects = [new Line3D(vert, next).vector().unit(), new Line3D(vert, prev).vector().unit()];
	          if (Vector3D.mostInLine(vects, trendSetter).equals(vects[1])) vects.reverse();
	          break;
	        }
	      }
	      const depthVector = vects[0];
	      const heightVector = vects[1];
	      const tkw = cabinet.eval('tkbw');
	      const tkh = cabinet.eval('tkh');
	      const tkd = cabinet.eval('tkd');
	      const point1 = closestPoint.translate(heightVector.scale(tkh), true)
	                                  .translate(depthVector.scale(tkw + tkd));
	      const point2 = point1.translate(depthVector.scale(so), true);
	      const point3 = point1.translate(heightVector.inverse().scale(so), true);
	      const triangle = new Polygon3D([point1, point2, point3]);
	      return BiPolygon.fromPolygon(triangle, so/2);
	    }
	
	    // function buildSupports(right, left, coords) {
	    //   supports = [];
	    //   const center = Vertex3D.center(coords.inner);
	    //   const leftBottom = coords.inner[3];
	    //   const rightBottom = coords.inner[2];
	    //
	    //   const rightTrendSetter = toeKick.faceNormal(1);
	    //   const leftTrendSetter = toeKick.faceNormal(0);
	    //   supports.push(sidePoly(left, leftBottom, leftTrendSetter));
	    //   addExtraSupports(supports);
	    //   supports.push(sidePoly(right, rightBottom, rightTrendSetter));
	    //   children.supports = supports;
	    //   return supports[0];
	    // }
	
	    function openingToeKick(opening) {
	      const right = opening.right();
	      const left = opening.left();
	      const coords = opening.coordinates();
	      const center = Vertex3D.center(coords.inner);
	      const innerPoly = new Polygon3D(coords.inner);
	
	      const tkh = cabinet.value('tkh');
	      const sdepth = cabinet.value('tkd');
	      const dem = cabinet.position().demension();
	      const xyOffset = {x: dem.x + dem.z + dem.y, y: 0};
	      vOid = buildOffset(right, left, center, coords, innerPoly, tkh, sdepth, null, xyOffset);
	      children.vOid = vOid;
	
	      const tkd1 = sdepth;
	      const tkd2 = tkd1 + cabinet.value('tkbw');
	      const tkah = tkh + cabinet.eval('B.t')/2;
	      offsetToeKickPoly = buildOffset(right, left, center, coords, innerPoly, tkah, tkd1, tkd2);
	
	      return buildToeKick(offsetToeKickPoly, vOid);
	      // return buildSupports(right, left, coords);
	
	      // return toeKick;
	    }
	
	    this.toBiPolygon = () => {
	      const openings = cabinet.openings;
	      let opening;
	      if (openings.length > 1) throw new Error('Not yet implemented for multiple openings...');
	      for (let index = 0; index < openings.length; index++) {
	        opening = openingToeKick(openings[index]);
	      }
	      return opening;
	    }
	
	    this.toModel = () => this.toBiPolygon().toModel();
	  }
	}
	
	module.exports = AutoToekick;
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/section/section-properties.js',
function (require, exports, module) {
	
const Vertex3D = require('../../../../three-d/objects/vertex.js');
	const Polygon3D = require('../../../../three-d/objects/polygon.js');
	const Line3D = require('../../../../three-d/objects/line.js');
	const Plane = require('../../../../three-d/objects/plane.js');
	const BiPolygon = require('../../../../three-d/objects/bi-polygon.js');
	const KeyValue = require('../../../../../../../public/js/utils/object/key-value.js');
	const Notification = require('../../../../../../../public/js/utils/collections/notification.js');
	const Assembly = require('../../assembly.js');
	const CSG = require('../../../../../public/js/3d-modeling/csg.js');
	const DividerSection = require('./partition/divider.js');
	const Pattern = require('../../../../division-patterns.js');
	
	const v = () => new Vertex3D();
	class SectionProperties extends KeyValue{
	  constructor(config, index, sections, pattern) {
	    super({childrenAttribute: 'sections', parentAttribute: 'parentAssembly'})
	    if (sections) {
	      this.sections.copy(sections);
	    }
	    // TODO: consider getting rid of, sections and cover are the only ones that matter.
	    this.subassemblies = [];
	
	    index ||= 0;
	    this.index = () => index;
	    const coordinates = {inner: [v(),v(),v(),v()], outer: [v(),v(),v(),v()]};
	    let rotation, innerCenter, outerCenter, outerLength, innerLength, outerWidth, innerWidth = null;
	    const temporaryInitialVals = {parent, _TEMPORARY: true};
	    Object.getSet(this, temporaryInitialVals, 'parentAssembly');
	    Object.getSet(this, {divideRight: false, config}, 'divider', 'cover');
	    const instance = this;
	    pattern ||= new Pattern('a');
	
	    this.divideRight = () =>
	      this.parentAssembly().sectionCount && this.parentAssembly().sectionCount() !== index;
	    this.partCode = () => 'S' + index;
	    this.partName = () => {
	      const orientation = this.vertical() ? 'V' : 'H';
	      if (!(this.parentAssembly() instanceof SectionProperties)) return orientation;
	      const pPartName = this.parentAssembly().partName();
	      return `${pPartName}${index}.${orientation}`;
	    }
	
	    this.config = () => JSON.copy(config);
	    this.outerPoly = () => new Polygon3D(this.coordinates().outer);
	    this.innerPoly = () => new Polygon3D(this.coordinates().inner);
	    this.coordinates = () => JSON.clone(coordinates);
	    this.reverseInner = () => CSG.reverseRotateAll(this.coordinates().inner);
	    this.reverseOuter = () => CSG.reverseRotateAll(this.coordinates().outer);
	    this.part = () => false;
	    this.included = () => false;
	    this.joints = [];
	    this.coverType = () => this.cover() && this.cover().constructor.name;
	    this.vertical = (is) => {
	      const curr = instance.value('vertical', is);
	      if (is !== undefined && curr !== is) removeCachedValues();
	      return curr;
	    }
	    const getPartFunc = (partCode) => () => instance.getAssembly(partCode);
	    this.top = getPartFunc('T');
	    this.bottom = getPartFunc('B');
	    this.left = getPartFunc('L');
	    this.right = getPartFunc('R');
	    this.back = getPartFunc('B');
	    this.isVertical = () => this.sections.length < 2 ? undefined : this.vertical();
	    this.verticalDivisions = () => {
	      const parent = this.parentAssembly();
	      if (parent instanceof SectionProperties) return parent.isVertical();
	      return false;
	    }
	    this.rotation = () => {
	      if (config.rotation === undefined || config._Type === 'part-code') return {x:0,y:0,z:0};
	      if (true || rotation === null) rotation = this.getRoot().evalObject(config.rotation);
	      return JSON.copy(rotation);
	    }
	
	    this.getCabinet = () => {
	      const root = this.getRoot();
	      return root.constructor.name === 'Cabinet' ? root : undefined;
	    }
	
	    this.innerDepth = () => {
	      const cabinet = this.getCabinet();
	      const back = cabinet.getAssembly(config.back);
	      if (back) return Math.abs(back.position().centerAdjust('z', '+z'));
	      return 4*2.54;
	    };
	
	    function offsetCenter(center, left, right, up, down, forward, backward) {
	      center = JSON.copy(center);
	      const offset = {
	        x: (right - left) / 2,
	        y: (up - down) / 2,
	        z: (forward - backward) / -2
	      }
	      const rotated = CSG.rotatePointAroundCenter(instance.rotation(), offset, {x:0,y:0, z:0});
	
	      return {x: center.x + rotated.x, y: center.y + rotated.y, z: center.z + rotated.z};
	    }
	
	    function offsetRotatedPoint(point, x, y, z, rotation) {
	      rotation ||= instance.rotation();
	      point = JSON.copy(point);
	      const originalPosition = CSG.reverseRotate(point, rotation);
	      originalPosition.x += x;
	      originalPosition.y += y;
	      originalPosition.z -= z;
	      return CSG.rotate(originalPosition, rotation);
	    }
	    this.offsetRotatedPoint = offsetRotatedPoint;
	    this.transRotate = CSG.transRotate;
	
	    function offsetPoint(point, x, y, z) {
	      const offset = {x,y,z};
	      return CSG.transRotate(point, offset, instance.rotation());
	    }
	    this.offsetPoint = offsetPoint;
	
	    function init () {
	      if (instance.sections.length === 0) {
	        instance.sections.push(new SectionProperties({rotation: config.rotation, back: config.back}, 1));
	      }
	    }
	
	    this.init = init;
	    this.dividerCount = () => this.sections.length - 1;
	    this.sectionCount = () => this.sections.length || 1;
	    this.children = () => this.sections;
	    this.getSubassemblies = () => {
	      const assems = Object.values(this.sections);
	      const cover = this.cover()
	      if (cover) assems.concatInPlace(cover.getSubassemblies());
	      if (this.divideRight()) assems.concatInPlace(this.divider().getSubassemblies());
	      for (let index = 0; index < this.sections.length; index++) {
	        assems.concatInPlace(this.sections[index].getSubassemblies());
	      }
	      return assems;
	    }
	
	    this.propertyConfig = () => this.getCabinet().propertyConfig();
	
	    this.getAssembly = (partCode, callingAssem) => {
	      if (callingAssem === this) return undefined;
	      if (this.partCode() === partCode) return this;
	      if (this.subassemblies[partCode]) return this.subassemblies[partCode];
	      if (callingAssem !== undefined) {
	        const children = Object.values(this.subassemblies);
	        for (let index = 0; index < children.length; index += 1) {
	          const assem = children[index].getAssembly(partCode, this);
	          if (assem !== undefined) return assem;
	        }
	      }
	      if (this.parentAssembly() !== undefined && this.parentAssembly() !== callingAssem)
	        return this.parentAssembly().getAssembly(partCode, this);
	      return undefined;
	    }
	
	    // TODO: innerOffset - proorly named and implemented values produced are in the ball park but not correct.
	    function updatdSectionPropertiesCoordinates(section, startOuter, startInner, endInner, endOuter, innerOffset) {
	      const coords = {};
	      const fresh = instance.coordinates();
	      const outer = fresh.outer;
	      const inner = fresh.inner;
	      const rotation = instance.rotation();
	      if (!instance.vertical()) {
	        const leftOutLine = new Line3D(outer[0], outer[3]);
	        const leftInnerLine = new Line3D(inner[0], inner[3]);
	        const rightOutLine = new Line3D(outer[1], outer[2]);
	        const rightInnerLine = new Line3D(inner[1], inner[2]);
	        coords.outer = [leftOutLine.pointAtDistance(startOuter - innerOffset),
	                        rightOutLine.pointAtDistance(startOuter - innerOffset),
	                        rightOutLine.pointAtDistance(endOuter - innerOffset),
	                        leftOutLine.pointAtDistance(endOuter - innerOffset)];
	        coords.inner = [
	                        leftInnerLine.pointAtDistance((startInner - innerOffset)),
	                        rightInnerLine.pointAtDistance((startInner - innerOffset)),
	                        rightInnerLine.pointAtDistance((endInner - innerOffset)),
	                        leftInnerLine.pointAtDistance((endInner - innerOffset))
	                                    ];
	
	
	      } else {
	        const topOutLine = new Line3D(outer[0], outer[1]);
	        const topInnerLine = new Line3D(inner[0], inner[1]);
	        const bottomOutLine = new Line3D(outer[3], outer[2]);
	        const bottomInnerLine = new Line3D(inner[3], inner[2]);
	        coords.outer = [topOutLine.pointAtDistance(startOuter),
	                        topOutLine.pointAtDistance(endOuter),
	                        bottomOutLine.pointAtDistance(endOuter),
	                        bottomOutLine.pointAtDistance(startOuter)];
	        coords.inner = [topInnerLine.pointAtDistance(startInner - innerOffset),
	                        topInnerLine.pointAtDistance(endInner - innerOffset),
	                        bottomInnerLine.pointAtDistance(endInner - innerOffset),
	                        bottomInnerLine.pointAtDistance(startInner - innerOffset)];
	      }
	      section.updateCoordinates(coords);
	    }
	
	    this.dividerLayout = () => {
	      init();
	      const dividerOffsetInfo = instance.dividerOffsetInfo();
	      const coverage = instance.coverage(dividerOffsetInfo.startOffset, dividerOffsetInfo.endOffset);
	      return instance.pattern().calc(coverage._TOTAL);
	    }
	
	    function setSectionCoordinates() {
	      const dividerOffsetInfo = instance.dividerOffsetInfo();
	      const coverage = instance.coverage(dividerOffsetInfo.startOffset, dividerOffsetInfo.endOffset);
	
	      if (coverage.length > 1) {
	        const patternInfo = instance.pattern().calc(coverage._TOTAL);
	
	        let offset = 0;
	        const innerOffset = dividerOffsetInfo[0].offset;
	        for (let index = 0; index < instance.sections.length; index++) {
	          const section = instance.sections[index];
	          const patVal = patternInfo.list;
	          const overlayOffset = coverage[index * 2].overlay + coverage[index * 2 + 1].overlay;
	          let startOuter, startInner, endInner, endOuter;
	
	          startOuter = offset;
	          if (index === 0) {
	            startOuter = dividerOffsetInfo[0].offset;
	            startInner = startOuter;
	          } else {
	            startInner = startOuter + dividerOffsetInfo[index].offset/2;
	          }
	
	          endInner = (startInner + patVal[index] - overlayOffset);
	          if (index === instance.sections.length - 1) endOuter = endInner + dividerOffsetInfo[index + 1].offset;
	          else endOuter = endInner + dividerOffsetInfo[index + 1].offset / 2;
	          if (index < instance.sections.length - 1) section.divideRight(true);
	          updatdSectionPropertiesCoordinates(section, startOuter, startInner, endInner, endOuter, innerOffset);
	          offset = endOuter;
	        }
	      }
	    }
	
	    function perpendicularDistance(point, line) {
	      if (instance.sectionCount() !== 0) {
	        const plane = Plane.fromPointNormal(point, line.vector());
	        const intersection = plane.intersection.line(line);
	        const distance = line.startVertex.distance(intersection);
	        return distance;
	      }
	      return 0;
	    }
	
	    this.coverage = (startOffset, endOffset) => {
	      const info = [];
	      const propConfig = this.propertyConfig();
	      const isReveal = propConfig.isReveal();
	      const isInset = propConfig.isInset();
	      const vertical = instance.vertical();
	      info._TOTAL = isReveal ?
	              (!vertical ? instance.outerLength() : instance.outerWidth()) :
	              (!vertical ? instance.innerLength() : instance.innerWidth());
	
	      let overlay, reveal, insetValue;
	      if (isReveal) reveal = propConfig.reveal().r.value();
	      else if (propConfig.isInset()) insetValue = propConfig('Inset').is.value();
	      else overlay = propConfig.overlay();
	
	      for (let index = 0; index < this.sections.length * 2; index += 1) {
	        const section = this.sections[Math.ceil((index - 1)/2)];
	        let offset = 0;
	        const divider = section.divider();
	        if (isReveal) {
	          if (index % 2 === 0) {
	            if (index === 0) info._TOTAL -= reveal;
	            else info._TOTAL -= reveal;
	          }
	          if (index === 0) info.push({overlay: startOffset - reveal / 2});
	          if (index === this.sections.length - 1) info.push({overlay: endOffset - reveal / 2});
	          else info.push({overlay: (divider.maxWidth() - reveal)/2});
	        }  else if (isInset) {
	          if (index % 2 === 0) {
	            if (index === this.sections.length * 2 - 2) info._TOTAL -= insetValue * 2;
	            else info._TOTAL -= (divider.maxWidth() + insetValue * 2);
	          }
	          info.push({overlay: -insetValue});
	        } else {
	          if (index % 2 === 0) {
	            if (index === this.sections.length * 2 - 2) info._TOTAL += overlay * 2;
	            else info._TOTAL += overlay * 2 - divider.maxWidth();
	          }
	          info.push({overlay: overlay});
	        }
	      }
	      return info;
	    }
	
	    this.dividerOffsetInfo = () => {
	      let startOffset = 0;
	      let endOffset = 0;
	
	      const coords = this.coordinates();
	      const outer = coords.outer;
	      const inner = coords.inner;
	      if (this.vertical()) {
	         startOffset = perpendicularDistance(outer[3], new Line3D(inner[3], inner[2]));
	         endOffset = perpendicularDistance(outer[2], new Line3D(inner[2], inner[3]));
	       } else {
	         startOffset = perpendicularDistance(outer[0], new Line3D(inner[0], inner[3]));
	         endOffset = perpendicularDistance(outer[3], new Line3D(inner[3], inner[0]));
	       }
	       const info = [{offset: startOffset}];
	       info.startOffset = startOffset;
	       info.endOffset = endOffset;
	
	      let offset = this.isVertical() ? this.outerLength() : this.outerWidth();
	      const propConfig = this.propertyConfig();
	      for (let index = 0; index < this.sections.length; index += 1) {
	        if (index < this.sections.length - 1) {
	          const section = this.sections[index];
	          const divider = section.divider();
	          const offset = divider.maxWidth();
	          info[index + 1] = {offset, divider};
	        } else {
	          info[index + 1] = {offset: endOffset};
	        }
	      }
	      return info;
	    }
	
	    this.divide = (dividerCount) => {
	      init();
	      if (!Number.isNaN(dividerCount) && dividerCount !== this.dividerCount()) {
	        dividerCount = dividerCount > 10 ? 10 : dividerCount;
	        dividerCount = dividerCount < 0 ? 0 : dividerCount;
	        const currDividerCount = this.dividerCount();
	        if (dividerCount < currDividerCount) {
	          const diff = currDividerCount - dividerCount;
	          this.sections.splice(dividerCount + 1);
	          setSectionCoordinates();
	          return true;
	        } else {
	          const diff = dividerCount - currDividerCount;
	          for (let index = currDividerCount; index < dividerCount; index +=1) {
	            const section = new SectionProperties({rotation: config.rotation, back: config.back}, index + 2);
	            this.sections.push(section);
	          }
	          if (diff !== 0) setSectionCoordinates();
	          return diff !== 0;
	        }
	      }
	      return false;
	    }
	
	    this.setPattern = (patternObj) => {
	      if (patternObj instanceof Pattern) {
	        pattern = patternObj;
	      }
	    }
	
	    this.pattern = (patternStr) => {
	      if ((typeof patternStr) === 'string') {
	        const sectionCount = patternStr.length;
	        pattern = pattern.clone(patternStr);
	        this.divide(sectionCount - 1);
	      } else {
	        if (!pattern || pattern.str.length !== this.sectionCount()) {
	          const patStr = new Array(this.sectionCount()).fill('a').join('');
	          pattern = pattern.clone(patStr);
	        }
	      }
	      return pattern;
	    }
	
	    this.outerCenter = () => {
	      if (true || outerCenter === null) outerCenter = Vertex3D.center(coordinates.outer);
	      return outerCenter;
	    }
	
	    this.innerCenter = () => {
	      if (true || innerCenter === null) innerCenter = Vertex3D.center(coordinates.inner);
	      return innerCenter;
	    }
	
	    this.outerLength = () => {
	      if (true || outerLength === null)
	        outerLength = coordinates.outer[0].distance(coordinates.outer[3]);
	      return outerLength;
	    }
	
	    this.outerWidth = () => {
	      if (true || outerWidth === null)
	        outerWidth = coordinates.outer[0].distance(coordinates.outer[1]);
	      return outerWidth;
	    }
	
	    this.innerLength = () => {
	      if (true || innerLength === null)
	        innerLength = coordinates.inner[0].distance(coordinates.inner[3]);
	      return innerLength;
	    }
	
	    this.innerWidth = () => {
	      if (true || innerWidth === null)
	        innerWidth = coordinates.inner[0].distance(coordinates.inner[1]);
	      return innerWidth;
	    }
	
	    this.longestRadius = () => {
	      const oc = this.outerCenter();
	      let max = oc.distance(outerCoordinates[0]);
	      for (let index = 1; index < outerCoordinates.length; index++) {
	        const dist = oc.distance(coordinates.outer[index]);
	        if (dist > max) max = dist;
	      }
	      return max;
	    };
	
	    this.coverInfo = () => {
	      const propConfig = this.propertyConfig();
	      let biPolygon, backOffset, frontOffset, offset, coords;
	      const doorThickness = 3 * 2.54/4;
	      const bumperThickness = 3 * 2.54 / 16;
	      if (propConfig.isInset()) {
	        coords = this.coordinates().inner;
	        offset = propConfig('Inset').is.value() * -2;
	        const projection = 3 * 2.54/64;
	        frontOffset = projection;
	        backOffset = projection - doorThickness;
	      } else if (propConfig.isReveal()) {
	        coords = this.coordinates().outer;
	        offset = -propConfig.reveal().r.value();
	        frontOffset = (doorThickness + bumperThickness);
	        backOffset = bumperThickness;
	      } else {
	        coords = this.coordinates().inner;
	        offset = propConfig.overlay();
	        frontOffset = (doorThickness + bumperThickness);
	        backOffset = bumperThickness;
	      }
	
	      frontOffset *= -1;
	      backOffset *= -1;
	      const offsetObj = {x: offset, y: offset};
	      biPolygon = BiPolygon.fromPolygon(new Polygon3D(coords), frontOffset, backOffset, offsetObj);
	      return {biPolygon, frontOffset, backOffset};
	    }
	
	    this.normal = () => this.coverInfo().biPolygon.normal()
	
	    this.dividerInfo = (panelThickness) => {
	      const coverInfo = this.coverInfo();
	      const normal = coverInfo.biPolygon.normal().inverse();
	      const depth = this.innerDepth();
	      const length = this.innerLength();
	      const width = this.innerWidth();
	      const innerCenter = this.innerCenter();
	      const coordinates = this.coordinates();
	      if (!this.verticalDivisions()) {
	        const outer = coordinates.outer;
	        const point1 = outer[3];
	        const point2 = outer[2];
	        let depthVector = normal.scale(depth);
	        const point3 = point2.translate(depthVector, true);
	        const point4 = point1.translate(depthVector, true);
	        const points = [point1, point2, point3, point4];
	        const offset = panelThickness / 2;
	        return BiPolygon.fromPolygon(new Polygon3D(points), offset, -offset);
	      }
	      const outer = coordinates.outer;
	      const point1 = outer[1];
	      const point2 = outer[2];
	      let depthVector = normal.scale(depth);
	      const point3 = point2.translate(depthVector, true);
	      const point4 = point1.translate(depthVector, true);
	      const points = [point1, point2, point3, point4];
	      const offset = panelThickness / -2;
	      return BiPolygon.fromPolygon(new Polygon3D(points), offset, -offset);
	    }
	
	    const assemToJson = this.toJson;
	    this.toJson = () => {
	      const json = assemToJson.apply(this);
	      json.pattern = this.pattern().toJson();
	      json.subassemblies = this.sections.map((section) => section.toJson());
	      return json;
	    }
	
	    function removeCachedValues() {
	      rotation = innerCenter = outerCenter = innerLength = innerWidth = outerLength = outerWidth = null;
	      setSectionCoordinates();
	    }
	
	    function updateCoordinates(obj, newCoords) {
	      let change = false;
	      for (let i = 0; i < 4; i++) {
	        const v = obj[i];
	        const nv = newCoords[i];
	        if (v.x !== nv.x || v.y !== nv.y || v.z !== nv.z) change = true;
	        v.x = nv.x;
	        v.y = nv.y;
	        v.z = nv.z;
	      }
	      return change
	    }
	
	    this.updateCoordinates = (newCoords) => {
	      let change = updateCoordinates(coordinates.outer, newCoords.outer) | updateCoordinates(coordinates.inner, newCoords.inner);
	      // TODO: need to detect child config changes aswell...
	      // if (change) {
	        removeCachedValues();
	        setSectionCoordinates();
	      // }
	    }
	
	    this.setSection = (constructorIdOobject) => {
	      let section = SectionProperties.new(constructorIdOobject);
	      this.cover(section);
	      section.parentAssembly(this);
	    }
	
	    const divider = new DividerSection(this);
	    divider.parentAssembly(this);
	    this.divider(divider);
	    this.value('vertical', true);
	    this.pattern().onChange(setSectionCoordinates);
	    // this.vertical(true);
	    // coordinates.onAfterChange(setSectionCoordinates);
	  }
	}
	
	const list = [];
	const byId = {};
	const tolerance = .04
	SectionProperties.updateLinks = (sectionProp) => {
	  const id = sectionProp.id();
	  if (byId[id] === undefined) {
	    byId[id] = sectionProp;
	    list.push(sectionProp);
	  }
	  sectionProp.clearDirections();
	  const sectRad = section.longestRadius();
	  const sectionOuterCenter = sectionProp.outerCenter();
	  const centerDist = {};
	  for (let index = 0; index < list.length; index++) {
	    if (!other.rotation().equals(this.rotation()))  {
	      const other = list[index];
	      const otherRad = other.longestRadius();
	      const centerDist = sectionOuterCenter.distance(other.outerCenter());
	      if (centerDist - tolerance < otherRad + sectRad) {
	        const direction = Vertex3D.direction(sectionProp.outerCoordinates(), other.outerCoordinates(), tolerance, true);
	        if (direction) {
	          if (sectionProp[direction]() === undefined || centerDist < centerDistObj[distance]) {
	            sectionProp[direction](other);
	            centerDistObj[distance] = centerDist;
	          }
	        }
	      }
	    }
	  }
	}
	
	SectionProperties.new = function (constructorId) {
	  const section = Assembly.new.apply(null, arguments);
	  return section;
	}
	
	SectionProperties.fromJson = (json) => {
	  const sections = [];
	  const pattern = Pattern.fromJson(json.pattern);
	  for (let index = 0; index < json.subassemblies.length; index++) {
	    const sectionJson = json.subassemblies[index];
	    sections.push(Object.fromJson(sectionJson));
	  }
	  const sp  = new SectionProperties(json.config, json.index, sections, pattern);
	  sp.value.all(json.value.values);
	  sp.parentAssembly(json.parent);
	  sp.cover(Object.fromJson(json.cover));
	  if (sp.cover()) sp.cover().parentAssembly(sp);
	  sp.divider(new DividerSection(sp));
	  return sp;
	}
	
	const sections = [];
	SectionProperties.addSection = (clazz) => sections.push(clazz);
	SectionProperties.list = () => [].concat(sections);
	
	Object.class.register(SectionProperties);
	module.exports = SectionProperties;
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/section/partition/divider.js',
function (require, exports, module) {
	

	
	const Position = require('../../../../../position.js');
	const Divider = require('../../divider.js');
	const Frame = require('../../frame.js');
	const Assembly = require('../../../assembly.js');
	const Joint = require('../../../../joint/joint');
	
	class DividerSection extends Assembly {
	  constructor(sectionProperties) {
	    super(undefined, 'Divider');
	    if (sectionProperties === undefined) return;
	    const props = sectionProperties;
	    const instance = this;
	    let panel;
	
	    this.partCode = () => `${sectionProperties.partCode()}-dp`;
	
	    function toModel() {
	      const biPoly = sectionProperties.dividerInfo(3*2.54/4);
	      return biPoly.toModel();
	    }
	
	    this.part = () => false;
	    this.included = () => false;
	
	
	    this.maxWidth = () => 2.54*3/4;
	
	    this.partName = () => `${sectionProperties.partName()}`;
	    const panelPartName = () =>
	        `${this.partName()}.Divider.Panel`;
	
	    panel = new Divider('dvp', panelPartName, null, null, null, toModel);
	    // const frame = new Frame(`df-${index}`, 'Divider.Frame', frameCenterFunc, frameDemFunc, frameRotFunc);
	    panel.parentAssembly(this);
	    this.addSubAssembly(panel);
	    // this.addSubAssembly(frame);
	  }
	}
	
	DividerSection.abbriviation = 'dvrs';
	
	
	module.exports = DividerSection
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/section/sections/duel-door.js',
function (require, exports, module) {
	

	
	const SectionProperties = require('../section-properties.js');
	const Door = require('../../door/door.js');
	const Handle = require('../../hardware/pull.js');
	const Assembly = require('../../../assembly.js');
	const Polygon3D = require('../../../../../three-d/objects/polygon.js');
	const BiPolygon = require('../../../../../three-d/objects/bi-polygon.js');
	
	class DualDoorSection extends Assembly {
	  constructor(leftDoor, rightDoor) {
	    super('dds', 'Duel.Door.Section');
	    const instance = this;
	    const sectionProps = () => instance.parentAssembly();
	
	    this.part = () => false;
	
	    function shrinkPoly(poly, left) {
	      const lines = JSON.clone(poly.lines());
	      const offset = (lines[0].length() - instance.gap()) / 2;
	      if (left) {
	        lines[0].adjustLength(offset, true);
	        lines[1].startVertex = lines[0].endVertex;
	        lines[2].adjustLength(-offset, false);
	        lines[1].endVertex = lines[2].startVertex;
	      } else {
	        lines[0].adjustLength(-offset, false);
	        lines[3].endVertex = lines[0].startVertex;
	        lines[2].adjustLength(offset, true);
	        lines[3].startVertex = lines[2].endVertex;
	      }
	      return Polygon3D.fromLines(lines);
	
	    }
	
	    function getBiPolygon(left) {
	      const fullPoly = sectionProps().coverInfo().biPolygon;
	      const front = shrinkPoly(fullPoly.front(), left);
	      const back = shrinkPoly(fullPoly.back(), left);
	      return new BiPolygon(front, back);
	    }
	
	    this.getBiPolygon = (partCode) => {
	      return getBiPolygon(partCode === 'dl');
	    }
	
	    if (!leftDoor) {
	      leftDoor = new Door('dl', 'DoorLeft');
	      leftDoor.setPulls([Handle.location.TOP_RIGHT]);
	    }
	    this.addSubAssembly(leftDoor);
	    leftDoor.partName = () => `${sectionProps().partName()}-dl`;
	    this.left = () => leftDoor;
	
	    if (!rightDoor) {
	      rightDoor ||= new Door('dr', 'DoorRight');
	      rightDoor.setPulls([Handle.location.TOP_LEFT]);
	    }
	    this.addSubAssembly(rightDoor);
	    rightDoor.partName = () => `${sectionProps().partName()}-dr`;
	    this.right = () => rightDoor;
	
	    this.gap = () => 2.54 / 16;
	  }
	}
	
	DualDoorSection.fromJson = (json) => {
	  const doorLeft = Object.fromJson(json.subassemblies.dl);
	  const doorRight = Object.fromJson(json.subassemblies.dr);
	  return new DualDoorSection(doorLeft, doorRight);
	}
	
	
	DualDoorSection.abbriviation = 'dds';
	SectionProperties.addSection(DualDoorSection);
	
	
	
	module.exports = DualDoorSection
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/section/sections/false-front.js',
function (require, exports, module) {
	

	
	const SectionProperties = require('../section-properties.js');
	const PULL_TYPE = require('../../../../../../globals/CONSTANTS.js').PULL_TYPE;
	const DrawerFront = require('../../drawer/drawer-front.js');
	const Assembly = require('../../../assembly.js');
	
	class FalseFrontSection extends Assembly {
	  constructor(front) {
	    super();
	    const instance = this;
	    const sectionProps = () => instance.parentAssembly();
	    this.part = () => false;
	
	    this.getBiPolygon = () => {
	      return sectionProps().coverInfo().biPolygon;
	    }
	
	    if (!front) front = new DrawerFront('ff', 'DrawerFront');
	    this.front = () => front;
	    front.partName = () => `${sectionProps().partName()}-ff`;
	    this.pull = (i) => front.pull(i);
	    this.addSubAssembly(front);
	  }
	}
	
	FalseFrontSection.fromJson = (json) => {
	  const front = Object.fromJson(json.subassemblies.ff);
	  return new FalseFrontSection(front);
	}
	
	FalseFrontSection.abbriviation = 'ffs';
	SectionProperties.addSection(FalseFrontSection);
	
	
	
	module.exports = FalseFrontSection
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/section/sections/drawer.js',
function (require, exports, module) {
	

	
	const SectionProperties = require('../section-properties.js');
	const PULL_TYPE = require('../../../../../../globals/CONSTANTS.js').PULL_TYPE;
	const DrawerBox = require('../../drawer/drawer-box.js');
	const DrawerFront = require('../../drawer/drawer-front.js');
	const Assembly = require('../../../assembly.js');
	const Polygon3D = require('../../../../../three-d/objects/polygon.js');
	
	class DrawerSection extends Assembly {
	  constructor(front, box) {
	    super();
	    const instance = this;
	    const sectionProps = () => instance.parentAssembly();
	    this.part = () => false;
	
	    function getFrontBiPolygon () {
	      return sectionProps().coverInfo().biPolygon;
	    }
	    this.getBiPolygon = getFrontBiPolygon;
	
	    // TODO: change ff to df.
	    if (!front) front = new DrawerFront('ff', 'DrawerFront');
	    front.partName = () => `${sectionProps().partName()}-df`;
	    this.front = () => door;
	    this.pull = (i) => front.pull(i);
	    this.addSubAssembly(front);
	
	
	
	    function getDrawerDepth() {
	      const depth = sectionProps().innerDepth();
	      if (depth < 3) return 0;
	      return (Math.floor(((depth - 2.54) / 2.54)/2) * 2) * 2.54;
	    }
	    this.drawerDepth = getDrawerDepth;
	
	    this.getNormal = () => front.biPolygon().normal();
	
	    function getFrontPoly() {
	      const propConfig = sectionProps().getRoot().group().propertyConfig;
	      const props = propConfig('Guides');
	      const innerPoly = new Polygon3D(sectionProps().coordinates().inner);
	      const coverInfo = sectionProps().coverInfo();
	      const biPoly = front.biPolygon();
	      const depth = getDrawerDepth(sectionProps().innerDepth);
	      const offsetVect = biPoly.normal().scale(-coverInfo.backOffset);
	      const sideOffset = props.dbsos.value();
	      const topOffset = props.dbtos.value();
	      const bottomOffset = props.dbbos.value();
	      innerPoly.offset(sideOffset/2, sideOffset/2, topOffset, bottomOffset);
	      return innerPoly.translate(offsetVect);
	    }
	
	    this.getBiPolygon = (partCode) => {
	      switch (partCode) {
	        case 'db': return getFrontPoly();
	        case 'ff': return getFrontBiPolygon();
	        default: throw new Error(`PartCode: '${partCode}' biPolygon has not been defined for this object`);
	      }
	    }
	
	    if (!box) box = new DrawerBox('db', 'Drawer.Box');
	    box.partName = () => `${sectionProps().partName()}-db`;
	    this.box = () => box;
	    this.addSubAssembly(box);
	  }
	}
	
	DrawerSection.fromJson = (json) => {
	  const drawerFront = Object.fromJson(json.subassemblies.ff);
	  const drawerBox = Object.fromJson(json.subassemblies.df);
	  return new DrawerSection(drawerFront, drawerBox);
	}
	
	DrawerSection.abbriviation = 'dws';
	SectionProperties.addSection(DrawerSection);
	
	
	module.exports = DrawerSection
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/section/sections/door.js',
function (require, exports, module) {
	

	const SectionProperties = require('../section-properties.js');
	const Door = require('../../door/door.js');
	const Assembly = require('../../../assembly.js');
	
	class DoorSection extends Assembly {
	  constructor(door) {
	    super();
	    const sectionProps = () => instance.parentAssembly();
	    const instance = this;
	    this.part = () => false;
	
	
	    function getBiPolygon () {
	      return sectionProps().coverInfo().biPolygon;
	    }
	    this.getBiPolygon = getBiPolygon;
	
	    if (!door) {
	      door = new Door('d', 'Door');
	      this.door = () => door;
	      this.pull = (i) => door.pull(i);
	    }
	    door.partName = () => `${sectionProps().partName()}-d`;
	
	    this.addSubAssembly(door);
	  }
	}
	
	DoorSection.fromJson = (json) => {
	  const door = Object.fromJson(json.subassemblies.d);
	  return new DoorSection(door);
	}
	
	DoorSection.abbriviation = 'drs';
	SectionProperties.addSection(DoorSection);
	
	module.exports = DoorSection
	
});


RequireJS.addFunction('./services/cabinet/app-src/objects/assembly/assemblies/section/space/sections/divide-section.js',
function (require, exports, module) {
	

	
	const SpaceSection = require('../space.js');
	const Pattern = require('../../../../../../division-patterns.js');
	const DividerSection = require('../../partition/sections/divider.js');
	const Section = require('../../section.js');
	const Assembly = require('../../../../assembly.js');
	
	function sectionId(parent, sectionProperties) {
	
	}
	
	let dvs;
	let dsCount = 0;
	class DivideSection extends SpaceSection {
	  constructor(sectionProperties, parent) {
	    const pId = parent && parent.id ? parent.id() : null;
	    const sIndex = (typeof sectionProperties) === 'function' ? sectionProperties().index : null;
	    super(`dvds-${pId}-${sIndex}`, 'divideSection', sectionProperties, parent);
	    // this.important = ['partCode', 'partName', 'borderIds', 'index'];
	    const instance = this;
	    dvs = dvs || this;
	    let pattern;
	    let sectionCount = 1;
	    this.vertical = (is) => instance.value('vertical', is);
	    this.vertical(true);
	    this.sections = [];
	    this.pattern = (patternStr) => {
	      if ((typeof patternStr) === 'string') {
	        sectionCount = patternStr.length;
	        this.divide(sectionCount - 1);
	        pattern = new Pattern(patternStr);
	      } else {
	        if (!pattern || pattern.str.length !== sectionCount)
	          pattern = new Pattern(new Array(sectionCount).fill('a').join(''));
	      }
	      return pattern;
	    }
	    this.dividerCount = () => this.init() && Math.ceil((this.sections.length - 1) / 2);
	    this.isVertical = () => this.sections.length < 2 ? undefined : this.vertical();
	    this.sectionProperties = () => JSON.stringify(sectionProperties);
	    this.init = () => {
	      if (this.sections.length === 0) {
	        this.sections.push(new DivideSection(this.borders(0), this));
	      }
	      return true;
	    }
	
	    // TODO: will break in future should be calling getJoints.. recursive iissue;
	    this.getJoints = () => {
	      let joints = [];
	      this.children().forEach((child) => joints = joints.concat(child.joints));
	      return joints;
	    }
	    this.children = () => this.sections;
	    this.partitions = () => this.sections.filter((e, index) => index % 2 === 1);
	    this.spaces = () => this.sections.filter((e, index) => index % 2 === 0);
	    this.borders = (index) => {
	      return () => {
	        // if (index === 1) {
	        //   console.log('center');
	        // }
	        const props = sectionProperties();
	        const position = {
	          front: props.position.front,
	          back: props.position.back,
	          top: props.position.top,
	          bottom: props.position.bottom,
	          left: props.position.left,
	          right: props.position.right
	        };
	        const rotation = props.rotation;
	
	        let top = props.borders ? props.borders.top : props.position.top;
	        let bottom = props.borders ? props.borders.bottom : props.position.bottom;
	        let left = props.borders ? props.borders.left : props.position.left;
	        let right = props.borders ? props.borders.right : props.position.right;
	        if (this.vertical()) {
	          if (index !== 0) {
	            left = this.sections[index - 1];
	            position.left = undefined;
	          } if (this.sections[index + 1] !== undefined) {
	            right = this.sections[index + 1];
	            position.right = undefined;
	          }
	        } else {
	          if (index !== 0) {
	            top = this.sections[index - 1];
	            position.top = undefined;
	          } if (this.sections[index + 1] !== undefined) {
	            bottom = this.sections[index + 1];
	            position.bottom = undefined;
	          }
	        }
	
	        const depth = props.depth;
	        if (!top || !bottom || !right || !left)
	          throw new Error('Border not defined');
	        return {borders: {top, bottom, right, left}, position, depth, index, rotation};
	      }
	    }
	    this.dividerProps = (index) => {
	      return () => {
	        // if (index === 1) {
	        //   console.log('center');
	        // }
	        const answer = this.dividerLayout().list;
	        let offset = this.dividerOffset(index * 2);
	        for (let i = 0; i < index + 1; i += 1) offset += answer[i];
	        let props = sectionProperties();
	        const innerSize = this.innerSize();
	        let center = this.center();
	        let dividerLength;
	        if (this.vertical()) {
	          const start = props.borders ? props.borders.left.position().centerAdjust('x', '-z') : props.position.left;
	          center.x = start + offset;
	          dividerLength = innerSize.y;
	        } else {
	          const start = props.borders ? props.borders.top.position().centerAdjust('y', '+z') : props.position.top;
	          center.y = start - offset;
	          dividerLength = innerSize.x;
	        }
	        const rotationFunc = () =>  this.vertical() ? {x: 0, y:0, z: 0} : {x: 0, y:0, z: 90};
	
	        const depth = props.depth;
	        const vertical = this.vertical();
	        const borders = props.borders;
	        return {center, dividerLength, rotationFunc, index, depth, vertical, borders};
	      }
	    }
	
	    this.dividerOffset = (limitIndex) => {
	      limitIndex = limitIndex > -1 && limitIndex < this.sections.length ? limitIndex : this.sections.length;
	      let cov = this.coverable();
	      let frOut = this.outerSize();
	      let offset = this.isVertical() ? cov.limits['-x'] - frOut.limits['-x'] : frOut.limits.y - cov.limits.y;
	      for (let index = 0; index < limitIndex + 2; index += 1) {
	        const section = this.sections[index];
	        if (section instanceof DividerSection) {
	          const maxWidth = section.maxWidth();
	          let halfReveal;
	          if (this.propertyConfig().isReveal()) {
	            halfReveal = this.propertyConfig().reveal().r.value() / 2;
	          } else if (this.propertyConfig().isInset()) {
	            const insetValue = this.propertyConfig('Inset').is.value();
	            halfReveal = (section.maxWidth() + insetValue * 2) / 2;
	          } else {
	            halfReveal = (maxWidth - this.propertyConfig().overlay() * 2)/2;
	          }
	          offset += index < limitIndex ? halfReveal*2 : halfReveal;
	        }
	      }
	      return offset;
	    }
	
	    this.dividerReveal = (limitIndex) => {
	      limitIndex = limitIndex > -1 && limitIndex < this.sections.length ? limitIndex : this.sections.length;
	      let offset = 0;
	      for (let index = 0; index < limitIndex; index += 1) {
	        const section = this.sections[index];
	        if (section instanceof DividerSection) {
	          if (this.propertyConfig().isReveal()) {
	            offset += this.propertyConfig().reveal().r.value();
	          }  else if (this.propertyConfig().isInset()) {
	            const insetValue = this.propertyConfig('Inset').is.value();
	            offset += section.maxWidth() + insetValue * 2;
	          } else {
	            offset += section.maxWidth();
	            offset -= this.propertyConfig().overlay() * 2;
	          }
	        }
	      }
	      return offset;
	    }
	
	    this.sectionCount = () => this.dividerCount() + 1;
	    this.dividerLayout = () => {
	      let distance;
	      const coverable = this.coverable();
	      distance = this.vertical() ? coverable.dems.x : coverable.dems.y;
	      distance -= this.dividerReveal();
	      return this.pattern().calc(distance);
	    };
	    this.divide = (dividerCount) => {
	      if (!Number.isNaN(dividerCount)) {
	        dividerCount = dividerCount > 10 ? 10 : dividerCount;
	        dividerCount = dividerCount < 0 ? 0 : dividerCount;
	        const currDividerCount = this.dividerCount();
	        if (dividerCount < currDividerCount) {
	          const diff = currDividerCount - dividerCount;
	          this.sections.splice(dividerCount * 2 + 1);
	          return true;
	        } else {
	          const diff = dividerCount - currDividerCount;
	          for (let index = currDividerCount; index < dividerCount; index +=1) {
	            this.sections.push(new DividerSection(`dv-${this.id()}-${index}`, this.dividerProps(index), instance));
	            const divideIndex = dividerCount + index + 1;
	            this.sections.push(new DivideSection(this.borders(divideIndex), instance));
	          }
	          return diff !== 0;
	        }
	      }
	      return false;
	    }
	    this.setSection = (constructorIdOobject, index) => {
	      let section;
	      index = Number.parseInt(index);
	      if ((typeof constructorIdOobject) === 'string') {
	        if (constructorIdOobject === 'DivideSection') {
	          section = new DivideSection(this.borders(index), instance);
	        } else {
	          section = Section.new(constructorIdOobject, 'dr', this.borders(index), this);
	        }
	      } else {
	        section = constructorIdOobject;
	      }
	      this.sections[index] = section;
	    }
	    this.size = () => {
	      return {width: this.width, height: this.height};
	    }
	    this.sizes = () => {
	      return 'val';
	    }
	    const assemToJson = this.toJson;
	    this.toJson = () => {
	      const json = assemToJson.apply(this);
	      json.pattern = this.pattern().toJson();
	      json.subassemblies = this.sections.map((section) => section.toJson());
	      return json;
	    }
	  }
	}
	
	DivideSection.fromJson = (json) => {
	  const sectionProps = json.parent.borders(json.borderIds || json.index);
	  const assembly = new DivideSection(sectionProps, json.parent);
	  assembly.partCode(json.partCode);
	  assembly.id(json.id)
	  assembly.index(json.index);
	  const subAssems = json.subassemblies;
	  assembly.values = json.values;
	  for (let index = 0; index < subAssems.length / 2; index += 1) {
	    const partIndex = index * 2 + 1;
	    if (partIndex < subAssems.length) {
	      const partJson = subAssems[partIndex];
	      partJson.parent = assembly;
	      const partition = Assembly.class(partJson._TYPE).fromJson(partJson, assembly);
	      assembly.setSection(partition, partIndex);
	    }
	
	    const spaceIndex = index * 2;
	    const spaceJson = subAssems[spaceIndex];
	    spaceJson.index = spaceIndex;
	    spaceJson.parent = assembly;
	    const space = Assembly.class(spaceJson._TYPE).fromJson(spaceJson, assembly);
	    assembly.setSection(space, spaceIndex);
	  }
	  assembly.pattern(json.pattern.str);
	  const pattern = assembly.pattern();
	  const patternIds = Object.keys(json.pattern.values);
	  patternIds.forEach((id) => pattern.value(id, json.pattern.values[id]));
	  return assembly;
	}
	
	DivideSection.abbriviation = 'ds';
	
	
	module.exports = DivideSection
	
});


RequireJS.addFunction('./services/cabinet/test/run.js',
function (require, exports, module) {
	

	
	const EPNTS = require('../generated/EPNTS.js');
	const Test = require('../../../public/js/utils/test/test').Test;
	
	if (EPNTS.getEnv() === 'local') {
	  require('../../../public/js/utils/test/tests/utils');
	  require('../../../public/js/utils/test/tests/imposter');
	  require('./tests/cabinet');
	  require('../../../public/js/utils/test/tests/decision-tree');
	  require('../../../public/js/utils/test/tests/logic-tree');
	  require('../../../public/js/utils/test/tests/star-line-map');
	  require('./tests/polygon-merge');
	  require('./tests/array-math');
	  require('./tests/plane');
	  require('./tests/line2d');
	  require('./tests/line-consolidate');
	}
	
	Test.run();
	
});


RequireJS.addFunction('./services/cabinet/test/tests/array-math.js',
function (require, exports, module) {
	const Test = require('../../../../public/js/utils/test/test').Test;
	const Matrix = require('../../app-src/three-d/objects/matrix.js');
	const Vertex3D = require('../../app-src/three-d/objects/vertex.js');
	const Vertex2d = require('../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line.js');
	const approximate = require('../../../../public/js/utils/approximate.js');
	
	const CSG = require('../../public/js/3d-modeling/csg');
	const GL = require('../../public/js/3d-modeling/lightgl');
	const FixedValue = require('../../app-src/three-d/objects/fixed-value');
	
	
	Test.add('Array: translate',(ts) => {
	  let result = [].translate([1,2,3]);
	  ts.assertTrue(result.equals([1,2,3]));
	  ts.assertFalse(result.equals([1,2,4]));
	  ts.assertFalse(result.equals([1,2,3,4]))
	  ts.assertFalse(result.equals([1,2]))
	
	  result = [3,6,9].translate([1,-2,3]);
	  ts.assertTrue(result.equals([4,4,12]));
	  ts.assertFalse(result.equals([4,2,12]));
	
	  let a = [4,-4,-4];
	  let b = a.translate([5,5,5], true, true);
	  ts.assertTrue(a.equals([4,-4,-4]));
	  ts.assertTrue(b.equals([9,1,1]));
	
	  ts.success();
	});
	
	
	Test.add('Array: inverse',(ts) => {
	  let result = [3,6,9].inverse();
	  ts.assertTrue(result.equals([-3,-6,-9]));
	
	  let a = [4,-4,-4];
	  let b = a.inverse(true);
	  ts.assertTrue(a.equals([4,-4,-4]));
	  ts.assertTrue(b.equals([-4,4,4]));
	
	  a = [1,2,3];
	  b = a.inverse(true);
	  let c = a.translate(b, true);
	  ts.assertTrue(a.equals([1,2,3]));
	  ts.assertTrue(b.equals([-1,-2,-3]));
	  ts.assertTrue(c.equals([0,0,0]));
	
	  ts.success();
	});
	
	
	Test.add('Matrix: multiply',(ts) => {
	  let result = new Matrix([[1,2],[6,7]]).multiply(new Matrix([[5,3],[4,4]]));
	  ts.assertTrue(result.equals(new Matrix([[13,11],[58,46]])));
	
	  let A = new Matrix([[7,7,7],[2,3,4],[6,7,8],[5,5,5]]);
	  let B = new Matrix([[4,0,7],[1,1,1],[7,7,7]]);
	
	  let AB = new Matrix([[84,56,105],[39,31,45],[87,63,105],[60,40,75]]);
	  ts.assertTrue(AB.equals(A.multiply(B)));
	
	  ts.success();
	});
	
	Test.add('Matrix: remove',(ts) => {
	  let matrix = new Matrix([
	    [1,2,3,4],
	    [5,6,7,8],
	    [9,0,2,3],
	    [6,6,6,6]
	  ]);
	  let result = matrix.remove();
	  ts.assertTrue(result.equals(matrix));
	
	  result = matrix.remove(0);
	  ts.assertTrue(result.equals(new Matrix([
	    [5,6,7,8],
	    [9,0,2,3],
	    [6,6,6,6]
	  ])));
	
	  result = matrix.remove(null, 2);
	  ts.assertTrue(result.equals(new Matrix([
	    [1,2,4],
	    [5,6,8],
	    [9,0,3],
	    [6,6,6]
	  ])));
	
	  result = matrix.remove(0,1);
	  ts.assertTrue(result.equals(new Matrix([
	    [5,7,8],
	    [9,2,3],
	    [6,6,6]
	  ])));
	
	  result = matrix.remove(-2, -1);
	  ts.assertTrue(result.equals(new Matrix([
	    [1,2,3],
	    [5,6,7],
	    [6,6,6]
	  ])));
	
	  result = matrix.minor(0);
	  ts.assertTrue(result.equals(new Matrix([
	    [6,7,8],
	    [0,2,3],
	    [6,6,6]
	  ])));
	
	  result = matrix.minor(2);
	  ts.assertTrue(result.equals(new Matrix([
	    [5,6,8],
	    [9,0,3],
	    [6,6,6]
	  ])));
	
	  ts.success();
	});
	
	
	Test.add('Matrix: remove',(ts) => {
	  let matrix = new Matrix([
	    [7,8],
	    [9,3],
	  ]);
	  let result = matrix.determinate();
	  ts.assertTrue(result === -51);
	
	  matrix = new Matrix([
	    [1,2,4],
	    [5,7,8],
	    [0,2,3]
	  ]);
	  let det = matrix.determinate();
	  ts.assertTrue(det === 15);
	
	  matrix = new Matrix([
	    [4,7],
	    [2,6]
	  ]);
	  det = matrix.determinate();
	
	  let inverse = matrix.diagonal();
	  inverse.scale(-1, true);
	  inverse.scale(1/det);
	
	  // matrix = new Matrix([
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1,2,4],
	  // ]);
	  // result = matrix.determinate();
	  // ts.assertTrue(result === 0);
	
	
	  // matrix = new Matrix([
	  //   [1,1,5,6,3,8,7,6,5,4],
	  //   [1,1,5,6,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,5,1,2,4],
	  //   [1,6,3,8,7,6,5,1,2,4],
	  //   [1,1,3,8,7,6,5,1,2,4],
	  //   [1,1,5,6,3,8,7,1,2,4],
	  //   [1,1,5,6,3,8,7,1,2,4],
	  //   [1,1,5,6,3,8,7,1,2,4],
	  //   [1,1,5,6,3,8,7,6,5,1],
	  //   [1,1,5,8,7,6,5,1,2,4],
	  // ]);
	  // result = matrix.determinate();
	  // ts.assertTrue(result === 0);
	
	  ts.success();
	});
	
	
	Test.add('Matrix: identity',(ts) => {
	  let identity2 = Matrix.identity(2);
	  let identity3 = Matrix.identity(3);
	
	  let matrix = new Matrix([
	    [7,8],
	    [9,3],
	  ]);
	  let inverse = matrix.inverse();
	  let result = matrix.multiply(inverse)
	  result.approximate();
	  ts.assertTrue(result.equals(identity2));
	
	  result = inverse.multiply(matrix);
	  result.approximate();
	  ts.assertTrue(result.equals(identity2));
	
	
	  matrix = new Matrix([
	    [1,2,3],
	    [4,5,6],
	    [7,2,9]
	  ]);
	  inverse = matrix.inverse();
	  result = matrix.multiply(inverse)
	  result.approximate();
	  ts.assertTrue(result.equals(identity3));
	
	  result = inverse.multiply(matrix);
	  result.approximate();
	  ts.assertTrue(result.equals(identity3));
	
	  ts.success();
	});
	
	Test.add('Matrix: rowEchelon', (ts) => {
	  let matrix = new Matrix([
	    [1,2,3,1],
	    [5,6,7,1],
	    [9,10,11,1],
	  ]);
	
	  let rowEsch = matrix.rowEchelon();
	  let reduced = matrix.rowEchelon(true);
	  ts.assertTrue(reduced.equals(new Matrix([[1,0,-1,-1],[0,1,2,1],[0,0,0,0]])));
	  ts.assertTrue(rowEsch.equals(new Matrix([[1,2,3,1],[0,-4,-8,-4],[0,0,0,0]])));
	
	  matrix = new Matrix([
	    [5,3,2,1],
	    [9,6,8,1],
	    [1,4,7,1],
	  ]);
	
	  rowEsch = matrix.rowEchelon();
	  reduced = matrix.rowEchelon(true);
	  ts.assertTrue(reduced.equals(new Matrix([[1,0,0,-9/55],[0,1,0,4/5],[0,0,1,-16/55]])));
	  ts.assertTrue(rowEsch.equals(new Matrix([[5,3,2,1],[0,3/5,22/5,-4/5],[0,0,-275/15,16/3]])));
	
	  ts.success();
	});
	
	Test.add('Matrix: fixedColumns', (ts) => {
	  let matrix = new Matrix([
	    [8,3,1],
	    [8,6,1],
	    [1,4,1],
	  ]);
	
	  let fixedColumns = matrix.fixedColumns();
	  ts.assertTrue(fixedColumns.equals([false, false, true]));
	
	  matrix = new Matrix([
	    [8,3,1],
	    [7.99999999999,6,1],
	    [8.000001,4,1],
	  ]);
	
	  fixedColumns = matrix.fixedColumns();
	  ts.assertTrue(fixedColumns.equals([true, false, true]));
	
	  ts.success();
	});
	
	Test.add('Matrix: uniqueRows', (ts) => {
	  let matrix = new Matrix([
	    [8,6,1],
	    [8,6,1],
	    [1,4,1],
	  ]);
	
	  let uniqueRows = matrix.uniqueRows();
	  ts.assertTrue(uniqueRows.equals(new Matrix([[8,6,1],[1,4,1]])));
	
	  matrix = new Matrix([
	    [0,0,3,-5,4,0,0,1],
	    [0,0,3,-5,4,0,0,1],
	    [0,0,5,2,1,0,0,1],
	    [0,0,5,2,1,0,0,1],
	    [0,0,2,3,-2,0,0,1],
	  ]);
	
	  uniqueRows = matrix.uniqueRows();
	  ts.assertTrue(uniqueRows.equals(new Matrix([[0,0,3,-5,4,0,0,1],[0,0,5,2,1,0,0,1],[0,0,2,3,-2,0,0,1]])));
	
	  ts.success();
	});
	
	Test.add('Matrix: properDemension', (ts) => {
	  let matrix = new Matrix([
	    [8,6,1],
	    [8,6,1],
	    [1,4,1],
	  ]);
	
	  const zero = new FixedValue(0);
	  const one = new FixedValue(1);
	  let properDemension = matrix.properDemension();
	  ts.assertTrue(properDemension.matrix.equals(new Matrix([[8,6],[1,4]])));
	  ts.assertTrue(properDemension.fixedValues.equals([,,one]));
	
	  matrix = new Matrix([
	    [0,0,3,-5,4,0,0,1],
	    [0,0,3,-5,4,0,0,1],
	    [0,0,5,2,1,0,0,1],
	    [0,0,5,2,1,0,0,1],
	    [0,0,2,3,-2,0,0,1],
	  ]);
	
	  properDemension = matrix.properDemension(true);
	  ts.assertTrue(properDemension.matrix.equals(new Matrix([[3,-5,4],[5,2,1],[2,3,-2]])));
	  ts.assertTrue(properDemension.fixedValues.equals([zero,zero,,,,zero,zero,one]));
	
	  matrix = new Matrix([
	    [8,7,1],
	    [8,7,1],
	    [1,4,1],
	  ]);
	
	  properDemension = matrix.properDemension();
	  ts.assertTrue(properDemension.matrix.equals(new Matrix([[8,7],[1,4]])));
	  ts.assertTrue(properDemension.fixedValues.equals([,,one]));
	
	  ts.success();
	});
	
	Test.add('Matrix: consise',(ts) => {
	  let cloudyMatirx = new Matrix([
	    [0,0,3,-5,4,0,0],
	    [0,0,3,-5,4,0,0],
	    [0,0,5,2,1,0,0],
	    [0,0,5,2,1,0,0],
	    [0,0,2,3,-2,0,0],
	  ]);
	
	  const consiseObj = cloudyMatirx.consise();
	  ts.assertTrue([6,5,1,0].equals(consiseObj.removedColumns));
	
	  let solution = new Matrix([
	    [3,-5,4],
	    [5,2,1],
	    [2,3,-2],
	  ]);
	  ts.assertTrue(solution.equals(consiseObj.matrix));
	
	  ts.success();
	
	});
	
	Test.add('Matrix: solve',(ts) => {
	  let equations = new Matrix([
	    [3,-5,4],
	    [5,2,1],
	    [2,3,-2],
	  ]);
	  let dColumn = [5, 0, 3];
	  let answer = new Matrix([[2],[-3],[-4]]);
	
	  let solution = equations.solve(dColumn);
	  ts.assertTrue(solution.equals(answer));
	
	  let cloudyMatirx = new Matrix([
	    [0,0,3,-5,4,0,0],
	    [0,0,3,-5,4,0,0],
	    [0,0,5,2,1,0,0],
	    [0,0,5,2,1,0,0],
	    [0,0,2,3,-2,0,0],
	  ]);
	
	  let unknownValue = 0;
	  answer = new Matrix([[unknownValue],[unknownValue],[2],[-3],[-4],[unknownValue],[unknownValue]]);
	  solution = cloudyMatirx.solve(dColumn);
	  ts.assertTrue(solution.equals(answer));
	
	  ts.success();
	});
	
	const accuracy = 10000000000;
	
	
	function testRotation(ts, center, rotation) {
	  center = new Vertex3D({x: 1, y:0, z:0});
	  let cube = CSG.cube({radius: .0000000000001});
	  cube.center(center);
	  cube.rotate(rotation);
	  let modelCenter = cube.polygons[0].vertices[0].pos;
	
	  let calculatedCenter = CSG.rotate(center, rotation);
	  ts.assertTrue(approximate.eq(modelCenter.x, calculatedCenter.x), `${modelCenter.x} !~= ${calculatedCenter.x}`);
	  ts.assertTrue(approximate.eq(modelCenter.y, calculatedCenter.y), `${modelCenter.y} !~= ${calculatedCenter.y}`);
	  ts.assertTrue(approximate.eq(modelCenter.z, calculatedCenter.z), `${modelCenter.z} !~= ${calculatedCenter.z}`);
	}
	
	function comparePoints(ts, p1, p2) {
	  ts.assertEquals(p1.x, p2.x, null,  accuracy);
	  ts.assertEquals(p1.y , p2.y, null,  accuracy);
	  ts.assertEquals(p1.z, p2.z, null,  accuracy);
	}
	
	Test.add('CSG: rotation',(ts) => {
	
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 90, y: 0, z: 0});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 0, y: 1, z: 0});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 0, y: 0, z: 1});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 1, y: 1, z: 1});
	  testRotation(ts, {x: 1, y:1, z:1}, {x: 27, y: 0, z: 0});
	  testRotation(ts, {x: 1, y:1, z:1}, {x: 0, y: -15, z: 0});
	  testRotation(ts, {x: 1, y:1, z:1}, {x: 0, y: 0, z: 33});
	  testRotation(ts, {x: 1, y:1, z:1}, {x: 90, y: 90, z: 90});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 27, y: 90, z: 0});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 27, y: 0, z: 90});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 27, y: 90, z: 90});
	  testRotation(ts, {x: 1, y:0, z:0}, {x: 27, y: -15, z: 33});
	
	  let rotation = {x: 27, y: -15, z: 33};
	  let start = {x: 50, y: -12, z:-4};
	  let point = CSG.rotate(start, rotation);
	  let reversed = CSG.reverseRotate(point, rotation);
	
	  ts.assertEquals(start.x, reversed.x, null, accuracy);
	  ts.assertEquals(start.y, reversed.y, null, accuracy);
	  ts.assertEquals(start.z, reversed.z, null, accuracy);
	
	  point = {x: 0, y:0, z: -3};
	  let offset = {x: 1, y:0, z: 0};
	  rotation = {x: 0, y:90, z: 0};
	
	  let result = CSG.transRotate(point, offset, rotation);
	  ts.assertEquals(result.x, 0, null,  accuracy);
	  ts.assertEquals(result.y , 0, null,  accuracy);
	  ts.assertEquals(result.z, -4, null,  accuracy);
	
	  point = {x: 0, y:0, z: -3};
	  offset = {x: -1, y:0, z: 2};
	  rotation = {x: 0, y:90, z: 0};
	
	  result = CSG.transRotate(point, offset, rotation);
	  ts.assertEquals(result.x, 2, null,  accuracy);
	  ts.assertEquals(result.y , 0, null,  accuracy);
	  ts.assertEquals(result.z, -2, null,  accuracy);
	
	
	  let topLeft = {x: -1, y: 1, z:0};
	  let topRight = {x: 1, y: 1, z:0};
	  let bottomRight = {x: 1, y:-1 , z:0};
	  let bottomLeft = {x: -1, y: -1, z:0};
	
	  offset = {x: -1, y: 0, z: 0}
	  rotation = {x: 0, y:90, z: 0};
	
	  let topLeftAns = {x: -1, y: 1, z:1};
	  let topRightAns = {x: 1, y: 1, z:1};
	  let bottomRightAns = {x: 1, y: -1, z:1};
	  let bottomLeftAns = {x: -1, y: -1, z:1};
	
	  let points = [topLeft, topRight, bottomRight, bottomLeft];
	  CSG.transRotateAll(points, offset, rotation);
	  comparePoints(ts, points[0], topLeftAns);
	  comparePoints(ts, points[1], topRightAns);
	  comparePoints(ts, points[2], bottomRightAns);
	  comparePoints(ts, points[3], bottomLeftAns);
	
	  point = {x: 10, y:20, z: 0};
	  offset = {x: -1, y: -1, z: 1};
	  answer = {x: 9, y: 19, z: 1};
	  result = CSG.transRotate(point, offset, {x:0,y:0,z:0});
	  comparePoints(ts, result, answer);
	  rotation = {x: 6.009, y: 0, z: 0};
	  let rotatedPoint = CSG.rotate(point, rotation);
	  result = CSG.transRotate(rotatedPoint, offset, rotation);
	  result = CSG.reverseRotate(result, rotation);
	  comparePoints(ts, result, answer);
	
	  ts.success();
	});
	
	Test.add('Vertex3D: direction',(ts) => {
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 0, y: 1, z: 0}]), 'up');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 0, y: -1, z: 0}]), 'down');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: -1, y: 0, z: 0}]), 'left');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 1, y: 0, z: 0}]), 'right');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 0, y: 0, z: -1}]), 'forward');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 0, y: 0, z: 1}]), 'backward');
	
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 1, y: 1, z: 0}]), 'right up');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: -1, y: 0, z: -1}]), 'left forward');
	  ts.assertEquals(Vertex3D.direction([{x:0, y: 0, z: 0}], [{x: 1, y: 1, z: 1}]), 'right up backward');
	
	  ts.success();
	});
	
	function checkRotateAroundPoint(ts, point, rotation) {
	  rotation ||= [2, 0, 0];
	  const glMatrix = GL.Matrix.rotateAroundPoint(point, rotation).m;
	  const matrix = Matrix.fromGL(glMatrix);
	  const vertMatrix = Matrix.fromVertex(point);
	  const result = matrix.dot(vertMatrix);
	
	  const glRotationMatrix = GL.Matrix.rotationMatrix(rotation);
	  const rotationMatrix = Matrix.fromGL(glRotationMatrix.m);
	  const T = new Matrix([[1,0,0,point.x],[0,1,0,point.y],[0,0,1,point.z],[0,0,0,1]]);
	  const Tneg = new Matrix([[1,0,0,-point.x],[0,1,0,-point.y],[0,0,1,-point.z],[0,0,0,1]]);
	  const rotMatrix = T.dot(rotationMatrix).dot(Tneg);
	  const manualResult = rotMatrix.dot(vertMatrix);
	
	  ts.assertTrue(manualResult.equals(vertMatrix), `Manual matrix attempt to perform operations is malfunctioning:\n${manualResult.toString()}\n\nshould be \n${vertMatrix.toString()}`);
	  ts.assertTrue(matrix.equals(rotMatrix), `Point Rotation matrix is incorrect:\n${rotMatrix.toString()}\n\nshould be\n${rotMatrix.toString()}`);
	  ts.assertTrue(manualResult.equals(result), `Dot product with point rotation matrix is not producing the desired result:\n${result.toString()}\n\nshould be\n${manualResult.toString()}`);
	  ts.assertTrue(vertMatrix.equals(result), `Point rotated around should not move:\n${result.toString()}\n\nshould be\n${vertMatrix.toString()}`);
	}
	
	function allRotationsAroundPoint(ts, point) {
	  checkRotateAroundPoint(ts, point, [2,0,0]);
	  checkRotateAroundPoint(ts, point, [0,2,0]);
	  checkRotateAroundPoint(ts, point, [0,0,2]);
	  checkRotateAroundPoint(ts, point, [2,2,2]);
	}
	
	function testOtherPointRotation(ts, center, rotation, other, expectedResult) {
	  const glMatrix = GL.Matrix.rotateAroundPoint(center, rotation).m;
	  const rotMatrix = Matrix.fromGL(glMatrix);
	  const rotatedPoint = rotMatrix.dot(Matrix.fromVertex(other));
	  ts.assertTrue(rotatedPoint.equals(expectedResult), `Rotated point did not end where expected:\n${rotatedPoint.toString()}\n\nshould be\n${expectedResult}`);
	}
	
	Test.add('lightgl: rotateAroundPoint', (ts) => {
	  allRotationsAroundPoint(ts, new Vertex3D(0,0,0));
	  allRotationsAroundPoint(ts, new Vertex3D(1,0,0));
	  allRotationsAroundPoint(ts, new Vertex3D(0,1,0));
	  allRotationsAroundPoint(ts, new Vertex3D(0,0,1));
	  allRotationsAroundPoint(ts, new Vertex3D(1,1,1));
	
	  allRotationsAroundPoint(ts, new Vertex3D(4,2,1));
	  allRotationsAroundPoint(ts, new Vertex3D(5,4,3));
	  allRotationsAroundPoint(ts, new Vertex3D(22,1,0));
	  allRotationsAroundPoint(ts, new Vertex3D(0,18,1));
	  allRotationsAroundPoint(ts, new Vertex3D(1,5,1));
	
	  testOtherPointRotation(ts, new Vertex3D(1,1,1), [0,Math.PI,0], new Vertex3D(3,1,2), new Matrix([[-1],[1],[0],[1]]));
	  testOtherPointRotation(ts, new Vertex3D(1,1,1), [0,Math.PI/2,0], new Vertex3D(3,1,2), new Matrix([[2],[1],[-1],[1]]));
	
	  testOtherPointRotation(ts, new Vertex3D(1,1,1), [0,0,Math.PI], new Vertex3D(3,1,2), new Matrix([[3],[1],[0],[1]]));
	  testOtherPointRotation(ts, new Vertex3D(1,1,1), [0,0,Math.PI/2], new Vertex3D(3,1,2), new Matrix([[3],[0],[1],[1]]));
	
	  testOtherPointRotation(ts, new Vertex3D(1,1,1), [Math.PI,0,0], new Vertex3D(3,1,2), new Matrix([[-1],[1],[2],[1]]));
	  testOtherPointRotation(ts, new Vertex3D(1,1,1), [Math.PI/2,0,0], new Vertex3D(3,1,2), new Matrix([[1],[3],[2],[1]]));
	
	  ts.success();
	});
	
});


RequireJS.addFunction('./services/cabinet/test/tests/RelationInput.js',
function (require, exports, module) {
	

	
	const RelationInput = require('../../../../public/js/utils/input/styles/select/relation.js');
	
	
	
	Test.add('RelationInput: Equal',(ts) => {
	  ts.assertEquals(RelationInput.eval('Equal', [1,4,3,5,6,4,8,9], 6), 4);
	  ts.assertEquals(RelationInput.eval('equal', [1,4,3,5,6,4,8,9], 7), undefined);
	  ts.assertEquals(RelationInput.eval('EQual', [1,4,3,5,6,4,8,9], 1), 0);
	  ts.assertEquals(RelationInput.eval('EqUAL', [1,4,3,5,6,4,8,9], 9), 7);
	  ts.assertEquals(RelationInput.eval('EquaL', [1,4,3,5,6,4,8,9], 4), 1);
	  ts.assertEquals(RelationInput.eval('EqUal', [1,4,3,5,6,undefined,8,9], 8), 6);
	  ts.success();
	});
	
	
	Test.add('RelationInput: Less Than',(ts) => {
	  ts.assertEquals(RelationInput.eval('Less ThAn', [1,4,3,5,6,4,8,9], 6), 3);
	  ts.assertEquals(RelationInput.eval('LeSs_Than', [1,4,3,5,6,4,8,9], 1), undefined);
	  ts.assertEquals(RelationInput.eval('LeSS Than', [1,4,3,5,6,4,8,9], 200), 7);
	  ts.assertEquals(RelationInput.eval('less than', [1,4,3,5,6,4,8,9], 9), 6);
	  ts.assertEquals(RelationInput.eval('Less Than', [1,4,3,5,6,4,8,9], -2), undefined);
	  ts.assertEquals(RelationInput.eval('Less Than', [1,4,3,5,6,undefined,8,9], 8), 4);
	  ts.success();
	});
	
	Test.add('RelationInput: Greater Than',(ts) => {
	  ts.assertEquals(RelationInput.eval('Greater ThAn', [1,4,3,5,6,4,8,9], 6), 6);
	  ts.assertEquals(RelationInput.eval('Greater_Than', [1,4,3,5,6,4,8,9], 1), 2);
	  ts.assertEquals(RelationInput.eval('Greater Than', [1,4,3,5,6,4,8,9], 200), undefined);
	  ts.assertEquals(RelationInput.eval('Greater than', [1,4,3,5,6,4,8,9], 9), undefined);
	  ts.assertEquals(RelationInput.eval('Greater Than', [1,4,3,5,6,4,8,9], -2), 0);
	  ts.assertEquals(RelationInput.eval('Greater Than', [1,4,3,5,6,undefined,8,9], 8), 7);
	  ts.success();
	});
	
	Test.add('RelationInput: Less Than Or Equal',(ts) => {
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], 6), 4);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], 2), 0);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], 200), 7);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], 9), 7);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,4,8,9], -2), undefined);
	  ts.assertEquals(RelationInput.eval('Less Than Or Equal', [1,4,3,5,6,undefined,8,9], 7.5), 4);
	  ts.success();
	});
	
	Test.add('RelationInput: Greater Than Or Equal',(ts) => {
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], 6), 4);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], 1.01), 2);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], 200), undefined);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], 9), 7);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,4,8,9], -2), 0);
	  ts.assertEquals(RelationInput.eval('Greater Than Or Equal', [1,4,3,5,6,undefined,8,9], 8), 6);
	  ts.success();
	});
	
});


RequireJS.addFunction('./services/cabinet/test/tests/polygon-merge.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Polygon3D = require('../../app-src/three-d/objects/polygon.js');
	
	
	const B = new Polygon3D([[0,1,0],[1,1,0],[1,3,0],[0,3,0]].reverse())
	const C = new Polygon3D([[0,4,0],[2,4,0],[2,6,0],[0,6,0]]);
	const A = new Polygon3D([[0,0,0],[0,1,0],[1,1,0],[4,1,0],[4,0,0]]);
	const D = new Polygon3D([[0,6,0],[0,8,0],[3,8,0],[3,7,0],[3,6,0],[2,6,0]]);
	const E = new Polygon3D([[3,8,0],[1,10,0],[0,8,0]]);
	const F = new Polygon3D([[6,7,0],[6,8,0],[6,10,0],[8,10,0],[8,7,0]]);
	const G = new Polygon3D([[4,7,0],[4,6,0],[3,6,0],[3,7,0]]);
	const H = new Polygon3D([[6,4,0],[4,4,0],[2,4,0],[2,6,0],[3,6,0],[4,6,0],[6,6,0]]);
	const I = new Polygon3D([[4,7,0],[4,8,0],[6,8,0],[6,7,0]].reverse());
	const J = new Polygon3D([[4,0,0],[4,1,0],[4,4,0],[6,4,0],[6,0,0]])
	
	const polyAB = new Polygon3D([[1,3,0],[0,3,0],[0,1,0],[0,0,0],[4,0,0],[4,1,0],[1,1,0]]);
	const polyIF = new Polygon3D([[6,10,0],[6,8,0],[4,8,0],[4,7,0],[6,7,0],[8,7,0],[8,10,0]]);
	const polyABCDEGHJ = new Polygon3D([[1,10,0],[3,8,0],[3,7,0],[4,7,0],[4,6,0],[6,6,0],[6,4,0],
	                                          [6,0,0],[4,0,0],[0,0,0],[0,1,0],[0,3,0],[1,3,0],[1,1,0],
	                                          [4,1,0],[4,4,0],[2,4,0],[0,4,0],[0,6,0],[0,8,0]]);
	
	// const A = new Polygon3D(null, [[,],[,],[,],[,]])
	Test.add('Polygon3D merge',(ts) => {
	  // const poly = A.merge(B).merge(J);
	  const AB = A.merge(B);
	  const IF = [F,I];
	  Polygon3D.merge(IF);
	  const ABCDEFGHIJ = [A,B,C,D,E,F,G,H,I,J];
	  ABCDEFGHIJ.shuffle();
	  Polygon3D.merge(ABCDEFGHIJ);
	
	  ts.assertTrue(polyAB.equals(AB), 'merge or equals is malfunctioning');
	  ts.assertTrue(AB.equals(polyAB), 'merge or equals is malfunctioning');
	  ts.assertFalse(polyAB.equals(undefined));
	  ts.assertFalse(polyAB.equals(A));
	  ts.assertTrue(IF[0].equals(polyIF));
	  ts.assertTrue(polyIF.equals(IF[0]));
	  ts.assertTrue(ABCDEFGHIJ.length === 2);
	  // This use to be part of the merge/build process until errors were found.
	  // TODO: Repair removeLoops... reinstate its use on all polygons.
	  ABCDEFGHIJ[0].removeLoops();
	  ABCDEFGHIJ[1].removeLoops();
	  ts.assertTrue(polyABCDEGHJ.equals(ABCDEFGHIJ[0]) || polyABCDEGHJ.equals(ABCDEFGHIJ[1]));
	  ts.assertTrue(polyIF.equals(ABCDEFGHIJ[1]) || polyIF.equals(ABCDEFGHIJ[0]))
	  ts.success();
	});
	
});


RequireJS.addFunction('./services/cabinet/test/tests/imposter.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	
	class JustTryAndCopyMe {
	  constructor() {
	    Object.getSet(this, {one: 1, two: 2, override1: 'unchanged1'});
	    this.three = 3;
	    this.four = 4;
	    this.override2 = 'unchanged2'
	    this.array = [1,2,3,4];
	    this.object = {one: 1, two: 2, three: 3};
	
	    this.equals = () => false;
	  }
	}
	
	Test.add('Imposter: fooled me',(ts) => {
	  const orig = new JustTryAndCopyMe();
	  const imposter = new Imposter(orig, {override1: () => 'changed1', override2: 'changed2'});
	  ts.assertTrue(imposter instanceof JustTryAndCopyMe);
	  ts.assertEquals(orig.one(), imposter.one());
	  ts.assertEquals(orig.two(), imposter.two());
	  ts.assertEquals(orig.three, imposter.three);
	  ts.assertEquals(orig.four, imposter.four);
	
	  ts.assertEquals(orig.one(4), imposter.one());
	  ts.assertEquals(orig.two(3), imposter.two());
	  orig.three = 7;
	  ts.assertEquals(orig.three, imposter.three);
	  orig.four = 8;
	  ts.assertEquals(orig.four, imposter.four);
	
	  ts.assertEquals(imposter.one(2), orig.one());
	  ts.assertEquals(imposter.two(1), orig.two());
	  imposter.three = 5;
	  ts.assertEquals(orig.three, imposter.three);
	  imposter.four = 0;
	  ts.assertEquals(orig.four, imposter.four);
	
	  ts.assertEquals(orig.array, imposter.array);
	  ts.assertEquals(orig.object, imposter.object);
	  orig.array[0] = 44;
	  imposter.object.one = 66;
	  ts.assertEquals(orig.array[0], imposter.array[0]);
	  ts.assertEquals(orig.object.one, imposter.object.one);
	
	  ts.assertFalse(orig === imposter);
	  ts.assertFalse(orig.equals(imposter));
	  ts.assertTrue(imposter.equals(orig));
	
	  // Test initial values
	  ts.assertEquals(imposter.override1(), 'changed1');
	  ts.assertEquals(imposter.override2, 'changed2');
	  ts.assertEquals(orig.override1(), 'unchanged1');
	  ts.assertEquals(orig.override2, 'unchanged2');
	
	  // Test function changes
	  ts.assertEquals(imposter.override1('changed3'), 'changed1');
	  ts.assertEquals(imposter.override2, 'changed2');
	  ts.assertEquals(orig.override1('unchanged3'), 'unchanged3');
	  ts.assertEquals(orig.override2, 'unchanged2');
	
	  // Test field assinments
	  imposter.override2 = 'changed4';
	  ts.assertEquals(imposter.override2, 'changed4');
	  ts.assertEquals(imposter.override1(), 'changed1');
	  orig.override2 = 'unchanged5';
	  ts.assertEquals(orig.override2, 'unchanged5');
	  ts.assertEquals(orig.override1(), 'unchanged3');
	
	  ts.success();
	});
	
});


RequireJS.addFunction('./services/cabinet/test/tests/cabinet.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Cabinet = require('../../app-src/objects/assembly/assemblies/cabinet.js')
	const approximate = require('../../../../public/js/utils/approximate.js').new(100);
	
	
	Test.add('Cabinet: doorIntersect',(ts) => {
	  ts.assertEquals(6, 6);
	  let dx;
	
	  //Parrelle up with no right point
	  let llp = {x:0,y:0};
	  let lcp = {x:0,y:10};
	  let rcp = {x:0,y:20};
	  let rrp = undefined;
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, 1/8);
	  ts.assertEquals(dx.center.length, 9.8125);
	  ts.assertEquals(dx.center.center.x(), .5, null, 1000);
	  ts.assertEquals(dx.center.center.y(), 15 - 1/32, null, 1000);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.center.left.reveal, 1/16);
	  ts.assertEquals(dx.center.right.reveal, 1/8);
	  ts.assertEquals(dx.left.reveal, 1/16);
	
	  //Parrelle down with no leftPoint.
	  llp = undefined;
	  lcp = {x:0,y:20};
	  rcp = {x:0,y:10};
	  rrp = {x:0,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, 1/8);
	  ts.assertEquals(dx.center.length, 9.8125);
	  ts.assertEquals(dx.center.center.x(), -.5, null, 1000);
	  ts.assertEquals(dx.center.center.y(), 15 - 1/32, null, 1000);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.center.left.reveal, 1/8);
	  ts.assertEquals(dx.center.right.reveal, 1/16);
	  ts.assertEquals(dx.right.reveal, 1/16);
	
	  //Parrelle right
	  llp = {x:0,y:0};
	  lcp = {x:10,y:0};
	  rcp = {x:20,y:0};
	  rrp = {x:30,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, 1/8);
	  ts.assertEquals(dx.center.length, 9.875);
	  ts.assertEquals(dx.center.center.x(), 15, null, 1000);
	  ts.assertEquals(dx.center.center.y(), -.5, null, 1000);
	  ts.assertEquals(dx.center.left.reveal, 1/16);
	  ts.assertEquals(dx.center.right.reveal, 1/16);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.left.reveal, 1/16);
	  ts.assertEquals(dx.right.reveal, 1/16);
	
	  //Parrelle left
	  llp = {x:30,y:0};
	  lcp = {x:20,y:0};
	  rcp = {x:10,y:0};
	  rrp = {x:0,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, 1/8);
	  ts.assertEquals(dx.center.length, 9.875);
	  ts.assertEquals(dx.center.center.x(), 15, null, 1000);
	  ts.assertEquals(dx.center.center.y(), .5, null, 1000);
	  ts.assertEquals(dx.center.left.reveal, 1/16);
	  ts.assertEquals(dx.center.right.reveal, 1/16);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.left.reveal, 1/16);
	  ts.assertEquals(dx.right.reveal, 1/16);
	
	  // Inner Horse Shoe
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:10,y:10};
	  rrp = {x:10,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, .125);
	  ts.assertEquals(dx.center.length, 7.75);
	  ts.assertEquals(dx.center.left.reveal, 1.125);
	  ts.assertEquals(dx.center.right.reveal, 1.125);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.left.reveal, 1);
	  ts.assertEquals(dx.right.reveal, 1);
	
	  // Inner Horse Shoe 3/4
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:10,y:10};
	  rrp = {x:10,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 3/4, 3/4, 3/4, .125, 1/4);
	  ts.assertEquals(dx.center.length, 7.75);
	  ts.assertEquals(dx.center.center.x(), 5, null, 1000);
	  ts.assertEquals(dx.center.center.y(), 9.375, null, 1000);
	  ts.assertEquals(dx.center.left.reveal, 1.125);
	  ts.assertEquals(dx.center.right.reveal, 1.125);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(dx.right.theta, undefined);
	  ts.assertEquals(dx.left.reveal, 1);
	  ts.assertEquals(dx.right.reveal, 1);
	
	  // Outer Horse Shoo
	  rrp = {x:0,y:0};
	  rcp = {x:0,y:10};
	  lcp = {x:10,y:10};
	  llp = {x:10,y:0};
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, .125);
	  ts.assertEquals(dx.center.length, 11.75);
	  ts.assertEquals(dx.center.left.reveal, -.875);
	  ts.assertEquals(dx.center.right.reveal, -.875);
	  ts.assertEquals(approximate(Math.toDegrees(dx.left.theta)), 45);
	  ts.assertEquals(approximate(Math.toDegrees(dx.right.theta)), 45);
	  ts.assertEquals(dx.left.reveal, -1);
	  ts.assertEquals(dx.right.reveal, -1);
	
	  // Zig
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:10,y:20};
	  rrp = {x:10,y:30};
	
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 1, .125);
	  ts.assertEquals(dx.left.theta, undefined);
	  ts.assertEquals(approximate(Math.toDegrees(dx.right.theta)), 22.5);
	
	  // Wall right
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:10,y:20};
	  rrp = {x:30,y:20};
	
	  dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 1, 1, 0, .125);
	  ts.assertEquals(dx.center.left.theta, undefined);
	  ts.assertEquals(approximate(Math.toDegrees(dx.center.right.theta)), 45);
	
	  // Wall left
	  llp = {x:0,y:0};
	  lcp = {x:0,y:10};
	  rcp = {x:9,y:25};
	  rrp = {x:30,y:20};
	
	  // dx = Cabinet.doorIntersect(llp, lcp, rcp, rrp, 0, 1, 1, .125);
	  // ts.assertEquals(approximate(Math.toDegrees(dx.center.right.theta)), 17.57);
	  // ts.assertEquals(approximate(Math.toDegrees(dx.center.left.theta)), 59.04);
	
	  ts.success();
	});
	
});


RequireJS.addFunction('./services/cabinet/test/tests/line2d.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line.js');
	const Vertex2d = require('../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const Polygon2d = require('../../../../public/js/utils/canvas/two-d/objects/polygon.js');
	
	
	const vertices = [
	  null, // Didnt zero index my drawing;
	  new Vertex2d(0,0), // 1
	  new Vertex2d(0,1), // 2
	  new Vertex2d(1,1), // 3
	  new Vertex2d(2,1), // 4
	  new Vertex2d(2,4), // 5
	  new Vertex2d(1,4), // 6
	  new Vertex2d(0,4), // 7
	  new Vertex2d(0,2), // 8
	  new Vertex2d(-1,2), // 9
	  new Vertex2d(-1,5), // 10
	  new Vertex2d(1,5), // 11
	  new Vertex2d(3,5), // 12
	  new Vertex2d(3,3), // 13
	  new Vertex2d(3,-1), // 14
	  new Vertex2d(2,-1), // 15
	  new Vertex2d(2,0) // 16
	];
	
	const parimeter = new Polygon2d(vertices.slice(1));
	
	const getLine = (index1, index2) => new Line2d(vertices[index1],vertices[index2]);
	const noise = [
	  getLine(1,3),
	  getLine(2,16),
	  getLine(3,16),
	  getLine(4,16),
	  getLine(16,14),
	  getLine(16,13),
	  getLine(13,15),
	  getLine(4,13),
	  getLine(13,5),
	  getLine(5,12),
	  // getLine(11,5),
	  // getLine(6,11),
	  // getLine(7,11),
	  getLine(10,7),
	  getLine(10,8),
	  getLine(9,7)
	];
	
	
	Test.add('Line2d parimeter',(ts) => {
	  ts.assertEquals(parimeter.area(), 13);
	  ts.success();
	});
	
	Test.add('Line2d parimeterArea',(ts) => {
	  let p = Polygon2d.toParimeter(parimeter.lines(), undefined, true);
	  ts.assertEquals(p.area(), 13);
	  ts.assertTrue(p.equals(parimeter), `Polygons do not equal: \n${p.toString()}, ${parimeter.toString()}`);
	  let keepGoing = false;
	  while (keepGoing) {
	    noise.shuffle();
	    const randNoise = noise.slice(0, Math.floor(Math.random() * noise.length));
	    let lines = parimeter.lines().concat(randNoise);
	    lines.shuffle();
	    p = Polygon2d.toParimeter(lines);
	    try {
	      ts.assertEquals(p.area(), 13);
	      ts.assertTrue(p.equals(parimeter), `Polygons do not equal: \n${p.toString()}, ${parimeter.toString()}`);
	    } catch (e) {
	      console.log('error');
	      Polygon2d.toParimeter(lines, undefined, true);
	      Polygon2d.toParimeter(lines, undefined, true);
	    }
	  }
	  ts.success();
	});
	
});


RequireJS.addFunction('./services/cabinet/test/tests/plane.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Plane = require('../../app-src/three-d/objects/plane.js');
	const Vertex3D = require('../../app-src/three-d/objects/vertex.js');
	const Vector3D = require('../../app-src/three-d/objects/vector.js');
	const Line3D = require('../../app-src/three-d/objects/line.js');
	const lpint = require('../../app-src/three-d/objects/line-plane-int.js');
	const CSG = require('../../public/js/3d-modeling/csg');
	
	const Notification = require('../../../../public/js/utils/collections/notification.js');
	
	
	
	
	Test.add('Plane: makePlane1MeetPlane2',(ts) => {
	
	  let plane1 = [{x: 0, y: 0, z: 0}, {x: 0, y: 3, z: 0}, {x: 2, y: 3, z: 0}, {x: 2, y: 0, z: 0}];
	  let plane2 = [{x: 4, y: 3, z: -1}, {x: 4, y: 0, z: -1}, {x: 4, y: 3, z: 1}, {x: 4, y: 0, z: 1}];
	  let answer = new Plane({x: 0, y: 0, z: 0}, {x: 0, y: 3, z: 0}, {x: 4, y: 3, z: 0}, {x: 4, y: 0, z: 0});
	  let rotation = {x: 0, y: 0, z: 0};
	  let result = Plane.makePlane1MeetPlane2(JSON.copy(plane1), plane2, rotation);
	  ts.assertTrue(answer.equals(result));
	
	  rotation = {x: 0, y: 90, z: 0};
	  let center = Vertex3D.center.apply(null, plane1);
	  let plane3 = CSG.rotatePointsAroundCenter(rotation, JSON.copy(plane1), center);
	  let plane4 = CSG.rotatePointsAroundCenter(rotation, JSON.copy(plane2), center);
	  result = Plane.makePlane1MeetPlane2(JSON.copy(plane3), plane4, rotation);
	  let reverted = CSG.rotatePointsAroundCenter(rotation, JSON.copy(result), center, true);
	  ts.assertTrue(answer.equals(reverted));
	
	  rotation = {x: 111, y: 62, z: 212};
	  center = Vertex3D.center.apply(null, plane1);
	  plane3 = CSG.rotatePointsAroundCenter(rotation, JSON.copy(plane1), center);
	  plane4 = CSG.rotatePointsAroundCenter(rotation, JSON.copy(plane2), center);
	  result = Plane.makePlane1MeetPlane2(JSON.copy(plane3), plane4, rotation);
	  reverted = CSG.rotatePointsAroundCenter(rotation, JSON.copy(result), center, true);
	  ts.assertTrue(answer.equals(reverted));
	
	  ts.success();
	});
	
	
	Test.add('Plane: equation',(ts) => {
	  const p1 = {x: 1, y: -2, z: 1};
	  const p2 = {x: 4, y: -2, z: -2};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  const equation = new Plane(p1, p2, p3).equation();
	  ts.assertEquals(equation.a * 54, 9);
	  ts.assertEquals(equation.b * 54, -18);
	  ts.assertEquals(equation.c * 54, 9);
	  ts.assertEquals(equation.d * 54, 54);
	  ts.success();
	});
	
	Test.add('Plane: XYrotation',(ts) => {
	  const p1 = {x: 1, y: -2, z: 1};
	  const p2 = {x: 4, y: -2, z: -2};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  const equation = new Plane(p1, p2, p3).equation();
	  const plane = new Plane(equation);
	  const rotation = plane.XYrotation();
	  const result = plane.matrixRotation(rotation);
	  ts.success();
	});
	
	Test.add('Plane: findPoints',(ts) => {
	  const p1 = {x: 1, y: -2, z: 4};
	  const p2 = {x: 4, y: -2, z: 4};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  const equation = new Plane(p1, p2, p3).equation();
	  const plane = new Plane(equation);
	
	  const result = plane.findPoints(13);
	  ts.assertEquals(result.length, 13);
	  ts.success();
	});
	
	Test.add('Vector: crossProduct',(ts) => {
	  const vect1 = new Vector3D(3,1,4);
	  const vect2 = new Vector3D(3,2,6);
	  const crossP = vect1.crossProduct(vect2);
	  ts.assertEquals(crossP.i(), -2/7);
	  ts.assertEquals(crossP.j(), -6/7);
	  ts.assertEquals(crossP.k(), 3/7);
	  ts.success();
	});
	
	Test.add('Plane: normal',(ts) => {
	  const p1 = {x: 1, y: 2, z: 4};
	  const p2 = {x: 4, y: 2, z: 4};
	  const p3 = {x: 4, y: 1, z: 4};
	
	  const equation = new Plane(p1, p2, p3).equation();
	  let plane = new Plane(equation);
	
	  let normal = plane.normal();
	
	  plane = new Plane(p1,p2,p3);
	  plane.rotate({x: 90, y:0, z:0});
	  normal = plane.normal();
	
	  plane = new Plane(p1,p2,p3);
	  plane.rotate({x: 0, y:90, z:0});
	  normal = plane.normal();
	
	  ts.success();
	});
	
	Test.add('Plane: intersection.line',(ts) => {
	  let p1 = {x: 1, y: 0, z: 4};
	  let p3 = {x: 0, y: 0, z: 4};
	  let p2 = {x: 0, y: 1, z: 4};
	
	  let plane = new Plane(p1,p2,p3);
	  let line = new Line3D({x:0,y:0,z:0}, {x:0,y:0,z:2});
	  let intersection = plane.intersection.line(line);
	  // intersection = lpint(line, plane);
	  ts.assertTrue(intersection.equals({x: 0, y: 0, z: 4}));
	
	  plane = new Plane(p2,p3,p1);
	  line = new Line3D({x:0,y:0,z:0}, {x:0,y:0,z:2});
	  intersection = plane.intersection.line(line);
	  // intersection = lpint(line, plane);
	  ts.assertTrue(intersection.equals({x: 0, y: 0, z: 4}));
	
	  plane = new Plane(p3,p1,p2);
	  line = new Line3D({x:0,y:0,z:0}, {x:0,y:0,z:2});
	  intersection = plane.intersection.line(line);
	  // intersection = lpint(line, plane);
	  ts.assertTrue(intersection.equals({x: 0, y: 0, z: 4}));
	
	  line = new Line3D({x:0,y:0,z:0}, {x:0,y:1,z:1});
	  intersection = plane.intersection.line(line);
	  // intersection = lpint(line, plane);
	  ts.assertTrue(intersection.equals({x: 0, y: 4, z: 4}));
	
	  line = new Line3D({x:-1,y:-1,z:-1}, {x:6,y:-1,z:6});
	  intersection = plane.intersection.line(line);
	  // intersection = lpint(line, plane);
	  ts.assertTrue(intersection.equals({x: 4, y: -1, z: 4}));
	
	  line = new Line3D({x:-1,y:-1,z:-1}, {x:1,y:1,z:1});
	  intersection = plane.intersection.line(line);
	  // intersection = lpint(line, plane);
	  ts.assertTrue(intersection.equals({x: 4, y: 4, z: 4}));
	
	  p1 = {x: 43.8, y: 0, z: -12.7};
	  p3 = {x: 43.8, y: 0, z: -12.1};
	  p2 = {x: 22.9, y: 0, z: -26};
	
	  plane = new Plane(p1,p2,p3);
	  line = new Line3D({x:1.9,y:12.1,z:-29.2}, {x:1.9,y:84.5,z:-29.2});
	  intersection = plane.intersection.line(line);
	  // intersection = lpint(line, plane);
	  ts.assertTrue(intersection.equals({x: 1.9, y: 0, z: -29.2}));
	
	
	  p1 = new Vertex3D(43.815,0,-12.69999999999996);
	  p2 = new Vertex3D(43.815,0,-12.06499999999996);
	  p3 = new Vertex3D(22.96,0,-26.034999999999975);
	
	  plane = new Plane(p1,p2,p3);
	  line = new Line3D({x:1.9050000000000018,y:12.064999999999998,z:-29.21000000000001}, {x:1.9050000000000018,y:84.455,z:-29.209999999999997});
	  intersection = plane.intersection.line(line);
	  // intersection = lpint(line, plane);
	  ts.assertTrue(intersection.equals({x: 1.905, y: 0, z: -29.21}));
	
	
	  ts.success();
	});
	
	Test.add('Plane: bisector',(ts) => {
	  let eqn1 = {a: 2, b: -1, c: 2, d: 3};
	  let eqn2 = {a: 3, b: -2, c: 6, d: 8};
	
	  let plane1 = new Plane(eqn1);
	  let plane2 = new Plane(eqn2);
	  let bisector = Plane.bisector(plane1, plane2);
	  let eqn = bisector.accute.equation();
	  ts.assertEquals(eqn.a, 23);
	  ts.assertEquals(eqn.b, -13);
	  ts.assertEquals(eqn.c, 32);
	  ts.assertEquals(eqn.d, 45);
	
	  eqn = bisector.obtuse.equation();
	  ts.assertEquals(eqn.a, 5);
	  ts.assertEquals(eqn.b, -1);
	  ts.assertEquals(eqn.c, -4);
	  ts.assertEquals(eqn.d, -3);
	
	  plane1 = new Plane({x:3, y: 8, z: 88}, {x:1, y: 12, z: 6}, {x:30, y: -2, z: 4});
	  plane2 = new Plane({x:5, y: 44, z: -16}, {x:-13, y: -20, z: 48}, {x:30, y: -2, z: 3});
	  bisector = Plane.bisector(plane1, plane2);
	
	  ts.assertEquals(plane1.equationEqualToZ(), '(0.038192x + 0.078697y + 1) / 0.002907');
	  ts.assertEquals(plane2.equationEqualToZ(), '(0.031282x + 0.035156y + 1) / 0.043954');
	  ts.assertEquals(bisector.obtuse.equationEqualToZ(), '(-0.000279x + 0.001991y + -0.023131) / -0.00366');
	  ts.assertEquals(bisector.accute.equationEqualToZ(), '(0.005197x + 0.008144y + 0.151916) / 0.004034');
	
	  ts.success();
	});
	
	
	Test.add('Plane: bisector',(ts) => {
	  const xyPlane = Plane.fromPointNormal({x: 12, y: 41, z: 0}, new Vector3D(1, 1, 1));
	  const yzPlane = Plane.fromPointNormal({x: 0, y: 41, z: 1}, new Vector3D(0, 3, -1));
	  const xzPlane = Plane.fromPointNormal({x: 12, y: 0, z: 50}, new Vector3D(5, 0, 13));
	  ts.success();
	});
	
});


RequireJS.addFunction('./services/cabinet/test/tests/line-consolidate.js',
function (require, exports, module) {
	
const Test = require('../../../../public/js/utils/test/test').Test;
	const Polygon2d = require('../../../../public/js/utils/canvas/two-d/objects/polygon.js');
	const Line2d = require('../../../../public/js/utils/canvas/two-d/objects/line.js');
	const Line3D = require('../../app-src/three-d/objects/line.js');
	const Vertex2d = require('../../../../public/js/utils/canvas/two-d/objects/vertex.js');
	const approximate = require('../../../../public/js/utils/approximate.js');
	
	const extraLinePoly = new Polygon2d([[0,0],[0,1],[0,2],[0,3],
	                [1,3],[1,4],[0,4],[0,5],[0,6],[1,6],[2,6],[3,6],
	                [3,5],[4,5],[5,4],[6,3],[5,3],[5,2],[6,2],[6,1],
	                [6,0],[5,0],[4,0],[4,-1],[4,-2],[1,0]]);
	
	const consisePoly = new Polygon2d([[0,0],[0,3],[1,3],[1,4],
	                [0,4],[0,6],[3,6],[3,5],[4,5],[6,3],[5,3],[5,2],
	                [6,2],[6,0],[4,0],[4,-2],[1,0]]);
	
	const root2 = Math.sqrt(2);
	
	
	// const A = new Polygon3D([[,],[,],[,],[,]])
	Test.add('Line2d: consolidate',(ts) => {
	  const lines = Polygon2d.lines(extraLinePoly);
	  ts.assertTrue(lines.length === consisePoly.lines().length);
	  ts.success();
	});
	
	
	Test.add('Line2d: perpendicular', (ts) => {
	  let line = new Line2d({x:0,y:0}, {x:1, y:0});
	  let perp = line.perpendicular(1, null, true);
	  let expectedMidpoint = new Vertex2d({x: .5, y: 0});
	  let expectedLine = new Line2d({x: .5, y: .5}, {x: .5, y: -.5});
	  ts.assertTrue(perp.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(-2, null, true);
	  expectedLine = new Line2d({x: .5, y: 1}, {x: .5, y: -1});
	  ts.assertTrue(perp.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(1);
	  expectedLine = new Line2d({x: .5, y: 0}, {x: .5, y: 1});
	  expectedMidpoint = new Vertex2d({x: .5, y: .5});
	  ts.assertTrue(perp.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(-2);
	  expectedLine = new Line2d({x: .5, y: 0}, {x: .5, y: -2});
	  expectedMidpoint = new Vertex2d({x: .5, y: -1});
	  ts.assertTrue(perp.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(-1);
	  expectedLine = new Line2d({x: .5, y: 0}, {x: .5, y: -1});
	  expectedMidpoint = new Vertex2d({x: .5, y: -.5});
	  ts.assertTrue(perp.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  perp = line.perpendicular(2);
	  expectedLine = new Line2d({x: .5, y: 0}, {x: .5, y: 2});
	  expectedMidpoint = new Vertex2d({x: .5, y: 1});
	  ts.assertTrue(perp.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  line = new Line2d({x:0,y:0}, {x:2, y:2});
	  perp = line.perpendicular(root2);
	  expectedLine = new Line2d({x: 1, y: 1}, {x: 0, y: 2});
	  expectedMidpoint = new Vertex2d({x: .5, y: 1.5});
	  ts.assertTrue(perp.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  line = new Line2d({x:0,y:0}, {x:2, y:2});
	  perp = line.perpendicular(-1 * root2);
	  expectedLine = new Line2d({x: 1, y: 1}, {x: 2, y: 0});
	  expectedMidpoint = new Vertex2d({x: 1.5, y: .5});
	  ts.assertTrue(perp.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${perp.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(perp.equals(expectedLine),
	        `Line not equal: ${perp} !== ${expectedLine}`);
	
	  ts.success();
	});
	
	Test.add('Line2d: parrelle', (ts) => {
	  let line = new Line2d({x:0,y:0}, {x:2, y:2});
	  let expectedLine = new Line2d({x: -1, y: 1}, {x: 1, y: 3});
	  let expectedMidpoint = new Vertex2d({x: 0, y: 2});
	  let parrelle = line.parrelle(-1 * root2);
	  ts.assertTrue(parrelle.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  expectedLine = new Line2d({x: 1, y: -1}, {x: 3, y: 1});
	  expectedMidpoint = new Vertex2d({x: 2, y: 0});
	  parrelle = line.parrelle(root2);
	  ts.assertTrue(parrelle.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  line = new Line2d({x:2, y:2}, {x:0,y:0});
	  expectedLine = new Line2d({x: 1, y: 3}, {x: -1, y: 1});
	  expectedMidpoint = new Vertex2d({x: 0, y: 2});
	  parrelle = line.parrelle(root2);
	  ts.assertTrue(parrelle.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  expectedLine = new Line2d({x: 3, y: 1}, {x: 1, y: -1});
	  expectedMidpoint = new Vertex2d({x: 2, y: 0});
	  parrelle = line.parrelle(-1 * root2);
	  ts.assertTrue(parrelle.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  line = new Line2d({x:3,y:1}, {x:8, y:4});
	  expectedMidpoint = new Vertex2d({x: -.5, y: 12.5});
	  expectedLine = new Line2d({x: -3, y: 11}, {x: 2, y: 14});
	  parrelle = line.parrelle(-1 * expectedMidpoint.distance(line.midpoint()));
	  ts.assertTrue(parrelle.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  expectedMidpoint = new Vertex2d({x: 11.5, y: -7.5});
	  expectedLine = new Line2d({x: 9, y: -9}, {x: 14, y: -6});
	  parrelle = line.parrelle(expectedMidpoint.distance(line.midpoint()));
	  ts.assertTrue(parrelle.midpoint().equals(expectedMidpoint),
	        `Midpoint not equal: ${parrelle.midpoint()} !== ${expectedMidpoint}`);
	  ts.assertTrue(parrelle.equals(expectedLine),
	        `Line not equal: ${parrelle} !== ${expectedLine}`);
	
	  ts.success();
	});
	
	Test.add('Line2d: trimmed', (ts) => {
	  let line = new Line2d({x:0,y:0}, {x:0, y:8});
	
	  let trimmed = line.trimmed(.5);
	  let expectedLine = new Line2d({x: 0, y: .5}, {x: 0, y: 8});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(-.5);
	  expectedLine = new Line2d({x: 0, y: 0}, {x: 0, y: 7.5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(.5, true);
	  expectedLine = new Line2d({x: 0, y: .5}, {x: 0, y: 7.5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(-.5, true);
	  expectedLine = new Line2d({x: 0, y: .5}, {x: 0, y: 7.5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  line = new Line2d({x:-4,y:-8}, {x:0, y:-4});
	  trimmed = line.trimmed(root2, true);
	  expectedLine = new Line2d({x: -3, y: -7}, {x: -1, y: -5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(root2);
	  expectedLine = new Line2d({x: -3, y: -7}, {x: 0, y: -4});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  trimmed = line.trimmed(-1 * root2);
	  expectedLine = new Line2d({x: -4, y: -8}, {x: -1, y: -5});
	  ts.assertTrue(trimmed.equals(expectedLine),
	        `Line not equal: ${trimmed} !== ${expectedLine}`);
	
	  ts.success();
	});
	
	Test.add('Line2d: thetaBetween', (ts) => {
	  let line = new Line2d({x:0,y:0}, {x:0, y:10});
	  let line2 = new Line2d({x:0,y:10}, {x:10, y:20});
	  let line3 = new Line2d({x:10,y:20}, {x:10, y:30})
	
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 135);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line3))), 225);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 225);
	  ts.assertEquals(approximate(Math.toDegrees(line3.thetaBetween(line2))), 135);
	
	  let origin = {x:3, y:22};
	  line = Line2d.startAndTheta(origin, Math.toRadians(16), 10);
	  line2 = Line2d.startAndTheta(origin, Math.toRadians(251), 10);
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 235);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 125);
	
	  line2 = line2.negitive();
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 235);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 125);
	
	  line = line.negitive();
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 235);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 125);
	
	  line2 = line2.negitive();
	  ts.assertEquals(approximate(Math.toDegrees(line.thetaBetween(line2))), 235);
	  ts.assertEquals(approximate(Math.toDegrees(line2.thetaBetween(line))), 125);
	
	  ts.success();
	});
	
	// Test.add('Line3D: intersects', (ts) => {
	//   const line1 = new Line3D({x: 10, y: 10, z: 10}, {x: 5, y: 5, z: 5});
	//   const line2 = new Line3D({x: 10, y: 10, z: -10}, {x: 5, y: 5, z: -5});
	//   let intersection = line1.intersects(line2);
	//   ts.assertTrue(intersection.equals({x: 0, y:0, z:0}));
	//   ts.success();
	// });
	
});


RequireJS.addFunction('./services/cabinet/test/tests/cost/material.js',
function (require, exports, module) {
	

	const Frame = require('./labor.js').Frame;
	const Material = require('./category.js').Material;
	
	
	{
	  const frame = new Frame('f', 'Frame', '0,0,0', '4, 196\', .75');
	  const panel = new Panel('p', 'Panel', '0,0,0', '24, 10, .75');
	  const props = {};
	  const smeRound = StringMathEvaluator.round;
	  const referenceable = true;
	  const group = 'localTest30487';
	
	  let unitCostValue = smeRound(15.37/(8*12));
	  let costValue = smeRound(unitCostValue * 2 * 196 * 12);
	  let assembly = frame;
	  props.linear = {
	    id: 'frame',
	    method: 'Linear Feet',
	    objectId: 'Frame',
	    length: '8\'',
	    cost: '15.37',
	    formula: '2*l',
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound((75.13)/(96*48));
	  costValue = smeRound(unitCostValue * 24 * 10);
	  assembly = panel;
	  props.square = {
	    id: 'panel0',
	    method: 'Square Feet',
	    objectId: 'Panel',
	    length: '96',
	    width: '48',
	    cost: 75.13,
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound(29.86/(12*6*1));
	  costValue = smeRound(unitCostValue * 24 * 10 * .75);
	  props.cubic = {
	    id: 'metal',
	    method: 'Cubic Feet',
	    objectId: 'Panel',
	    length: '12',
	    width: '6',
	    depth: '1',
	    cost: 29.86,
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound(50.12/10);
	  costValue = smeRound(unitCostValue * 13);
	  props.unit = {
	    id: 'parts',
	    method: 'Unit',
	    laborType: 'Instalation',
	    hourlyRate: '20',
	    hours: '.66',
	    cost: '50.12',
	    count: '10',
	    referenceable, unitCostValue, costValue, group,
	    assembly: 13
	  };
	
	  Test.add('MaterialCost: unitCost/calc',(ts) => {
	    const costs = [];
	    function testProps(props) {
	      const labor = new Material(props);
	      costs.push(labor);
	      ts.assertTolerance(labor.unitCost().value, props.unitCostValue, .0001);
	      ts.assertTolerance(labor.calc(props.assembly), props.costValue, .0001);
	    }
	    Object.values(props).forEach(testProps);
	    costs.forEach((cost) => cost.delete());
	    ts.success();
	  });
	}
	
	exports.Frame = Frame
	exports.Material = Material
	
});


RequireJS.addFunction('./services/cabinet/test/tests/cost/labor.js',
function (require, exports, module) {
	

	
	const Frame = require('../../../app-src/objects/assembly/assemblies/frame.js');
	const Panel = require('../../../app-src/objects/assembly/assemblies/panel.js');
	const StringMathEvaluator = require('../../../../../public/js/utils/string-math-evaluator.js');
	const Labor = require('../../../app-src/cost/types/material/labor.js');
	const FunctionArgumentTest = require('../../test.js').FunctionArgumentTest;
	
	
	{
	  const frame = new Frame('f', 'Frame', '0,0,0', '4, 196\', .75');
	  const panel = new Panel('p', 'Panel', '0,0,0', '24, 10, .75');
	  const props = {};
	  const smeRound = StringMathEvaluator.round;
	  const referenceable = true;
	  const group = 'localTest30487';
	
	  let unitCostValue = smeRound((35*.017)/(8*12));
	  let costValue = smeRound(unitCostValue * 196 * 12);
	  let assembly = frame;
	  props.linear = {
	    id: 'Sand Frame',
	    method: 'Linear Feet',
	    laborType: 'Sand',
	    objectId: 'Frame',
	    hourlyRate: '35',
	    length: '8\'',
	    hours: '.017',
	    formula: 'l',
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound((35*.08)/(48*48));
	  costValue = smeRound(unitCostValue * 24 * 10);
	  assembly = panel;
	  props.square = {
	    id: 'Sand Panel',
	    method: 'Square Feet',
	    laborType: 'Sand',
	    length: '48',
	    objectId: 'Panel',
	    width: '48',
	    hours: '.08',
	    formula: 'l*w',
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound((35*.06)/(12*6*1));
	  costValue = smeRound(unitCostValue * 24 * 10 * .75);
	  props.cubic = {
	    id: 'Sand Block',
	    method: 'Cubic Feet',
	    laborType: 'Sand',
	    hourlyRate: '35',
	    objectId: 'Panel',
	    length: '12',
	    width: '6',
	    depth: '1',
	    hours: '.06',
	    formula: 'l*w*d',
	    referenceable, unitCostValue, costValue, assembly, group
	  };
	
	  unitCostValue = smeRound(20*.66);
	  costValue = smeRound(unitCostValue * 13);
	  props.unit = {
	    id: 'instalation',
	    method: 'Unit',
	    laborType: 'Instalation',
	    hourlyRate: '20',
	    hours: '.66',
	    referenceable, unitCostValue, costValue, group,
	    assembly: 13
	  };
	
	  Test.add('LaborCost: unitCost/calc',(ts) => {
	    const costs = [];
	    function testProps(props) {
	      const labor = new Labor(props);
	      costs.push(labor);
	      ts.assertTolerance(labor.unitCost().value, props.unitCostValue, .00001);
	      ts.assertTolerance(labor.calc(props.assembly), props.costValue, .00001);
	    }
	    Object.values(props).forEach(testProps);
	    costs.forEach((cost) => cost.delete());
	    ts.success();
	  });
	
	  // Test.add('LaborCost: argument validation',(ts) => {
	  //   const args = [props.linear];
	  //   const func = function (args) {new (Labor.prototype.constructor)(...arguments);}
	  //   new FunctionArgumentTest(ts, func, args)
	  //       .setIndex(0)
	  //       .add('id', undefined)
	  //       .run();
	  //   ts.success();
	  // });
	}
	
	exports.Frame = Frame
	exports.Panel = Panel
	exports.StringMathEvaluator = StringMathEvaluator
	exports.Labor = Labor
	exports.FunctionArgumentTest = FunctionArgumentTest
	
});


RequireJS.addFunction('./services/cabinet/test/tests/cost/category.js',
function (require, exports, module) {
	

	
	const Frame = require('../../../app-src/objects/assembly/assemblies/frame.js');
	const Panel = require('../../../app-src/objects/assembly/assemblies/panel.js');
	const StringMathEvaluator = require('../../../../../public/js/utils/string-math-evaluator.js');
	const Category = require('../../../app-src/cost/types/category.js');
	const Material = require('../../../app-src/cost/types/material.js');
	
	//
	//
	// {
	//   const frame = new Frame('f', 'Frame', '0,0,0', '4, 196\', .75');
	//   const panel = new Panel('p', 'Panel', '0,0,0', '24, 10, .75');
	//   const frame.addSubAssembly(panel);
	//   const props = {};
	//   const smeRound = StringMathEvaluator.round;
	//
	//   let unitCostValue = smeRound(15.37/(8*12));
	//   let costValue = smeRound(unitCostValue * 2 * 196 * 12);
	//   let assembly = frame;
	//   props.linear = {
	//     id: 'frame',
	//     method: 'Linear Feet',
	//     length: '8\'',
	//     cost: '15.37',
	//     formula: '2*l',
	//     unitCostValue, costValue, assembly
	//   };
	//
	//   unitCostValue = smeRound((75.13)/(96*48));
	//   costValue = smeRound(unitCostValue * 24 * 10);
	//   props.square = {
	//     id: 'panel0',
	//     method: 'Square Feet',
	//     length: '96',
	//     width: '48',
	//     cost: 75.13,
	//     unitCostValue, costValue, assembly
	//   };
	//
	//   unitCostValue = smeRound(29.86/(12*6*1));
	//   costValue = smeRound(unitCostValue * 24 * 10 * .75);
	//   props.cubic = {
	//     id: 'metal',
	//     method: 'Cubic Feet',
	//     length: '12',
	//     width: '6',
	//     depth: '1',
	//     cost: 29.86,
	//     unitCostValue, costValue, assembly
	//   };
	//
	//   unitCostValue = smeRound(50.12/10);
	//   costValue = smeRound(unitCostValue * 13);
	//   props.unit = {
	//     id: 'parts',
	//     method: 'Unit',
	//     laborType: 'Instalation',
	//     hourlyRate: '20',
	//     hours: '.66',
	//     cost: '50.12',
	//     count: '10',
	//     unitCostValue, costValue,
	//     assembly: 13
	//   };
	//   const catCost = new Category({id: 'catTest'});
	//
	//   Test.add('CategoryCost: calc',(ts) => {
	//     let totalCost = 0;
	//     function testProps(props) {
	//       const matCost = new Material(props);
	//       catCost.addChild(matCost);
	//       totalCost += matCost.calc(props.assembly);
	//     }
	//     Object.values(props).forEach(testProps);
	//     ts.assertTolerance(totalCost, catCost.calc(), .0001);
	//     ts.success();
	//   });
	// }
	
	exports.Frame = Frame
	exports.Panel = Panel
	exports.StringMathEvaluator = StringMathEvaluator
	exports.Category = Category
	exports.Material = Material
	
});


window.onload = () => RequireJS.init('./services/cabinet/app-src/init.js')
